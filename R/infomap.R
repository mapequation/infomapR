# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

##   Generated via the command line invocation:
##	 swig -c++ -r -outdir build/R -o build/R/infomap_wrap.cpp build/R/Infomap.i


#                         srun.swg                            #
#
# This is the basic code that is needed at run time within R to
# provide and define the relevant classes.  It is included
# automatically in the generated code by copying the contents of
# srun.swg into the newly created binding code.


# This could be provided as a separate run-time library but this
# approach allows the code to be included directly into the
# generated bindings and so removes the need to have and install an
# additional library.  We may however end up with multiple copies of
# this and some confusion at run-time as to which class to use. This
# is an issue when we use NAMESPACES as we may need to export certain
# classes.

######################################################################

if(length(getClassDef("RSWIGStruct")) == 0) 
  setClass("RSWIGStruct", representation("VIRTUAL"))



if(length(getClassDef("ExternalReference")) == 0) 
# Should be virtual but this means it loses its slots currently
#representation("VIRTUAL")
  setClass("ExternalReference", representation( ref = "externalptr"))



if(length(getClassDef("NativeRoutinePointer")) == 0) 
  setClass("NativeRoutinePointer", 
              representation(parameterTypes = "character",
                             returnType = "character",
                             "VIRTUAL"), 
              contains = "ExternalReference")

if(length(getClassDef("CRoutinePointer")) == 0) 
  setClass("CRoutinePointer", contains = "NativeRoutinePointer")


if(length(getClassDef("EnumerationValue")) == 0) 
  setClass("EnumerationValue", contains = "integer")


if(!isGeneric("copyToR")) 
 setGeneric("copyToR",
            function(value, obj = new(gsub("Ref$", "", class(value)))) 
               standardGeneric("copyToR"
           ))

setGeneric("delete", function(obj) standardGeneric("delete"))


SWIG_createNewRef = 
function(className, ..., append = TRUE)
{
  f = get(paste("new", className, sep = "_"), mode = "function")

  f(...)
}

if(!isGeneric("copyToC")) 
 setGeneric("copyToC", 
             function(value, obj = SWIG_createNewRef(class(value)))
              standardGeneric("copyToC"
            ))


# 
defineEnumeration =
function(name, .values, where = topenv(parent.frame()), suffix = "Value")
{
   # Mirror the class definitions via the E analogous to .__C__
  defName = paste(".__E__", name, sep = "")
  delayedAssign(defName,  .values, assign.env = where)

  if(nchar(suffix))
    name = paste(name, suffix, sep = "")

  setClass(name, contains = "EnumerationValue", where = where)
}

enumToInteger <- function(name,type)
{
   if (is.character(name)) {
   ans <- as.integer(get(paste(".__E__", type, sep = ""))[name])
   if (is.na(ans)) {warning("enum not found ", name, " ", type)}
   ans
   } 
}

enumFromInteger =
function(i,type)
{
  itemlist <- get(paste(".__E__", type, sep=""))
  names(itemlist)[match(i, itemlist)]
}

coerceIfNotSubclass =
function(obj, type) 
{
    if(!is(obj, type)) {as(obj, type)} else obj
}


setClass("SWIGArray", representation(dims = "integer"), contains = "ExternalReference")

setMethod("length", "SWIGArray", function(x) x@dims[1])


defineEnumeration("SCopyReferences",
                   .values = c( "FALSE" = 0, "TRUE" = 1, "DEEP" = 2))

assert = 
function(condition, message = "")
{
  if(!condition)
    stop(message)

  TRUE
}


if(FALSE) {
print.SWIGFunction =
function(x, ...)
 {
 }
}


#######################################################################

R_SWIG_getCallbackFunctionStack =
function()
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_debug_getCallbackFunctionData")
}

R_SWIG_addCallbackFunctionStack =
function(fun, userData = NULL)
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_R_pushCallbackFunctionData", fun, userData)
}


#######################################################################



setClass('C++Reference', contains = 'ExternalReference')
setClass('_p_infomap__FlowModel', contains = 'ExternalReference')
setClass("infomap::FlowModel",
    representation(
        undirected = "integer",
        directed = "integer",
        undirdir = "integer",
        outdirdir = "integer",
        rawdir = "integer",
        value = "integer"),
        contains = "RSWIGStruct")


# End class infomap::FlowModel

setClass('_p_infomap__OptimizationLevel', contains = 'ExternalReference')
setClass("infomap::OptimizationLevel",
    representation(
        FullCoarseTune = "integer",
        FastCoarseTune = "integer",
        NoTune = "integer",
        NoAggregationNoTune = "integer",
        value = "integer"),
        contains = "RSWIGStruct")


# End class infomap::OptimizationLevel

setClass('_p_infomap__Config', contains = 'ExternalReference')
setClass("infomap::Config",
    representation(
        isCLI = "logical",
        networkFile = "character",
        inputFormat = "character",
        memoryInput = "logical",
        multilayerInput = "logical",
        weightThreshold = "numeric",
        unweightedPaths = "logical",
        pathMarkovOrder = "integer",
        bipartite = "logical",
        skipAdjustBipartiteFlow = "logical",
        bipartiteTeleportation = "logical",
        hardPartitions = "logical",
        parseWithoutIOStreams = "logical",
        zeroBasedNodeNumbers = "logical",
        includeSelfLinks = "logical",
        ignoreEdgeWeights = "logical",
        nodeLimit = "integer",
        preClusterMultilayer = "logical",
        clusterDataFile = "character",
        metaDataFile = "character",
        metaDataRate = "numeric",
        unweightedMetaData = "logical",
        numMetaDataDimensions = "integer",
        clusterDataIsHard = "logical",
        assignToNeighbouringModule = "logical",
        noInfomap = "logical",
        directed = "logical",
        undirdir = "logical",
        outdirdir = "logical",
        rawdir = "logical",
        useNodeWeightsAsFlow = "logical",
        teleportToNodes = "logical",
        selfTeleportationProbability = "numeric",
        markovTime = "numeric",
        multilayerRelaxRate = "numeric",
        multilayerRelaxLimit = "integer",
        multilayerRelaxLimitUp = "integer",
        multilayerRelaxLimitDown = "integer",
        multilayerJSRelaxRate = "numeric",
        multilayerRelaxByJensenShannonDivergence = "logical",
        multilayerJSRelaxLimit = "integer",
        twoLevel = "logical",
        noCoarseTune = "logical",
        directedEdges = "logical",
        recordedTeleportation = "logical",
        teleportationProbability = "numeric",
        preferredNumberOfModules = "integer",
        seedToRandomNumberGenerator = "integer",
        numTrials = "integer",
        minimumCodelengthImprovement = "numeric",
        minimumSingleNodeCodelengthImprovement = "numeric",
        randomizeCoreLoopLimit = "logical",
        coreLoopLimit = "integer",
        levelAggregationLimit = "integer",
        tuneIterationLimit = "integer",
        minimumRelativeTuneIterationImprovement = "numeric",
        fastCoarseTunePartition = "logical",
        alternateCoarseTuneLevel = "logical",
        coarseTuneLevel = "integer",
        superLevelLimit = "integer",
        onlySuperModules = "logical",
        fastHierarchicalSolution = "integer",
        fastFirstIteration = "logical",
        preferModularSolution = "logical",
        innerParallelization = "logical",
        outDirectory = "character",
        outName = "character",
        outputFormats = "character",
        originallyUndirected = "logical",
        printTree = "logical",
        printFlowTree = "logical",
        printNewick = "logical",
        printMap = "logical",
        printClu = "logical",
        cluLevel = "integer",
        printNodeRanks = "logical",
        printFlowNetwork = "logical",
        printPajekNetwork = "logical",
        printStateNetwork = "logical",
        printBinaryTree = "logical",
        printBinaryFlowTree = "logical",
        noFileOutput = "logical",
        verbosity = "integer",
        verboseNumberPrecision = "integer",
        silent = "logical",
        benchmark = "logical",
        hideBipartiteNodes = "logical",
        maxNodeIndexVisible = "integer",
        minBipartiteNodeIndex = "integer",
        version = "character",
        parsedString = "character",
        error = "character"),
        contains = "RSWIGStruct")


# End class infomap::Config

setClass('_p_infomap__FlowData', contains = 'ExternalReference')
setClass("infomap::FlowData",
    representation(
        flow = "numeric",
        enterFlow = "numeric",
        exitFlow = "numeric"),
        contains = "RSWIGStruct")


# End class infomap::FlowData

setClass('_p_infomap__DeltaFlow', contains = 'ExternalReference')
setClass("infomap::DeltaFlow",
    representation(
        module = "integer",
        deltaExit = "numeric",
        deltaEnter = "numeric",
        count = "integer"),
        contains = "RSWIGStruct")


# End class infomap::DeltaFlow

setClass('_p_infomap__MemDeltaFlow', contains = 'ExternalReference')
setClass("infomap::MemDeltaFlow",
    representation(
        sumDeltaPlogpPhysFlow = "numeric",
        sumPlogpPhysFlow = "numeric"),
        contains = "RSWIGStruct")


# End class infomap::MemDeltaFlow

setClass('_p_infomap__PhysData', contains = 'ExternalReference')
setClass("infomap::PhysData",
    representation(
        physNodeIndex = "integer",
        sumFlowFromM2Node = "numeric"),
        contains = "RSWIGStruct")


# End class infomap::PhysData

setClass('_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t', contains = 'C++Reference')
setClass('_p_infomap__InfoNode', contains = 'C++Reference')
setClass('_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t', contains = 'C++Reference')
setClass('_p_infomap__InfomapIterator', contains = 'ExternalReference')
setClass("infomap::InfomapIterator",
    representation(
        m_moduleIndexLevel = "integer",
        m_moduleIndex = "integer",
        m_depth = "integer"),
        contains = "RSWIGStruct")


# End class infomap::InfomapIterator

setClass('_p_infomap__InfomapModuleIterator', contains = 'ExternalReference')
setClass("infomap::InfomapModuleIterator",
    representation(
),
        contains = "RSWIGStruct")


# End class infomap::InfomapModuleIterator

setClass('_p_infomap__InfomapLeafModuleIterator', contains = 'ExternalReference')
setClass("infomap::InfomapLeafModuleIterator",
    representation(
),
        contains = "RSWIGStruct")


# End class infomap::InfomapLeafModuleIterator

setClass('_p_infomap__InfomapLeafIterator', contains = 'ExternalReference')
setClass("infomap::InfomapLeafIterator",
    representation(
),
        contains = "RSWIGStruct")


# End class infomap::InfomapLeafIterator

setClass('_p_infomap__InfomapIteratorPhysical', contains = 'ExternalReference')
setClass("infomap::InfomapIteratorPhysical",
    representation(
),
        contains = "RSWIGStruct")


# End class infomap::InfomapIteratorPhysical

setClass('_p_infomap__InfomapLeafIteratorPhysical', contains = 'ExternalReference')
setClass("infomap::InfomapLeafIteratorPhysical",
    representation(
),
        contains = "RSWIGStruct")


# End class infomap::InfomapLeafIteratorPhysical

setClass('_p_infomap__InfomapParentIterator', contains = 'ExternalReference')
setClass("infomap::InfomapParentIterator",
    representation(
),
        contains = "RSWIGStruct")


# End class infomap::InfomapParentIterator

setClass('_p_infomap__StateNetwork', contains = 'C++Reference')
setClass('_p_infomap__Network', contains = c('_p_infomap__StateNetwork'))
setClass('_p_infomap__LayerNode', contains = 'ExternalReference')
setClass("infomap::LayerNode",
    representation(
        layer = "integer",
        node = "integer"),
        contains = "RSWIGStruct")


# End class infomap::LayerNode

setClass('_p_infomap__Bigram', contains = 'ExternalReference')
setClass("infomap::Bigram",
    representation(
        first = "integer",
        second = "integer"),
        contains = "RSWIGStruct")


# End class infomap::Bigram

setClass('_p_infomap__BipartiteLink', contains = 'ExternalReference')
setClass("infomap::BipartiteLink",
    representation(
        featureNode = "integer",
        node = "integer",
        swapOrder = "logical"),
        contains = "RSWIGStruct")


# End class infomap::BipartiteLink

setClass('_p_infomap__Weight', contains = 'ExternalReference')
setClass("infomap::Weight",
    representation(
        weight = "numeric"),
        contains = "RSWIGStruct")


# End class infomap::Weight

setClass('_p_infomap__Triple', contains = 'ExternalReference')
setClass("infomap::Triple",
    representation(
        n1 = "integer",
        n2 = "integer",
        n3 = "integer"),
        contains = "RSWIGStruct")


# End class infomap::Triple

setClass('_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_double_std__allocatorT_double_t_t', contains = 'C++Reference')
setClass('_p_infomap__InfomapConfigT_infomap__InfomapBase_t', contains = c('_p_infomap__Config'))
setClass('_p_infomap__InfomapBase', contains = c('_p_infomap__InfomapConfigT_infomap__InfomapBase_t'))
setClass('_p_infomap__PerLevelStat', contains = 'ExternalReference')
setClass("infomap::PerLevelStat",
    representation(
        numModules = "integer",
        numLeafNodes = "integer",
        indexLength = "numeric",
        leafLength = "numeric"),
        contains = "RSWIGStruct")


# End class infomap::PerLevelStat

setClass('_p_infomap__detail__PartitionQueue', contains = 'C++Reference')
setClass('_p_infomap__MapEquation', contains = 'C++Reference')
setClass('_p_infomap__MemMapEquation', contains = 'C++Reference')
setClass('_p_infomap__MemNodeSet', contains = 'ExternalReference')
setClass("infomap::MemNodeSet",
    representation(
        numMemNodes = "integer",
        sumFlow = "numeric"),
        contains = "RSWIGStruct")


# End class infomap::MemNodeSet

setClass('_p_infomap__MetaMapEquation', contains = 'C++Reference')
setClass('_p_infomap__InfomapCore', contains = c('_p_infomap__InfomapBase'))
setClass('_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t', contains = 'C++Reference')
setClass('_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t', contains = 'C++Reference')
setClass('_p_infomap__InfomapWrapper', contains = 'ExternalReference')
setClass("infomap::InfomapWrapper",
    representation(
),
        contains = "RSWIGStruct")


# End class infomap::InfomapWrapper




setMethod('[', "ExternalReference",
function(x,i,j, ..., drop=TRUE) 
if (!is.null(x$"__getitem__")) 
sapply(i, function(n) x$"__getitem__"(i=as.integer(n-1))))

setMethod('[<-' , "ExternalReference",
function(x,i,j, ..., value) 
if (!is.null(x$"__setitem__")) {
sapply(1:length(i), function(n) 
x$"__setitem__"(i=as.integer(i[n]-1), x=value[n]))
x
})

setAs('ExternalReference', 'character',
function(from) {if (!is.null(from$"__str__")) from$"__str__"()})

suppressMessages(suppressWarnings(setMethod('print', 'ExternalReference',
function(x) {print(as(x, "character"))})))

# Start of FlowModel_value_set

`FlowModel_value_set` = function(self, s_value)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_value = as.integer(s_value);
  
  if(length(s_value) > 1) {
    warning("using only the first element of s_value");
  };
  
  ;.Call('R_swig_FlowModel_value_set', self, s_value, PACKAGE='infomap');
  
}

attr(`FlowModel_value_set`, 'returnType') = 'void'
attr(`FlowModel_value_set`, "inputTypes") = c('_p_infomap__FlowModel', 'integer')
class(`FlowModel_value_set`) = c("SWIGFunction", class('FlowModel_value_set'))

# Start of FlowModel_value_get

`FlowModel_value_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_FlowModel_value_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`FlowModel_value_get`, 'returnType') = 'integer'
attr(`FlowModel_value_get`, "inputTypes") = c('_p_infomap__FlowModel')
class(`FlowModel_value_get`) = c("SWIGFunction", class('FlowModel_value_get'))

# Start of new_FlowModel

`FlowModel` = function(val)
{
  val = as.integer(val);
  
  if(length(val) > 1) {
    warning("using only the first element of val");
  };
  
  ;ans = .Call('R_swig_new_FlowModel', val, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__FlowModel", ref=ans);
  
  reg.finalizer(ans@ref, delete_FlowModel);
  ans
  
}

attr(`FlowModel`, 'returnType') = '_p_infomap__FlowModel'
attr(`FlowModel`, "inputTypes") = c('integer')
class(`FlowModel`) = c("SWIGFunction", class('FlowModel'))

# Start of FlowModel_Equal

`FlowModel_Equal` = function(self, val, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  val = as.integer(val);
  
  if(length(val) > 1) {
    warning("using only the first element of val");
  };
  
  ;ans = .Call('R_swig_FlowModel_Equal', self, val, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__FlowModel", ref=ans);
  
  ans
  
}

attr(`FlowModel_Equal`, 'returnType') = '_p_infomap__FlowModel'
attr(`FlowModel_Equal`, "inputTypes") = c('_p_infomap__FlowModel', 'integer')
class(`FlowModel_Equal`) = c("SWIGFunction", class('FlowModel_Equal'))

# Start of delete_FlowModel

`delete_FlowModel` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_FlowModel', self, PACKAGE='infomap');
  
}

attr(`delete_FlowModel`, 'returnType') = 'void'
attr(`delete_FlowModel`, "inputTypes") = c('_p_infomap__FlowModel')
class(`delete_FlowModel`) = c("SWIGFunction", class('delete_FlowModel'))

# Start of accessor method for infomap::FlowModel
setMethod('$', '_p_infomap__FlowModel', function(x, name)

{
  accessorFuns = list('value' = FlowModel_value_get, 'Equal' = FlowModel_Equal);
  vaccessors = c('value');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for infomap::FlowModel
# Start of accessor method for infomap::FlowModel
setMethod('$<-', '_p_infomap__FlowModel', function(x, name, value)

{
  accessorFuns = list('value' = FlowModel_value_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_infomap__FlowModel', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('value' = FlowModel_value_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for infomap::FlowModel
setMethod('delete', '_p_infomap__FlowModel', function(obj) {delete_infomap__FlowModel(obj)})
# Start definition of copy functions & methods for infomap::FlowModel
CopyToR_infomap__FlowModel = function(value, obj = new("infomap::FlowModel"))
{
  obj@undirected = value$undirected;
  obj@directed = value$directed;
  obj@undirdir = value$undirdir;
  obj@outdirdir = value$outdirdir;
  obj@rawdir = value$rawdir;
  obj@value = value$value;
  obj;
}



CopyToC_infomap__FlowModel = function(value, obj)
{
  obj$undirected = value@undirected;
  obj$directed = value@directed;
  obj$undirdir = value@undirdir;
  obj$outdirdir = value@outdirdir;
  obj$rawdir = value@rawdir;
  obj$value = value@value;
  obj
}



# Start definition of copy methods for infomap::FlowModel
setMethod('copyToR', '_p_infomap::FlowModel', CopyToR_infomap__FlowModel);
setMethod('copyToC', 'infomap::FlowModel', CopyToC_infomap__FlowModel);

# End definition of copy methods for infomap::FlowModel
# End definition of copy functions & methods for infomap::FlowModel
# Start of OptimizationLevel_value_set

`OptimizationLevel_value_set` = function(self, s_value)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_value = as.integer(s_value);
  
  if(length(s_value) > 1) {
    warning("using only the first element of s_value");
  };
  
  ;.Call('R_swig_OptimizationLevel_value_set', self, s_value, PACKAGE='infomap');
  
}

attr(`OptimizationLevel_value_set`, 'returnType') = 'void'
attr(`OptimizationLevel_value_set`, "inputTypes") = c('_p_infomap__OptimizationLevel', 'integer')
class(`OptimizationLevel_value_set`) = c("SWIGFunction", class('OptimizationLevel_value_set'))

# Start of OptimizationLevel_value_get

`OptimizationLevel_value_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_OptimizationLevel_value_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`OptimizationLevel_value_get`, 'returnType') = 'integer'
attr(`OptimizationLevel_value_get`, "inputTypes") = c('_p_infomap__OptimizationLevel')
class(`OptimizationLevel_value_get`) = c("SWIGFunction", class('OptimizationLevel_value_get'))

# Start of new_OptimizationLevel

`OptimizationLevel` = function()
{
  ;ans = .Call('R_swig_new_OptimizationLevel', PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__OptimizationLevel", ref=ans);
  
  reg.finalizer(ans@ref, delete_OptimizationLevel);
  ans
  
}

attr(`OptimizationLevel`, 'returnType') = '_p_infomap__OptimizationLevel'
class(`OptimizationLevel`) = c("SWIGFunction", class('OptimizationLevel'))

# Start of delete_OptimizationLevel

`delete_OptimizationLevel` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_OptimizationLevel', self, PACKAGE='infomap');
  
}

attr(`delete_OptimizationLevel`, 'returnType') = 'void'
attr(`delete_OptimizationLevel`, "inputTypes") = c('_p_infomap__OptimizationLevel')
class(`delete_OptimizationLevel`) = c("SWIGFunction", class('delete_OptimizationLevel'))

# Start of accessor method for infomap::OptimizationLevel
setMethod('$', '_p_infomap__OptimizationLevel', function(x, name)

{
  accessorFuns = list('value' = OptimizationLevel_value_get);
  vaccessors = c('value');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for infomap::OptimizationLevel
# Start of accessor method for infomap::OptimizationLevel
setMethod('$<-', '_p_infomap__OptimizationLevel', function(x, name, value)

{
  accessorFuns = list('value' = OptimizationLevel_value_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_infomap__OptimizationLevel', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('value' = OptimizationLevel_value_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for infomap::OptimizationLevel
setMethod('delete', '_p_infomap__OptimizationLevel', function(obj) {delete_infomap__OptimizationLevel(obj)})
# Start definition of copy functions & methods for infomap::OptimizationLevel
CopyToR_infomap__OptimizationLevel = function(value, obj = new("infomap::OptimizationLevel"))
{
  obj@FullCoarseTune = value$FullCoarseTune;
  obj@FastCoarseTune = value$FastCoarseTune;
  obj@NoTune = value$NoTune;
  obj@NoAggregationNoTune = value$NoAggregationNoTune;
  obj@value = value$value;
  obj;
}



CopyToC_infomap__OptimizationLevel = function(value, obj)
{
  obj$FullCoarseTune = value@FullCoarseTune;
  obj$FastCoarseTune = value@FastCoarseTune;
  obj$NoTune = value@NoTune;
  obj$NoAggregationNoTune = value@NoAggregationNoTune;
  obj$value = value@value;
  obj
}



# Start definition of copy methods for infomap::OptimizationLevel
setMethod('copyToR', '_p_infomap::OptimizationLevel', CopyToR_infomap__OptimizationLevel);
setMethod('copyToC', 'infomap::OptimizationLevel', CopyToC_infomap__OptimizationLevel);

# End definition of copy methods for infomap::OptimizationLevel
# End definition of copy functions & methods for infomap::OptimizationLevel
# Start of Config_isCLI_set

`Config_isCLI_set` = function(self, s_isCLI)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_isCLI = as.logical(s_isCLI);
  ;.Call('R_swig_Config_isCLI_set', self, s_isCLI, PACKAGE='infomap');
  
}

attr(`Config_isCLI_set`, 'returnType') = 'void'
attr(`Config_isCLI_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_isCLI_set`) = c("SWIGFunction", class('Config_isCLI_set'))

# Start of Config_isCLI_get

`Config_isCLI_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_isCLI_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_isCLI_get`, 'returnType') = 'logical'
attr(`Config_isCLI_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_isCLI_get`) = c("SWIGFunction", class('Config_isCLI_get'))

# Start of Config_networkFile_set

`Config_networkFile_set` = function(self, s_networkFile)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_networkFile = as(s_networkFile, "character"); 
  ;.Call('R_swig_Config_networkFile_set', self, s_networkFile, PACKAGE='infomap');
  
}

attr(`Config_networkFile_set`, 'returnType') = 'void'
attr(`Config_networkFile_set`, "inputTypes") = c('_p_infomap__Config', 'character')
class(`Config_networkFile_set`) = c("SWIGFunction", class('Config_networkFile_set'))

# Start of Config_networkFile_get

`Config_networkFile_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_networkFile_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_networkFile_get`, 'returnType') = 'character'
attr(`Config_networkFile_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_networkFile_get`) = c("SWIGFunction", class('Config_networkFile_get'))

# Start of Config_additionalInput_set

`Config_additionalInput_set` = function(self, s_additionalInput)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_additionalInput, "ExternalReference")) s_additionalInput = slot(s_additionalInput,"ref"); 
  ;.Call('R_swig_Config_additionalInput_set', self, s_additionalInput, PACKAGE='infomap');
  
}

attr(`Config_additionalInput_set`, 'returnType') = 'void'
attr(`Config_additionalInput_set`, "inputTypes") = c('_p_infomap__Config', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`Config_additionalInput_set`) = c("SWIGFunction", class('Config_additionalInput_set'))

# Start of Config_additionalInput_get

`Config_additionalInput_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_Config_additionalInput_get', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans);
  
  ans
  
}

attr(`Config_additionalInput_get`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`Config_additionalInput_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_additionalInput_get`) = c("SWIGFunction", class('Config_additionalInput_get'))

# Start of Config_inputFormat_set

`Config_inputFormat_set` = function(self, s_inputFormat)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_inputFormat = as(s_inputFormat, "character"); 
  ;.Call('R_swig_Config_inputFormat_set', self, s_inputFormat, PACKAGE='infomap');
  
}

attr(`Config_inputFormat_set`, 'returnType') = 'void'
attr(`Config_inputFormat_set`, "inputTypes") = c('_p_infomap__Config', 'character')
class(`Config_inputFormat_set`) = c("SWIGFunction", class('Config_inputFormat_set'))

# Start of Config_inputFormat_get

`Config_inputFormat_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_inputFormat_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_inputFormat_get`, 'returnType') = 'character'
attr(`Config_inputFormat_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_inputFormat_get`) = c("SWIGFunction", class('Config_inputFormat_get'))

# Start of Config_memoryInput_set

`Config_memoryInput_set` = function(self, s_memoryInput)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_memoryInput = as.logical(s_memoryInput);
  ;.Call('R_swig_Config_memoryInput_set', self, s_memoryInput, PACKAGE='infomap');
  
}

attr(`Config_memoryInput_set`, 'returnType') = 'void'
attr(`Config_memoryInput_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_memoryInput_set`) = c("SWIGFunction", class('Config_memoryInput_set'))

# Start of Config_memoryInput_get

`Config_memoryInput_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_memoryInput_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_memoryInput_get`, 'returnType') = 'logical'
attr(`Config_memoryInput_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_memoryInput_get`) = c("SWIGFunction", class('Config_memoryInput_get'))

# Start of Config_multilayerInput_set

`Config_multilayerInput_set` = function(self, s_multilayerInput)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_multilayerInput = as.logical(s_multilayerInput);
  ;.Call('R_swig_Config_multilayerInput_set', self, s_multilayerInput, PACKAGE='infomap');
  
}

attr(`Config_multilayerInput_set`, 'returnType') = 'void'
attr(`Config_multilayerInput_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_multilayerInput_set`) = c("SWIGFunction", class('Config_multilayerInput_set'))

# Start of Config_multilayerInput_get

`Config_multilayerInput_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_multilayerInput_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_multilayerInput_get`, 'returnType') = 'logical'
attr(`Config_multilayerInput_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_multilayerInput_get`) = c("SWIGFunction", class('Config_multilayerInput_get'))

# Start of Config_weightThreshold_set

`Config_weightThreshold_set` = function(self, s_weightThreshold)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_Config_weightThreshold_set', self, s_weightThreshold, PACKAGE='infomap');
  
}

attr(`Config_weightThreshold_set`, 'returnType') = 'void'
attr(`Config_weightThreshold_set`, "inputTypes") = c('_p_infomap__Config', 'numeric')
class(`Config_weightThreshold_set`) = c("SWIGFunction", class('Config_weightThreshold_set'))

# Start of Config_weightThreshold_get

`Config_weightThreshold_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_weightThreshold_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_weightThreshold_get`, 'returnType') = 'numeric'
attr(`Config_weightThreshold_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_weightThreshold_get`) = c("SWIGFunction", class('Config_weightThreshold_get'))

# Start of Config_unweightedPaths_set

`Config_unweightedPaths_set` = function(self, s_unweightedPaths)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_unweightedPaths = as.logical(s_unweightedPaths);
  ;.Call('R_swig_Config_unweightedPaths_set', self, s_unweightedPaths, PACKAGE='infomap');
  
}

attr(`Config_unweightedPaths_set`, 'returnType') = 'void'
attr(`Config_unweightedPaths_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_unweightedPaths_set`) = c("SWIGFunction", class('Config_unweightedPaths_set'))

# Start of Config_unweightedPaths_get

`Config_unweightedPaths_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_unweightedPaths_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_unweightedPaths_get`, 'returnType') = 'logical'
attr(`Config_unweightedPaths_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_unweightedPaths_get`) = c("SWIGFunction", class('Config_unweightedPaths_get'))

# Start of Config_pathMarkovOrder_set

`Config_pathMarkovOrder_set` = function(self, s_pathMarkovOrder)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_pathMarkovOrder = as.integer(s_pathMarkovOrder);
  
  if(length(s_pathMarkovOrder) > 1) {
    warning("using only the first element of s_pathMarkovOrder");
  };
  
  ;.Call('R_swig_Config_pathMarkovOrder_set', self, s_pathMarkovOrder, PACKAGE='infomap');
  
}

attr(`Config_pathMarkovOrder_set`, 'returnType') = 'void'
attr(`Config_pathMarkovOrder_set`, "inputTypes") = c('_p_infomap__Config', 'integer')
class(`Config_pathMarkovOrder_set`) = c("SWIGFunction", class('Config_pathMarkovOrder_set'))

# Start of Config_pathMarkovOrder_get

`Config_pathMarkovOrder_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_pathMarkovOrder_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_pathMarkovOrder_get`, 'returnType') = 'integer'
attr(`Config_pathMarkovOrder_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_pathMarkovOrder_get`) = c("SWIGFunction", class('Config_pathMarkovOrder_get'))

# Start of Config_bipartite_set

`Config_bipartite_set` = function(self, s_bipartite)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_bipartite = as.logical(s_bipartite);
  ;.Call('R_swig_Config_bipartite_set', self, s_bipartite, PACKAGE='infomap');
  
}

attr(`Config_bipartite_set`, 'returnType') = 'void'
attr(`Config_bipartite_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_bipartite_set`) = c("SWIGFunction", class('Config_bipartite_set'))

# Start of Config_bipartite_get

`Config_bipartite_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_bipartite_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_bipartite_get`, 'returnType') = 'logical'
attr(`Config_bipartite_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_bipartite_get`) = c("SWIGFunction", class('Config_bipartite_get'))

# Start of Config_skipAdjustBipartiteFlow_set

`Config_skipAdjustBipartiteFlow_set` = function(self, s_skipAdjustBipartiteFlow)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_skipAdjustBipartiteFlow = as.logical(s_skipAdjustBipartiteFlow);
  ;.Call('R_swig_Config_skipAdjustBipartiteFlow_set', self, s_skipAdjustBipartiteFlow, PACKAGE='infomap');
  
}

attr(`Config_skipAdjustBipartiteFlow_set`, 'returnType') = 'void'
attr(`Config_skipAdjustBipartiteFlow_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_skipAdjustBipartiteFlow_set`) = c("SWIGFunction", class('Config_skipAdjustBipartiteFlow_set'))

# Start of Config_skipAdjustBipartiteFlow_get

`Config_skipAdjustBipartiteFlow_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_skipAdjustBipartiteFlow_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_skipAdjustBipartiteFlow_get`, 'returnType') = 'logical'
attr(`Config_skipAdjustBipartiteFlow_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_skipAdjustBipartiteFlow_get`) = c("SWIGFunction", class('Config_skipAdjustBipartiteFlow_get'))

# Start of Config_bipartiteTeleportation_set

`Config_bipartiteTeleportation_set` = function(self, s_bipartiteTeleportation)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_bipartiteTeleportation = as.logical(s_bipartiteTeleportation);
  ;.Call('R_swig_Config_bipartiteTeleportation_set', self, s_bipartiteTeleportation, PACKAGE='infomap');
  
}

attr(`Config_bipartiteTeleportation_set`, 'returnType') = 'void'
attr(`Config_bipartiteTeleportation_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_bipartiteTeleportation_set`) = c("SWIGFunction", class('Config_bipartiteTeleportation_set'))

# Start of Config_bipartiteTeleportation_get

`Config_bipartiteTeleportation_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_bipartiteTeleportation_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_bipartiteTeleportation_get`, 'returnType') = 'logical'
attr(`Config_bipartiteTeleportation_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_bipartiteTeleportation_get`) = c("SWIGFunction", class('Config_bipartiteTeleportation_get'))

# Start of Config_hardPartitions_set

`Config_hardPartitions_set` = function(self, s_hardPartitions)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_hardPartitions = as.logical(s_hardPartitions);
  ;.Call('R_swig_Config_hardPartitions_set', self, s_hardPartitions, PACKAGE='infomap');
  
}

attr(`Config_hardPartitions_set`, 'returnType') = 'void'
attr(`Config_hardPartitions_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_hardPartitions_set`) = c("SWIGFunction", class('Config_hardPartitions_set'))

# Start of Config_hardPartitions_get

`Config_hardPartitions_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_hardPartitions_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_hardPartitions_get`, 'returnType') = 'logical'
attr(`Config_hardPartitions_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_hardPartitions_get`) = c("SWIGFunction", class('Config_hardPartitions_get'))

# Start of Config_parseWithoutIOStreams_set

`Config_parseWithoutIOStreams_set` = function(self, s_parseWithoutIOStreams)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_parseWithoutIOStreams = as.logical(s_parseWithoutIOStreams);
  ;.Call('R_swig_Config_parseWithoutIOStreams_set', self, s_parseWithoutIOStreams, PACKAGE='infomap');
  
}

attr(`Config_parseWithoutIOStreams_set`, 'returnType') = 'void'
attr(`Config_parseWithoutIOStreams_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_parseWithoutIOStreams_set`) = c("SWIGFunction", class('Config_parseWithoutIOStreams_set'))

# Start of Config_parseWithoutIOStreams_get

`Config_parseWithoutIOStreams_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_parseWithoutIOStreams_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_parseWithoutIOStreams_get`, 'returnType') = 'logical'
attr(`Config_parseWithoutIOStreams_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_parseWithoutIOStreams_get`) = c("SWIGFunction", class('Config_parseWithoutIOStreams_get'))

# Start of Config_zeroBasedNodeNumbers_set

`Config_zeroBasedNodeNumbers_set` = function(self, s_zeroBasedNodeNumbers)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_zeroBasedNodeNumbers = as.logical(s_zeroBasedNodeNumbers);
  ;.Call('R_swig_Config_zeroBasedNodeNumbers_set', self, s_zeroBasedNodeNumbers, PACKAGE='infomap');
  
}

attr(`Config_zeroBasedNodeNumbers_set`, 'returnType') = 'void'
attr(`Config_zeroBasedNodeNumbers_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_zeroBasedNodeNumbers_set`) = c("SWIGFunction", class('Config_zeroBasedNodeNumbers_set'))

# Start of Config_zeroBasedNodeNumbers_get

`Config_zeroBasedNodeNumbers_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_zeroBasedNodeNumbers_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_zeroBasedNodeNumbers_get`, 'returnType') = 'logical'
attr(`Config_zeroBasedNodeNumbers_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_zeroBasedNodeNumbers_get`) = c("SWIGFunction", class('Config_zeroBasedNodeNumbers_get'))

# Start of Config_includeSelfLinks_set

`Config_includeSelfLinks_set` = function(self, s_includeSelfLinks)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_includeSelfLinks = as.logical(s_includeSelfLinks);
  ;.Call('R_swig_Config_includeSelfLinks_set', self, s_includeSelfLinks, PACKAGE='infomap');
  
}

attr(`Config_includeSelfLinks_set`, 'returnType') = 'void'
attr(`Config_includeSelfLinks_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_includeSelfLinks_set`) = c("SWIGFunction", class('Config_includeSelfLinks_set'))

# Start of Config_includeSelfLinks_get

`Config_includeSelfLinks_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_includeSelfLinks_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_includeSelfLinks_get`, 'returnType') = 'logical'
attr(`Config_includeSelfLinks_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_includeSelfLinks_get`) = c("SWIGFunction", class('Config_includeSelfLinks_get'))

# Start of Config_ignoreEdgeWeights_set

`Config_ignoreEdgeWeights_set` = function(self, s_ignoreEdgeWeights)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_ignoreEdgeWeights = as.logical(s_ignoreEdgeWeights);
  ;.Call('R_swig_Config_ignoreEdgeWeights_set', self, s_ignoreEdgeWeights, PACKAGE='infomap');
  
}

attr(`Config_ignoreEdgeWeights_set`, 'returnType') = 'void'
attr(`Config_ignoreEdgeWeights_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_ignoreEdgeWeights_set`) = c("SWIGFunction", class('Config_ignoreEdgeWeights_set'))

# Start of Config_ignoreEdgeWeights_get

`Config_ignoreEdgeWeights_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_ignoreEdgeWeights_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_ignoreEdgeWeights_get`, 'returnType') = 'logical'
attr(`Config_ignoreEdgeWeights_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_ignoreEdgeWeights_get`) = c("SWIGFunction", class('Config_ignoreEdgeWeights_get'))

# Start of Config_nodeLimit_set

`Config_nodeLimit_set` = function(self, s_nodeLimit)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_nodeLimit = as.integer(s_nodeLimit);
  
  if(length(s_nodeLimit) > 1) {
    warning("using only the first element of s_nodeLimit");
  };
  
  ;.Call('R_swig_Config_nodeLimit_set', self, s_nodeLimit, PACKAGE='infomap');
  
}

attr(`Config_nodeLimit_set`, 'returnType') = 'void'
attr(`Config_nodeLimit_set`, "inputTypes") = c('_p_infomap__Config', 'integer')
class(`Config_nodeLimit_set`) = c("SWIGFunction", class('Config_nodeLimit_set'))

# Start of Config_nodeLimit_get

`Config_nodeLimit_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_nodeLimit_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_nodeLimit_get`, 'returnType') = 'integer'
attr(`Config_nodeLimit_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_nodeLimit_get`) = c("SWIGFunction", class('Config_nodeLimit_get'))

# Start of Config_preClusterMultilayer_set

`Config_preClusterMultilayer_set` = function(self, s_preClusterMultilayer)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_preClusterMultilayer = as.logical(s_preClusterMultilayer);
  ;.Call('R_swig_Config_preClusterMultilayer_set', self, s_preClusterMultilayer, PACKAGE='infomap');
  
}

attr(`Config_preClusterMultilayer_set`, 'returnType') = 'void'
attr(`Config_preClusterMultilayer_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_preClusterMultilayer_set`) = c("SWIGFunction", class('Config_preClusterMultilayer_set'))

# Start of Config_preClusterMultilayer_get

`Config_preClusterMultilayer_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_preClusterMultilayer_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_preClusterMultilayer_get`, 'returnType') = 'logical'
attr(`Config_preClusterMultilayer_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_preClusterMultilayer_get`) = c("SWIGFunction", class('Config_preClusterMultilayer_get'))

# Start of Config_clusterDataFile_set

`Config_clusterDataFile_set` = function(self, s_clusterDataFile)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_clusterDataFile = as(s_clusterDataFile, "character"); 
  ;.Call('R_swig_Config_clusterDataFile_set', self, s_clusterDataFile, PACKAGE='infomap');
  
}

attr(`Config_clusterDataFile_set`, 'returnType') = 'void'
attr(`Config_clusterDataFile_set`, "inputTypes") = c('_p_infomap__Config', 'character')
class(`Config_clusterDataFile_set`) = c("SWIGFunction", class('Config_clusterDataFile_set'))

# Start of Config_clusterDataFile_get

`Config_clusterDataFile_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_clusterDataFile_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_clusterDataFile_get`, 'returnType') = 'character'
attr(`Config_clusterDataFile_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_clusterDataFile_get`) = c("SWIGFunction", class('Config_clusterDataFile_get'))

# Start of Config_metaDataFile_set

`Config_metaDataFile_set` = function(self, s_metaDataFile)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_metaDataFile = as(s_metaDataFile, "character"); 
  ;.Call('R_swig_Config_metaDataFile_set', self, s_metaDataFile, PACKAGE='infomap');
  
}

attr(`Config_metaDataFile_set`, 'returnType') = 'void'
attr(`Config_metaDataFile_set`, "inputTypes") = c('_p_infomap__Config', 'character')
class(`Config_metaDataFile_set`) = c("SWIGFunction", class('Config_metaDataFile_set'))

# Start of Config_metaDataFile_get

`Config_metaDataFile_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_metaDataFile_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_metaDataFile_get`, 'returnType') = 'character'
attr(`Config_metaDataFile_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_metaDataFile_get`) = c("SWIGFunction", class('Config_metaDataFile_get'))

# Start of Config_metaDataRate_set

`Config_metaDataRate_set` = function(self, s_metaDataRate)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_Config_metaDataRate_set', self, s_metaDataRate, PACKAGE='infomap');
  
}

attr(`Config_metaDataRate_set`, 'returnType') = 'void'
attr(`Config_metaDataRate_set`, "inputTypes") = c('_p_infomap__Config', 'numeric')
class(`Config_metaDataRate_set`) = c("SWIGFunction", class('Config_metaDataRate_set'))

# Start of Config_metaDataRate_get

`Config_metaDataRate_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_metaDataRate_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_metaDataRate_get`, 'returnType') = 'numeric'
attr(`Config_metaDataRate_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_metaDataRate_get`) = c("SWIGFunction", class('Config_metaDataRate_get'))

# Start of Config_unweightedMetaData_set

`Config_unweightedMetaData_set` = function(self, s_unweightedMetaData)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_unweightedMetaData = as.logical(s_unweightedMetaData);
  ;.Call('R_swig_Config_unweightedMetaData_set', self, s_unweightedMetaData, PACKAGE='infomap');
  
}

attr(`Config_unweightedMetaData_set`, 'returnType') = 'void'
attr(`Config_unweightedMetaData_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_unweightedMetaData_set`) = c("SWIGFunction", class('Config_unweightedMetaData_set'))

# Start of Config_unweightedMetaData_get

`Config_unweightedMetaData_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_unweightedMetaData_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_unweightedMetaData_get`, 'returnType') = 'logical'
attr(`Config_unweightedMetaData_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_unweightedMetaData_get`) = c("SWIGFunction", class('Config_unweightedMetaData_get'))

# Start of Config_numMetaDataDimensions_set

`Config_numMetaDataDimensions_set` = function(self, s_numMetaDataDimensions)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_numMetaDataDimensions = as.integer(s_numMetaDataDimensions);
  
  if(length(s_numMetaDataDimensions) > 1) {
    warning("using only the first element of s_numMetaDataDimensions");
  };
  
  ;.Call('R_swig_Config_numMetaDataDimensions_set', self, s_numMetaDataDimensions, PACKAGE='infomap');
  
}

attr(`Config_numMetaDataDimensions_set`, 'returnType') = 'void'
attr(`Config_numMetaDataDimensions_set`, "inputTypes") = c('_p_infomap__Config', 'integer')
class(`Config_numMetaDataDimensions_set`) = c("SWIGFunction", class('Config_numMetaDataDimensions_set'))

# Start of Config_numMetaDataDimensions_get

`Config_numMetaDataDimensions_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_numMetaDataDimensions_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_numMetaDataDimensions_get`, 'returnType') = 'integer'
attr(`Config_numMetaDataDimensions_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_numMetaDataDimensions_get`) = c("SWIGFunction", class('Config_numMetaDataDimensions_get'))

# Start of Config_clusterDataIsHard_set

`Config_clusterDataIsHard_set` = function(self, s_clusterDataIsHard)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_clusterDataIsHard = as.logical(s_clusterDataIsHard);
  ;.Call('R_swig_Config_clusterDataIsHard_set', self, s_clusterDataIsHard, PACKAGE='infomap');
  
}

attr(`Config_clusterDataIsHard_set`, 'returnType') = 'void'
attr(`Config_clusterDataIsHard_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_clusterDataIsHard_set`) = c("SWIGFunction", class('Config_clusterDataIsHard_set'))

# Start of Config_clusterDataIsHard_get

`Config_clusterDataIsHard_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_clusterDataIsHard_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_clusterDataIsHard_get`, 'returnType') = 'logical'
attr(`Config_clusterDataIsHard_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_clusterDataIsHard_get`) = c("SWIGFunction", class('Config_clusterDataIsHard_get'))

# Start of Config_assignToNeighbouringModule_set

`Config_assignToNeighbouringModule_set` = function(self, s_assignToNeighbouringModule)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_assignToNeighbouringModule = as.logical(s_assignToNeighbouringModule);
  ;.Call('R_swig_Config_assignToNeighbouringModule_set', self, s_assignToNeighbouringModule, PACKAGE='infomap');
  
}

attr(`Config_assignToNeighbouringModule_set`, 'returnType') = 'void'
attr(`Config_assignToNeighbouringModule_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_assignToNeighbouringModule_set`) = c("SWIGFunction", class('Config_assignToNeighbouringModule_set'))

# Start of Config_assignToNeighbouringModule_get

`Config_assignToNeighbouringModule_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_assignToNeighbouringModule_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_assignToNeighbouringModule_get`, 'returnType') = 'logical'
attr(`Config_assignToNeighbouringModule_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_assignToNeighbouringModule_get`) = c("SWIGFunction", class('Config_assignToNeighbouringModule_get'))

# Start of Config_noInfomap_set

`Config_noInfomap_set` = function(self, s_noInfomap)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_noInfomap = as.logical(s_noInfomap);
  ;.Call('R_swig_Config_noInfomap_set', self, s_noInfomap, PACKAGE='infomap');
  
}

attr(`Config_noInfomap_set`, 'returnType') = 'void'
attr(`Config_noInfomap_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_noInfomap_set`) = c("SWIGFunction", class('Config_noInfomap_set'))

# Start of Config_noInfomap_get

`Config_noInfomap_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_noInfomap_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_noInfomap_get`, 'returnType') = 'logical'
attr(`Config_noInfomap_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_noInfomap_get`) = c("SWIGFunction", class('Config_noInfomap_get'))

# Start of Config_flowModel_set

`Config_flowModel_set` = function(self, s_flowModel)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_flowModel, "ExternalReference")) s_flowModel = slot(s_flowModel,"ref"); 
  ;.Call('R_swig_Config_flowModel_set', self, s_flowModel, PACKAGE='infomap');
  
}

attr(`Config_flowModel_set`, 'returnType') = 'void'
attr(`Config_flowModel_set`, "inputTypes") = c('_p_infomap__Config', '_p_infomap__FlowModel')
class(`Config_flowModel_set`) = c("SWIGFunction", class('Config_flowModel_set'))

# Start of Config_flowModel_get

`Config_flowModel_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_Config_flowModel_get', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__FlowModel", ref=ans);
  
  ans
  
}

attr(`Config_flowModel_get`, 'returnType') = '_p_infomap__FlowModel'
attr(`Config_flowModel_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_flowModel_get`) = c("SWIGFunction", class('Config_flowModel_get'))

# Start of Config_directed_set

`Config_directed_set` = function(self, s_directed)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_directed = as.logical(s_directed);
  ;.Call('R_swig_Config_directed_set', self, s_directed, PACKAGE='infomap');
  
}

attr(`Config_directed_set`, 'returnType') = 'void'
attr(`Config_directed_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_directed_set`) = c("SWIGFunction", class('Config_directed_set'))

# Start of Config_directed_get

`Config_directed_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_directed_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_directed_get`, 'returnType') = 'logical'
attr(`Config_directed_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_directed_get`) = c("SWIGFunction", class('Config_directed_get'))

# Start of Config_undirdir_set

`Config_undirdir_set` = function(self, s_undirdir)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_undirdir = as.logical(s_undirdir);
  ;.Call('R_swig_Config_undirdir_set', self, s_undirdir, PACKAGE='infomap');
  
}

attr(`Config_undirdir_set`, 'returnType') = 'void'
attr(`Config_undirdir_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_undirdir_set`) = c("SWIGFunction", class('Config_undirdir_set'))

# Start of Config_undirdir_get

`Config_undirdir_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_undirdir_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_undirdir_get`, 'returnType') = 'logical'
attr(`Config_undirdir_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_undirdir_get`) = c("SWIGFunction", class('Config_undirdir_get'))

# Start of Config_outdirdir_set

`Config_outdirdir_set` = function(self, s_outdirdir)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_outdirdir = as.logical(s_outdirdir);
  ;.Call('R_swig_Config_outdirdir_set', self, s_outdirdir, PACKAGE='infomap');
  
}

attr(`Config_outdirdir_set`, 'returnType') = 'void'
attr(`Config_outdirdir_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_outdirdir_set`) = c("SWIGFunction", class('Config_outdirdir_set'))

# Start of Config_outdirdir_get

`Config_outdirdir_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_outdirdir_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_outdirdir_get`, 'returnType') = 'logical'
attr(`Config_outdirdir_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_outdirdir_get`) = c("SWIGFunction", class('Config_outdirdir_get'))

# Start of Config_rawdir_set

`Config_rawdir_set` = function(self, s_rawdir)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_rawdir = as.logical(s_rawdir);
  ;.Call('R_swig_Config_rawdir_set', self, s_rawdir, PACKAGE='infomap');
  
}

attr(`Config_rawdir_set`, 'returnType') = 'void'
attr(`Config_rawdir_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_rawdir_set`) = c("SWIGFunction", class('Config_rawdir_set'))

# Start of Config_rawdir_get

`Config_rawdir_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_rawdir_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_rawdir_get`, 'returnType') = 'logical'
attr(`Config_rawdir_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_rawdir_get`) = c("SWIGFunction", class('Config_rawdir_get'))

# Start of Config_useNodeWeightsAsFlow_set

`Config_useNodeWeightsAsFlow_set` = function(self, s_useNodeWeightsAsFlow)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_useNodeWeightsAsFlow = as.logical(s_useNodeWeightsAsFlow);
  ;.Call('R_swig_Config_useNodeWeightsAsFlow_set', self, s_useNodeWeightsAsFlow, PACKAGE='infomap');
  
}

attr(`Config_useNodeWeightsAsFlow_set`, 'returnType') = 'void'
attr(`Config_useNodeWeightsAsFlow_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_useNodeWeightsAsFlow_set`) = c("SWIGFunction", class('Config_useNodeWeightsAsFlow_set'))

# Start of Config_useNodeWeightsAsFlow_get

`Config_useNodeWeightsAsFlow_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_useNodeWeightsAsFlow_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_useNodeWeightsAsFlow_get`, 'returnType') = 'logical'
attr(`Config_useNodeWeightsAsFlow_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_useNodeWeightsAsFlow_get`) = c("SWIGFunction", class('Config_useNodeWeightsAsFlow_get'))

# Start of Config_teleportToNodes_set

`Config_teleportToNodes_set` = function(self, s_teleportToNodes)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_teleportToNodes = as.logical(s_teleportToNodes);
  ;.Call('R_swig_Config_teleportToNodes_set', self, s_teleportToNodes, PACKAGE='infomap');
  
}

attr(`Config_teleportToNodes_set`, 'returnType') = 'void'
attr(`Config_teleportToNodes_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_teleportToNodes_set`) = c("SWIGFunction", class('Config_teleportToNodes_set'))

# Start of Config_teleportToNodes_get

`Config_teleportToNodes_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_teleportToNodes_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_teleportToNodes_get`, 'returnType') = 'logical'
attr(`Config_teleportToNodes_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_teleportToNodes_get`) = c("SWIGFunction", class('Config_teleportToNodes_get'))

# Start of Config_selfTeleportationProbability_set

`Config_selfTeleportationProbability_set` = function(self, s_selfTeleportationProbability)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_Config_selfTeleportationProbability_set', self, s_selfTeleportationProbability, PACKAGE='infomap');
  
}

attr(`Config_selfTeleportationProbability_set`, 'returnType') = 'void'
attr(`Config_selfTeleportationProbability_set`, "inputTypes") = c('_p_infomap__Config', 'numeric')
class(`Config_selfTeleportationProbability_set`) = c("SWIGFunction", class('Config_selfTeleportationProbability_set'))

# Start of Config_selfTeleportationProbability_get

`Config_selfTeleportationProbability_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_selfTeleportationProbability_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_selfTeleportationProbability_get`, 'returnType') = 'numeric'
attr(`Config_selfTeleportationProbability_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_selfTeleportationProbability_get`) = c("SWIGFunction", class('Config_selfTeleportationProbability_get'))

# Start of Config_markovTime_set

`Config_markovTime_set` = function(self, s_markovTime)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_Config_markovTime_set', self, s_markovTime, PACKAGE='infomap');
  
}

attr(`Config_markovTime_set`, 'returnType') = 'void'
attr(`Config_markovTime_set`, "inputTypes") = c('_p_infomap__Config', 'numeric')
class(`Config_markovTime_set`) = c("SWIGFunction", class('Config_markovTime_set'))

# Start of Config_markovTime_get

`Config_markovTime_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_markovTime_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_markovTime_get`, 'returnType') = 'numeric'
attr(`Config_markovTime_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_markovTime_get`) = c("SWIGFunction", class('Config_markovTime_get'))

# Start of Config_multilayerRelaxRate_set

`Config_multilayerRelaxRate_set` = function(self, s_multilayerRelaxRate)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_Config_multilayerRelaxRate_set', self, s_multilayerRelaxRate, PACKAGE='infomap');
  
}

attr(`Config_multilayerRelaxRate_set`, 'returnType') = 'void'
attr(`Config_multilayerRelaxRate_set`, "inputTypes") = c('_p_infomap__Config', 'numeric')
class(`Config_multilayerRelaxRate_set`) = c("SWIGFunction", class('Config_multilayerRelaxRate_set'))

# Start of Config_multilayerRelaxRate_get

`Config_multilayerRelaxRate_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_multilayerRelaxRate_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_multilayerRelaxRate_get`, 'returnType') = 'numeric'
attr(`Config_multilayerRelaxRate_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_multilayerRelaxRate_get`) = c("SWIGFunction", class('Config_multilayerRelaxRate_get'))

# Start of Config_multilayerRelaxLimit_set

`Config_multilayerRelaxLimit_set` = function(self, s_multilayerRelaxLimit)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_multilayerRelaxLimit = as.integer(s_multilayerRelaxLimit);
  
  if(length(s_multilayerRelaxLimit) > 1) {
    warning("using only the first element of s_multilayerRelaxLimit");
  };
  
  ;.Call('R_swig_Config_multilayerRelaxLimit_set', self, s_multilayerRelaxLimit, PACKAGE='infomap');
  
}

attr(`Config_multilayerRelaxLimit_set`, 'returnType') = 'void'
attr(`Config_multilayerRelaxLimit_set`, "inputTypes") = c('_p_infomap__Config', 'integer')
class(`Config_multilayerRelaxLimit_set`) = c("SWIGFunction", class('Config_multilayerRelaxLimit_set'))

# Start of Config_multilayerRelaxLimit_get

`Config_multilayerRelaxLimit_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_multilayerRelaxLimit_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_multilayerRelaxLimit_get`, 'returnType') = 'integer'
attr(`Config_multilayerRelaxLimit_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_multilayerRelaxLimit_get`) = c("SWIGFunction", class('Config_multilayerRelaxLimit_get'))

# Start of Config_multilayerRelaxLimitUp_set

`Config_multilayerRelaxLimitUp_set` = function(self, s_multilayerRelaxLimitUp)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_multilayerRelaxLimitUp = as.integer(s_multilayerRelaxLimitUp);
  
  if(length(s_multilayerRelaxLimitUp) > 1) {
    warning("using only the first element of s_multilayerRelaxLimitUp");
  };
  
  ;.Call('R_swig_Config_multilayerRelaxLimitUp_set', self, s_multilayerRelaxLimitUp, PACKAGE='infomap');
  
}

attr(`Config_multilayerRelaxLimitUp_set`, 'returnType') = 'void'
attr(`Config_multilayerRelaxLimitUp_set`, "inputTypes") = c('_p_infomap__Config', 'integer')
class(`Config_multilayerRelaxLimitUp_set`) = c("SWIGFunction", class('Config_multilayerRelaxLimitUp_set'))

# Start of Config_multilayerRelaxLimitUp_get

`Config_multilayerRelaxLimitUp_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_multilayerRelaxLimitUp_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_multilayerRelaxLimitUp_get`, 'returnType') = 'integer'
attr(`Config_multilayerRelaxLimitUp_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_multilayerRelaxLimitUp_get`) = c("SWIGFunction", class('Config_multilayerRelaxLimitUp_get'))

# Start of Config_multilayerRelaxLimitDown_set

`Config_multilayerRelaxLimitDown_set` = function(self, s_multilayerRelaxLimitDown)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_multilayerRelaxLimitDown = as.integer(s_multilayerRelaxLimitDown);
  
  if(length(s_multilayerRelaxLimitDown) > 1) {
    warning("using only the first element of s_multilayerRelaxLimitDown");
  };
  
  ;.Call('R_swig_Config_multilayerRelaxLimitDown_set', self, s_multilayerRelaxLimitDown, PACKAGE='infomap');
  
}

attr(`Config_multilayerRelaxLimitDown_set`, 'returnType') = 'void'
attr(`Config_multilayerRelaxLimitDown_set`, "inputTypes") = c('_p_infomap__Config', 'integer')
class(`Config_multilayerRelaxLimitDown_set`) = c("SWIGFunction", class('Config_multilayerRelaxLimitDown_set'))

# Start of Config_multilayerRelaxLimitDown_get

`Config_multilayerRelaxLimitDown_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_multilayerRelaxLimitDown_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_multilayerRelaxLimitDown_get`, 'returnType') = 'integer'
attr(`Config_multilayerRelaxLimitDown_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_multilayerRelaxLimitDown_get`) = c("SWIGFunction", class('Config_multilayerRelaxLimitDown_get'))

# Start of Config_multilayerJSRelaxRate_set

`Config_multilayerJSRelaxRate_set` = function(self, s_multilayerJSRelaxRate)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_Config_multilayerJSRelaxRate_set', self, s_multilayerJSRelaxRate, PACKAGE='infomap');
  
}

attr(`Config_multilayerJSRelaxRate_set`, 'returnType') = 'void'
attr(`Config_multilayerJSRelaxRate_set`, "inputTypes") = c('_p_infomap__Config', 'numeric')
class(`Config_multilayerJSRelaxRate_set`) = c("SWIGFunction", class('Config_multilayerJSRelaxRate_set'))

# Start of Config_multilayerJSRelaxRate_get

`Config_multilayerJSRelaxRate_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_multilayerJSRelaxRate_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_multilayerJSRelaxRate_get`, 'returnType') = 'numeric'
attr(`Config_multilayerJSRelaxRate_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_multilayerJSRelaxRate_get`) = c("SWIGFunction", class('Config_multilayerJSRelaxRate_get'))

# Start of Config_multilayerRelaxByJensenShannonDivergence_set

`Config_multilayerRelaxByJensenShannonDivergence_set` = function(self, s_multilayerRelaxByJensenShannonDivergence)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_multilayerRelaxByJensenShannonDivergence = as.logical(s_multilayerRelaxByJensenShannonDivergence);
  ;.Call('R_swig_Config_multilayerRelaxByJensenShannonDivergence_set', self, s_multilayerRelaxByJensenShannonDivergence, PACKAGE='infomap');
  
}

attr(`Config_multilayerRelaxByJensenShannonDivergence_set`, 'returnType') = 'void'
attr(`Config_multilayerRelaxByJensenShannonDivergence_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_multilayerRelaxByJensenShannonDivergence_set`) = c("SWIGFunction", class('Config_multilayerRelaxByJensenShannonDivergence_set'))

# Start of Config_multilayerRelaxByJensenShannonDivergence_get

`Config_multilayerRelaxByJensenShannonDivergence_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_multilayerRelaxByJensenShannonDivergence_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_multilayerRelaxByJensenShannonDivergence_get`, 'returnType') = 'logical'
attr(`Config_multilayerRelaxByJensenShannonDivergence_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_multilayerRelaxByJensenShannonDivergence_get`) = c("SWIGFunction", class('Config_multilayerRelaxByJensenShannonDivergence_get'))

# Start of Config_multilayerJSRelaxLimit_set

`Config_multilayerJSRelaxLimit_set` = function(self, s_multilayerJSRelaxLimit)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_multilayerJSRelaxLimit = as.integer(s_multilayerJSRelaxLimit);
  
  if(length(s_multilayerJSRelaxLimit) > 1) {
    warning("using only the first element of s_multilayerJSRelaxLimit");
  };
  
  ;.Call('R_swig_Config_multilayerJSRelaxLimit_set', self, s_multilayerJSRelaxLimit, PACKAGE='infomap');
  
}

attr(`Config_multilayerJSRelaxLimit_set`, 'returnType') = 'void'
attr(`Config_multilayerJSRelaxLimit_set`, "inputTypes") = c('_p_infomap__Config', 'integer')
class(`Config_multilayerJSRelaxLimit_set`) = c("SWIGFunction", class('Config_multilayerJSRelaxLimit_set'))

# Start of Config_multilayerJSRelaxLimit_get

`Config_multilayerJSRelaxLimit_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_multilayerJSRelaxLimit_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_multilayerJSRelaxLimit_get`, 'returnType') = 'integer'
attr(`Config_multilayerJSRelaxLimit_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_multilayerJSRelaxLimit_get`) = c("SWIGFunction", class('Config_multilayerJSRelaxLimit_get'))

# Start of Config_twoLevel_set

`Config_twoLevel_set` = function(self, s_twoLevel)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_twoLevel = as.logical(s_twoLevel);
  ;.Call('R_swig_Config_twoLevel_set', self, s_twoLevel, PACKAGE='infomap');
  
}

attr(`Config_twoLevel_set`, 'returnType') = 'void'
attr(`Config_twoLevel_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_twoLevel_set`) = c("SWIGFunction", class('Config_twoLevel_set'))

# Start of Config_twoLevel_get

`Config_twoLevel_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_twoLevel_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_twoLevel_get`, 'returnType') = 'logical'
attr(`Config_twoLevel_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_twoLevel_get`) = c("SWIGFunction", class('Config_twoLevel_get'))

# Start of Config_noCoarseTune_set

`Config_noCoarseTune_set` = function(self, s_noCoarseTune)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_noCoarseTune = as.logical(s_noCoarseTune);
  ;.Call('R_swig_Config_noCoarseTune_set', self, s_noCoarseTune, PACKAGE='infomap');
  
}

attr(`Config_noCoarseTune_set`, 'returnType') = 'void'
attr(`Config_noCoarseTune_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_noCoarseTune_set`) = c("SWIGFunction", class('Config_noCoarseTune_set'))

# Start of Config_noCoarseTune_get

`Config_noCoarseTune_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_noCoarseTune_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_noCoarseTune_get`, 'returnType') = 'logical'
attr(`Config_noCoarseTune_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_noCoarseTune_get`) = c("SWIGFunction", class('Config_noCoarseTune_get'))

# Start of Config_directedEdges_set

`Config_directedEdges_set` = function(self, s_directedEdges)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_directedEdges = as.logical(s_directedEdges);
  ;.Call('R_swig_Config_directedEdges_set', self, s_directedEdges, PACKAGE='infomap');
  
}

attr(`Config_directedEdges_set`, 'returnType') = 'void'
attr(`Config_directedEdges_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_directedEdges_set`) = c("SWIGFunction", class('Config_directedEdges_set'))

# Start of Config_directedEdges_get

`Config_directedEdges_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_directedEdges_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_directedEdges_get`, 'returnType') = 'logical'
attr(`Config_directedEdges_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_directedEdges_get`) = c("SWIGFunction", class('Config_directedEdges_get'))

# Start of Config_recordedTeleportation_set

`Config_recordedTeleportation_set` = function(self, s_recordedTeleportation)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_recordedTeleportation = as.logical(s_recordedTeleportation);
  ;.Call('R_swig_Config_recordedTeleportation_set', self, s_recordedTeleportation, PACKAGE='infomap');
  
}

attr(`Config_recordedTeleportation_set`, 'returnType') = 'void'
attr(`Config_recordedTeleportation_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_recordedTeleportation_set`) = c("SWIGFunction", class('Config_recordedTeleportation_set'))

# Start of Config_recordedTeleportation_get

`Config_recordedTeleportation_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_recordedTeleportation_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_recordedTeleportation_get`, 'returnType') = 'logical'
attr(`Config_recordedTeleportation_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_recordedTeleportation_get`) = c("SWIGFunction", class('Config_recordedTeleportation_get'))

# Start of Config_teleportationProbability_set

`Config_teleportationProbability_set` = function(self, s_teleportationProbability)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_Config_teleportationProbability_set', self, s_teleportationProbability, PACKAGE='infomap');
  
}

attr(`Config_teleportationProbability_set`, 'returnType') = 'void'
attr(`Config_teleportationProbability_set`, "inputTypes") = c('_p_infomap__Config', 'numeric')
class(`Config_teleportationProbability_set`) = c("SWIGFunction", class('Config_teleportationProbability_set'))

# Start of Config_teleportationProbability_get

`Config_teleportationProbability_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_teleportationProbability_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_teleportationProbability_get`, 'returnType') = 'numeric'
attr(`Config_teleportationProbability_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_teleportationProbability_get`) = c("SWIGFunction", class('Config_teleportationProbability_get'))

# Start of Config_preferredNumberOfModules_set

`Config_preferredNumberOfModules_set` = function(self, s_preferredNumberOfModules)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_preferredNumberOfModules = as.integer(s_preferredNumberOfModules);
  
  if(length(s_preferredNumberOfModules) > 1) {
    warning("using only the first element of s_preferredNumberOfModules");
  };
  
  ;.Call('R_swig_Config_preferredNumberOfModules_set', self, s_preferredNumberOfModules, PACKAGE='infomap');
  
}

attr(`Config_preferredNumberOfModules_set`, 'returnType') = 'void'
attr(`Config_preferredNumberOfModules_set`, "inputTypes") = c('_p_infomap__Config', 'integer')
class(`Config_preferredNumberOfModules_set`) = c("SWIGFunction", class('Config_preferredNumberOfModules_set'))

# Start of Config_preferredNumberOfModules_get

`Config_preferredNumberOfModules_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_preferredNumberOfModules_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_preferredNumberOfModules_get`, 'returnType') = 'integer'
attr(`Config_preferredNumberOfModules_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_preferredNumberOfModules_get`) = c("SWIGFunction", class('Config_preferredNumberOfModules_get'))

# Start of Config_seedToRandomNumberGenerator_set

`Config_seedToRandomNumberGenerator_set` = function(self, s_seedToRandomNumberGenerator)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_seedToRandomNumberGenerator = as.integer(s_seedToRandomNumberGenerator);
  
  if(length(s_seedToRandomNumberGenerator) > 1) {
    warning("using only the first element of s_seedToRandomNumberGenerator");
  };
  
  ;.Call('R_swig_Config_seedToRandomNumberGenerator_set', self, s_seedToRandomNumberGenerator, PACKAGE='infomap');
  
}

attr(`Config_seedToRandomNumberGenerator_set`, 'returnType') = 'void'
attr(`Config_seedToRandomNumberGenerator_set`, "inputTypes") = c('_p_infomap__Config', 'integer')
class(`Config_seedToRandomNumberGenerator_set`) = c("SWIGFunction", class('Config_seedToRandomNumberGenerator_set'))

# Start of Config_seedToRandomNumberGenerator_get

`Config_seedToRandomNumberGenerator_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_seedToRandomNumberGenerator_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_seedToRandomNumberGenerator_get`, 'returnType') = 'integer'
attr(`Config_seedToRandomNumberGenerator_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_seedToRandomNumberGenerator_get`) = c("SWIGFunction", class('Config_seedToRandomNumberGenerator_get'))

# Start of Config_numTrials_set

`Config_numTrials_set` = function(self, s_numTrials)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_numTrials = as.integer(s_numTrials);
  
  if(length(s_numTrials) > 1) {
    warning("using only the first element of s_numTrials");
  };
  
  ;.Call('R_swig_Config_numTrials_set', self, s_numTrials, PACKAGE='infomap');
  
}

attr(`Config_numTrials_set`, 'returnType') = 'void'
attr(`Config_numTrials_set`, "inputTypes") = c('_p_infomap__Config', 'integer')
class(`Config_numTrials_set`) = c("SWIGFunction", class('Config_numTrials_set'))

# Start of Config_numTrials_get

`Config_numTrials_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_numTrials_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_numTrials_get`, 'returnType') = 'integer'
attr(`Config_numTrials_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_numTrials_get`) = c("SWIGFunction", class('Config_numTrials_get'))

# Start of Config_minimumCodelengthImprovement_set

`Config_minimumCodelengthImprovement_set` = function(self, s_minimumCodelengthImprovement)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_Config_minimumCodelengthImprovement_set', self, s_minimumCodelengthImprovement, PACKAGE='infomap');
  
}

attr(`Config_minimumCodelengthImprovement_set`, 'returnType') = 'void'
attr(`Config_minimumCodelengthImprovement_set`, "inputTypes") = c('_p_infomap__Config', 'numeric')
class(`Config_minimumCodelengthImprovement_set`) = c("SWIGFunction", class('Config_minimumCodelengthImprovement_set'))

# Start of Config_minimumCodelengthImprovement_get

`Config_minimumCodelengthImprovement_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_minimumCodelengthImprovement_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_minimumCodelengthImprovement_get`, 'returnType') = 'numeric'
attr(`Config_minimumCodelengthImprovement_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_minimumCodelengthImprovement_get`) = c("SWIGFunction", class('Config_minimumCodelengthImprovement_get'))

# Start of Config_minimumSingleNodeCodelengthImprovement_set

`Config_minimumSingleNodeCodelengthImprovement_set` = function(self, s_minimumSingleNodeCodelengthImprovement)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_Config_minimumSingleNodeCodelengthImprovement_set', self, s_minimumSingleNodeCodelengthImprovement, PACKAGE='infomap');
  
}

attr(`Config_minimumSingleNodeCodelengthImprovement_set`, 'returnType') = 'void'
attr(`Config_minimumSingleNodeCodelengthImprovement_set`, "inputTypes") = c('_p_infomap__Config', 'numeric')
class(`Config_minimumSingleNodeCodelengthImprovement_set`) = c("SWIGFunction", class('Config_minimumSingleNodeCodelengthImprovement_set'))

# Start of Config_minimumSingleNodeCodelengthImprovement_get

`Config_minimumSingleNodeCodelengthImprovement_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_minimumSingleNodeCodelengthImprovement_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_minimumSingleNodeCodelengthImprovement_get`, 'returnType') = 'numeric'
attr(`Config_minimumSingleNodeCodelengthImprovement_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_minimumSingleNodeCodelengthImprovement_get`) = c("SWIGFunction", class('Config_minimumSingleNodeCodelengthImprovement_get'))

# Start of Config_randomizeCoreLoopLimit_set

`Config_randomizeCoreLoopLimit_set` = function(self, s_randomizeCoreLoopLimit)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_randomizeCoreLoopLimit = as.logical(s_randomizeCoreLoopLimit);
  ;.Call('R_swig_Config_randomizeCoreLoopLimit_set', self, s_randomizeCoreLoopLimit, PACKAGE='infomap');
  
}

attr(`Config_randomizeCoreLoopLimit_set`, 'returnType') = 'void'
attr(`Config_randomizeCoreLoopLimit_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_randomizeCoreLoopLimit_set`) = c("SWIGFunction", class('Config_randomizeCoreLoopLimit_set'))

# Start of Config_randomizeCoreLoopLimit_get

`Config_randomizeCoreLoopLimit_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_randomizeCoreLoopLimit_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_randomizeCoreLoopLimit_get`, 'returnType') = 'logical'
attr(`Config_randomizeCoreLoopLimit_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_randomizeCoreLoopLimit_get`) = c("SWIGFunction", class('Config_randomizeCoreLoopLimit_get'))

# Start of Config_coreLoopLimit_set

`Config_coreLoopLimit_set` = function(self, s_coreLoopLimit)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_coreLoopLimit = as.integer(s_coreLoopLimit);
  
  if(length(s_coreLoopLimit) > 1) {
    warning("using only the first element of s_coreLoopLimit");
  };
  
  ;.Call('R_swig_Config_coreLoopLimit_set', self, s_coreLoopLimit, PACKAGE='infomap');
  
}

attr(`Config_coreLoopLimit_set`, 'returnType') = 'void'
attr(`Config_coreLoopLimit_set`, "inputTypes") = c('_p_infomap__Config', 'integer')
class(`Config_coreLoopLimit_set`) = c("SWIGFunction", class('Config_coreLoopLimit_set'))

# Start of Config_coreLoopLimit_get

`Config_coreLoopLimit_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_coreLoopLimit_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_coreLoopLimit_get`, 'returnType') = 'integer'
attr(`Config_coreLoopLimit_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_coreLoopLimit_get`) = c("SWIGFunction", class('Config_coreLoopLimit_get'))

# Start of Config_levelAggregationLimit_set

`Config_levelAggregationLimit_set` = function(self, s_levelAggregationLimit)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_levelAggregationLimit = as.integer(s_levelAggregationLimit);
  
  if(length(s_levelAggregationLimit) > 1) {
    warning("using only the first element of s_levelAggregationLimit");
  };
  
  ;.Call('R_swig_Config_levelAggregationLimit_set', self, s_levelAggregationLimit, PACKAGE='infomap');
  
}

attr(`Config_levelAggregationLimit_set`, 'returnType') = 'void'
attr(`Config_levelAggregationLimit_set`, "inputTypes") = c('_p_infomap__Config', 'integer')
class(`Config_levelAggregationLimit_set`) = c("SWIGFunction", class('Config_levelAggregationLimit_set'))

# Start of Config_levelAggregationLimit_get

`Config_levelAggregationLimit_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_levelAggregationLimit_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_levelAggregationLimit_get`, 'returnType') = 'integer'
attr(`Config_levelAggregationLimit_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_levelAggregationLimit_get`) = c("SWIGFunction", class('Config_levelAggregationLimit_get'))

# Start of Config_tuneIterationLimit_set

`Config_tuneIterationLimit_set` = function(self, s_tuneIterationLimit)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_tuneIterationLimit = as.integer(s_tuneIterationLimit);
  
  if(length(s_tuneIterationLimit) > 1) {
    warning("using only the first element of s_tuneIterationLimit");
  };
  
  ;.Call('R_swig_Config_tuneIterationLimit_set', self, s_tuneIterationLimit, PACKAGE='infomap');
  
}

attr(`Config_tuneIterationLimit_set`, 'returnType') = 'void'
attr(`Config_tuneIterationLimit_set`, "inputTypes") = c('_p_infomap__Config', 'integer')
class(`Config_tuneIterationLimit_set`) = c("SWIGFunction", class('Config_tuneIterationLimit_set'))

# Start of Config_tuneIterationLimit_get

`Config_tuneIterationLimit_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_tuneIterationLimit_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_tuneIterationLimit_get`, 'returnType') = 'integer'
attr(`Config_tuneIterationLimit_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_tuneIterationLimit_get`) = c("SWIGFunction", class('Config_tuneIterationLimit_get'))

# Start of Config_minimumRelativeTuneIterationImprovement_set

`Config_minimumRelativeTuneIterationImprovement_set` = function(self, s_minimumRelativeTuneIterationImprovement)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_Config_minimumRelativeTuneIterationImprovement_set', self, s_minimumRelativeTuneIterationImprovement, PACKAGE='infomap');
  
}

attr(`Config_minimumRelativeTuneIterationImprovement_set`, 'returnType') = 'void'
attr(`Config_minimumRelativeTuneIterationImprovement_set`, "inputTypes") = c('_p_infomap__Config', 'numeric')
class(`Config_minimumRelativeTuneIterationImprovement_set`) = c("SWIGFunction", class('Config_minimumRelativeTuneIterationImprovement_set'))

# Start of Config_minimumRelativeTuneIterationImprovement_get

`Config_minimumRelativeTuneIterationImprovement_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_minimumRelativeTuneIterationImprovement_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_minimumRelativeTuneIterationImprovement_get`, 'returnType') = 'numeric'
attr(`Config_minimumRelativeTuneIterationImprovement_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_minimumRelativeTuneIterationImprovement_get`) = c("SWIGFunction", class('Config_minimumRelativeTuneIterationImprovement_get'))

# Start of Config_fastCoarseTunePartition_set

`Config_fastCoarseTunePartition_set` = function(self, s_fastCoarseTunePartition)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_fastCoarseTunePartition = as.logical(s_fastCoarseTunePartition);
  ;.Call('R_swig_Config_fastCoarseTunePartition_set', self, s_fastCoarseTunePartition, PACKAGE='infomap');
  
}

attr(`Config_fastCoarseTunePartition_set`, 'returnType') = 'void'
attr(`Config_fastCoarseTunePartition_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_fastCoarseTunePartition_set`) = c("SWIGFunction", class('Config_fastCoarseTunePartition_set'))

# Start of Config_fastCoarseTunePartition_get

`Config_fastCoarseTunePartition_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_fastCoarseTunePartition_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_fastCoarseTunePartition_get`, 'returnType') = 'logical'
attr(`Config_fastCoarseTunePartition_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_fastCoarseTunePartition_get`) = c("SWIGFunction", class('Config_fastCoarseTunePartition_get'))

# Start of Config_alternateCoarseTuneLevel_set

`Config_alternateCoarseTuneLevel_set` = function(self, s_alternateCoarseTuneLevel)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_alternateCoarseTuneLevel = as.logical(s_alternateCoarseTuneLevel);
  ;.Call('R_swig_Config_alternateCoarseTuneLevel_set', self, s_alternateCoarseTuneLevel, PACKAGE='infomap');
  
}

attr(`Config_alternateCoarseTuneLevel_set`, 'returnType') = 'void'
attr(`Config_alternateCoarseTuneLevel_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_alternateCoarseTuneLevel_set`) = c("SWIGFunction", class('Config_alternateCoarseTuneLevel_set'))

# Start of Config_alternateCoarseTuneLevel_get

`Config_alternateCoarseTuneLevel_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_alternateCoarseTuneLevel_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_alternateCoarseTuneLevel_get`, 'returnType') = 'logical'
attr(`Config_alternateCoarseTuneLevel_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_alternateCoarseTuneLevel_get`) = c("SWIGFunction", class('Config_alternateCoarseTuneLevel_get'))

# Start of Config_coarseTuneLevel_set

`Config_coarseTuneLevel_set` = function(self, s_coarseTuneLevel)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_coarseTuneLevel = as.integer(s_coarseTuneLevel);
  
  if(length(s_coarseTuneLevel) > 1) {
    warning("using only the first element of s_coarseTuneLevel");
  };
  
  ;.Call('R_swig_Config_coarseTuneLevel_set', self, s_coarseTuneLevel, PACKAGE='infomap');
  
}

attr(`Config_coarseTuneLevel_set`, 'returnType') = 'void'
attr(`Config_coarseTuneLevel_set`, "inputTypes") = c('_p_infomap__Config', 'integer')
class(`Config_coarseTuneLevel_set`) = c("SWIGFunction", class('Config_coarseTuneLevel_set'))

# Start of Config_coarseTuneLevel_get

`Config_coarseTuneLevel_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_coarseTuneLevel_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_coarseTuneLevel_get`, 'returnType') = 'integer'
attr(`Config_coarseTuneLevel_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_coarseTuneLevel_get`) = c("SWIGFunction", class('Config_coarseTuneLevel_get'))

# Start of Config_superLevelLimit_set

`Config_superLevelLimit_set` = function(self, s_superLevelLimit)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_superLevelLimit = as.integer(s_superLevelLimit);
  
  if(length(s_superLevelLimit) > 1) {
    warning("using only the first element of s_superLevelLimit");
  };
  
  ;.Call('R_swig_Config_superLevelLimit_set', self, s_superLevelLimit, PACKAGE='infomap');
  
}

attr(`Config_superLevelLimit_set`, 'returnType') = 'void'
attr(`Config_superLevelLimit_set`, "inputTypes") = c('_p_infomap__Config', 'integer')
class(`Config_superLevelLimit_set`) = c("SWIGFunction", class('Config_superLevelLimit_set'))

# Start of Config_superLevelLimit_get

`Config_superLevelLimit_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_superLevelLimit_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_superLevelLimit_get`, 'returnType') = 'integer'
attr(`Config_superLevelLimit_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_superLevelLimit_get`) = c("SWIGFunction", class('Config_superLevelLimit_get'))

# Start of Config_onlySuperModules_set

`Config_onlySuperModules_set` = function(self, s_onlySuperModules)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_onlySuperModules = as.logical(s_onlySuperModules);
  ;.Call('R_swig_Config_onlySuperModules_set', self, s_onlySuperModules, PACKAGE='infomap');
  
}

attr(`Config_onlySuperModules_set`, 'returnType') = 'void'
attr(`Config_onlySuperModules_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_onlySuperModules_set`) = c("SWIGFunction", class('Config_onlySuperModules_set'))

# Start of Config_onlySuperModules_get

`Config_onlySuperModules_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_onlySuperModules_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_onlySuperModules_get`, 'returnType') = 'logical'
attr(`Config_onlySuperModules_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_onlySuperModules_get`) = c("SWIGFunction", class('Config_onlySuperModules_get'))

# Start of Config_fastHierarchicalSolution_set

`Config_fastHierarchicalSolution_set` = function(self, s_fastHierarchicalSolution)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_fastHierarchicalSolution = as.integer(s_fastHierarchicalSolution);
  
  if(length(s_fastHierarchicalSolution) > 1) {
    warning("using only the first element of s_fastHierarchicalSolution");
  };
  
  ;.Call('R_swig_Config_fastHierarchicalSolution_set', self, s_fastHierarchicalSolution, PACKAGE='infomap');
  
}

attr(`Config_fastHierarchicalSolution_set`, 'returnType') = 'void'
attr(`Config_fastHierarchicalSolution_set`, "inputTypes") = c('_p_infomap__Config', 'integer')
class(`Config_fastHierarchicalSolution_set`) = c("SWIGFunction", class('Config_fastHierarchicalSolution_set'))

# Start of Config_fastHierarchicalSolution_get

`Config_fastHierarchicalSolution_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_fastHierarchicalSolution_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_fastHierarchicalSolution_get`, 'returnType') = 'integer'
attr(`Config_fastHierarchicalSolution_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_fastHierarchicalSolution_get`) = c("SWIGFunction", class('Config_fastHierarchicalSolution_get'))

# Start of Config_fastFirstIteration_set

`Config_fastFirstIteration_set` = function(self, s_fastFirstIteration)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_fastFirstIteration = as.logical(s_fastFirstIteration);
  ;.Call('R_swig_Config_fastFirstIteration_set', self, s_fastFirstIteration, PACKAGE='infomap');
  
}

attr(`Config_fastFirstIteration_set`, 'returnType') = 'void'
attr(`Config_fastFirstIteration_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_fastFirstIteration_set`) = c("SWIGFunction", class('Config_fastFirstIteration_set'))

# Start of Config_fastFirstIteration_get

`Config_fastFirstIteration_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_fastFirstIteration_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_fastFirstIteration_get`, 'returnType') = 'logical'
attr(`Config_fastFirstIteration_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_fastFirstIteration_get`) = c("SWIGFunction", class('Config_fastFirstIteration_get'))

# Start of Config_preferModularSolution_set

`Config_preferModularSolution_set` = function(self, s_preferModularSolution)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_preferModularSolution = as.logical(s_preferModularSolution);
  ;.Call('R_swig_Config_preferModularSolution_set', self, s_preferModularSolution, PACKAGE='infomap');
  
}

attr(`Config_preferModularSolution_set`, 'returnType') = 'void'
attr(`Config_preferModularSolution_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_preferModularSolution_set`) = c("SWIGFunction", class('Config_preferModularSolution_set'))

# Start of Config_preferModularSolution_get

`Config_preferModularSolution_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_preferModularSolution_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_preferModularSolution_get`, 'returnType') = 'logical'
attr(`Config_preferModularSolution_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_preferModularSolution_get`) = c("SWIGFunction", class('Config_preferModularSolution_get'))

# Start of Config_innerParallelization_set

`Config_innerParallelization_set` = function(self, s_innerParallelization)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_innerParallelization = as.logical(s_innerParallelization);
  ;.Call('R_swig_Config_innerParallelization_set', self, s_innerParallelization, PACKAGE='infomap');
  
}

attr(`Config_innerParallelization_set`, 'returnType') = 'void'
attr(`Config_innerParallelization_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_innerParallelization_set`) = c("SWIGFunction", class('Config_innerParallelization_set'))

# Start of Config_innerParallelization_get

`Config_innerParallelization_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_innerParallelization_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_innerParallelization_get`, 'returnType') = 'logical'
attr(`Config_innerParallelization_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_innerParallelization_get`) = c("SWIGFunction", class('Config_innerParallelization_get'))

# Start of Config_outDirectory_set

`Config_outDirectory_set` = function(self, s_outDirectory)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_outDirectory = as(s_outDirectory, "character"); 
  ;.Call('R_swig_Config_outDirectory_set', self, s_outDirectory, PACKAGE='infomap');
  
}

attr(`Config_outDirectory_set`, 'returnType') = 'void'
attr(`Config_outDirectory_set`, "inputTypes") = c('_p_infomap__Config', 'character')
class(`Config_outDirectory_set`) = c("SWIGFunction", class('Config_outDirectory_set'))

# Start of Config_outDirectory_get

`Config_outDirectory_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_outDirectory_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_outDirectory_get`, 'returnType') = 'character'
attr(`Config_outDirectory_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_outDirectory_get`) = c("SWIGFunction", class('Config_outDirectory_get'))

# Start of Config_outName_set

`Config_outName_set` = function(self, s_outName)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_outName = as(s_outName, "character"); 
  ;.Call('R_swig_Config_outName_set', self, s_outName, PACKAGE='infomap');
  
}

attr(`Config_outName_set`, 'returnType') = 'void'
attr(`Config_outName_set`, "inputTypes") = c('_p_infomap__Config', 'character')
class(`Config_outName_set`) = c("SWIGFunction", class('Config_outName_set'))

# Start of Config_outName_get

`Config_outName_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_outName_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_outName_get`, 'returnType') = 'character'
attr(`Config_outName_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_outName_get`) = c("SWIGFunction", class('Config_outName_get'))

# Start of Config_outputFormats_set

`Config_outputFormats_set` = function(self, s_outputFormats)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_outputFormats = as(s_outputFormats, "character"); 
  ;.Call('R_swig_Config_outputFormats_set', self, s_outputFormats, PACKAGE='infomap');
  
}

attr(`Config_outputFormats_set`, 'returnType') = 'void'
attr(`Config_outputFormats_set`, "inputTypes") = c('_p_infomap__Config', 'character')
class(`Config_outputFormats_set`) = c("SWIGFunction", class('Config_outputFormats_set'))

# Start of Config_outputFormats_get

`Config_outputFormats_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_outputFormats_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_outputFormats_get`, 'returnType') = 'character'
attr(`Config_outputFormats_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_outputFormats_get`) = c("SWIGFunction", class('Config_outputFormats_get'))

# Start of Config_originallyUndirected_set

`Config_originallyUndirected_set` = function(self, s_originallyUndirected)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_originallyUndirected = as.logical(s_originallyUndirected);
  ;.Call('R_swig_Config_originallyUndirected_set', self, s_originallyUndirected, PACKAGE='infomap');
  
}

attr(`Config_originallyUndirected_set`, 'returnType') = 'void'
attr(`Config_originallyUndirected_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_originallyUndirected_set`) = c("SWIGFunction", class('Config_originallyUndirected_set'))

# Start of Config_originallyUndirected_get

`Config_originallyUndirected_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_originallyUndirected_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_originallyUndirected_get`, 'returnType') = 'logical'
attr(`Config_originallyUndirected_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_originallyUndirected_get`) = c("SWIGFunction", class('Config_originallyUndirected_get'))

# Start of Config_printTree_set

`Config_printTree_set` = function(self, s_printTree)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_printTree = as.logical(s_printTree);
  ;.Call('R_swig_Config_printTree_set', self, s_printTree, PACKAGE='infomap');
  
}

attr(`Config_printTree_set`, 'returnType') = 'void'
attr(`Config_printTree_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_printTree_set`) = c("SWIGFunction", class('Config_printTree_set'))

# Start of Config_printTree_get

`Config_printTree_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_printTree_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_printTree_get`, 'returnType') = 'logical'
attr(`Config_printTree_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_printTree_get`) = c("SWIGFunction", class('Config_printTree_get'))

# Start of Config_printFlowTree_set

`Config_printFlowTree_set` = function(self, s_printFlowTree)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_printFlowTree = as.logical(s_printFlowTree);
  ;.Call('R_swig_Config_printFlowTree_set', self, s_printFlowTree, PACKAGE='infomap');
  
}

attr(`Config_printFlowTree_set`, 'returnType') = 'void'
attr(`Config_printFlowTree_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_printFlowTree_set`) = c("SWIGFunction", class('Config_printFlowTree_set'))

# Start of Config_printFlowTree_get

`Config_printFlowTree_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_printFlowTree_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_printFlowTree_get`, 'returnType') = 'logical'
attr(`Config_printFlowTree_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_printFlowTree_get`) = c("SWIGFunction", class('Config_printFlowTree_get'))

# Start of Config_printNewick_set

`Config_printNewick_set` = function(self, s_printNewick)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_printNewick = as.logical(s_printNewick);
  ;.Call('R_swig_Config_printNewick_set', self, s_printNewick, PACKAGE='infomap');
  
}

attr(`Config_printNewick_set`, 'returnType') = 'void'
attr(`Config_printNewick_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_printNewick_set`) = c("SWIGFunction", class('Config_printNewick_set'))

# Start of Config_printNewick_get

`Config_printNewick_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_printNewick_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_printNewick_get`, 'returnType') = 'logical'
attr(`Config_printNewick_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_printNewick_get`) = c("SWIGFunction", class('Config_printNewick_get'))

# Start of Config_printMap_set

`Config_printMap_set` = function(self, s_printMap)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_printMap = as.logical(s_printMap);
  ;.Call('R_swig_Config_printMap_set', self, s_printMap, PACKAGE='infomap');
  
}

attr(`Config_printMap_set`, 'returnType') = 'void'
attr(`Config_printMap_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_printMap_set`) = c("SWIGFunction", class('Config_printMap_set'))

# Start of Config_printMap_get

`Config_printMap_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_printMap_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_printMap_get`, 'returnType') = 'logical'
attr(`Config_printMap_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_printMap_get`) = c("SWIGFunction", class('Config_printMap_get'))

# Start of Config_printClu_set

`Config_printClu_set` = function(self, s_printClu)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_printClu = as.logical(s_printClu);
  ;.Call('R_swig_Config_printClu_set', self, s_printClu, PACKAGE='infomap');
  
}

attr(`Config_printClu_set`, 'returnType') = 'void'
attr(`Config_printClu_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_printClu_set`) = c("SWIGFunction", class('Config_printClu_set'))

# Start of Config_printClu_get

`Config_printClu_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_printClu_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_printClu_get`, 'returnType') = 'logical'
attr(`Config_printClu_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_printClu_get`) = c("SWIGFunction", class('Config_printClu_get'))

# Start of Config_cluLevel_set

`Config_cluLevel_set` = function(self, s_cluLevel)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_cluLevel = as.integer(s_cluLevel);
  
  if(length(s_cluLevel) > 1) {
    warning("using only the first element of s_cluLevel");
  };
  
  ;.Call('R_swig_Config_cluLevel_set', self, s_cluLevel, PACKAGE='infomap');
  
}

attr(`Config_cluLevel_set`, 'returnType') = 'void'
attr(`Config_cluLevel_set`, "inputTypes") = c('_p_infomap__Config', 'integer')
class(`Config_cluLevel_set`) = c("SWIGFunction", class('Config_cluLevel_set'))

# Start of Config_cluLevel_get

`Config_cluLevel_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_cluLevel_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_cluLevel_get`, 'returnType') = 'integer'
attr(`Config_cluLevel_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_cluLevel_get`) = c("SWIGFunction", class('Config_cluLevel_get'))

# Start of Config_printNodeRanks_set

`Config_printNodeRanks_set` = function(self, s_printNodeRanks)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_printNodeRanks = as.logical(s_printNodeRanks);
  ;.Call('R_swig_Config_printNodeRanks_set', self, s_printNodeRanks, PACKAGE='infomap');
  
}

attr(`Config_printNodeRanks_set`, 'returnType') = 'void'
attr(`Config_printNodeRanks_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_printNodeRanks_set`) = c("SWIGFunction", class('Config_printNodeRanks_set'))

# Start of Config_printNodeRanks_get

`Config_printNodeRanks_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_printNodeRanks_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_printNodeRanks_get`, 'returnType') = 'logical'
attr(`Config_printNodeRanks_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_printNodeRanks_get`) = c("SWIGFunction", class('Config_printNodeRanks_get'))

# Start of Config_printFlowNetwork_set

`Config_printFlowNetwork_set` = function(self, s_printFlowNetwork)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_printFlowNetwork = as.logical(s_printFlowNetwork);
  ;.Call('R_swig_Config_printFlowNetwork_set', self, s_printFlowNetwork, PACKAGE='infomap');
  
}

attr(`Config_printFlowNetwork_set`, 'returnType') = 'void'
attr(`Config_printFlowNetwork_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_printFlowNetwork_set`) = c("SWIGFunction", class('Config_printFlowNetwork_set'))

# Start of Config_printFlowNetwork_get

`Config_printFlowNetwork_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_printFlowNetwork_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_printFlowNetwork_get`, 'returnType') = 'logical'
attr(`Config_printFlowNetwork_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_printFlowNetwork_get`) = c("SWIGFunction", class('Config_printFlowNetwork_get'))

# Start of Config_printPajekNetwork_set

`Config_printPajekNetwork_set` = function(self, s_printPajekNetwork)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_printPajekNetwork = as.logical(s_printPajekNetwork);
  ;.Call('R_swig_Config_printPajekNetwork_set', self, s_printPajekNetwork, PACKAGE='infomap');
  
}

attr(`Config_printPajekNetwork_set`, 'returnType') = 'void'
attr(`Config_printPajekNetwork_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_printPajekNetwork_set`) = c("SWIGFunction", class('Config_printPajekNetwork_set'))

# Start of Config_printPajekNetwork_get

`Config_printPajekNetwork_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_printPajekNetwork_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_printPajekNetwork_get`, 'returnType') = 'logical'
attr(`Config_printPajekNetwork_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_printPajekNetwork_get`) = c("SWIGFunction", class('Config_printPajekNetwork_get'))

# Start of Config_printStateNetwork_set

`Config_printStateNetwork_set` = function(self, s_printStateNetwork)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_printStateNetwork = as.logical(s_printStateNetwork);
  ;.Call('R_swig_Config_printStateNetwork_set', self, s_printStateNetwork, PACKAGE='infomap');
  
}

attr(`Config_printStateNetwork_set`, 'returnType') = 'void'
attr(`Config_printStateNetwork_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_printStateNetwork_set`) = c("SWIGFunction", class('Config_printStateNetwork_set'))

# Start of Config_printStateNetwork_get

`Config_printStateNetwork_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_printStateNetwork_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_printStateNetwork_get`, 'returnType') = 'logical'
attr(`Config_printStateNetwork_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_printStateNetwork_get`) = c("SWIGFunction", class('Config_printStateNetwork_get'))

# Start of Config_printBinaryTree_set

`Config_printBinaryTree_set` = function(self, s_printBinaryTree)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_printBinaryTree = as.logical(s_printBinaryTree);
  ;.Call('R_swig_Config_printBinaryTree_set', self, s_printBinaryTree, PACKAGE='infomap');
  
}

attr(`Config_printBinaryTree_set`, 'returnType') = 'void'
attr(`Config_printBinaryTree_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_printBinaryTree_set`) = c("SWIGFunction", class('Config_printBinaryTree_set'))

# Start of Config_printBinaryTree_get

`Config_printBinaryTree_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_printBinaryTree_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_printBinaryTree_get`, 'returnType') = 'logical'
attr(`Config_printBinaryTree_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_printBinaryTree_get`) = c("SWIGFunction", class('Config_printBinaryTree_get'))

# Start of Config_printBinaryFlowTree_set

`Config_printBinaryFlowTree_set` = function(self, s_printBinaryFlowTree)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_printBinaryFlowTree = as.logical(s_printBinaryFlowTree);
  ;.Call('R_swig_Config_printBinaryFlowTree_set', self, s_printBinaryFlowTree, PACKAGE='infomap');
  
}

attr(`Config_printBinaryFlowTree_set`, 'returnType') = 'void'
attr(`Config_printBinaryFlowTree_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_printBinaryFlowTree_set`) = c("SWIGFunction", class('Config_printBinaryFlowTree_set'))

# Start of Config_printBinaryFlowTree_get

`Config_printBinaryFlowTree_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_printBinaryFlowTree_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_printBinaryFlowTree_get`, 'returnType') = 'logical'
attr(`Config_printBinaryFlowTree_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_printBinaryFlowTree_get`) = c("SWIGFunction", class('Config_printBinaryFlowTree_get'))

# Start of Config_noFileOutput_set

`Config_noFileOutput_set` = function(self, s_noFileOutput)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_noFileOutput = as.logical(s_noFileOutput);
  ;.Call('R_swig_Config_noFileOutput_set', self, s_noFileOutput, PACKAGE='infomap');
  
}

attr(`Config_noFileOutput_set`, 'returnType') = 'void'
attr(`Config_noFileOutput_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_noFileOutput_set`) = c("SWIGFunction", class('Config_noFileOutput_set'))

# Start of Config_noFileOutput_get

`Config_noFileOutput_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_noFileOutput_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_noFileOutput_get`, 'returnType') = 'logical'
attr(`Config_noFileOutput_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_noFileOutput_get`) = c("SWIGFunction", class('Config_noFileOutput_get'))

# Start of Config_verbosity_set

`Config_verbosity_set` = function(self, s_verbosity)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_verbosity = as.integer(s_verbosity);
  
  if(length(s_verbosity) > 1) {
    warning("using only the first element of s_verbosity");
  };
  
  ;.Call('R_swig_Config_verbosity_set', self, s_verbosity, PACKAGE='infomap');
  
}

attr(`Config_verbosity_set`, 'returnType') = 'void'
attr(`Config_verbosity_set`, "inputTypes") = c('_p_infomap__Config', 'integer')
class(`Config_verbosity_set`) = c("SWIGFunction", class('Config_verbosity_set'))

# Start of Config_verbosity_get

`Config_verbosity_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_verbosity_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_verbosity_get`, 'returnType') = 'integer'
attr(`Config_verbosity_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_verbosity_get`) = c("SWIGFunction", class('Config_verbosity_get'))

# Start of Config_verboseNumberPrecision_set

`Config_verboseNumberPrecision_set` = function(self, s_verboseNumberPrecision)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_verboseNumberPrecision = as.integer(s_verboseNumberPrecision);
  
  if(length(s_verboseNumberPrecision) > 1) {
    warning("using only the first element of s_verboseNumberPrecision");
  };
  
  ;.Call('R_swig_Config_verboseNumberPrecision_set', self, s_verboseNumberPrecision, PACKAGE='infomap');
  
}

attr(`Config_verboseNumberPrecision_set`, 'returnType') = 'void'
attr(`Config_verboseNumberPrecision_set`, "inputTypes") = c('_p_infomap__Config', 'integer')
class(`Config_verboseNumberPrecision_set`) = c("SWIGFunction", class('Config_verboseNumberPrecision_set'))

# Start of Config_verboseNumberPrecision_get

`Config_verboseNumberPrecision_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_verboseNumberPrecision_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_verboseNumberPrecision_get`, 'returnType') = 'integer'
attr(`Config_verboseNumberPrecision_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_verboseNumberPrecision_get`) = c("SWIGFunction", class('Config_verboseNumberPrecision_get'))

# Start of Config_silent_set

`Config_silent_set` = function(self, s_silent)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_silent = as.logical(s_silent);
  ;.Call('R_swig_Config_silent_set', self, s_silent, PACKAGE='infomap');
  
}

attr(`Config_silent_set`, 'returnType') = 'void'
attr(`Config_silent_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_silent_set`) = c("SWIGFunction", class('Config_silent_set'))

# Start of Config_silent_get

`Config_silent_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_silent_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_silent_get`, 'returnType') = 'logical'
attr(`Config_silent_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_silent_get`) = c("SWIGFunction", class('Config_silent_get'))

# Start of Config_benchmark_set

`Config_benchmark_set` = function(self, s_benchmark)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_benchmark = as.logical(s_benchmark);
  ;.Call('R_swig_Config_benchmark_set', self, s_benchmark, PACKAGE='infomap');
  
}

attr(`Config_benchmark_set`, 'returnType') = 'void'
attr(`Config_benchmark_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_benchmark_set`) = c("SWIGFunction", class('Config_benchmark_set'))

# Start of Config_benchmark_get

`Config_benchmark_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_benchmark_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_benchmark_get`, 'returnType') = 'logical'
attr(`Config_benchmark_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_benchmark_get`) = c("SWIGFunction", class('Config_benchmark_get'))

# Start of Config_hideBipartiteNodes_set

`Config_hideBipartiteNodes_set` = function(self, s_hideBipartiteNodes)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_hideBipartiteNodes = as.logical(s_hideBipartiteNodes);
  ;.Call('R_swig_Config_hideBipartiteNodes_set', self, s_hideBipartiteNodes, PACKAGE='infomap');
  
}

attr(`Config_hideBipartiteNodes_set`, 'returnType') = 'void'
attr(`Config_hideBipartiteNodes_set`, "inputTypes") = c('_p_infomap__Config', 'logical')
class(`Config_hideBipartiteNodes_set`) = c("SWIGFunction", class('Config_hideBipartiteNodes_set'))

# Start of Config_hideBipartiteNodes_get

`Config_hideBipartiteNodes_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_hideBipartiteNodes_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_hideBipartiteNodes_get`, 'returnType') = 'logical'
attr(`Config_hideBipartiteNodes_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_hideBipartiteNodes_get`) = c("SWIGFunction", class('Config_hideBipartiteNodes_get'))

# Start of Config_maxNodeIndexVisible_set

`Config_maxNodeIndexVisible_set` = function(self, s_maxNodeIndexVisible)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_maxNodeIndexVisible = as.integer(s_maxNodeIndexVisible);
  
  if(length(s_maxNodeIndexVisible) > 1) {
    warning("using only the first element of s_maxNodeIndexVisible");
  };
  
  ;.Call('R_swig_Config_maxNodeIndexVisible_set', self, s_maxNodeIndexVisible, PACKAGE='infomap');
  
}

attr(`Config_maxNodeIndexVisible_set`, 'returnType') = 'void'
attr(`Config_maxNodeIndexVisible_set`, "inputTypes") = c('_p_infomap__Config', 'integer')
class(`Config_maxNodeIndexVisible_set`) = c("SWIGFunction", class('Config_maxNodeIndexVisible_set'))

# Start of Config_maxNodeIndexVisible_get

`Config_maxNodeIndexVisible_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_maxNodeIndexVisible_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_maxNodeIndexVisible_get`, 'returnType') = 'integer'
attr(`Config_maxNodeIndexVisible_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_maxNodeIndexVisible_get`) = c("SWIGFunction", class('Config_maxNodeIndexVisible_get'))

# Start of Config_minBipartiteNodeIndex_set

`Config_minBipartiteNodeIndex_set` = function(self, s_minBipartiteNodeIndex)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_minBipartiteNodeIndex = as.integer(s_minBipartiteNodeIndex);
  
  if(length(s_minBipartiteNodeIndex) > 1) {
    warning("using only the first element of s_minBipartiteNodeIndex");
  };
  
  ;.Call('R_swig_Config_minBipartiteNodeIndex_set', self, s_minBipartiteNodeIndex, PACKAGE='infomap');
  
}

attr(`Config_minBipartiteNodeIndex_set`, 'returnType') = 'void'
attr(`Config_minBipartiteNodeIndex_set`, "inputTypes") = c('_p_infomap__Config', 'integer')
class(`Config_minBipartiteNodeIndex_set`) = c("SWIGFunction", class('Config_minBipartiteNodeIndex_set'))

# Start of Config_minBipartiteNodeIndex_get

`Config_minBipartiteNodeIndex_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_minBipartiteNodeIndex_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_minBipartiteNodeIndex_get`, 'returnType') = 'integer'
attr(`Config_minBipartiteNodeIndex_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_minBipartiteNodeIndex_get`) = c("SWIGFunction", class('Config_minBipartiteNodeIndex_get'))

# Start of Config_startDate_set

`Config_startDate_set` = function(self, s_startDate)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_startDate, "ExternalReference")) s_startDate = slot(s_startDate,"ref"); 
  ;.Call('R_swig_Config_startDate_set', self, s_startDate, PACKAGE='infomap');
  
}

attr(`Config_startDate_set`, 'returnType') = 'void'
attr(`Config_startDate_set`, "inputTypes") = c('_p_infomap__Config', '_p_Date')
class(`Config_startDate_set`) = c("SWIGFunction", class('Config_startDate_set'))

# Start of Config_startDate_get

`Config_startDate_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_Config_startDate_get', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_Date", ref=ans);
  
  ans
  
}

attr(`Config_startDate_get`, 'returnType') = '_p_Date'
attr(`Config_startDate_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_startDate_get`) = c("SWIGFunction", class('Config_startDate_get'))

# Start of Config_version_set

`Config_version_set` = function(self, s_version)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_version = as(s_version, "character"); 
  ;.Call('R_swig_Config_version_set', self, s_version, PACKAGE='infomap');
  
}

attr(`Config_version_set`, 'returnType') = 'void'
attr(`Config_version_set`, "inputTypes") = c('_p_infomap__Config', 'character')
class(`Config_version_set`) = c("SWIGFunction", class('Config_version_set'))

# Start of Config_version_get

`Config_version_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_version_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_version_get`, 'returnType') = 'character'
attr(`Config_version_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_version_get`) = c("SWIGFunction", class('Config_version_get'))

# Start of Config_parsedString_set

`Config_parsedString_set` = function(self, s_parsedString)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_parsedString = as(s_parsedString, "character"); 
  ;.Call('R_swig_Config_parsedString_set', self, s_parsedString, PACKAGE='infomap');
  
}

attr(`Config_parsedString_set`, 'returnType') = 'void'
attr(`Config_parsedString_set`, "inputTypes") = c('_p_infomap__Config', 'character')
class(`Config_parsedString_set`) = c("SWIGFunction", class('Config_parsedString_set'))

# Start of Config_parsedString_get

`Config_parsedString_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_parsedString_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_parsedString_get`, 'returnType') = 'character'
attr(`Config_parsedString_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_parsedString_get`) = c("SWIGFunction", class('Config_parsedString_get'))

# Start of Config_parsedOptions_set

`Config_parsedOptions_set` = function(self, s_parsedOptions)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_parsedOptions, "ExternalReference")) s_parsedOptions = slot(s_parsedOptions,"ref"); 
  ;.Call('R_swig_Config_parsedOptions_set', self, s_parsedOptions, PACKAGE='infomap');
  
}

attr(`Config_parsedOptions_set`, 'returnType') = 'void'
attr(`Config_parsedOptions_set`, "inputTypes") = c('_p_infomap__Config', '_p_std__vectorT_ParsedOption_std__allocatorT_ParsedOption_t_t')
class(`Config_parsedOptions_set`) = c("SWIGFunction", class('Config_parsedOptions_set'))

# Start of Config_parsedOptions_get

`Config_parsedOptions_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_Config_parsedOptions_get', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_ParsedOption_std__allocatorT_ParsedOption_t_t", ref=ans);
  
  ans
  
}

attr(`Config_parsedOptions_get`, 'returnType') = '_p_std__vectorT_ParsedOption_std__allocatorT_ParsedOption_t_t'
attr(`Config_parsedOptions_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_parsedOptions_get`) = c("SWIGFunction", class('Config_parsedOptions_get'))

# Start of Config_error_set

`Config_error_set` = function(self, s_error)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_error = as(s_error, "character"); 
  ;.Call('R_swig_Config_error_set', self, s_error, PACKAGE='infomap');
  
}

attr(`Config_error_set`, 'returnType') = 'void'
attr(`Config_error_set`, "inputTypes") = c('_p_infomap__Config', 'character')
class(`Config_error_set`) = c("SWIGFunction", class('Config_error_set'))

# Start of Config_error_get

`Config_error_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_error_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_error_get`, 'returnType') = 'character'
attr(`Config_error_get`, "inputTypes") = c('_p_infomap__Config')
class(`Config_error_get`) = c("SWIGFunction", class('Config_error_get'))

# Start of new_Config

`Config__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_Config__SWIG_0', PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__Config", ref=ans);
  
  reg.finalizer(ans@ref, delete_Config);
  ans
  
}

attr(`Config__SWIG_0`, 'returnType') = '_p_infomap__Config'
class(`Config__SWIG_0`) = c("SWIGFunction", class('Config__SWIG_0'))

# Start of new_Config

`Config__SWIG_1` = function(flags, isCLI)
{
  flags = as(flags, "character"); 
  isCLI = as.logical(isCLI);
  ;ans = .Call('R_swig_new_Config__SWIG_1', flags, isCLI, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__Config", ref=ans);
  
  reg.finalizer(ans@ref, delete_Config);
  ans
  
}

attr(`Config__SWIG_1`, 'returnType') = '_p_infomap__Config'
attr(`Config__SWIG_1`, "inputTypes") = c('character', 'logical')
class(`Config__SWIG_1`) = c("SWIGFunction", class('Config__SWIG_1'))

# Start of new_Config

`Config__SWIG_2` = function(flags)
{
  flags = as(flags, "character"); 
  ;ans = .Call('R_swig_new_Config__SWIG_2', flags, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__Config", ref=ans);
  
  reg.finalizer(ans@ref, delete_Config);
  ans
  
}

attr(`Config__SWIG_2`, 'returnType') = '_p_infomap__Config'
attr(`Config__SWIG_2`, "inputTypes") = c('character')
class(`Config__SWIG_2`) = c("SWIGFunction", class('Config__SWIG_2'))

`Config` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 0) {
    f <- Config__SWIG_0; 
  } else if (argc == 1) {
    if (is.character(argv[[1]]) && length(argv[[1]]) == 1) {
      f <- Config__SWIG_2; 
    }
  } else if (argc == 2) {
    if (is.character(argv[[1]]) && length(argv[[1]]) == 1 && ( is.logical(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- Config__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for Config with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Config_cloneAsNonMain

`Config_cloneAsNonMain` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_Config_cloneAsNonMain', self, other, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__Config", ref=ans);
  
  ans
  
}

attr(`Config_cloneAsNonMain`, 'returnType') = '_p_infomap__Config'
attr(`Config_cloneAsNonMain`, "inputTypes") = c('_p_infomap__Config', '_p_infomap__Config')
class(`Config_cloneAsNonMain`) = c("SWIGFunction", class('Config_cloneAsNonMain'))

# Start of Config_setOptimizationLevel

`Config_setOptimizationLevel` = function(self, level)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(level, "ExternalReference")) level = slot(level,"ref"); 
  ;.Call('R_swig_Config_setOptimizationLevel', self, level, PACKAGE='infomap');
  
}

attr(`Config_setOptimizationLevel`, 'returnType') = 'void'
attr(`Config_setOptimizationLevel`, "inputTypes") = c('_p_infomap__Config', '_p_infomap__OptimizationLevel')
class(`Config_setOptimizationLevel`) = c("SWIGFunction", class('Config_setOptimizationLevel'))

# Start of Config_adaptDefaults

`Config_adaptDefaults` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_adaptDefaults', self, PACKAGE='infomap');
  
}

attr(`Config_adaptDefaults`, 'returnType') = 'void'
attr(`Config_adaptDefaults`, "inputTypes") = c('_p_infomap__Config')
class(`Config_adaptDefaults`) = c("SWIGFunction", class('Config_adaptDefaults'))

# Start of Config_setMemoryInput

`Config_setMemoryInput` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_setMemoryInput', self, PACKAGE='infomap');
  
}

attr(`Config_setMemoryInput`, 'returnType') = 'void'
attr(`Config_setMemoryInput`, "inputTypes") = c('_p_infomap__Config')
class(`Config_setMemoryInput`) = c("SWIGFunction", class('Config_setMemoryInput'))

# Start of Config_setMultilayerInput

`Config_setMultilayerInput` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_setMultilayerInput', self, PACKAGE='infomap');
  
}

attr(`Config_setMultilayerInput`, 'returnType') = 'void'
attr(`Config_setMultilayerInput`, "inputTypes") = c('_p_infomap__Config')
class(`Config_setMultilayerInput`) = c("SWIGFunction", class('Config_setMultilayerInput'))

# Start of Config_isUndirectedClustering

`Config_isUndirectedClustering` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_isUndirectedClustering', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_isUndirectedClustering`, 'returnType') = 'logical'
attr(`Config_isUndirectedClustering`, "inputTypes") = c('_p_infomap__Config')
class(`Config_isUndirectedClustering`) = c("SWIGFunction", class('Config_isUndirectedClustering'))

# Start of Config_isUndirectedFlow

`Config_isUndirectedFlow` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_isUndirectedFlow', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_isUndirectedFlow`, 'returnType') = 'logical'
attr(`Config_isUndirectedFlow`, "inputTypes") = c('_p_infomap__Config')
class(`Config_isUndirectedFlow`) = c("SWIGFunction", class('Config_isUndirectedFlow'))

# Start of Config_printAsUndirected

`Config_printAsUndirected` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_printAsUndirected', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_printAsUndirected`, 'returnType') = 'logical'
attr(`Config_printAsUndirected`, "inputTypes") = c('_p_infomap__Config')
class(`Config_printAsUndirected`) = c("SWIGFunction", class('Config_printAsUndirected'))

# Start of Config_is3gram

`Config_is3gram` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_is3gram', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_is3gram`, 'returnType') = 'logical'
attr(`Config_is3gram`, "inputTypes") = c('_p_infomap__Config')
class(`Config_is3gram`) = c("SWIGFunction", class('Config_is3gram'))

# Start of Config_isPath

`Config_isPath` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_isPath', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_isPath`, 'returnType') = 'logical'
attr(`Config_isPath`, "inputTypes") = c('_p_infomap__Config')
class(`Config_isPath`) = c("SWIGFunction", class('Config_isPath'))

# Start of Config_isMultilayerNetwork

`Config_isMultilayerNetwork` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_isMultilayerNetwork', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_isMultilayerNetwork`, 'returnType') = 'logical'
attr(`Config_isMultilayerNetwork`, "inputTypes") = c('_p_infomap__Config')
class(`Config_isMultilayerNetwork`) = c("SWIGFunction", class('Config_isMultilayerNetwork'))

# Start of Config_isStateNetwork

`Config_isStateNetwork` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_isStateNetwork', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_isStateNetwork`, 'returnType') = 'logical'
attr(`Config_isStateNetwork`, "inputTypes") = c('_p_infomap__Config')
class(`Config_isStateNetwork`) = c("SWIGFunction", class('Config_isStateNetwork'))

# Start of Config_isBipartite

`Config_isBipartite` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_isBipartite', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_isBipartite`, 'returnType') = 'logical'
attr(`Config_isBipartite`, "inputTypes") = c('_p_infomap__Config')
class(`Config_isBipartite`) = c("SWIGFunction", class('Config_isBipartite'))

# Start of Config_haveMemory

`Config_haveMemory` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_haveMemory', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_haveMemory`, 'returnType') = 'logical'
attr(`Config_haveMemory`, "inputTypes") = c('_p_infomap__Config')
class(`Config_haveMemory`) = c("SWIGFunction", class('Config_haveMemory'))

# Start of Config_haveMetaData

`Config_haveMetaData` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_haveMetaData', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_haveMetaData`, 'returnType') = 'logical'
attr(`Config_haveMetaData`, "inputTypes") = c('_p_infomap__Config')
class(`Config_haveMetaData`) = c("SWIGFunction", class('Config_haveMetaData'))

# Start of Config_haveOutput

`Config_haveOutput` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_haveOutput', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_haveOutput`, 'returnType') = 'logical'
attr(`Config_haveOutput`, "inputTypes") = c('_p_infomap__Config')
class(`Config_haveOutput`) = c("SWIGFunction", class('Config_haveOutput'))

# Start of Config_haveModularResultOutput

`Config_haveModularResultOutput` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Config_haveModularResultOutput', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Config_haveModularResultOutput`, 'returnType') = 'logical'
attr(`Config_haveModularResultOutput`, "inputTypes") = c('_p_infomap__Config')
class(`Config_haveModularResultOutput`) = c("SWIGFunction", class('Config_haveModularResultOutput'))

# Start of delete_Config

`delete_Config` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_Config', self, PACKAGE='infomap');
  
}

attr(`delete_Config`, 'returnType') = 'void'
attr(`delete_Config`, "inputTypes") = c('_p_infomap__Config')
class(`delete_Config`) = c("SWIGFunction", class('delete_Config'))

# Start of accessor method for infomap::Config
setMethod('$', '_p_infomap__Config', function(x, name)

{
  accessorFuns = list('isCLI' = Config_isCLI_get, 'networkFile' = Config_networkFile_get, 'additionalInput' = Config_additionalInput_get, 'inputFormat' = Config_inputFormat_get, 'memoryInput' = Config_memoryInput_get, 'multilayerInput' = Config_multilayerInput_get, 'weightThreshold' = Config_weightThreshold_get, 'unweightedPaths' = Config_unweightedPaths_get, 'pathMarkovOrder' = Config_pathMarkovOrder_get, 'bipartite' = Config_bipartite_get, 'skipAdjustBipartiteFlow' = Config_skipAdjustBipartiteFlow_get, 'bipartiteTeleportation' = Config_bipartiteTeleportation_get, 'hardPartitions' = Config_hardPartitions_get, 'parseWithoutIOStreams' = Config_parseWithoutIOStreams_get, 'zeroBasedNodeNumbers' = Config_zeroBasedNodeNumbers_get, 'includeSelfLinks' = Config_includeSelfLinks_get, 'ignoreEdgeWeights' = Config_ignoreEdgeWeights_get, 'nodeLimit' = Config_nodeLimit_get, 'preClusterMultilayer' = Config_preClusterMultilayer_get, 'clusterDataFile' = Config_clusterDataFile_get, 'metaDataFile' = Config_metaDataFile_get, 'metaDataRate' = Config_metaDataRate_get, 'unweightedMetaData' = Config_unweightedMetaData_get, 'numMetaDataDimensions' = Config_numMetaDataDimensions_get, 'clusterDataIsHard' = Config_clusterDataIsHard_get, 'assignToNeighbouringModule' = Config_assignToNeighbouringModule_get, 'noInfomap' = Config_noInfomap_get, 'flowModel' = Config_flowModel_get, 'directed' = Config_directed_get, 'undirdir' = Config_undirdir_get, 'outdirdir' = Config_outdirdir_get, 'rawdir' = Config_rawdir_get, 'useNodeWeightsAsFlow' = Config_useNodeWeightsAsFlow_get, 'teleportToNodes' = Config_teleportToNodes_get, 'selfTeleportationProbability' = Config_selfTeleportationProbability_get, 'markovTime' = Config_markovTime_get, 'multilayerRelaxRate' = Config_multilayerRelaxRate_get, 'multilayerRelaxLimit' = Config_multilayerRelaxLimit_get, 'multilayerRelaxLimitUp' = Config_multilayerRelaxLimitUp_get, 'multilayerRelaxLimitDown' = Config_multilayerRelaxLimitDown_get, 'multilayerJSRelaxRate' = Config_multilayerJSRelaxRate_get, 'multilayerRelaxByJensenShannonDivergence' = Config_multilayerRelaxByJensenShannonDivergence_get, 'multilayerJSRelaxLimit' = Config_multilayerJSRelaxLimit_get, 'twoLevel' = Config_twoLevel_get, 'noCoarseTune' = Config_noCoarseTune_get, 'directedEdges' = Config_directedEdges_get, 'recordedTeleportation' = Config_recordedTeleportation_get, 'teleportationProbability' = Config_teleportationProbability_get, 'preferredNumberOfModules' = Config_preferredNumberOfModules_get, 'seedToRandomNumberGenerator' = Config_seedToRandomNumberGenerator_get, 'numTrials' = Config_numTrials_get, 'minimumCodelengthImprovement' = Config_minimumCodelengthImprovement_get, 'minimumSingleNodeCodelengthImprovement' = Config_minimumSingleNodeCodelengthImprovement_get, 'randomizeCoreLoopLimit' = Config_randomizeCoreLoopLimit_get, 'coreLoopLimit' = Config_coreLoopLimit_get, 'levelAggregationLimit' = Config_levelAggregationLimit_get, 'tuneIterationLimit' = Config_tuneIterationLimit_get, 'minimumRelativeTuneIterationImprovement' = Config_minimumRelativeTuneIterationImprovement_get, 'fastCoarseTunePartition' = Config_fastCoarseTunePartition_get, 'alternateCoarseTuneLevel' = Config_alternateCoarseTuneLevel_get, 'coarseTuneLevel' = Config_coarseTuneLevel_get, 'superLevelLimit' = Config_superLevelLimit_get, 'onlySuperModules' = Config_onlySuperModules_get, 'fastHierarchicalSolution' = Config_fastHierarchicalSolution_get, 'fastFirstIteration' = Config_fastFirstIteration_get, 'preferModularSolution' = Config_preferModularSolution_get, 'innerParallelization' = Config_innerParallelization_get, 'outDirectory' = Config_outDirectory_get, 'outName' = Config_outName_get, 'outputFormats' = Config_outputFormats_get, 'originallyUndirected' = Config_originallyUndirected_get, 'printTree' = Config_printTree_get, 'printFlowTree' = Config_printFlowTree_get, 'printNewick' = Config_printNewick_get, 'printMap' = Config_printMap_get, 'printClu' = Config_printClu_get, 'cluLevel' = Config_cluLevel_get, 'printNodeRanks' = Config_printNodeRanks_get, 'printFlowNetwork' = Config_printFlowNetwork_get, 'printPajekNetwork' = Config_printPajekNetwork_get, 'printStateNetwork' = Config_printStateNetwork_get, 'printBinaryTree' = Config_printBinaryTree_get, 'printBinaryFlowTree' = Config_printBinaryFlowTree_get, 'noFileOutput' = Config_noFileOutput_get, 'verbosity' = Config_verbosity_get, 'verboseNumberPrecision' = Config_verboseNumberPrecision_get, 'silent' = Config_silent_get, 'benchmark' = Config_benchmark_get, 'hideBipartiteNodes' = Config_hideBipartiteNodes_get, 'maxNodeIndexVisible' = Config_maxNodeIndexVisible_get, 'minBipartiteNodeIndex' = Config_minBipartiteNodeIndex_get, 'startDate' = Config_startDate_get, 'version' = Config_version_get, 'parsedString' = Config_parsedString_get, 'parsedOptions' = Config_parsedOptions_get, 'error' = Config_error_get, 'cloneAsNonMain' = Config_cloneAsNonMain, 'setOptimizationLevel' = Config_setOptimizationLevel, 'adaptDefaults' = Config_adaptDefaults, 'setMemoryInput' = Config_setMemoryInput, 'setMultilayerInput' = Config_setMultilayerInput, 'isUndirectedClustering' = Config_isUndirectedClustering, 'isUndirectedFlow' = Config_isUndirectedFlow, 'printAsUndirected' = Config_printAsUndirected, 'is3gram' = Config_is3gram, 'isPath' = Config_isPath, 'isMultilayerNetwork' = Config_isMultilayerNetwork, 'isStateNetwork' = Config_isStateNetwork, 'isBipartite' = Config_isBipartite, 'haveMemory' = Config_haveMemory, 'haveMetaData' = Config_haveMetaData, 'haveOutput' = Config_haveOutput, 'haveModularResultOutput' = Config_haveModularResultOutput);
  vaccessors = c('isCLI', 'networkFile', 'additionalInput', 'inputFormat', 'memoryInput', 'multilayerInput', 'weightThreshold', 'unweightedPaths', 'pathMarkovOrder', 'bipartite', 'skipAdjustBipartiteFlow', 'bipartiteTeleportation', 'hardPartitions', 'parseWithoutIOStreams', 'zeroBasedNodeNumbers', 'includeSelfLinks', 'ignoreEdgeWeights', 'nodeLimit', 'preClusterMultilayer', 'clusterDataFile', 'metaDataFile', 'metaDataRate', 'unweightedMetaData', 'numMetaDataDimensions', 'clusterDataIsHard', 'assignToNeighbouringModule', 'noInfomap', 'flowModel', 'directed', 'undirdir', 'outdirdir', 'rawdir', 'useNodeWeightsAsFlow', 'teleportToNodes', 'selfTeleportationProbability', 'markovTime', 'multilayerRelaxRate', 'multilayerRelaxLimit', 'multilayerRelaxLimitUp', 'multilayerRelaxLimitDown', 'multilayerJSRelaxRate', 'multilayerRelaxByJensenShannonDivergence', 'multilayerJSRelaxLimit', 'twoLevel', 'noCoarseTune', 'directedEdges', 'recordedTeleportation', 'teleportationProbability', 'preferredNumberOfModules', 'seedToRandomNumberGenerator', 'numTrials', 'minimumCodelengthImprovement', 'minimumSingleNodeCodelengthImprovement', 'randomizeCoreLoopLimit', 'coreLoopLimit', 'levelAggregationLimit', 'tuneIterationLimit', 'minimumRelativeTuneIterationImprovement', 'fastCoarseTunePartition', 'alternateCoarseTuneLevel', 'coarseTuneLevel', 'superLevelLimit', 'onlySuperModules', 'fastHierarchicalSolution', 'fastFirstIteration', 'preferModularSolution', 'innerParallelization', 'outDirectory', 'outName', 'outputFormats', 'originallyUndirected', 'printTree', 'printFlowTree', 'printNewick', 'printMap', 'printClu', 'cluLevel', 'printNodeRanks', 'printFlowNetwork', 'printPajekNetwork', 'printStateNetwork', 'printBinaryTree', 'printBinaryFlowTree', 'noFileOutput', 'verbosity', 'verboseNumberPrecision', 'silent', 'benchmark', 'hideBipartiteNodes', 'maxNodeIndexVisible', 'minBipartiteNodeIndex', 'startDate', 'version', 'parsedString', 'parsedOptions', 'error');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for infomap::Config
# Start of accessor method for infomap::Config
setMethod('$<-', '_p_infomap__Config', function(x, name, value)

{
  accessorFuns = list('isCLI' = Config_isCLI_set, 'networkFile' = Config_networkFile_set, 'additionalInput' = Config_additionalInput_set, 'inputFormat' = Config_inputFormat_set, 'memoryInput' = Config_memoryInput_set, 'multilayerInput' = Config_multilayerInput_set, 'weightThreshold' = Config_weightThreshold_set, 'unweightedPaths' = Config_unweightedPaths_set, 'pathMarkovOrder' = Config_pathMarkovOrder_set, 'bipartite' = Config_bipartite_set, 'skipAdjustBipartiteFlow' = Config_skipAdjustBipartiteFlow_set, 'bipartiteTeleportation' = Config_bipartiteTeleportation_set, 'hardPartitions' = Config_hardPartitions_set, 'parseWithoutIOStreams' = Config_parseWithoutIOStreams_set, 'zeroBasedNodeNumbers' = Config_zeroBasedNodeNumbers_set, 'includeSelfLinks' = Config_includeSelfLinks_set, 'ignoreEdgeWeights' = Config_ignoreEdgeWeights_set, 'nodeLimit' = Config_nodeLimit_set, 'preClusterMultilayer' = Config_preClusterMultilayer_set, 'clusterDataFile' = Config_clusterDataFile_set, 'metaDataFile' = Config_metaDataFile_set, 'metaDataRate' = Config_metaDataRate_set, 'unweightedMetaData' = Config_unweightedMetaData_set, 'numMetaDataDimensions' = Config_numMetaDataDimensions_set, 'clusterDataIsHard' = Config_clusterDataIsHard_set, 'assignToNeighbouringModule' = Config_assignToNeighbouringModule_set, 'noInfomap' = Config_noInfomap_set, 'flowModel' = Config_flowModel_set, 'directed' = Config_directed_set, 'undirdir' = Config_undirdir_set, 'outdirdir' = Config_outdirdir_set, 'rawdir' = Config_rawdir_set, 'useNodeWeightsAsFlow' = Config_useNodeWeightsAsFlow_set, 'teleportToNodes' = Config_teleportToNodes_set, 'selfTeleportationProbability' = Config_selfTeleportationProbability_set, 'markovTime' = Config_markovTime_set, 'multilayerRelaxRate' = Config_multilayerRelaxRate_set, 'multilayerRelaxLimit' = Config_multilayerRelaxLimit_set, 'multilayerRelaxLimitUp' = Config_multilayerRelaxLimitUp_set, 'multilayerRelaxLimitDown' = Config_multilayerRelaxLimitDown_set, 'multilayerJSRelaxRate' = Config_multilayerJSRelaxRate_set, 'multilayerRelaxByJensenShannonDivergence' = Config_multilayerRelaxByJensenShannonDivergence_set, 'multilayerJSRelaxLimit' = Config_multilayerJSRelaxLimit_set, 'twoLevel' = Config_twoLevel_set, 'noCoarseTune' = Config_noCoarseTune_set, 'directedEdges' = Config_directedEdges_set, 'recordedTeleportation' = Config_recordedTeleportation_set, 'teleportationProbability' = Config_teleportationProbability_set, 'preferredNumberOfModules' = Config_preferredNumberOfModules_set, 'seedToRandomNumberGenerator' = Config_seedToRandomNumberGenerator_set, 'numTrials' = Config_numTrials_set, 'minimumCodelengthImprovement' = Config_minimumCodelengthImprovement_set, 'minimumSingleNodeCodelengthImprovement' = Config_minimumSingleNodeCodelengthImprovement_set, 'randomizeCoreLoopLimit' = Config_randomizeCoreLoopLimit_set, 'coreLoopLimit' = Config_coreLoopLimit_set, 'levelAggregationLimit' = Config_levelAggregationLimit_set, 'tuneIterationLimit' = Config_tuneIterationLimit_set, 'minimumRelativeTuneIterationImprovement' = Config_minimumRelativeTuneIterationImprovement_set, 'fastCoarseTunePartition' = Config_fastCoarseTunePartition_set, 'alternateCoarseTuneLevel' = Config_alternateCoarseTuneLevel_set, 'coarseTuneLevel' = Config_coarseTuneLevel_set, 'superLevelLimit' = Config_superLevelLimit_set, 'onlySuperModules' = Config_onlySuperModules_set, 'fastHierarchicalSolution' = Config_fastHierarchicalSolution_set, 'fastFirstIteration' = Config_fastFirstIteration_set, 'preferModularSolution' = Config_preferModularSolution_set, 'innerParallelization' = Config_innerParallelization_set, 'outDirectory' = Config_outDirectory_set, 'outName' = Config_outName_set, 'outputFormats' = Config_outputFormats_set, 'originallyUndirected' = Config_originallyUndirected_set, 'printTree' = Config_printTree_set, 'printFlowTree' = Config_printFlowTree_set, 'printNewick' = Config_printNewick_set, 'printMap' = Config_printMap_set, 'printClu' = Config_printClu_set, 'cluLevel' = Config_cluLevel_set, 'printNodeRanks' = Config_printNodeRanks_set, 'printFlowNetwork' = Config_printFlowNetwork_set, 'printPajekNetwork' = Config_printPajekNetwork_set, 'printStateNetwork' = Config_printStateNetwork_set, 'printBinaryTree' = Config_printBinaryTree_set, 'printBinaryFlowTree' = Config_printBinaryFlowTree_set, 'noFileOutput' = Config_noFileOutput_set, 'verbosity' = Config_verbosity_set, 'verboseNumberPrecision' = Config_verboseNumberPrecision_set, 'silent' = Config_silent_set, 'benchmark' = Config_benchmark_set, 'hideBipartiteNodes' = Config_hideBipartiteNodes_set, 'maxNodeIndexVisible' = Config_maxNodeIndexVisible_set, 'minBipartiteNodeIndex' = Config_minBipartiteNodeIndex_set, 'startDate' = Config_startDate_set, 'version' = Config_version_set, 'parsedString' = Config_parsedString_set, 'parsedOptions' = Config_parsedOptions_set, 'error' = Config_error_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_infomap__Config', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('isCLI' = Config_isCLI_set, 'networkFile' = Config_networkFile_set, 'additionalInput' = Config_additionalInput_set, 'inputFormat' = Config_inputFormat_set, 'memoryInput' = Config_memoryInput_set, 'multilayerInput' = Config_multilayerInput_set, 'weightThreshold' = Config_weightThreshold_set, 'unweightedPaths' = Config_unweightedPaths_set, 'pathMarkovOrder' = Config_pathMarkovOrder_set, 'bipartite' = Config_bipartite_set, 'skipAdjustBipartiteFlow' = Config_skipAdjustBipartiteFlow_set, 'bipartiteTeleportation' = Config_bipartiteTeleportation_set, 'hardPartitions' = Config_hardPartitions_set, 'parseWithoutIOStreams' = Config_parseWithoutIOStreams_set, 'zeroBasedNodeNumbers' = Config_zeroBasedNodeNumbers_set, 'includeSelfLinks' = Config_includeSelfLinks_set, 'ignoreEdgeWeights' = Config_ignoreEdgeWeights_set, 'nodeLimit' = Config_nodeLimit_set, 'preClusterMultilayer' = Config_preClusterMultilayer_set, 'clusterDataFile' = Config_clusterDataFile_set, 'metaDataFile' = Config_metaDataFile_set, 'metaDataRate' = Config_metaDataRate_set, 'unweightedMetaData' = Config_unweightedMetaData_set, 'numMetaDataDimensions' = Config_numMetaDataDimensions_set, 'clusterDataIsHard' = Config_clusterDataIsHard_set, 'assignToNeighbouringModule' = Config_assignToNeighbouringModule_set, 'noInfomap' = Config_noInfomap_set, 'flowModel' = Config_flowModel_set, 'directed' = Config_directed_set, 'undirdir' = Config_undirdir_set, 'outdirdir' = Config_outdirdir_set, 'rawdir' = Config_rawdir_set, 'useNodeWeightsAsFlow' = Config_useNodeWeightsAsFlow_set, 'teleportToNodes' = Config_teleportToNodes_set, 'selfTeleportationProbability' = Config_selfTeleportationProbability_set, 'markovTime' = Config_markovTime_set, 'multilayerRelaxRate' = Config_multilayerRelaxRate_set, 'multilayerRelaxLimit' = Config_multilayerRelaxLimit_set, 'multilayerRelaxLimitUp' = Config_multilayerRelaxLimitUp_set, 'multilayerRelaxLimitDown' = Config_multilayerRelaxLimitDown_set, 'multilayerJSRelaxRate' = Config_multilayerJSRelaxRate_set, 'multilayerRelaxByJensenShannonDivergence' = Config_multilayerRelaxByJensenShannonDivergence_set, 'multilayerJSRelaxLimit' = Config_multilayerJSRelaxLimit_set, 'twoLevel' = Config_twoLevel_set, 'noCoarseTune' = Config_noCoarseTune_set, 'directedEdges' = Config_directedEdges_set, 'recordedTeleportation' = Config_recordedTeleportation_set, 'teleportationProbability' = Config_teleportationProbability_set, 'preferredNumberOfModules' = Config_preferredNumberOfModules_set, 'seedToRandomNumberGenerator' = Config_seedToRandomNumberGenerator_set, 'numTrials' = Config_numTrials_set, 'minimumCodelengthImprovement' = Config_minimumCodelengthImprovement_set, 'minimumSingleNodeCodelengthImprovement' = Config_minimumSingleNodeCodelengthImprovement_set, 'randomizeCoreLoopLimit' = Config_randomizeCoreLoopLimit_set, 'coreLoopLimit' = Config_coreLoopLimit_set, 'levelAggregationLimit' = Config_levelAggregationLimit_set, 'tuneIterationLimit' = Config_tuneIterationLimit_set, 'minimumRelativeTuneIterationImprovement' = Config_minimumRelativeTuneIterationImprovement_set, 'fastCoarseTunePartition' = Config_fastCoarseTunePartition_set, 'alternateCoarseTuneLevel' = Config_alternateCoarseTuneLevel_set, 'coarseTuneLevel' = Config_coarseTuneLevel_set, 'superLevelLimit' = Config_superLevelLimit_set, 'onlySuperModules' = Config_onlySuperModules_set, 'fastHierarchicalSolution' = Config_fastHierarchicalSolution_set, 'fastFirstIteration' = Config_fastFirstIteration_set, 'preferModularSolution' = Config_preferModularSolution_set, 'innerParallelization' = Config_innerParallelization_set, 'outDirectory' = Config_outDirectory_set, 'outName' = Config_outName_set, 'outputFormats' = Config_outputFormats_set, 'originallyUndirected' = Config_originallyUndirected_set, 'printTree' = Config_printTree_set, 'printFlowTree' = Config_printFlowTree_set, 'printNewick' = Config_printNewick_set, 'printMap' = Config_printMap_set, 'printClu' = Config_printClu_set, 'cluLevel' = Config_cluLevel_set, 'printNodeRanks' = Config_printNodeRanks_set, 'printFlowNetwork' = Config_printFlowNetwork_set, 'printPajekNetwork' = Config_printPajekNetwork_set, 'printStateNetwork' = Config_printStateNetwork_set, 'printBinaryTree' = Config_printBinaryTree_set, 'printBinaryFlowTree' = Config_printBinaryFlowTree_set, 'noFileOutput' = Config_noFileOutput_set, 'verbosity' = Config_verbosity_set, 'verboseNumberPrecision' = Config_verboseNumberPrecision_set, 'silent' = Config_silent_set, 'benchmark' = Config_benchmark_set, 'hideBipartiteNodes' = Config_hideBipartiteNodes_set, 'maxNodeIndexVisible' = Config_maxNodeIndexVisible_set, 'minBipartiteNodeIndex' = Config_minBipartiteNodeIndex_set, 'startDate' = Config_startDate_set, 'version' = Config_version_set, 'parsedString' = Config_parsedString_set, 'parsedOptions' = Config_parsedOptions_set, 'error' = Config_error_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for infomap::Config
setMethod('delete', '_p_infomap__Config', function(obj) {delete_infomap__Config(obj)})
# Start definition of copy functions & methods for infomap::Config
CopyToR_infomap__Config = function(value, obj = new("infomap::Config"))
{
  obj@isCLI = value$isCLI;
  obj@networkFile = value$networkFile;
  obj@inputFormat = value$inputFormat;
  obj@memoryInput = value$memoryInput;
  obj@multilayerInput = value$multilayerInput;
  obj@weightThreshold = value$weightThreshold;
  obj@unweightedPaths = value$unweightedPaths;
  obj@pathMarkovOrder = value$pathMarkovOrder;
  obj@bipartite = value$bipartite;
  obj@skipAdjustBipartiteFlow = value$skipAdjustBipartiteFlow;
  obj@bipartiteTeleportation = value$bipartiteTeleportation;
  obj@hardPartitions = value$hardPartitions;
  obj@parseWithoutIOStreams = value$parseWithoutIOStreams;
  obj@zeroBasedNodeNumbers = value$zeroBasedNodeNumbers;
  obj@includeSelfLinks = value$includeSelfLinks;
  obj@ignoreEdgeWeights = value$ignoreEdgeWeights;
  obj@nodeLimit = value$nodeLimit;
  obj@preClusterMultilayer = value$preClusterMultilayer;
  obj@clusterDataFile = value$clusterDataFile;
  obj@metaDataFile = value$metaDataFile;
  obj@metaDataRate = value$metaDataRate;
  obj@unweightedMetaData = value$unweightedMetaData;
  obj@numMetaDataDimensions = value$numMetaDataDimensions;
  obj@clusterDataIsHard = value$clusterDataIsHard;
  obj@assignToNeighbouringModule = value$assignToNeighbouringModule;
  obj@noInfomap = value$noInfomap;
  obj@directed = value$directed;
  obj@undirdir = value$undirdir;
  obj@outdirdir = value$outdirdir;
  obj@rawdir = value$rawdir;
  obj@useNodeWeightsAsFlow = value$useNodeWeightsAsFlow;
  obj@teleportToNodes = value$teleportToNodes;
  obj@selfTeleportationProbability = value$selfTeleportationProbability;
  obj@markovTime = value$markovTime;
  obj@multilayerRelaxRate = value$multilayerRelaxRate;
  obj@multilayerRelaxLimit = value$multilayerRelaxLimit;
  obj@multilayerRelaxLimitUp = value$multilayerRelaxLimitUp;
  obj@multilayerRelaxLimitDown = value$multilayerRelaxLimitDown;
  obj@multilayerJSRelaxRate = value$multilayerJSRelaxRate;
  obj@multilayerRelaxByJensenShannonDivergence = value$multilayerRelaxByJensenShannonDivergence;
  obj@multilayerJSRelaxLimit = value$multilayerJSRelaxLimit;
  obj@twoLevel = value$twoLevel;
  obj@noCoarseTune = value$noCoarseTune;
  obj@directedEdges = value$directedEdges;
  obj@recordedTeleportation = value$recordedTeleportation;
  obj@teleportationProbability = value$teleportationProbability;
  obj@preferredNumberOfModules = value$preferredNumberOfModules;
  obj@seedToRandomNumberGenerator = value$seedToRandomNumberGenerator;
  obj@numTrials = value$numTrials;
  obj@minimumCodelengthImprovement = value$minimumCodelengthImprovement;
  obj@minimumSingleNodeCodelengthImprovement = value$minimumSingleNodeCodelengthImprovement;
  obj@randomizeCoreLoopLimit = value$randomizeCoreLoopLimit;
  obj@coreLoopLimit = value$coreLoopLimit;
  obj@levelAggregationLimit = value$levelAggregationLimit;
  obj@tuneIterationLimit = value$tuneIterationLimit;
  obj@minimumRelativeTuneIterationImprovement = value$minimumRelativeTuneIterationImprovement;
  obj@fastCoarseTunePartition = value$fastCoarseTunePartition;
  obj@alternateCoarseTuneLevel = value$alternateCoarseTuneLevel;
  obj@coarseTuneLevel = value$coarseTuneLevel;
  obj@superLevelLimit = value$superLevelLimit;
  obj@onlySuperModules = value$onlySuperModules;
  obj@fastHierarchicalSolution = value$fastHierarchicalSolution;
  obj@fastFirstIteration = value$fastFirstIteration;
  obj@preferModularSolution = value$preferModularSolution;
  obj@innerParallelization = value$innerParallelization;
  obj@outDirectory = value$outDirectory;
  obj@outName = value$outName;
  obj@outputFormats = value$outputFormats;
  obj@originallyUndirected = value$originallyUndirected;
  obj@printTree = value$printTree;
  obj@printFlowTree = value$printFlowTree;
  obj@printNewick = value$printNewick;
  obj@printMap = value$printMap;
  obj@printClu = value$printClu;
  obj@cluLevel = value$cluLevel;
  obj@printNodeRanks = value$printNodeRanks;
  obj@printFlowNetwork = value$printFlowNetwork;
  obj@printPajekNetwork = value$printPajekNetwork;
  obj@printStateNetwork = value$printStateNetwork;
  obj@printBinaryTree = value$printBinaryTree;
  obj@printBinaryFlowTree = value$printBinaryFlowTree;
  obj@noFileOutput = value$noFileOutput;
  obj@verbosity = value$verbosity;
  obj@verboseNumberPrecision = value$verboseNumberPrecision;
  obj@silent = value$silent;
  obj@benchmark = value$benchmark;
  obj@hideBipartiteNodes = value$hideBipartiteNodes;
  obj@maxNodeIndexVisible = value$maxNodeIndexVisible;
  obj@minBipartiteNodeIndex = value$minBipartiteNodeIndex;
  obj@version = value$version;
  obj@parsedString = value$parsedString;
  obj@error = value$error;
  obj;
}



CopyToC_infomap__Config = function(value, obj)
{
  obj$isCLI = value@isCLI;
  obj$networkFile = value@networkFile;
  obj$inputFormat = value@inputFormat;
  obj$memoryInput = value@memoryInput;
  obj$multilayerInput = value@multilayerInput;
  obj$weightThreshold = value@weightThreshold;
  obj$unweightedPaths = value@unweightedPaths;
  obj$pathMarkovOrder = value@pathMarkovOrder;
  obj$bipartite = value@bipartite;
  obj$skipAdjustBipartiteFlow = value@skipAdjustBipartiteFlow;
  obj$bipartiteTeleportation = value@bipartiteTeleportation;
  obj$hardPartitions = value@hardPartitions;
  obj$parseWithoutIOStreams = value@parseWithoutIOStreams;
  obj$zeroBasedNodeNumbers = value@zeroBasedNodeNumbers;
  obj$includeSelfLinks = value@includeSelfLinks;
  obj$ignoreEdgeWeights = value@ignoreEdgeWeights;
  obj$nodeLimit = value@nodeLimit;
  obj$preClusterMultilayer = value@preClusterMultilayer;
  obj$clusterDataFile = value@clusterDataFile;
  obj$metaDataFile = value@metaDataFile;
  obj$metaDataRate = value@metaDataRate;
  obj$unweightedMetaData = value@unweightedMetaData;
  obj$numMetaDataDimensions = value@numMetaDataDimensions;
  obj$clusterDataIsHard = value@clusterDataIsHard;
  obj$assignToNeighbouringModule = value@assignToNeighbouringModule;
  obj$noInfomap = value@noInfomap;
  obj$directed = value@directed;
  obj$undirdir = value@undirdir;
  obj$outdirdir = value@outdirdir;
  obj$rawdir = value@rawdir;
  obj$useNodeWeightsAsFlow = value@useNodeWeightsAsFlow;
  obj$teleportToNodes = value@teleportToNodes;
  obj$selfTeleportationProbability = value@selfTeleportationProbability;
  obj$markovTime = value@markovTime;
  obj$multilayerRelaxRate = value@multilayerRelaxRate;
  obj$multilayerRelaxLimit = value@multilayerRelaxLimit;
  obj$multilayerRelaxLimitUp = value@multilayerRelaxLimitUp;
  obj$multilayerRelaxLimitDown = value@multilayerRelaxLimitDown;
  obj$multilayerJSRelaxRate = value@multilayerJSRelaxRate;
  obj$multilayerRelaxByJensenShannonDivergence = value@multilayerRelaxByJensenShannonDivergence;
  obj$multilayerJSRelaxLimit = value@multilayerJSRelaxLimit;
  obj$twoLevel = value@twoLevel;
  obj$noCoarseTune = value@noCoarseTune;
  obj$directedEdges = value@directedEdges;
  obj$recordedTeleportation = value@recordedTeleportation;
  obj$teleportationProbability = value@teleportationProbability;
  obj$preferredNumberOfModules = value@preferredNumberOfModules;
  obj$seedToRandomNumberGenerator = value@seedToRandomNumberGenerator;
  obj$numTrials = value@numTrials;
  obj$minimumCodelengthImprovement = value@minimumCodelengthImprovement;
  obj$minimumSingleNodeCodelengthImprovement = value@minimumSingleNodeCodelengthImprovement;
  obj$randomizeCoreLoopLimit = value@randomizeCoreLoopLimit;
  obj$coreLoopLimit = value@coreLoopLimit;
  obj$levelAggregationLimit = value@levelAggregationLimit;
  obj$tuneIterationLimit = value@tuneIterationLimit;
  obj$minimumRelativeTuneIterationImprovement = value@minimumRelativeTuneIterationImprovement;
  obj$fastCoarseTunePartition = value@fastCoarseTunePartition;
  obj$alternateCoarseTuneLevel = value@alternateCoarseTuneLevel;
  obj$coarseTuneLevel = value@coarseTuneLevel;
  obj$superLevelLimit = value@superLevelLimit;
  obj$onlySuperModules = value@onlySuperModules;
  obj$fastHierarchicalSolution = value@fastHierarchicalSolution;
  obj$fastFirstIteration = value@fastFirstIteration;
  obj$preferModularSolution = value@preferModularSolution;
  obj$innerParallelization = value@innerParallelization;
  obj$outDirectory = value@outDirectory;
  obj$outName = value@outName;
  obj$outputFormats = value@outputFormats;
  obj$originallyUndirected = value@originallyUndirected;
  obj$printTree = value@printTree;
  obj$printFlowTree = value@printFlowTree;
  obj$printNewick = value@printNewick;
  obj$printMap = value@printMap;
  obj$printClu = value@printClu;
  obj$cluLevel = value@cluLevel;
  obj$printNodeRanks = value@printNodeRanks;
  obj$printFlowNetwork = value@printFlowNetwork;
  obj$printPajekNetwork = value@printPajekNetwork;
  obj$printStateNetwork = value@printStateNetwork;
  obj$printBinaryTree = value@printBinaryTree;
  obj$printBinaryFlowTree = value@printBinaryFlowTree;
  obj$noFileOutput = value@noFileOutput;
  obj$verbosity = value@verbosity;
  obj$verboseNumberPrecision = value@verboseNumberPrecision;
  obj$silent = value@silent;
  obj$benchmark = value@benchmark;
  obj$hideBipartiteNodes = value@hideBipartiteNodes;
  obj$maxNodeIndexVisible = value@maxNodeIndexVisible;
  obj$minBipartiteNodeIndex = value@minBipartiteNodeIndex;
  obj$version = value@version;
  obj$parsedString = value@parsedString;
  obj$error = value@error;
  obj
}



# Start definition of copy methods for infomap::Config
setMethod('copyToR', '_p_infomap::Config', CopyToR_infomap__Config);
setMethod('copyToC', 'infomap::Config', CopyToC_infomap__Config);

# End definition of copy methods for infomap::Config
# End definition of copy functions & methods for infomap::Config
# Start of new_FlowData

`FlowData__SWIG_0` = function(flow)
{
  ;ans = .Call('R_swig_new_FlowData__SWIG_0', flow, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__FlowData", ref=ans);
  
  reg.finalizer(ans@ref, delete_FlowData);
  ans
  
}

attr(`FlowData__SWIG_0`, 'returnType') = '_p_infomap__FlowData'
attr(`FlowData__SWIG_0`, "inputTypes") = c('numeric')
class(`FlowData__SWIG_0`) = c("SWIGFunction", class('FlowData__SWIG_0'))

# Start of new_FlowData

`FlowData__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_FlowData__SWIG_1', PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__FlowData", ref=ans);
  
  reg.finalizer(ans@ref, delete_FlowData);
  ans
  
}

attr(`FlowData__SWIG_1`, 'returnType') = '_p_infomap__FlowData'
class(`FlowData__SWIG_1`) = c("SWIGFunction", class('FlowData__SWIG_1'))

# Start of new_FlowData

`FlowData__SWIG_2` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_new_FlowData__SWIG_2', other, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__FlowData", ref=ans);
  
  reg.finalizer(ans@ref, delete_FlowData);
  ans
  
}

attr(`FlowData__SWIG_2`, 'returnType') = '_p_infomap__FlowData'
attr(`FlowData__SWIG_2`, "inputTypes") = c('_p_infomap__FlowData')
class(`FlowData__SWIG_2`) = c("SWIGFunction", class('FlowData__SWIG_2'))

`FlowData` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 0) {
    f <- FlowData__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_infomap__FlowData') && length(argv[[1]]) == 1) {
      f <- FlowData__SWIG_2; 
    }
    else if (( is.numeric(argv[[1]]) && length(argv[[1]]) == 1 )) {
      f <- FlowData__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for FlowData with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of FlowData_Equal

`FlowData_Equal` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_FlowData_Equal', self, other, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__FlowData", ref=ans);
  
  ans
  
}

attr(`FlowData_Equal`, 'returnType') = '_p_infomap__FlowData'
attr(`FlowData_Equal`, "inputTypes") = c('_p_infomap__FlowData', '_p_infomap__FlowData')
class(`FlowData_Equal`) = c("SWIGFunction", class('FlowData_Equal'))

# Start of FlowData_flow_set

`FlowData_flow_set` = function(self, s_flow)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_FlowData_flow_set', self, s_flow, PACKAGE='infomap');
  
}

attr(`FlowData_flow_set`, 'returnType') = 'void'
attr(`FlowData_flow_set`, "inputTypes") = c('_p_infomap__FlowData', 'numeric')
class(`FlowData_flow_set`) = c("SWIGFunction", class('FlowData_flow_set'))

# Start of FlowData_flow_get

`FlowData_flow_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_FlowData_flow_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`FlowData_flow_get`, 'returnType') = 'numeric'
attr(`FlowData_flow_get`, "inputTypes") = c('_p_infomap__FlowData')
class(`FlowData_flow_get`) = c("SWIGFunction", class('FlowData_flow_get'))

# Start of FlowData_enterFlow_set

`FlowData_enterFlow_set` = function(self, s_enterFlow)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_FlowData_enterFlow_set', self, s_enterFlow, PACKAGE='infomap');
  
}

attr(`FlowData_enterFlow_set`, 'returnType') = 'void'
attr(`FlowData_enterFlow_set`, "inputTypes") = c('_p_infomap__FlowData', 'numeric')
class(`FlowData_enterFlow_set`) = c("SWIGFunction", class('FlowData_enterFlow_set'))

# Start of FlowData_enterFlow_get

`FlowData_enterFlow_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_FlowData_enterFlow_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`FlowData_enterFlow_get`, 'returnType') = 'numeric'
attr(`FlowData_enterFlow_get`, "inputTypes") = c('_p_infomap__FlowData')
class(`FlowData_enterFlow_get`) = c("SWIGFunction", class('FlowData_enterFlow_get'))

# Start of FlowData_exitFlow_set

`FlowData_exitFlow_set` = function(self, s_exitFlow)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_FlowData_exitFlow_set', self, s_exitFlow, PACKAGE='infomap');
  
}

attr(`FlowData_exitFlow_set`, 'returnType') = 'void'
attr(`FlowData_exitFlow_set`, "inputTypes") = c('_p_infomap__FlowData', 'numeric')
class(`FlowData_exitFlow_set`) = c("SWIGFunction", class('FlowData_exitFlow_set'))

# Start of FlowData_exitFlow_get

`FlowData_exitFlow_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_FlowData_exitFlow_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`FlowData_exitFlow_get`, 'returnType') = 'numeric'
attr(`FlowData_exitFlow_get`, "inputTypes") = c('_p_infomap__FlowData')
class(`FlowData_exitFlow_get`) = c("SWIGFunction", class('FlowData_exitFlow_get'))

# Start of FlowData_PlusEqual

`FlowData_PlusEqual` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_FlowData_PlusEqual', self, other, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__FlowData", ref=ans);
  
  ans
  
}

attr(`FlowData_PlusEqual`, 'returnType') = '_p_infomap__FlowData'
attr(`FlowData_PlusEqual`, "inputTypes") = c('_p_infomap__FlowData', '_p_infomap__FlowData')
class(`FlowData_PlusEqual`) = c("SWIGFunction", class('FlowData_PlusEqual'))

# Start of FlowData_MinusEqual

`FlowData_MinusEqual` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_FlowData_MinusEqual', self, other, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__FlowData", ref=ans);
  
  ans
  
}

attr(`FlowData_MinusEqual`, 'returnType') = '_p_infomap__FlowData'
attr(`FlowData_MinusEqual`, "inputTypes") = c('_p_infomap__FlowData', '_p_infomap__FlowData')
class(`FlowData_MinusEqual`) = c("SWIGFunction", class('FlowData_MinusEqual'))

# Start of delete_FlowData

`delete_FlowData` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_FlowData', self, PACKAGE='infomap');
  
}

attr(`delete_FlowData`, 'returnType') = 'void'
attr(`delete_FlowData`, "inputTypes") = c('_p_infomap__FlowData')
class(`delete_FlowData`) = c("SWIGFunction", class('delete_FlowData'))

# Start of accessor method for infomap::FlowData
setMethod('$', '_p_infomap__FlowData', function(x, name)

{
  accessorFuns = list('Equal' = FlowData_Equal, 'flow' = FlowData_flow_get, 'enterFlow' = FlowData_enterFlow_get, 'exitFlow' = FlowData_exitFlow_get, 'PlusEqual' = FlowData_PlusEqual, 'MinusEqual' = FlowData_MinusEqual);
  vaccessors = c('flow', 'enterFlow', 'exitFlow');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for infomap::FlowData
# Start of accessor method for infomap::FlowData
setMethod('$<-', '_p_infomap__FlowData', function(x, name, value)

{
  accessorFuns = list('flow' = FlowData_flow_set, 'enterFlow' = FlowData_enterFlow_set, 'exitFlow' = FlowData_exitFlow_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_infomap__FlowData', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('flow' = FlowData_flow_set, 'enterFlow' = FlowData_enterFlow_set, 'exitFlow' = FlowData_exitFlow_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for infomap::FlowData
setMethod('delete', '_p_infomap__FlowData', function(obj) {delete_infomap__FlowData(obj)})
# Start definition of copy functions & methods for infomap::FlowData
CopyToR_infomap__FlowData = function(value, obj = new("infomap::FlowData"))
{
  obj@flow = value$flow;
  obj@enterFlow = value$enterFlow;
  obj@exitFlow = value$exitFlow;
  obj;
}



CopyToC_infomap__FlowData = function(value, obj)
{
  obj$flow = value@flow;
  obj$enterFlow = value@enterFlow;
  obj$exitFlow = value@exitFlow;
  obj
}



# Start definition of copy methods for infomap::FlowData
setMethod('copyToR', '_p_infomap::FlowData', CopyToR_infomap__FlowData);
setMethod('copyToC', 'infomap::FlowData', CopyToC_infomap__FlowData);

# End definition of copy methods for infomap::FlowData
# End definition of copy functions & methods for infomap::FlowData
# Start of DeltaFlow_module_set

`DeltaFlow_module_set` = function(self, s_module)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_module = as.integer(s_module);
  
  if(length(s_module) > 1) {
    warning("using only the first element of s_module");
  };
  
  ;.Call('R_swig_DeltaFlow_module_set', self, s_module, PACKAGE='infomap');
  
}

attr(`DeltaFlow_module_set`, 'returnType') = 'void'
attr(`DeltaFlow_module_set`, "inputTypes") = c('_p_infomap__DeltaFlow', 'integer')
class(`DeltaFlow_module_set`) = c("SWIGFunction", class('DeltaFlow_module_set'))

# Start of DeltaFlow_module_get

`DeltaFlow_module_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_DeltaFlow_module_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`DeltaFlow_module_get`, 'returnType') = 'integer'
attr(`DeltaFlow_module_get`, "inputTypes") = c('_p_infomap__DeltaFlow')
class(`DeltaFlow_module_get`) = c("SWIGFunction", class('DeltaFlow_module_get'))

# Start of DeltaFlow_deltaExit_set

`DeltaFlow_deltaExit_set` = function(self, s_deltaExit)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_DeltaFlow_deltaExit_set', self, s_deltaExit, PACKAGE='infomap');
  
}

attr(`DeltaFlow_deltaExit_set`, 'returnType') = 'void'
attr(`DeltaFlow_deltaExit_set`, "inputTypes") = c('_p_infomap__DeltaFlow', 'numeric')
class(`DeltaFlow_deltaExit_set`) = c("SWIGFunction", class('DeltaFlow_deltaExit_set'))

# Start of DeltaFlow_deltaExit_get

`DeltaFlow_deltaExit_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_DeltaFlow_deltaExit_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`DeltaFlow_deltaExit_get`, 'returnType') = 'numeric'
attr(`DeltaFlow_deltaExit_get`, "inputTypes") = c('_p_infomap__DeltaFlow')
class(`DeltaFlow_deltaExit_get`) = c("SWIGFunction", class('DeltaFlow_deltaExit_get'))

# Start of DeltaFlow_deltaEnter_set

`DeltaFlow_deltaEnter_set` = function(self, s_deltaEnter)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_DeltaFlow_deltaEnter_set', self, s_deltaEnter, PACKAGE='infomap');
  
}

attr(`DeltaFlow_deltaEnter_set`, 'returnType') = 'void'
attr(`DeltaFlow_deltaEnter_set`, "inputTypes") = c('_p_infomap__DeltaFlow', 'numeric')
class(`DeltaFlow_deltaEnter_set`) = c("SWIGFunction", class('DeltaFlow_deltaEnter_set'))

# Start of DeltaFlow_deltaEnter_get

`DeltaFlow_deltaEnter_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_DeltaFlow_deltaEnter_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`DeltaFlow_deltaEnter_get`, 'returnType') = 'numeric'
attr(`DeltaFlow_deltaEnter_get`, "inputTypes") = c('_p_infomap__DeltaFlow')
class(`DeltaFlow_deltaEnter_get`) = c("SWIGFunction", class('DeltaFlow_deltaEnter_get'))

# Start of DeltaFlow_count_set

`DeltaFlow_count_set` = function(self, s_count)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_count = as.integer(s_count);
  
  if(length(s_count) > 1) {
    warning("using only the first element of s_count");
  };
  
  ;.Call('R_swig_DeltaFlow_count_set', self, s_count, PACKAGE='infomap');
  
}

attr(`DeltaFlow_count_set`, 'returnType') = 'void'
attr(`DeltaFlow_count_set`, "inputTypes") = c('_p_infomap__DeltaFlow', 'integer')
class(`DeltaFlow_count_set`) = c("SWIGFunction", class('DeltaFlow_count_set'))

# Start of DeltaFlow_count_get

`DeltaFlow_count_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_DeltaFlow_count_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`DeltaFlow_count_get`, 'returnType') = 'integer'
attr(`DeltaFlow_count_get`, "inputTypes") = c('_p_infomap__DeltaFlow')
class(`DeltaFlow_count_get`) = c("SWIGFunction", class('DeltaFlow_count_get'))

# Start of delete_DeltaFlow

`delete_DeltaFlow` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_DeltaFlow', self, PACKAGE='infomap');
  
}

attr(`delete_DeltaFlow`, 'returnType') = 'void'
attr(`delete_DeltaFlow`, "inputTypes") = c('_p_infomap__DeltaFlow')
class(`delete_DeltaFlow`) = c("SWIGFunction", class('delete_DeltaFlow'))

# Start of new_DeltaFlow

`DeltaFlow__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_DeltaFlow__SWIG_0', PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__DeltaFlow", ref=ans);
  
  reg.finalizer(ans@ref, delete_DeltaFlow);
  ans
  
}

attr(`DeltaFlow__SWIG_0`, 'returnType') = '_p_infomap__DeltaFlow'
class(`DeltaFlow__SWIG_0`) = c("SWIGFunction", class('DeltaFlow__SWIG_0'))

# Start of new_DeltaFlow

`DeltaFlow__SWIG_1` = function(module, deltaExit, deltaEnter)
{
  module = as.integer(module);
  
  if(length(module) > 1) {
    warning("using only the first element of module");
  };
  
  
  
  ;ans = .Call('R_swig_new_DeltaFlow__SWIG_1', module, deltaExit, deltaEnter, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__DeltaFlow", ref=ans);
  
  reg.finalizer(ans@ref, delete_DeltaFlow);
  ans
  
}

attr(`DeltaFlow__SWIG_1`, 'returnType') = '_p_infomap__DeltaFlow'
attr(`DeltaFlow__SWIG_1`, "inputTypes") = c('integer', 'numeric', 'numeric')
class(`DeltaFlow__SWIG_1`) = c("SWIGFunction", class('DeltaFlow__SWIG_1'))

# Start of new_DeltaFlow

`DeltaFlow__SWIG_2` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref"); 
  ;ans = .Call('R_swig_new_DeltaFlow__SWIG_2', s_arg1, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__DeltaFlow", ref=ans);
  
  reg.finalizer(ans@ref, delete_DeltaFlow);
  ans
  
}

attr(`DeltaFlow__SWIG_2`, 'returnType') = '_p_infomap__DeltaFlow'
attr(`DeltaFlow__SWIG_2`, "inputTypes") = c('_p_infomap__DeltaFlow')
class(`DeltaFlow__SWIG_2`) = c("SWIGFunction", class('DeltaFlow__SWIG_2'))

# Start of DeltaFlow_Equal

`DeltaFlow_Equal__SWIG_0` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref"); 
  ;ans = .Call('R_swig_DeltaFlow_Equal__SWIG_0', self, s_arg2, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__DeltaFlow", ref=ans);
  
  ans
  
}

attr(`DeltaFlow_Equal__SWIG_0`, 'returnType') = '_p_infomap__DeltaFlow'
attr(`DeltaFlow_Equal__SWIG_0`, "inputTypes") = c('_p_infomap__DeltaFlow', '_p_infomap__DeltaFlow')
class(`DeltaFlow_Equal__SWIG_0`) = c("SWIGFunction", class('DeltaFlow_Equal__SWIG_0'))

# Start of new_DeltaFlow

`DeltaFlow__SWIG_3` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref"); 
  ;ans = .Call('R_swig_new_DeltaFlow__SWIG_3', s_arg1, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__DeltaFlow", ref=ans);
  
  reg.finalizer(ans@ref, delete_DeltaFlow);
  ans
  
}

attr(`DeltaFlow__SWIG_3`, 'returnType') = '_p_infomap__DeltaFlow'
attr(`DeltaFlow__SWIG_3`, "inputTypes") = c('_p_infomap__DeltaFlow')
class(`DeltaFlow__SWIG_3`) = c("SWIGFunction", class('DeltaFlow__SWIG_3'))

`DeltaFlow` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- DeltaFlow__SWIG_0; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_infomap__DeltaFlow') && length(argv[[1]]) == 1) {
      f <- DeltaFlow__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_infomap__DeltaFlow') && length(argv[[1]]) == 1) {
      f <- DeltaFlow__SWIG_3; 
    }
  } else if (argc == 3) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 ) && ( is.numeric(argv[[3]]) && length(argv[[3]]) == 1 )) {
      f <- DeltaFlow__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for DeltaFlow with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of DeltaFlow_Equal

`DeltaFlow_Equal__SWIG_1` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref"); 
  ;ans = .Call('R_swig_DeltaFlow_Equal__SWIG_1', self, s_arg2, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__DeltaFlow", ref=ans);
  
  ans
  
}

attr(`DeltaFlow_Equal__SWIG_1`, 'returnType') = '_p_infomap__DeltaFlow'
attr(`DeltaFlow_Equal__SWIG_1`, "inputTypes") = c('_p_infomap__DeltaFlow', '_p_infomap__DeltaFlow')
class(`DeltaFlow_Equal__SWIG_1`) = c("SWIGFunction", class('DeltaFlow_Equal__SWIG_1'))

`DeltaFlow_Equal` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__DeltaFlow') || is.null(argv[[1]])) && extends(argtypes[2], '_p_infomap__DeltaFlow') && length(argv[[2]]) == 1) {
      f <- DeltaFlow_Equal__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__DeltaFlow') || is.null(argv[[1]])) && extends(argtypes[2], '_p_infomap__DeltaFlow') && length(argv[[2]]) == 1) {
      f <- DeltaFlow_Equal__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for DeltaFlow_Equal with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of DeltaFlow_PlusEqual

`DeltaFlow_PlusEqual` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_DeltaFlow_PlusEqual', self, other, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__DeltaFlow", ref=ans);
  
  ans
  
}

attr(`DeltaFlow_PlusEqual`, 'returnType') = '_p_infomap__DeltaFlow'
attr(`DeltaFlow_PlusEqual`, "inputTypes") = c('_p_infomap__DeltaFlow', '_p_infomap__DeltaFlow')
class(`DeltaFlow_PlusEqual`) = c("SWIGFunction", class('DeltaFlow_PlusEqual'))

# Start of DeltaFlow_reset

`DeltaFlow_reset` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_DeltaFlow_reset', self, PACKAGE='infomap');
  
}

attr(`DeltaFlow_reset`, 'returnType') = 'void'
attr(`DeltaFlow_reset`, "inputTypes") = c('_p_infomap__DeltaFlow')
class(`DeltaFlow_reset`) = c("SWIGFunction", class('DeltaFlow_reset'))

# Start of accessor method for infomap::DeltaFlow
setMethod('$', '_p_infomap__DeltaFlow', function(x, name)

{
  accessorFuns = list('module' = DeltaFlow_module_get, 'deltaExit' = DeltaFlow_deltaExit_get, 'deltaEnter' = DeltaFlow_deltaEnter_get, 'count' = DeltaFlow_count_get, 'Equal' = DeltaFlow_Equal, 'PlusEqual' = DeltaFlow_PlusEqual, 'reset' = DeltaFlow_reset);
  vaccessors = c('module', 'deltaExit', 'deltaEnter', 'count');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for infomap::DeltaFlow
# Start of accessor method for infomap::DeltaFlow
setMethod('$<-', '_p_infomap__DeltaFlow', function(x, name, value)

{
  accessorFuns = list('module' = DeltaFlow_module_set, 'deltaExit' = DeltaFlow_deltaExit_set, 'deltaEnter' = DeltaFlow_deltaEnter_set, 'count' = DeltaFlow_count_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_infomap__DeltaFlow', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('module' = DeltaFlow_module_set, 'deltaExit' = DeltaFlow_deltaExit_set, 'deltaEnter' = DeltaFlow_deltaEnter_set, 'count' = DeltaFlow_count_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for infomap::DeltaFlow
setMethod('delete', '_p_infomap__DeltaFlow', function(obj) {delete_infomap__DeltaFlow(obj)})
# Start definition of copy functions & methods for infomap::DeltaFlow
CopyToR_infomap__DeltaFlow = function(value, obj = new("infomap::DeltaFlow"))
{
  obj@module = value$module;
  obj@deltaExit = value$deltaExit;
  obj@deltaEnter = value$deltaEnter;
  obj@count = value$count;
  obj;
}



CopyToC_infomap__DeltaFlow = function(value, obj)
{
  obj$module = value@module;
  obj$deltaExit = value@deltaExit;
  obj$deltaEnter = value@deltaEnter;
  obj$count = value@count;
  obj
}



# Start definition of copy methods for infomap::DeltaFlow
setMethod('copyToR', '_p_infomap::DeltaFlow', CopyToR_infomap__DeltaFlow);
setMethod('copyToC', 'infomap::DeltaFlow', CopyToC_infomap__DeltaFlow);

# End definition of copy methods for infomap::DeltaFlow
# End definition of copy functions & methods for infomap::DeltaFlow
# Start of MemDeltaFlow_sumDeltaPlogpPhysFlow_set

`MemDeltaFlow_sumDeltaPlogpPhysFlow_set` = function(self, s_sumDeltaPlogpPhysFlow)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_MemDeltaFlow_sumDeltaPlogpPhysFlow_set', self, s_sumDeltaPlogpPhysFlow, PACKAGE='infomap');
  
}

attr(`MemDeltaFlow_sumDeltaPlogpPhysFlow_set`, 'returnType') = 'void'
attr(`MemDeltaFlow_sumDeltaPlogpPhysFlow_set`, "inputTypes") = c('_p_infomap__MemDeltaFlow', 'numeric')
class(`MemDeltaFlow_sumDeltaPlogpPhysFlow_set`) = c("SWIGFunction", class('MemDeltaFlow_sumDeltaPlogpPhysFlow_set'))

# Start of MemDeltaFlow_sumDeltaPlogpPhysFlow_get

`MemDeltaFlow_sumDeltaPlogpPhysFlow_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MemDeltaFlow_sumDeltaPlogpPhysFlow_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MemDeltaFlow_sumDeltaPlogpPhysFlow_get`, 'returnType') = 'numeric'
attr(`MemDeltaFlow_sumDeltaPlogpPhysFlow_get`, "inputTypes") = c('_p_infomap__MemDeltaFlow')
class(`MemDeltaFlow_sumDeltaPlogpPhysFlow_get`) = c("SWIGFunction", class('MemDeltaFlow_sumDeltaPlogpPhysFlow_get'))

# Start of MemDeltaFlow_sumPlogpPhysFlow_set

`MemDeltaFlow_sumPlogpPhysFlow_set` = function(self, s_sumPlogpPhysFlow)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_MemDeltaFlow_sumPlogpPhysFlow_set', self, s_sumPlogpPhysFlow, PACKAGE='infomap');
  
}

attr(`MemDeltaFlow_sumPlogpPhysFlow_set`, 'returnType') = 'void'
attr(`MemDeltaFlow_sumPlogpPhysFlow_set`, "inputTypes") = c('_p_infomap__MemDeltaFlow', 'numeric')
class(`MemDeltaFlow_sumPlogpPhysFlow_set`) = c("SWIGFunction", class('MemDeltaFlow_sumPlogpPhysFlow_set'))

# Start of MemDeltaFlow_sumPlogpPhysFlow_get

`MemDeltaFlow_sumPlogpPhysFlow_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MemDeltaFlow_sumPlogpPhysFlow_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MemDeltaFlow_sumPlogpPhysFlow_get`, 'returnType') = 'numeric'
attr(`MemDeltaFlow_sumPlogpPhysFlow_get`, "inputTypes") = c('_p_infomap__MemDeltaFlow')
class(`MemDeltaFlow_sumPlogpPhysFlow_get`) = c("SWIGFunction", class('MemDeltaFlow_sumPlogpPhysFlow_get'))

# Start of new_MemDeltaFlow

`MemDeltaFlow__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_MemDeltaFlow__SWIG_0', PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__MemDeltaFlow", ref=ans);
  
  reg.finalizer(ans@ref, delete_MemDeltaFlow);
  ans
  
}

attr(`MemDeltaFlow__SWIG_0`, 'returnType') = '_p_infomap__MemDeltaFlow'
class(`MemDeltaFlow__SWIG_0`) = c("SWIGFunction", class('MemDeltaFlow__SWIG_0'))

# Start of new_MemDeltaFlow

`MemDeltaFlow__SWIG_1` = function(module, deltaExit, deltaEnter, sumDeltaPlogpPhysFlow, sumPlogpPhysFlow)
{
  module = as.integer(module);
  
  if(length(module) > 1) {
    warning("using only the first element of module");
  };
  
  
  
  
  
  ;ans = .Call('R_swig_new_MemDeltaFlow__SWIG_1', module, deltaExit, deltaEnter, sumDeltaPlogpPhysFlow, sumPlogpPhysFlow, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__MemDeltaFlow", ref=ans);
  
  reg.finalizer(ans@ref, delete_MemDeltaFlow);
  ans
  
}

attr(`MemDeltaFlow__SWIG_1`, 'returnType') = '_p_infomap__MemDeltaFlow'
attr(`MemDeltaFlow__SWIG_1`, "inputTypes") = c('integer', 'numeric', 'numeric', 'numeric', 'numeric')
class(`MemDeltaFlow__SWIG_1`) = c("SWIGFunction", class('MemDeltaFlow__SWIG_1'))

# Start of new_MemDeltaFlow

`MemDeltaFlow__SWIG_2` = function(module, deltaExit, deltaEnter, sumDeltaPlogpPhysFlow)
{
  module = as.integer(module);
  
  if(length(module) > 1) {
    warning("using only the first element of module");
  };
  
  
  
  
  ;ans = .Call('R_swig_new_MemDeltaFlow__SWIG_2', module, deltaExit, deltaEnter, sumDeltaPlogpPhysFlow, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__MemDeltaFlow", ref=ans);
  
  reg.finalizer(ans@ref, delete_MemDeltaFlow);
  ans
  
}

attr(`MemDeltaFlow__SWIG_2`, 'returnType') = '_p_infomap__MemDeltaFlow'
attr(`MemDeltaFlow__SWIG_2`, "inputTypes") = c('integer', 'numeric', 'numeric', 'numeric')
class(`MemDeltaFlow__SWIG_2`) = c("SWIGFunction", class('MemDeltaFlow__SWIG_2'))

# Start of new_MemDeltaFlow

`MemDeltaFlow__SWIG_3` = function(module, deltaExit, deltaEnter)
{
  module = as.integer(module);
  
  if(length(module) > 1) {
    warning("using only the first element of module");
  };
  
  
  
  ;ans = .Call('R_swig_new_MemDeltaFlow__SWIG_3', module, deltaExit, deltaEnter, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__MemDeltaFlow", ref=ans);
  
  reg.finalizer(ans@ref, delete_MemDeltaFlow);
  ans
  
}

attr(`MemDeltaFlow__SWIG_3`, 'returnType') = '_p_infomap__MemDeltaFlow'
attr(`MemDeltaFlow__SWIG_3`, "inputTypes") = c('integer', 'numeric', 'numeric')
class(`MemDeltaFlow__SWIG_3`) = c("SWIGFunction", class('MemDeltaFlow__SWIG_3'))

`MemDeltaFlow` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- MemDeltaFlow__SWIG_0; 
  } else if (argc == 3) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 ) && ( is.numeric(argv[[3]]) && length(argv[[3]]) == 1 )) {
      f <- MemDeltaFlow__SWIG_3; 
    }
  } else if (argc == 4) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 ) && ( is.numeric(argv[[3]]) && length(argv[[3]]) == 1 ) && ( is.numeric(argv[[4]]) && length(argv[[4]]) == 1 )) {
      f <- MemDeltaFlow__SWIG_2; 
    }
  } else if (argc == 5) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 ) && ( is.numeric(argv[[3]]) && length(argv[[3]]) == 1 ) && ( is.numeric(argv[[4]]) && length(argv[[4]]) == 1 ) && ( is.numeric(argv[[5]]) && length(argv[[5]]) == 1 )) {
      f <- MemDeltaFlow__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for MemDeltaFlow with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of MemDeltaFlow_PlusEqual

`MemDeltaFlow_PlusEqual` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_MemDeltaFlow_PlusEqual', self, other, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__MemDeltaFlow", ref=ans);
  
  ans
  
}

attr(`MemDeltaFlow_PlusEqual`, 'returnType') = '_p_infomap__MemDeltaFlow'
attr(`MemDeltaFlow_PlusEqual`, "inputTypes") = c('_p_infomap__MemDeltaFlow', '_p_infomap__MemDeltaFlow')
class(`MemDeltaFlow_PlusEqual`) = c("SWIGFunction", class('MemDeltaFlow_PlusEqual'))

# Start of MemDeltaFlow_reset

`MemDeltaFlow_reset` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MemDeltaFlow_reset', self, PACKAGE='infomap');
  
}

attr(`MemDeltaFlow_reset`, 'returnType') = 'void'
attr(`MemDeltaFlow_reset`, "inputTypes") = c('_p_infomap__MemDeltaFlow')
class(`MemDeltaFlow_reset`) = c("SWIGFunction", class('MemDeltaFlow_reset'))

# Start of delete_MemDeltaFlow

`delete_MemDeltaFlow` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_MemDeltaFlow', self, PACKAGE='infomap');
  
}

attr(`delete_MemDeltaFlow`, 'returnType') = 'void'
attr(`delete_MemDeltaFlow`, "inputTypes") = c('_p_infomap__MemDeltaFlow')
class(`delete_MemDeltaFlow`) = c("SWIGFunction", class('delete_MemDeltaFlow'))

# Start of accessor method for infomap::MemDeltaFlow
setMethod('$', '_p_infomap__MemDeltaFlow', function(x, name)

{
  accessorFuns = list('sumDeltaPlogpPhysFlow' = MemDeltaFlow_sumDeltaPlogpPhysFlow_get, 'sumPlogpPhysFlow' = MemDeltaFlow_sumPlogpPhysFlow_get, 'PlusEqual' = MemDeltaFlow_PlusEqual, 'reset' = MemDeltaFlow_reset);
  vaccessors = c('sumDeltaPlogpPhysFlow', 'sumPlogpPhysFlow');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for infomap::MemDeltaFlow
# Start of accessor method for infomap::MemDeltaFlow
setMethod('$<-', '_p_infomap__MemDeltaFlow', function(x, name, value)

{
  accessorFuns = list('sumDeltaPlogpPhysFlow' = MemDeltaFlow_sumDeltaPlogpPhysFlow_set, 'sumPlogpPhysFlow' = MemDeltaFlow_sumPlogpPhysFlow_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_infomap__MemDeltaFlow', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('sumDeltaPlogpPhysFlow' = MemDeltaFlow_sumDeltaPlogpPhysFlow_set, 'sumPlogpPhysFlow' = MemDeltaFlow_sumPlogpPhysFlow_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for infomap::MemDeltaFlow
setMethod('delete', '_p_infomap__MemDeltaFlow', function(obj) {delete_infomap__MemDeltaFlow(obj)})
# Start definition of copy functions & methods for infomap::MemDeltaFlow
CopyToR_infomap__MemDeltaFlow = function(value, obj = new("infomap::MemDeltaFlow"))
{
  obj@sumDeltaPlogpPhysFlow = value$sumDeltaPlogpPhysFlow;
  obj@sumPlogpPhysFlow = value$sumPlogpPhysFlow;
  obj;
}



CopyToC_infomap__MemDeltaFlow = function(value, obj)
{
  obj$sumDeltaPlogpPhysFlow = value@sumDeltaPlogpPhysFlow;
  obj$sumPlogpPhysFlow = value@sumPlogpPhysFlow;
  obj
}



# Start definition of copy methods for infomap::MemDeltaFlow
setMethod('copyToR', '_p_infomap::MemDeltaFlow', CopyToR_infomap__MemDeltaFlow);
setMethod('copyToC', 'infomap::MemDeltaFlow', CopyToC_infomap__MemDeltaFlow);

# End definition of copy methods for infomap::MemDeltaFlow
# End definition of copy functions & methods for infomap::MemDeltaFlow
# Start of new_PhysData

`PhysData__SWIG_0` = function(physNodeIndex, sumFlowFromM2Node)
{
  physNodeIndex = as.integer(physNodeIndex);
  
  if(length(physNodeIndex) > 1) {
    warning("using only the first element of physNodeIndex");
  };
  
  
  ;ans = .Call('R_swig_new_PhysData__SWIG_0', physNodeIndex, sumFlowFromM2Node, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__PhysData", ref=ans);
  
  reg.finalizer(ans@ref, delete_PhysData);
  ans
  
}

attr(`PhysData__SWIG_0`, 'returnType') = '_p_infomap__PhysData'
attr(`PhysData__SWIG_0`, "inputTypes") = c('integer', 'numeric')
class(`PhysData__SWIG_0`) = c("SWIGFunction", class('PhysData__SWIG_0'))

# Start of new_PhysData

`PhysData__SWIG_1` = function(physNodeIndex)
{
  physNodeIndex = as.integer(physNodeIndex);
  
  if(length(physNodeIndex) > 1) {
    warning("using only the first element of physNodeIndex");
  };
  
  ;ans = .Call('R_swig_new_PhysData__SWIG_1', physNodeIndex, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__PhysData", ref=ans);
  
  reg.finalizer(ans@ref, delete_PhysData);
  ans
  
}

attr(`PhysData__SWIG_1`, 'returnType') = '_p_infomap__PhysData'
attr(`PhysData__SWIG_1`, "inputTypes") = c('integer')
class(`PhysData__SWIG_1`) = c("SWIGFunction", class('PhysData__SWIG_1'))

# Start of new_PhysData

`PhysData__SWIG_2` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_new_PhysData__SWIG_2', other, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__PhysData", ref=ans);
  
  reg.finalizer(ans@ref, delete_PhysData);
  ans
  
}

attr(`PhysData__SWIG_2`, 'returnType') = '_p_infomap__PhysData'
attr(`PhysData__SWIG_2`, "inputTypes") = c('_p_infomap__PhysData')
class(`PhysData__SWIG_2`) = c("SWIGFunction", class('PhysData__SWIG_2'))

`PhysData` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 1) {
    if (extends(argtypes[1], '_p_infomap__PhysData') && length(argv[[1]]) == 1) {
      f <- PhysData__SWIG_2; 
    }
    else if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- PhysData__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- PhysData__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for PhysData with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of PhysData_physNodeIndex_set

`PhysData_physNodeIndex_set` = function(self, s_physNodeIndex)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_physNodeIndex = as.integer(s_physNodeIndex);
  
  if(length(s_physNodeIndex) > 1) {
    warning("using only the first element of s_physNodeIndex");
  };
  
  ;.Call('R_swig_PhysData_physNodeIndex_set', self, s_physNodeIndex, PACKAGE='infomap');
  
}

attr(`PhysData_physNodeIndex_set`, 'returnType') = 'void'
attr(`PhysData_physNodeIndex_set`, "inputTypes") = c('_p_infomap__PhysData', 'integer')
class(`PhysData_physNodeIndex_set`) = c("SWIGFunction", class('PhysData_physNodeIndex_set'))

# Start of PhysData_physNodeIndex_get

`PhysData_physNodeIndex_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_PhysData_physNodeIndex_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`PhysData_physNodeIndex_get`, 'returnType') = 'integer'
attr(`PhysData_physNodeIndex_get`, "inputTypes") = c('_p_infomap__PhysData')
class(`PhysData_physNodeIndex_get`) = c("SWIGFunction", class('PhysData_physNodeIndex_get'))

# Start of PhysData_sumFlowFromM2Node_set

`PhysData_sumFlowFromM2Node_set` = function(self, s_sumFlowFromM2Node)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_PhysData_sumFlowFromM2Node_set', self, s_sumFlowFromM2Node, PACKAGE='infomap');
  
}

attr(`PhysData_sumFlowFromM2Node_set`, 'returnType') = 'void'
attr(`PhysData_sumFlowFromM2Node_set`, "inputTypes") = c('_p_infomap__PhysData', 'numeric')
class(`PhysData_sumFlowFromM2Node_set`) = c("SWIGFunction", class('PhysData_sumFlowFromM2Node_set'))

# Start of PhysData_sumFlowFromM2Node_get

`PhysData_sumFlowFromM2Node_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_PhysData_sumFlowFromM2Node_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`PhysData_sumFlowFromM2Node_get`, 'returnType') = 'numeric'
attr(`PhysData_sumFlowFromM2Node_get`, "inputTypes") = c('_p_infomap__PhysData')
class(`PhysData_sumFlowFromM2Node_get`) = c("SWIGFunction", class('PhysData_sumFlowFromM2Node_get'))

# Start of delete_PhysData

`delete_PhysData` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_PhysData', self, PACKAGE='infomap');
  
}

attr(`delete_PhysData`, 'returnType') = 'void'
attr(`delete_PhysData`, "inputTypes") = c('_p_infomap__PhysData')
class(`delete_PhysData`) = c("SWIGFunction", class('delete_PhysData'))

# Start of accessor method for infomap::PhysData
setMethod('$', '_p_infomap__PhysData', function(x, name)

{
  accessorFuns = list('physNodeIndex' = PhysData_physNodeIndex_get, 'sumFlowFromM2Node' = PhysData_sumFlowFromM2Node_get);
  vaccessors = c('physNodeIndex', 'sumFlowFromM2Node');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for infomap::PhysData
# Start of accessor method for infomap::PhysData
setMethod('$<-', '_p_infomap__PhysData', function(x, name, value)

{
  accessorFuns = list('physNodeIndex' = PhysData_physNodeIndex_set, 'sumFlowFromM2Node' = PhysData_sumFlowFromM2Node_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_infomap__PhysData', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('physNodeIndex' = PhysData_physNodeIndex_set, 'sumFlowFromM2Node' = PhysData_sumFlowFromM2Node_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for infomap::PhysData
setMethod('delete', '_p_infomap__PhysData', function(obj) {delete_infomap__PhysData(obj)})
# Start definition of copy functions & methods for infomap::PhysData
CopyToR_infomap__PhysData = function(value, obj = new("infomap::PhysData"))
{
  obj@physNodeIndex = value$physNodeIndex;
  obj@sumFlowFromM2Node = value$sumFlowFromM2Node;
  obj;
}



CopyToC_infomap__PhysData = function(value, obj)
{
  obj$physNodeIndex = value@physNodeIndex;
  obj$sumFlowFromM2Node = value@sumFlowFromM2Node;
  obj
}



# Start definition of copy methods for infomap::PhysData
setMethod('copyToR', '_p_infomap::PhysData', CopyToR_infomap__PhysData);
setMethod('copyToC', 'infomap::PhysData', CopyToC_infomap__PhysData);

# End definition of copy methods for infomap::PhysData
# End definition of copy functions & methods for infomap::PhysData
# Start of vector_uint___nonzero__

`vector_uint___nonzero__` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_vector_uint___nonzero__', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`vector_uint___nonzero__`, 'returnType') = 'logical'
attr(`vector_uint___nonzero__`, "inputTypes") = c('integer')
class(`vector_uint___nonzero__`) = c("SWIGFunction", class('vector_uint___nonzero__'))

# Start of vector_uint___len__

`vector_uint___len__` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_vector_uint___len__', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`vector_uint___len__`, 'returnType') = 'integer'
attr(`vector_uint___len__`, "inputTypes") = c('integer')
class(`vector_uint___len__`) = c("SWIGFunction", class('vector_uint___len__'))

# Start of vector_uint_pop

`vector_uint_pop` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_vector_uint_pop', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`vector_uint_pop`, 'returnType') = 'integer'
attr(`vector_uint_pop`, "inputTypes") = c('integer')
class(`vector_uint_pop`) = c("SWIGFunction", class('vector_uint_pop'))

# Start of vector_uint___getslice__

`vector_uint___getslice__` = function(self, i, j)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_vector_uint___getslice__', self, i, j, PACKAGE='infomap');
  
}

attr(`vector_uint___getslice__`, 'returnType') = 'integer'
attr(`vector_uint___getslice__`, "inputTypes") = c('integer', 'integer', 'integer')
class(`vector_uint___getslice__`) = c("SWIGFunction", class('vector_uint___getslice__'))

# Start of vector_uint___setslice__

`vector_uint___setslice__` = function(self, i, j, v)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  v = as.integer(v);
  ;.Call('R_swig_vector_uint___setslice__', self, i, j, v, PACKAGE='infomap');
  
}

attr(`vector_uint___setslice__`, 'returnType') = 'void'
attr(`vector_uint___setslice__`, "inputTypes") = c('integer', 'integer', 'integer', 'integer')
class(`vector_uint___setslice__`) = c("SWIGFunction", class('vector_uint___setslice__'))

# Start of vector_uint___delslice__

`vector_uint___delslice__` = function(self, i, j)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_vector_uint___delslice__', self, i, j, PACKAGE='infomap');
  
}

attr(`vector_uint___delslice__`, 'returnType') = 'void'
attr(`vector_uint___delslice__`, "inputTypes") = c('integer', 'integer', 'integer')
class(`vector_uint___delslice__`) = c("SWIGFunction", class('vector_uint___delslice__'))

# Start of vector_uint___delitem__

`vector_uint___delitem__` = function(self, i)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_vector_uint___delitem__', self, i, PACKAGE='infomap');
  
}

attr(`vector_uint___delitem__`, 'returnType') = 'void'
attr(`vector_uint___delitem__`, "inputTypes") = c('integer', 'integer')
class(`vector_uint___delitem__`) = c("SWIGFunction", class('vector_uint___delitem__'))

# Start of vector_uint___getitem__

`vector_uint___getitem__` = function(self, i, .copy = FALSE)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_vector_uint___getitem__', self, i, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`vector_uint___getitem__`, 'returnType') = '_p_unsigned_int'
attr(`vector_uint___getitem__`, "inputTypes") = c('integer', 'integer')
class(`vector_uint___getitem__`) = c("SWIGFunction", class('vector_uint___getitem__'))

# Start of vector_uint___setitem__

`vector_uint___setitem__` = function(self, i, x)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_vector_uint___setitem__', self, i, x, PACKAGE='infomap');
  
}

attr(`vector_uint___setitem__`, 'returnType') = 'void'
attr(`vector_uint___setitem__`, "inputTypes") = c('integer', 'integer', '_p_unsigned_int')
class(`vector_uint___setitem__`) = c("SWIGFunction", class('vector_uint___setitem__'))

# Start of vector_uint_append

`vector_uint_append` = function(self, x)
{
  self = as.integer(self);
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_vector_uint_append', self, x, PACKAGE='infomap');
  
}

attr(`vector_uint_append`, 'returnType') = 'void'
attr(`vector_uint_append`, "inputTypes") = c('integer', '_p_unsigned_int')
class(`vector_uint_append`) = c("SWIGFunction", class('vector_uint_append'))

# Start of new_vector_uint

`vector_uint__SWIG_0` = function()
{
  ;.Call('R_swig_new_vector_uint__SWIG_0', PACKAGE='infomap');
  
}

attr(`vector_uint__SWIG_0`, 'returnType') = 'integer'
class(`vector_uint__SWIG_0`) = c("SWIGFunction", class('vector_uint__SWIG_0'))

# Start of new_vector_uint

`vector_uint__SWIG_1` = function(other)
{
  other = as.integer(other);
  ;.Call('R_swig_new_vector_uint__SWIG_1', other, PACKAGE='infomap');
  
}

attr(`vector_uint__SWIG_1`, 'returnType') = 'integer'
attr(`vector_uint__SWIG_1`, "inputTypes") = c('integer')
class(`vector_uint__SWIG_1`) = c("SWIGFunction", class('vector_uint__SWIG_1'))

# Start of vector_uint_empty

`vector_uint_empty` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_vector_uint_empty', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`vector_uint_empty`, 'returnType') = 'logical'
attr(`vector_uint_empty`, "inputTypes") = c('integer')
class(`vector_uint_empty`) = c("SWIGFunction", class('vector_uint_empty'))

# Start of vector_uint_size

`vector_uint_size` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_vector_uint_size', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`vector_uint_size`, 'returnType') = 'integer'
attr(`vector_uint_size`, "inputTypes") = c('integer')
class(`vector_uint_size`) = c("SWIGFunction", class('vector_uint_size'))

# Start of vector_uint_swap

`vector_uint_swap` = function(self, v)
{
  self = as.integer(self);
  v = as.integer(v);
  ;.Call('R_swig_vector_uint_swap', self, v, PACKAGE='infomap');
  
}

attr(`vector_uint_swap`, 'returnType') = 'void'
attr(`vector_uint_swap`, "inputTypes") = c('integer', 'integer')
class(`vector_uint_swap`) = c("SWIGFunction", class('vector_uint_swap'))

# Start of vector_uint_clear

`vector_uint_clear` = function(self)
{
  self = as.integer(self);
  ;.Call('R_swig_vector_uint_clear', self, PACKAGE='infomap');
  
}

attr(`vector_uint_clear`, 'returnType') = 'void'
attr(`vector_uint_clear`, "inputTypes") = c('integer')
class(`vector_uint_clear`) = c("SWIGFunction", class('vector_uint_clear'))

# Start of vector_uint_get_allocator

`vector_uint_get_allocator` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;ans = .Call('R_swig_vector_uint_get_allocator', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_unsigned_int_t", ref=ans);
  
  ans
  
}

attr(`vector_uint_get_allocator`, 'returnType') = '_p_std__allocatorT_unsigned_int_t'
attr(`vector_uint_get_allocator`, "inputTypes") = c('integer')
class(`vector_uint_get_allocator`) = c("SWIGFunction", class('vector_uint_get_allocator'))

# Start of new_vector_uint

`vector_uint__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;.Call('R_swig_new_vector_uint__SWIG_2', size, PACKAGE='infomap');
  
}

attr(`vector_uint__SWIG_2`, 'returnType') = 'integer'
attr(`vector_uint__SWIG_2`, "inputTypes") = c('integer')
class(`vector_uint__SWIG_2`) = c("SWIGFunction", class('vector_uint__SWIG_2'))

# Start of vector_uint_pop_back

`vector_uint_pop_back` = function(self)
{
  self = as.integer(self);
  ;.Call('R_swig_vector_uint_pop_back', self, PACKAGE='infomap');
  
}

attr(`vector_uint_pop_back`, 'returnType') = 'void'
attr(`vector_uint_pop_back`, "inputTypes") = c('integer')
class(`vector_uint_pop_back`) = c("SWIGFunction", class('vector_uint_pop_back'))

# Start of vector_uint_resize

`vector_uint_resize__SWIG_0` = function(self, new_size)
{
  self = as.integer(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_vector_uint_resize__SWIG_0', self, new_size, PACKAGE='infomap');
  
}

attr(`vector_uint_resize__SWIG_0`, 'returnType') = 'void'
attr(`vector_uint_resize__SWIG_0`, "inputTypes") = c('integer', 'integer')
class(`vector_uint_resize__SWIG_0`) = c("SWIGFunction", class('vector_uint_resize__SWIG_0'))

# Start of new_vector_uint

`vector_uint__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  if (inherits(value, "ExternalReference")) value = slot(value,"ref"); 
  ;.Call('R_swig_new_vector_uint__SWIG_3', size, value, PACKAGE='infomap');
  
}

attr(`vector_uint__SWIG_3`, 'returnType') = 'integer'
attr(`vector_uint__SWIG_3`, "inputTypes") = c('integer', '_p_unsigned_int')
class(`vector_uint__SWIG_3`) = c("SWIGFunction", class('vector_uint__SWIG_3'))

`vector_uint` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- vector_uint__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- vector_uint__SWIG_2; 
    }
    else if (( is.integer(argv[[1]]) || is.numeric(argv[[1]]) )) {
      f <- vector_uint__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && extends(argtypes[2], '_p_unsigned_int') && length(argv[[2]]) == 1) {
      f <- vector_uint__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for vector_uint with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of vector_uint_push_back

`vector_uint_push_back` = function(self, x)
{
  self = as.integer(self);
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_vector_uint_push_back', self, x, PACKAGE='infomap');
  
}

attr(`vector_uint_push_back`, 'returnType') = 'void'
attr(`vector_uint_push_back`, "inputTypes") = c('integer', '_p_unsigned_int')
class(`vector_uint_push_back`) = c("SWIGFunction", class('vector_uint_push_back'))

# Start of vector_uint_front

`vector_uint_front` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_vector_uint_front', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`vector_uint_front`, 'returnType') = '_p_unsigned_int'
attr(`vector_uint_front`, "inputTypes") = c('integer')
class(`vector_uint_front`) = c("SWIGFunction", class('vector_uint_front'))

# Start of vector_uint_back

`vector_uint_back` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_vector_uint_back', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`vector_uint_back`, 'returnType') = '_p_unsigned_int'
attr(`vector_uint_back`, "inputTypes") = c('integer')
class(`vector_uint_back`) = c("SWIGFunction", class('vector_uint_back'))

# Start of vector_uint_assign

`vector_uint_assign` = function(self, n, x)
{
  self = as.integer(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_vector_uint_assign', self, n, x, PACKAGE='infomap');
  
}

attr(`vector_uint_assign`, 'returnType') = 'void'
attr(`vector_uint_assign`, "inputTypes") = c('integer', 'integer', '_p_unsigned_int')
class(`vector_uint_assign`) = c("SWIGFunction", class('vector_uint_assign'))

# Start of vector_uint_resize

`vector_uint_resize__SWIG_1` = function(self, new_size, x)
{
  self = as.integer(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_vector_uint_resize__SWIG_1', self, new_size, x, PACKAGE='infomap');
  
}

attr(`vector_uint_resize__SWIG_1`, 'returnType') = 'void'
attr(`vector_uint_resize__SWIG_1`, "inputTypes") = c('integer', 'integer', '_p_unsigned_int')
class(`vector_uint_resize__SWIG_1`) = c("SWIGFunction", class('vector_uint_resize__SWIG_1'))

`vector_uint_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (( is.integer(argv[[1]]) || is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- vector_uint_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (( is.integer(argv[[1]]) || is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && extends(argtypes[3], '_p_unsigned_int') && length(argv[[3]]) == 1) {
      f <- vector_uint_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for vector_uint_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of vector_uint_reserve

`vector_uint_reserve` = function(self, n)
{
  self = as.integer(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_vector_uint_reserve', self, n, PACKAGE='infomap');
  
}

attr(`vector_uint_reserve`, 'returnType') = 'void'
attr(`vector_uint_reserve`, "inputTypes") = c('integer', 'integer')
class(`vector_uint_reserve`) = c("SWIGFunction", class('vector_uint_reserve'))

# Start of vector_uint_capacity

`vector_uint_capacity` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_vector_uint_capacity', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`vector_uint_capacity`, 'returnType') = 'integer'
attr(`vector_uint_capacity`, "inputTypes") = c('integer')
class(`vector_uint_capacity`) = c("SWIGFunction", class('vector_uint_capacity'))

# Start of delete_vector_uint

`delete_vector_uint` = function(self)
{
  self = as.integer(self);
  ;.Call('R_swig_delete_vector_uint', self, PACKAGE='infomap');
  
}

attr(`delete_vector_uint`, 'returnType') = 'void'
attr(`delete_vector_uint`, "inputTypes") = c('integer')
class(`delete_vector_uint`) = c("SWIGFunction", class('delete_vector_uint'))

# Start of accessor method for std::vector< unsigned int >
setMethod('$', '_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = vector_uint___nonzero__, '__len__' = vector_uint___len__, 'pop' = vector_uint_pop, '__getslice__' = vector_uint___getslice__, '__setslice__' = vector_uint___setslice__, '__delslice__' = vector_uint___delslice__, '__delitem__' = vector_uint___delitem__, '__getitem__' = vector_uint___getitem__, '__setitem__' = vector_uint___setitem__, 'append' = vector_uint_append, 'empty' = vector_uint_empty, 'size' = vector_uint_size, 'swap' = vector_uint_swap, 'clear' = vector_uint_clear, 'get_allocator' = vector_uint_get_allocator, 'pop_back' = vector_uint_pop_back, 'resize' = vector_uint_resize, 'push_back' = vector_uint_push_back, 'front' = vector_uint_front, 'back' = vector_uint_back, 'assign' = vector_uint_assign, 'reserve' = vector_uint_reserve, 'capacity' = vector_uint_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector< unsigned int >
setMethod('delete', '_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t', function(obj) {delete_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t(obj)})
# Start of InfoNode_data_set

`InfoNode_data_set` = function(self, s_data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_data, "ExternalReference")) s_data = slot(s_data,"ref"); 
  ;.Call('R_swig_InfoNode_data_set', self, s_data, PACKAGE='infomap');
  
}

attr(`InfoNode_data_set`, 'returnType') = 'void'
attr(`InfoNode_data_set`, "inputTypes") = c('_p_infomap__InfoNode', '_p_infomap__FlowData')
class(`InfoNode_data_set`) = c("SWIGFunction", class('InfoNode_data_set'))

# Start of InfoNode_data_get

`InfoNode_data_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_data_get', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__FlowData", ref=ans);
  
  ans
  
}

attr(`InfoNode_data_get`, 'returnType') = '_p_infomap__FlowData'
attr(`InfoNode_data_get`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_data_get`) = c("SWIGFunction", class('InfoNode_data_get'))

# Start of InfoNode_index_set

`InfoNode_index_set` = function(self, s_index)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_index = as.integer(s_index);
  
  if(length(s_index) > 1) {
    warning("using only the first element of s_index");
  };
  
  ;.Call('R_swig_InfoNode_index_set', self, s_index, PACKAGE='infomap');
  
}

attr(`InfoNode_index_set`, 'returnType') = 'void'
attr(`InfoNode_index_set`, "inputTypes") = c('_p_infomap__InfoNode', 'integer')
class(`InfoNode_index_set`) = c("SWIGFunction", class('InfoNode_index_set'))

# Start of InfoNode_index_get

`InfoNode_index_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_index_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfoNode_index_get`, 'returnType') = 'integer'
attr(`InfoNode_index_get`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_index_get`) = c("SWIGFunction", class('InfoNode_index_get'))

# Start of InfoNode_stateId_set

`InfoNode_stateId_set` = function(self, s_stateId)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_stateId = as.integer(s_stateId);
  
  if(length(s_stateId) > 1) {
    warning("using only the first element of s_stateId");
  };
  
  ;.Call('R_swig_InfoNode_stateId_set', self, s_stateId, PACKAGE='infomap');
  
}

attr(`InfoNode_stateId_set`, 'returnType') = 'void'
attr(`InfoNode_stateId_set`, "inputTypes") = c('_p_infomap__InfoNode', 'integer')
class(`InfoNode_stateId_set`) = c("SWIGFunction", class('InfoNode_stateId_set'))

# Start of InfoNode_stateId_get

`InfoNode_stateId_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_stateId_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfoNode_stateId_get`, 'returnType') = 'integer'
attr(`InfoNode_stateId_get`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_stateId_get`) = c("SWIGFunction", class('InfoNode_stateId_get'))

# Start of InfoNode_physicalId_set

`InfoNode_physicalId_set` = function(self, s_physicalId)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_physicalId = as.integer(s_physicalId);
  
  if(length(s_physicalId) > 1) {
    warning("using only the first element of s_physicalId");
  };
  
  ;.Call('R_swig_InfoNode_physicalId_set', self, s_physicalId, PACKAGE='infomap');
  
}

attr(`InfoNode_physicalId_set`, 'returnType') = 'void'
attr(`InfoNode_physicalId_set`, "inputTypes") = c('_p_infomap__InfoNode', 'integer')
class(`InfoNode_physicalId_set`) = c("SWIGFunction", class('InfoNode_physicalId_set'))

# Start of InfoNode_physicalId_get

`InfoNode_physicalId_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_physicalId_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfoNode_physicalId_get`, 'returnType') = 'integer'
attr(`InfoNode_physicalId_get`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_physicalId_get`) = c("SWIGFunction", class('InfoNode_physicalId_get'))

# Start of InfoNode_layerId_set

`InfoNode_layerId_set` = function(self, s_layerId)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_layerId = as.integer(s_layerId);
  
  if(length(s_layerId) > 1) {
    warning("using only the first element of s_layerId");
  };
  
  ;.Call('R_swig_InfoNode_layerId_set', self, s_layerId, PACKAGE='infomap');
  
}

attr(`InfoNode_layerId_set`, 'returnType') = 'void'
attr(`InfoNode_layerId_set`, "inputTypes") = c('_p_infomap__InfoNode', 'integer')
class(`InfoNode_layerId_set`) = c("SWIGFunction", class('InfoNode_layerId_set'))

# Start of InfoNode_layerId_get

`InfoNode_layerId_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_layerId_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfoNode_layerId_get`, 'returnType') = 'integer'
attr(`InfoNode_layerId_get`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_layerId_get`) = c("SWIGFunction", class('InfoNode_layerId_get'))

# Start of InfoNode_metaData_set

`InfoNode_metaData_set` = function(self, s_metaData)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_metaData = as.integer(s_metaData);
  ;.Call('R_swig_InfoNode_metaData_set', self, s_metaData, PACKAGE='infomap');
  
}

attr(`InfoNode_metaData_set`, 'returnType') = 'void'
attr(`InfoNode_metaData_set`, "inputTypes") = c('_p_infomap__InfoNode', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`InfoNode_metaData_set`) = c("SWIGFunction", class('InfoNode_metaData_set'))

# Start of InfoNode_metaData_get

`InfoNode_metaData_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_metaData_get', self, PACKAGE='infomap');
  
}

attr(`InfoNode_metaData_get`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`InfoNode_metaData_get`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_metaData_get`) = c("SWIGFunction", class('InfoNode_metaData_get'))

# Start of InfoNode_owner_set

`InfoNode_owner_set` = function(self, s_owner)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_owner, "ExternalReference")) s_owner = slot(s_owner,"ref"); 
  ;.Call('R_swig_InfoNode_owner_set', self, s_owner, PACKAGE='infomap');
  
}

attr(`InfoNode_owner_set`, 'returnType') = 'void'
attr(`InfoNode_owner_set`, "inputTypes") = c('_p_infomap__InfoNode', '_p_infomap__InfoNode')
class(`InfoNode_owner_set`) = c("SWIGFunction", class('InfoNode_owner_set'))

# Start of InfoNode_owner_get

`InfoNode_owner_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_owner_get', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfoNode_owner_get`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfoNode_owner_get`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_owner_get`) = c("SWIGFunction", class('InfoNode_owner_get'))

# Start of InfoNode_parent_set

`InfoNode_parent_set` = function(self, s_parent)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_parent, "ExternalReference")) s_parent = slot(s_parent,"ref"); 
  ;.Call('R_swig_InfoNode_parent_set', self, s_parent, PACKAGE='infomap');
  
}

attr(`InfoNode_parent_set`, 'returnType') = 'void'
attr(`InfoNode_parent_set`, "inputTypes") = c('_p_infomap__InfoNode', '_p_infomap__InfoNode')
class(`InfoNode_parent_set`) = c("SWIGFunction", class('InfoNode_parent_set'))

# Start of InfoNode_parent_get

`InfoNode_parent_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_parent_get', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfoNode_parent_get`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfoNode_parent_get`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_parent_get`) = c("SWIGFunction", class('InfoNode_parent_get'))

# Start of InfoNode_previous_set

`InfoNode_previous_set` = function(self, s_previous)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_previous, "ExternalReference")) s_previous = slot(s_previous,"ref"); 
  ;.Call('R_swig_InfoNode_previous_set', self, s_previous, PACKAGE='infomap');
  
}

attr(`InfoNode_previous_set`, 'returnType') = 'void'
attr(`InfoNode_previous_set`, "inputTypes") = c('_p_infomap__InfoNode', '_p_infomap__InfoNode')
class(`InfoNode_previous_set`) = c("SWIGFunction", class('InfoNode_previous_set'))

# Start of InfoNode_previous_get

`InfoNode_previous_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_previous_get', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfoNode_previous_get`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfoNode_previous_get`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_previous_get`) = c("SWIGFunction", class('InfoNode_previous_get'))

# Start of InfoNode__next_set

`InfoNode__next_set` = function(self, s_arg2)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref"); 
  ;.Call('R_swig_InfoNode__next_set', self, s_arg2, PACKAGE='infomap');
  
}

attr(`InfoNode__next_set`, 'returnType') = 'void'
attr(`InfoNode__next_set`, "inputTypes") = c('_p_infomap__InfoNode', '_p_infomap__InfoNode')
class(`InfoNode__next_set`) = c("SWIGFunction", class('InfoNode__next_set'))

# Start of InfoNode__next_get

`InfoNode__next_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode__next_get', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfoNode__next_get`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfoNode__next_get`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode__next_get`) = c("SWIGFunction", class('InfoNode__next_get'))

# Start of InfoNode_firstChild_set

`InfoNode_firstChild_set` = function(self, s_firstChild)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_firstChild, "ExternalReference")) s_firstChild = slot(s_firstChild,"ref"); 
  ;.Call('R_swig_InfoNode_firstChild_set', self, s_firstChild, PACKAGE='infomap');
  
}

attr(`InfoNode_firstChild_set`, 'returnType') = 'void'
attr(`InfoNode_firstChild_set`, "inputTypes") = c('_p_infomap__InfoNode', '_p_infomap__InfoNode')
class(`InfoNode_firstChild_set`) = c("SWIGFunction", class('InfoNode_firstChild_set'))

# Start of InfoNode_firstChild_get

`InfoNode_firstChild_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_firstChild_get', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfoNode_firstChild_get`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfoNode_firstChild_get`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_firstChild_get`) = c("SWIGFunction", class('InfoNode_firstChild_get'))

# Start of InfoNode_lastChild_set

`InfoNode_lastChild_set` = function(self, s_lastChild)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_lastChild, "ExternalReference")) s_lastChild = slot(s_lastChild,"ref"); 
  ;.Call('R_swig_InfoNode_lastChild_set', self, s_lastChild, PACKAGE='infomap');
  
}

attr(`InfoNode_lastChild_set`, 'returnType') = 'void'
attr(`InfoNode_lastChild_set`, "inputTypes") = c('_p_infomap__InfoNode', '_p_infomap__InfoNode')
class(`InfoNode_lastChild_set`) = c("SWIGFunction", class('InfoNode_lastChild_set'))

# Start of InfoNode_lastChild_get

`InfoNode_lastChild_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_lastChild_get', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfoNode_lastChild_get`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfoNode_lastChild_get`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_lastChild_get`) = c("SWIGFunction", class('InfoNode_lastChild_get'))

# Start of InfoNode_collapsedFirstChild_set

`InfoNode_collapsedFirstChild_set` = function(self, s_collapsedFirstChild)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_collapsedFirstChild, "ExternalReference")) s_collapsedFirstChild = slot(s_collapsedFirstChild,"ref"); 
  ;.Call('R_swig_InfoNode_collapsedFirstChild_set', self, s_collapsedFirstChild, PACKAGE='infomap');
  
}

attr(`InfoNode_collapsedFirstChild_set`, 'returnType') = 'void'
attr(`InfoNode_collapsedFirstChild_set`, "inputTypes") = c('_p_infomap__InfoNode', '_p_infomap__InfoNode')
class(`InfoNode_collapsedFirstChild_set`) = c("SWIGFunction", class('InfoNode_collapsedFirstChild_set'))

# Start of InfoNode_collapsedFirstChild_get

`InfoNode_collapsedFirstChild_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_collapsedFirstChild_get', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfoNode_collapsedFirstChild_get`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfoNode_collapsedFirstChild_get`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_collapsedFirstChild_get`) = c("SWIGFunction", class('InfoNode_collapsedFirstChild_get'))

# Start of InfoNode_collapsedLastChild_set

`InfoNode_collapsedLastChild_set` = function(self, s_collapsedLastChild)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_collapsedLastChild, "ExternalReference")) s_collapsedLastChild = slot(s_collapsedLastChild,"ref"); 
  ;.Call('R_swig_InfoNode_collapsedLastChild_set', self, s_collapsedLastChild, PACKAGE='infomap');
  
}

attr(`InfoNode_collapsedLastChild_set`, 'returnType') = 'void'
attr(`InfoNode_collapsedLastChild_set`, "inputTypes") = c('_p_infomap__InfoNode', '_p_infomap__InfoNode')
class(`InfoNode_collapsedLastChild_set`) = c("SWIGFunction", class('InfoNode_collapsedLastChild_set'))

# Start of InfoNode_collapsedLastChild_get

`InfoNode_collapsedLastChild_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_collapsedLastChild_get', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfoNode_collapsedLastChild_get`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfoNode_collapsedLastChild_get`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_collapsedLastChild_get`) = c("SWIGFunction", class('InfoNode_collapsedLastChild_get'))

# Start of InfoNode_codelength_set

`InfoNode_codelength_set` = function(self, s_codelength)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_InfoNode_codelength_set', self, s_codelength, PACKAGE='infomap');
  
}

attr(`InfoNode_codelength_set`, 'returnType') = 'void'
attr(`InfoNode_codelength_set`, "inputTypes") = c('_p_infomap__InfoNode', 'numeric')
class(`InfoNode_codelength_set`) = c("SWIGFunction", class('InfoNode_codelength_set'))

# Start of InfoNode_codelength_get

`InfoNode_codelength_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_codelength_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfoNode_codelength_get`, 'returnType') = 'numeric'
attr(`InfoNode_codelength_get`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_codelength_get`) = c("SWIGFunction", class('InfoNode_codelength_get'))

# Start of InfoNode_dirty_set

`InfoNode_dirty_set` = function(self, s_dirty)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_dirty = as.logical(s_dirty);
  ;.Call('R_swig_InfoNode_dirty_set', self, s_dirty, PACKAGE='infomap');
  
}

attr(`InfoNode_dirty_set`, 'returnType') = 'void'
attr(`InfoNode_dirty_set`, "inputTypes") = c('_p_infomap__InfoNode', 'logical')
class(`InfoNode_dirty_set`) = c("SWIGFunction", class('InfoNode_dirty_set'))

# Start of InfoNode_dirty_get

`InfoNode_dirty_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_dirty_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfoNode_dirty_get`, 'returnType') = 'logical'
attr(`InfoNode_dirty_get`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_dirty_get`) = c("SWIGFunction", class('InfoNode_dirty_get'))

# Start of InfoNode_physicalNodes_set

`InfoNode_physicalNodes_set` = function(self, s_physicalNodes)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_physicalNodes, "ExternalReference")) s_physicalNodes = slot(s_physicalNodes,"ref"); 
  ;.Call('R_swig_InfoNode_physicalNodes_set', self, s_physicalNodes, PACKAGE='infomap');
  
}

attr(`InfoNode_physicalNodes_set`, 'returnType') = 'void'
attr(`InfoNode_physicalNodes_set`, "inputTypes") = c('_p_infomap__InfoNode', '_p_std__vectorT_infomap__PhysData_std__allocatorT_infomap__PhysData_t_t')
class(`InfoNode_physicalNodes_set`) = c("SWIGFunction", class('InfoNode_physicalNodes_set'))

# Start of InfoNode_physicalNodes_get

`InfoNode_physicalNodes_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_physicalNodes_get', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_infomap__PhysData_std__allocatorT_infomap__PhysData_t_t", ref=ans);
  
  ans
  
}

attr(`InfoNode_physicalNodes_get`, 'returnType') = '_p_std__vectorT_infomap__PhysData_std__allocatorT_infomap__PhysData_t_t'
attr(`InfoNode_physicalNodes_get`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_physicalNodes_get`) = c("SWIGFunction", class('InfoNode_physicalNodes_get'))

# Start of InfoNode_metaCollection_set

`InfoNode_metaCollection_set` = function(self, s_metaCollection)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_metaCollection, "ExternalReference")) s_metaCollection = slot(s_metaCollection,"ref"); 
  ;.Call('R_swig_InfoNode_metaCollection_set', self, s_metaCollection, PACKAGE='infomap');
  
}

attr(`InfoNode_metaCollection_set`, 'returnType') = 'void'
attr(`InfoNode_metaCollection_set`, "inputTypes") = c('_p_infomap__InfoNode', '_p_MetaCollection')
class(`InfoNode_metaCollection_set`) = c("SWIGFunction", class('InfoNode_metaCollection_set'))

# Start of InfoNode_metaCollection_get

`InfoNode_metaCollection_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_metaCollection_get', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_MetaCollection", ref=ans);
  
  ans
  
}

attr(`InfoNode_metaCollection_get`, 'returnType') = '_p_MetaCollection'
attr(`InfoNode_metaCollection_get`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_metaCollection_get`) = c("SWIGFunction", class('InfoNode_metaCollection_get'))

# Start of InfoNode_stateNodes_set

`InfoNode_stateNodes_set` = function(self, s_stateNodes)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_stateNodes = as.integer(s_stateNodes);
  ;.Call('R_swig_InfoNode_stateNodes_set', self, s_stateNodes, PACKAGE='infomap');
  
}

attr(`InfoNode_stateNodes_set`, 'returnType') = 'void'
attr(`InfoNode_stateNodes_set`, "inputTypes") = c('_p_infomap__InfoNode', 'integer')
class(`InfoNode_stateNodes_set`) = c("SWIGFunction", class('InfoNode_stateNodes_set'))

# Start of InfoNode_stateNodes_get

`InfoNode_stateNodes_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_stateNodes_get', self, PACKAGE='infomap');
  
}

attr(`InfoNode_stateNodes_get`, 'returnType') = 'integer'
attr(`InfoNode_stateNodes_get`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_stateNodes_get`) = c("SWIGFunction", class('InfoNode_stateNodes_get'))

# Start of new_InfoNode

`InfoNode__SWIG_0` = function(flowData)
{
  if (inherits(flowData, "ExternalReference")) flowData = slot(flowData,"ref"); 
  ;ans = .Call('R_swig_new_InfoNode__SWIG_0', flowData, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfoNode);
  ans
  
}

attr(`InfoNode__SWIG_0`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfoNode__SWIG_0`, "inputTypes") = c('_p_infomap__FlowData')
class(`InfoNode__SWIG_0`) = c("SWIGFunction", class('InfoNode__SWIG_0'))

# Start of new_InfoNode

`InfoNode__SWIG_1` = function(flowData, stateId)
{
  if (inherits(flowData, "ExternalReference")) flowData = slot(flowData,"ref"); 
  stateId = as.integer(stateId);
  
  if(length(stateId) > 1) {
    warning("using only the first element of stateId");
  };
  
  ;ans = .Call('R_swig_new_InfoNode__SWIG_1', flowData, stateId, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfoNode);
  ans
  
}

attr(`InfoNode__SWIG_1`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfoNode__SWIG_1`, "inputTypes") = c('_p_infomap__FlowData', 'integer')
class(`InfoNode__SWIG_1`) = c("SWIGFunction", class('InfoNode__SWIG_1'))

# Start of new_InfoNode

`InfoNode__SWIG_2` = function(flowData, stateId, physicalId)
{
  if (inherits(flowData, "ExternalReference")) flowData = slot(flowData,"ref"); 
  stateId = as.integer(stateId);
  
  if(length(stateId) > 1) {
    warning("using only the first element of stateId");
  };
  
  physicalId = as.integer(physicalId);
  
  if(length(physicalId) > 1) {
    warning("using only the first element of physicalId");
  };
  
  ;ans = .Call('R_swig_new_InfoNode__SWIG_2', flowData, stateId, physicalId, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfoNode);
  ans
  
}

attr(`InfoNode__SWIG_2`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfoNode__SWIG_2`, "inputTypes") = c('_p_infomap__FlowData', 'integer', 'integer')
class(`InfoNode__SWIG_2`) = c("SWIGFunction", class('InfoNode__SWIG_2'))

# Start of new_InfoNode

`InfoNode__SWIG_3` = function(flowData, stateId, physicalId, layerId)
{
  if (inherits(flowData, "ExternalReference")) flowData = slot(flowData,"ref"); 
  stateId = as.integer(stateId);
  
  if(length(stateId) > 1) {
    warning("using only the first element of stateId");
  };
  
  physicalId = as.integer(physicalId);
  
  if(length(physicalId) > 1) {
    warning("using only the first element of physicalId");
  };
  
  layerId = as.integer(layerId);
  
  if(length(layerId) > 1) {
    warning("using only the first element of layerId");
  };
  
  ;ans = .Call('R_swig_new_InfoNode__SWIG_3', flowData, stateId, physicalId, layerId, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfoNode);
  ans
  
}

attr(`InfoNode__SWIG_3`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfoNode__SWIG_3`, "inputTypes") = c('_p_infomap__FlowData', 'integer', 'integer', 'integer')
class(`InfoNode__SWIG_3`) = c("SWIGFunction", class('InfoNode__SWIG_3'))

# Start of new_InfoNode

`InfoNode__SWIG_4` = function()
{
  ;ans = .Call('R_swig_new_InfoNode__SWIG_4', PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfoNode);
  ans
  
}

attr(`InfoNode__SWIG_4`, 'returnType') = '_p_infomap__InfoNode'
class(`InfoNode__SWIG_4`) = c("SWIGFunction", class('InfoNode__SWIG_4'))

# Start of new_InfoNode

`InfoNode__SWIG_5` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_new_InfoNode__SWIG_5', other, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfoNode);
  ans
  
}

attr(`InfoNode__SWIG_5`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfoNode__SWIG_5`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode__SWIG_5`) = c("SWIGFunction", class('InfoNode__SWIG_5'))

`InfoNode` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 6
  if (argc == 0) {
    f <- InfoNode__SWIG_4; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_infomap__FlowData') && length(argv[[1]]) == 1) {
      f <- InfoNode__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_infomap__InfoNode') && length(argv[[1]]) == 1) {
      f <- InfoNode__SWIG_5; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_infomap__FlowData') && length(argv[[1]]) == 1 && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- InfoNode__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_infomap__FlowData') && length(argv[[1]]) == 1 && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 )) {
      f <- InfoNode__SWIG_2; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_infomap__FlowData') && length(argv[[1]]) == 1 && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 )) {
      f <- InfoNode__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for InfoNode with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_InfoNode

`delete_InfoNode` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_InfoNode', self, PACKAGE='infomap');
  
}

attr(`delete_InfoNode`, 'returnType') = 'void'
attr(`delete_InfoNode`, "inputTypes") = c('_p_infomap__InfoNode')
class(`delete_InfoNode`) = c("SWIGFunction", class('delete_InfoNode'))

# Start of InfoNode_Equal

`InfoNode_Equal` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_InfoNode_Equal', self, other, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfoNode_Equal`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfoNode_Equal`, "inputTypes") = c('_p_infomap__InfoNode', '_p_infomap__InfoNode')
class(`InfoNode_Equal`) = c("SWIGFunction", class('InfoNode_Equal'))

# Start of InfoNode_getMetaData

`InfoNode_getMetaData__SWIG_0` = function(self, dimension, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  dimension = as.integer(dimension);
  
  if(length(dimension) > 1) {
    warning("using only the first element of dimension");
  };
  
  ;.Call('R_swig_InfoNode_getMetaData__SWIG_0', self, dimension, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfoNode_getMetaData__SWIG_0`, 'returnType') = 'integer'
attr(`InfoNode_getMetaData__SWIG_0`, "inputTypes") = c('_p_infomap__InfoNode', 'integer')
class(`InfoNode_getMetaData__SWIG_0`) = c("SWIGFunction", class('InfoNode_getMetaData__SWIG_0'))

# Start of InfoNode_getMetaData

`InfoNode_getMetaData__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_getMetaData__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfoNode_getMetaData__SWIG_1`, 'returnType') = 'integer'
attr(`InfoNode_getMetaData__SWIG_1`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_getMetaData__SWIG_1`) = c("SWIGFunction", class('InfoNode_getMetaData__SWIG_1'))

`InfoNode_getMetaData` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]]))) {
      f <- InfoNode_getMetaData__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- InfoNode_getMetaData__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InfoNode_getMetaData with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfoNode_getInfomap

`InfoNode_getInfomap` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_getInfomap', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfoNode_getInfomap`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfoNode_getInfomap`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_getInfomap`) = c("SWIGFunction", class('InfoNode_getInfomap'))

# Start of InfoNode_setInfomap

`InfoNode_setInfomap` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref"); 
  ;ans = .Call('R_swig_InfoNode_setInfomap', self, s_arg2, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfoNode_setInfomap`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfoNode_setInfomap`, "inputTypes") = c('_p_infomap__InfoNode', '_p_infomap__InfomapBase')
class(`InfoNode_setInfomap`) = c("SWIGFunction", class('InfoNode_setInfomap'))

# Start of InfoNode_getInfomapRoot

`InfoNode_getInfomapRoot__SWIG_0` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_getInfomapRoot__SWIG_0', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfoNode_getInfomapRoot__SWIG_0`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfoNode_getInfomapRoot__SWIG_0`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_getInfomapRoot__SWIG_0`) = c("SWIGFunction", class('InfoNode_getInfomapRoot__SWIG_0'))

# Start of InfoNode_getInfomapRoot

`InfoNode_getInfomapRoot__SWIG_1` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_getInfomapRoot__SWIG_1', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfoNode_getInfomapRoot__SWIG_1`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfoNode_getInfomapRoot__SWIG_1`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_getInfomapRoot__SWIG_1`) = c("SWIGFunction", class('InfoNode_getInfomapRoot__SWIG_1'))

`InfoNode_getInfomapRoot` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]]))) {
      f <- InfoNode_getInfomapRoot__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]]))) {
      f <- InfoNode_getInfomapRoot__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfoNode_getInfomapRoot with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfoNode_disposeInfomap

`InfoNode_disposeInfomap` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_disposeInfomap', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfoNode_disposeInfomap`, 'returnType') = 'logical'
attr(`InfoNode_disposeInfomap`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_disposeInfomap`) = c("SWIGFunction", class('InfoNode_disposeInfomap'))

# Start of InfoNode_numPhysicalNodes

`InfoNode_numPhysicalNodes` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_numPhysicalNodes', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfoNode_numPhysicalNodes`, 'returnType') = 'integer'
attr(`InfoNode_numPhysicalNodes`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_numPhysicalNodes`) = c("SWIGFunction", class('InfoNode_numPhysicalNodes'))

# Start of InfoNode_begin

`InfoNode_begin__SWIG_0` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_begin__SWIG_0', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_ChildIteratorT_infomap__InfoNode_p_t", ref=ans);
  
  ans
  
}

attr(`InfoNode_begin__SWIG_0`, 'returnType') = '_p_ChildIteratorT_infomap__InfoNode_p_t'
attr(`InfoNode_begin__SWIG_0`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_begin__SWIG_0`) = c("SWIGFunction", class('InfoNode_begin__SWIG_0'))

# Start of InfoNode_end

`InfoNode_end__SWIG_0` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_end__SWIG_0', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_ChildIteratorT_infomap__InfoNode_p_t", ref=ans);
  
  ans
  
}

attr(`InfoNode_end__SWIG_0`, 'returnType') = '_p_ChildIteratorT_infomap__InfoNode_p_t'
attr(`InfoNode_end__SWIG_0`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_end__SWIG_0`) = c("SWIGFunction", class('InfoNode_end__SWIG_0'))

# Start of InfoNode_begin

`InfoNode_begin__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_begin__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_ChildIteratorT_infomap__InfoNode_const_p_t", ref=ans);
  
  ans
  
}

attr(`InfoNode_begin__SWIG_1`, 'returnType') = '_p_ChildIteratorT_infomap__InfoNode_const_p_t'
attr(`InfoNode_begin__SWIG_1`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_begin__SWIG_1`) = c("SWIGFunction", class('InfoNode_begin__SWIG_1'))

`InfoNode_begin` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]]))) {
      f <- InfoNode_begin__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]]))) {
      f <- InfoNode_begin__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfoNode_begin with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfoNode_end

`InfoNode_end__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_end__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_ChildIteratorT_infomap__InfoNode_const_p_t", ref=ans);
  
  ans
  
}

attr(`InfoNode_end__SWIG_1`, 'returnType') = '_p_ChildIteratorT_infomap__InfoNode_const_p_t'
attr(`InfoNode_end__SWIG_1`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_end__SWIG_1`) = c("SWIGFunction", class('InfoNode_end__SWIG_1'))

`InfoNode_end` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]]))) {
      f <- InfoNode_end__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]]))) {
      f <- InfoNode_end__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfoNode_end with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfoNode_begin_child

`InfoNode_begin_child__SWIG_0` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_begin_child__SWIG_0', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_ChildIteratorT_infomap__InfoNode_p_t", ref=ans);
  
  ans
  
}

attr(`InfoNode_begin_child__SWIG_0`, 'returnType') = '_p_ChildIteratorT_infomap__InfoNode_p_t'
attr(`InfoNode_begin_child__SWIG_0`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_begin_child__SWIG_0`) = c("SWIGFunction", class('InfoNode_begin_child__SWIG_0'))

# Start of InfoNode_end_child

`InfoNode_end_child__SWIG_0` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_end_child__SWIG_0', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_ChildIteratorT_infomap__InfoNode_p_t", ref=ans);
  
  ans
  
}

attr(`InfoNode_end_child__SWIG_0`, 'returnType') = '_p_ChildIteratorT_infomap__InfoNode_p_t'
attr(`InfoNode_end_child__SWIG_0`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_end_child__SWIG_0`) = c("SWIGFunction", class('InfoNode_end_child__SWIG_0'))

# Start of InfoNode_begin_child

`InfoNode_begin_child__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_begin_child__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_ChildIteratorT_infomap__InfoNode_const_p_t", ref=ans);
  
  ans
  
}

attr(`InfoNode_begin_child__SWIG_1`, 'returnType') = '_p_ChildIteratorT_infomap__InfoNode_const_p_t'
attr(`InfoNode_begin_child__SWIG_1`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_begin_child__SWIG_1`) = c("SWIGFunction", class('InfoNode_begin_child__SWIG_1'))

`InfoNode_begin_child` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]]))) {
      f <- InfoNode_begin_child__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]]))) {
      f <- InfoNode_begin_child__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfoNode_begin_child with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfoNode_end_child

`InfoNode_end_child__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_end_child__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_ChildIteratorT_infomap__InfoNode_const_p_t", ref=ans);
  
  ans
  
}

attr(`InfoNode_end_child__SWIG_1`, 'returnType') = '_p_ChildIteratorT_infomap__InfoNode_const_p_t'
attr(`InfoNode_end_child__SWIG_1`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_end_child__SWIG_1`) = c("SWIGFunction", class('InfoNode_end_child__SWIG_1'))

`InfoNode_end_child` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]]))) {
      f <- InfoNode_end_child__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]]))) {
      f <- InfoNode_end_child__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfoNode_end_child with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfoNode_children

`InfoNode_children__SWIG_0` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_children__SWIG_0', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_IterWrapperT_ChildIteratorT_infomap__InfoNode_p_t_t", ref=ans);
  
  ans
  
}

attr(`InfoNode_children__SWIG_0`, 'returnType') = '_p_IterWrapperT_ChildIteratorT_infomap__InfoNode_p_t_t'
attr(`InfoNode_children__SWIG_0`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_children__SWIG_0`) = c("SWIGFunction", class('InfoNode_children__SWIG_0'))

# Start of InfoNode_children

`InfoNode_children__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_children__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_IterWrapperT_ChildIteratorT_infomap__InfoNode_const_p_t_t", ref=ans);
  
  ans
  
}

attr(`InfoNode_children__SWIG_1`, 'returnType') = '_p_IterWrapperT_ChildIteratorT_infomap__InfoNode_const_p_t_t'
attr(`InfoNode_children__SWIG_1`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_children__SWIG_1`) = c("SWIGFunction", class('InfoNode_children__SWIG_1'))

`InfoNode_children` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]]))) {
      f <- InfoNode_children__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]]))) {
      f <- InfoNode_children__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfoNode_children with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfoNode_infomap_children

`InfoNode_infomap_children__SWIG_0` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_infomap_children__SWIG_0', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_IterWrapperT_InfomapChildIteratorT_infomap__InfoNode_p_t_t", ref=ans);
  
  ans
  
}

attr(`InfoNode_infomap_children__SWIG_0`, 'returnType') = '_p_IterWrapperT_InfomapChildIteratorT_infomap__InfoNode_p_t_t'
attr(`InfoNode_infomap_children__SWIG_0`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_infomap_children__SWIG_0`) = c("SWIGFunction", class('InfoNode_infomap_children__SWIG_0'))

# Start of InfoNode_infomap_children

`InfoNode_infomap_children__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_infomap_children__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_IterWrapperT_InfomapChildIteratorT_infomap__InfoNode_const_p_t_t", ref=ans);
  
  ans
  
}

attr(`InfoNode_infomap_children__SWIG_1`, 'returnType') = '_p_IterWrapperT_InfomapChildIteratorT_infomap__InfoNode_const_p_t_t'
attr(`InfoNode_infomap_children__SWIG_1`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_infomap_children__SWIG_1`) = c("SWIGFunction", class('InfoNode_infomap_children__SWIG_1'))

`InfoNode_infomap_children` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]]))) {
      f <- InfoNode_infomap_children__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]]))) {
      f <- InfoNode_infomap_children__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfoNode_infomap_children with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfoNode_begin_post_depth_first

`InfoNode_begin_post_depth_first` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_begin_post_depth_first', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_DepthFirstIteratorT_infomap__InfoNode_p_false_t", ref=ans);
  
  ans
  
}

attr(`InfoNode_begin_post_depth_first`, 'returnType') = '_p_DepthFirstIteratorT_infomap__InfoNode_p_false_t'
attr(`InfoNode_begin_post_depth_first`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_begin_post_depth_first`) = c("SWIGFunction", class('InfoNode_begin_post_depth_first'))

# Start of InfoNode_begin_leaf_nodes

`InfoNode_begin_leaf_nodes` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_begin_leaf_nodes', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_LeafNodeIteratorT_infomap__InfoNode_p_t", ref=ans);
  
  ans
  
}

attr(`InfoNode_begin_leaf_nodes`, 'returnType') = '_p_LeafNodeIteratorT_infomap__InfoNode_p_t'
attr(`InfoNode_begin_leaf_nodes`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_begin_leaf_nodes`) = c("SWIGFunction", class('InfoNode_begin_leaf_nodes'))

# Start of InfoNode_begin_leaf_modules

`InfoNode_begin_leaf_modules` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_begin_leaf_modules', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_LeafModuleIteratorT_infomap__InfoNode_p_t", ref=ans);
  
  ans
  
}

attr(`InfoNode_begin_leaf_modules`, 'returnType') = '_p_LeafModuleIteratorT_infomap__InfoNode_p_t'
attr(`InfoNode_begin_leaf_modules`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_begin_leaf_modules`) = c("SWIGFunction", class('InfoNode_begin_leaf_modules'))

# Start of InfoNode_begin_tree

`InfoNode_begin_tree__SWIG_0` = function(self, maxClusterLevel, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  maxClusterLevel = as.integer(maxClusterLevel);
  
  if(length(maxClusterLevel) > 1) {
    warning("using only the first element of maxClusterLevel");
  };
  
  ;ans = .Call('R_swig_InfoNode_begin_tree__SWIG_0', self, maxClusterLevel, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_TreeIteratorT_infomap__InfoNode_p_t", ref=ans);
  
  ans
  
}

attr(`InfoNode_begin_tree__SWIG_0`, 'returnType') = '_p_TreeIteratorT_infomap__InfoNode_p_t'
attr(`InfoNode_begin_tree__SWIG_0`, "inputTypes") = c('_p_infomap__InfoNode', 'integer')
class(`InfoNode_begin_tree__SWIG_0`) = c("SWIGFunction", class('InfoNode_begin_tree__SWIG_0'))

# Start of InfoNode_begin_tree

`InfoNode_begin_tree__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_begin_tree__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_TreeIteratorT_infomap__InfoNode_p_t", ref=ans);
  
  ans
  
}

attr(`InfoNode_begin_tree__SWIG_1`, 'returnType') = '_p_TreeIteratorT_infomap__InfoNode_p_t'
attr(`InfoNode_begin_tree__SWIG_1`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_begin_tree__SWIG_1`) = c("SWIGFunction", class('InfoNode_begin_tree__SWIG_1'))

# Start of InfoNode_end_tree

`InfoNode_end_tree__SWIG_0` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_end_tree__SWIG_0', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_TreeIteratorT_infomap__InfoNode_p_t", ref=ans);
  
  ans
  
}

attr(`InfoNode_end_tree__SWIG_0`, 'returnType') = '_p_TreeIteratorT_infomap__InfoNode_p_t'
attr(`InfoNode_end_tree__SWIG_0`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_end_tree__SWIG_0`) = c("SWIGFunction", class('InfoNode_end_tree__SWIG_0'))

# Start of InfoNode_begin_tree

`InfoNode_begin_tree__SWIG_2` = function(self, maxClusterLevel, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  maxClusterLevel = as.integer(maxClusterLevel);
  
  if(length(maxClusterLevel) > 1) {
    warning("using only the first element of maxClusterLevel");
  };
  
  ;ans = .Call('R_swig_InfoNode_begin_tree__SWIG_2', self, maxClusterLevel, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_TreeIteratorT_infomap__InfoNode_const_p_t", ref=ans);
  
  ans
  
}

attr(`InfoNode_begin_tree__SWIG_2`, 'returnType') = '_p_TreeIteratorT_infomap__InfoNode_const_p_t'
attr(`InfoNode_begin_tree__SWIG_2`, "inputTypes") = c('_p_infomap__InfoNode', 'integer')
class(`InfoNode_begin_tree__SWIG_2`) = c("SWIGFunction", class('InfoNode_begin_tree__SWIG_2'))

# Start of InfoNode_begin_tree

`InfoNode_begin_tree__SWIG_3` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_begin_tree__SWIG_3', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_TreeIteratorT_infomap__InfoNode_const_p_t", ref=ans);
  
  ans
  
}

attr(`InfoNode_begin_tree__SWIG_3`, 'returnType') = '_p_TreeIteratorT_infomap__InfoNode_const_p_t'
attr(`InfoNode_begin_tree__SWIG_3`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_begin_tree__SWIG_3`) = c("SWIGFunction", class('InfoNode_begin_tree__SWIG_3'))

`InfoNode_begin_tree` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]]))) {
      f <- InfoNode_begin_tree__SWIG_1; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]]))) {
      f <- InfoNode_begin_tree__SWIG_3; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- InfoNode_begin_tree__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- InfoNode_begin_tree__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for InfoNode_begin_tree with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfoNode_end_tree

`InfoNode_end_tree__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_end_tree__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_TreeIteratorT_infomap__InfoNode_const_p_t", ref=ans);
  
  ans
  
}

attr(`InfoNode_end_tree__SWIG_1`, 'returnType') = '_p_TreeIteratorT_infomap__InfoNode_const_p_t'
attr(`InfoNode_end_tree__SWIG_1`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_end_tree__SWIG_1`) = c("SWIGFunction", class('InfoNode_end_tree__SWIG_1'))

`InfoNode_end_tree` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]]))) {
      f <- InfoNode_end_tree__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]]))) {
      f <- InfoNode_end_tree__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfoNode_end_tree with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfoNode_infomapTree

`InfoNode_infomapTree__SWIG_0` = function(self, maxClusterLevel, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  maxClusterLevel = as.integer(maxClusterLevel);
  
  if(length(maxClusterLevel) > 1) {
    warning("using only the first element of maxClusterLevel");
  };
  
  ;ans = .Call('R_swig_InfoNode_infomapTree__SWIG_0', self, maxClusterLevel, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_p_t_t", ref=ans);
  
  ans
  
}

attr(`InfoNode_infomapTree__SWIG_0`, 'returnType') = '_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_p_t_t'
attr(`InfoNode_infomapTree__SWIG_0`, "inputTypes") = c('_p_infomap__InfoNode', 'integer')
class(`InfoNode_infomapTree__SWIG_0`) = c("SWIGFunction", class('InfoNode_infomapTree__SWIG_0'))

# Start of InfoNode_infomapTree

`InfoNode_infomapTree__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_infomapTree__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_p_t_t", ref=ans);
  
  ans
  
}

attr(`InfoNode_infomapTree__SWIG_1`, 'returnType') = '_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_p_t_t'
attr(`InfoNode_infomapTree__SWIG_1`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_infomapTree__SWIG_1`) = c("SWIGFunction", class('InfoNode_infomapTree__SWIG_1'))

# Start of InfoNode_infomapTree

`InfoNode_infomapTree__SWIG_2` = function(self, maxClusterLevel, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  maxClusterLevel = as.integer(maxClusterLevel);
  
  if(length(maxClusterLevel) > 1) {
    warning("using only the first element of maxClusterLevel");
  };
  
  ;ans = .Call('R_swig_InfoNode_infomapTree__SWIG_2', self, maxClusterLevel, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_const_p_t_t", ref=ans);
  
  ans
  
}

attr(`InfoNode_infomapTree__SWIG_2`, 'returnType') = '_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_const_p_t_t'
attr(`InfoNode_infomapTree__SWIG_2`, "inputTypes") = c('_p_infomap__InfoNode', 'integer')
class(`InfoNode_infomapTree__SWIG_2`) = c("SWIGFunction", class('InfoNode_infomapTree__SWIG_2'))

# Start of InfoNode_infomapTree

`InfoNode_infomapTree__SWIG_3` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_infomapTree__SWIG_3', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_const_p_t_t", ref=ans);
  
  ans
  
}

attr(`InfoNode_infomapTree__SWIG_3`, 'returnType') = '_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_const_p_t_t'
attr(`InfoNode_infomapTree__SWIG_3`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_infomapTree__SWIG_3`) = c("SWIGFunction", class('InfoNode_infomapTree__SWIG_3'))

`InfoNode_infomapTree` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]]))) {
      f <- InfoNode_infomapTree__SWIG_1; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]]))) {
      f <- InfoNode_infomapTree__SWIG_3; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- InfoNode_infomapTree__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- InfoNode_infomapTree__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for InfoNode_infomapTree with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfoNode_begin_outEdge

`InfoNode_begin_outEdge` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_begin_outEdge', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator", ref=ans);
  
  ans
  
}

attr(`InfoNode_begin_outEdge`, 'returnType') = '_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator'
attr(`InfoNode_begin_outEdge`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_begin_outEdge`) = c("SWIGFunction", class('InfoNode_begin_outEdge'))

# Start of InfoNode_end_outEdge

`InfoNode_end_outEdge` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_end_outEdge', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator", ref=ans);
  
  ans
  
}

attr(`InfoNode_end_outEdge`, 'returnType') = '_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator'
attr(`InfoNode_end_outEdge`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_end_outEdge`) = c("SWIGFunction", class('InfoNode_end_outEdge'))

# Start of InfoNode_begin_inEdge

`InfoNode_begin_inEdge` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_begin_inEdge', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator", ref=ans);
  
  ans
  
}

attr(`InfoNode_begin_inEdge`, 'returnType') = '_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator'
attr(`InfoNode_begin_inEdge`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_begin_inEdge`) = c("SWIGFunction", class('InfoNode_begin_inEdge'))

# Start of InfoNode_end_inEdge

`InfoNode_end_inEdge` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_end_inEdge', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator", ref=ans);
  
  ans
  
}

attr(`InfoNode_end_inEdge`, 'returnType') = '_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator'
attr(`InfoNode_end_inEdge`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_end_inEdge`) = c("SWIGFunction", class('InfoNode_end_inEdge'))

# Start of InfoNode_outEdges

`InfoNode_outEdges` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_outEdges', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_IterWrapperT_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator_t", ref=ans);
  
  ans
  
}

attr(`InfoNode_outEdges`, 'returnType') = '_p_IterWrapperT_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator_t'
attr(`InfoNode_outEdges`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_outEdges`) = c("SWIGFunction", class('InfoNode_outEdges'))

# Start of InfoNode_inEdges

`InfoNode_inEdges` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_inEdges', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_IterWrapperT_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator_t", ref=ans);
  
  ans
  
}

attr(`InfoNode_inEdges`, 'returnType') = '_p_IterWrapperT_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator_t'
attr(`InfoNode_inEdges`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_inEdges`) = c("SWIGFunction", class('InfoNode_inEdges'))

# Start of InfoNode_childDegree

`InfoNode_childDegree` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_childDegree', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfoNode_childDegree`, 'returnType') = 'integer'
attr(`InfoNode_childDegree`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_childDegree`) = c("SWIGFunction", class('InfoNode_childDegree'))

# Start of InfoNode_isLeaf

`InfoNode_isLeaf` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_isLeaf', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfoNode_isLeaf`, 'returnType') = 'logical'
attr(`InfoNode_isLeaf`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_isLeaf`) = c("SWIGFunction", class('InfoNode_isLeaf'))

# Start of InfoNode_isLeafModule

`InfoNode_isLeafModule` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_isLeafModule', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfoNode_isLeafModule`, 'returnType') = 'logical'
attr(`InfoNode_isLeafModule`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_isLeafModule`) = c("SWIGFunction", class('InfoNode_isLeafModule'))

# Start of InfoNode_isRoot

`InfoNode_isRoot` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_isRoot', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfoNode_isRoot`, 'returnType') = 'logical'
attr(`InfoNode_isRoot`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_isRoot`) = c("SWIGFunction", class('InfoNode_isRoot'))

# Start of InfoNode_depth

`InfoNode_depth` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_depth', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfoNode_depth`, 'returnType') = 'integer'
attr(`InfoNode_depth`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_depth`) = c("SWIGFunction", class('InfoNode_depth'))

# Start of InfoNode_firstDepthBelow

`InfoNode_firstDepthBelow` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_firstDepthBelow', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfoNode_firstDepthBelow`, 'returnType') = 'integer'
attr(`InfoNode_firstDepthBelow`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_firstDepthBelow`) = c("SWIGFunction", class('InfoNode_firstDepthBelow'))

# Start of InfoNode_numLeafMembers

`InfoNode_numLeafMembers` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_numLeafMembers', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfoNode_numLeafMembers`, 'returnType') = 'integer'
attr(`InfoNode_numLeafMembers`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_numLeafMembers`) = c("SWIGFunction", class('InfoNode_numLeafMembers'))

# Start of InfoNode_isDangling

`InfoNode_isDangling` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_isDangling', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfoNode_isDangling`, 'returnType') = 'logical'
attr(`InfoNode_isDangling`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_isDangling`) = c("SWIGFunction", class('InfoNode_isDangling'))

# Start of InfoNode_outDegree

`InfoNode_outDegree` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_outDegree', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfoNode_outDegree`, 'returnType') = 'integer'
attr(`InfoNode_outDegree`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_outDegree`) = c("SWIGFunction", class('InfoNode_outDegree'))

# Start of InfoNode_inDegree

`InfoNode_inDegree` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_inDegree', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfoNode_inDegree`, 'returnType') = 'integer'
attr(`InfoNode_inDegree`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_inDegree`) = c("SWIGFunction", class('InfoNode_inDegree'))

# Start of InfoNode_degree

`InfoNode_degree` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_degree', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfoNode_degree`, 'returnType') = 'integer'
attr(`InfoNode_degree`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_degree`) = c("SWIGFunction", class('InfoNode_degree'))

# Start of InfoNode_isFirst

`InfoNode_isFirst` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_isFirst', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfoNode_isFirst`, 'returnType') = 'logical'
attr(`InfoNode_isFirst`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_isFirst`) = c("SWIGFunction", class('InfoNode_isFirst'))

# Start of InfoNode_isLast

`InfoNode_isLast` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_isLast', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfoNode_isLast`, 'returnType') = 'logical'
attr(`InfoNode_isLast`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_isLast`) = c("SWIGFunction", class('InfoNode_isLast'))

# Start of InfoNode_childIndex

`InfoNode_childIndex` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_childIndex', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfoNode_childIndex`, 'returnType') = 'integer'
attr(`InfoNode_childIndex`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_childIndex`) = c("SWIGFunction", class('InfoNode_childIndex'))

# Start of InfoNode_calculatePath

`InfoNode_calculatePath` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_calculatePath', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfoNode_calculatePath`, 'returnType') = 'integer'
attr(`InfoNode_calculatePath`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_calculatePath`) = c("SWIGFunction", class('InfoNode_calculatePath'))

# Start of InfoNode_infomapChildDegree

`InfoNode_infomapChildDegree` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_infomapChildDegree', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfoNode_infomapChildDegree`, 'returnType') = 'integer'
attr(`InfoNode_infomapChildDegree`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_infomapChildDegree`) = c("SWIGFunction", class('InfoNode_infomapChildDegree'))

# Start of InfoNode_id

`InfoNode_id` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_id', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfoNode_id`, 'returnType') = 'integer'
attr(`InfoNode_id`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_id`) = c("SWIGFunction", class('InfoNode_id'))

# Start of InfoNode_EqualEqual

`InfoNode_EqualEqual` = function(self, rhs, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(rhs, "ExternalReference")) rhs = slot(rhs,"ref"); 
  ;.Call('R_swig_InfoNode_EqualEqual', self, rhs, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfoNode_EqualEqual`, 'returnType') = 'logical'
attr(`InfoNode_EqualEqual`, "inputTypes") = c('_p_infomap__InfoNode', '_p_infomap__InfoNode')
class(`InfoNode_EqualEqual`) = c("SWIGFunction", class('InfoNode_EqualEqual'))

# Start of InfoNode_NotEqual

`InfoNode_NotEqual` = function(self, rhs, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(rhs, "ExternalReference")) rhs = slot(rhs,"ref"); 
  ;.Call('R_swig_InfoNode_NotEqual', self, rhs, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfoNode_NotEqual`, 'returnType') = 'logical'
attr(`InfoNode_NotEqual`, "inputTypes") = c('_p_infomap__InfoNode', '_p_infomap__InfoNode')
class(`InfoNode_NotEqual`) = c("SWIGFunction", class('InfoNode_NotEqual'))

# Start of InfoNode_initClean

`InfoNode_initClean` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_initClean', self, PACKAGE='infomap');
  
}

attr(`InfoNode_initClean`, 'returnType') = 'void'
attr(`InfoNode_initClean`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_initClean`) = c("SWIGFunction", class('InfoNode_initClean'))

# Start of InfoNode_sortChildrenOnFlow

`InfoNode_sortChildrenOnFlow__SWIG_0` = function(self, recurse)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  recurse = as.logical(recurse);
  ;.Call('R_swig_InfoNode_sortChildrenOnFlow__SWIG_0', self, recurse, PACKAGE='infomap');
  
}

attr(`InfoNode_sortChildrenOnFlow__SWIG_0`, 'returnType') = 'void'
attr(`InfoNode_sortChildrenOnFlow__SWIG_0`, "inputTypes") = c('_p_infomap__InfoNode', 'logical')
class(`InfoNode_sortChildrenOnFlow__SWIG_0`) = c("SWIGFunction", class('InfoNode_sortChildrenOnFlow__SWIG_0'))

# Start of InfoNode_sortChildrenOnFlow

`InfoNode_sortChildrenOnFlow__SWIG_1` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_sortChildrenOnFlow__SWIG_1', self, PACKAGE='infomap');
  
}

attr(`InfoNode_sortChildrenOnFlow__SWIG_1`, 'returnType') = 'void'
attr(`InfoNode_sortChildrenOnFlow__SWIG_1`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_sortChildrenOnFlow__SWIG_1`) = c("SWIGFunction", class('InfoNode_sortChildrenOnFlow__SWIG_1'))

`InfoNode_sortChildrenOnFlow` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]]))) {
      f <- InfoNode_sortChildrenOnFlow__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]])) && ( is.logical(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- InfoNode_sortChildrenOnFlow__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InfoNode_sortChildrenOnFlow with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfoNode_collapseChildren

`InfoNode_collapseChildren` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_collapseChildren', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfoNode_collapseChildren`, 'returnType') = 'integer'
attr(`InfoNode_collapseChildren`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_collapseChildren`) = c("SWIGFunction", class('InfoNode_collapseChildren'))

# Start of InfoNode_expandChildren

`InfoNode_expandChildren` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_expandChildren', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfoNode_expandChildren`, 'returnType') = 'integer'
attr(`InfoNode_expandChildren`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_expandChildren`) = c("SWIGFunction", class('InfoNode_expandChildren'))

# Start of InfoNode_setChildDegree

`InfoNode_setChildDegree` = function(self, value)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  value = as.integer(value);
  
  if(length(value) > 1) {
    warning("using only the first element of value");
  };
  
  ;.Call('R_swig_InfoNode_setChildDegree', self, value, PACKAGE='infomap');
  
}

attr(`InfoNode_setChildDegree`, 'returnType') = 'void'
attr(`InfoNode_setChildDegree`, "inputTypes") = c('_p_infomap__InfoNode', 'integer')
class(`InfoNode_setChildDegree`) = c("SWIGFunction", class('InfoNode_setChildDegree'))

# Start of InfoNode_setNumLeafNodes

`InfoNode_setNumLeafNodes` = function(self, value)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  value = as.integer(value);
  
  if(length(value) > 1) {
    warning("using only the first element of value");
  };
  
  ;.Call('R_swig_InfoNode_setNumLeafNodes', self, value, PACKAGE='infomap');
  
}

attr(`InfoNode_setNumLeafNodes`, 'returnType') = 'void'
attr(`InfoNode_setNumLeafNodes`, "inputTypes") = c('_p_infomap__InfoNode', 'integer')
class(`InfoNode_setNumLeafNodes`) = c("SWIGFunction", class('InfoNode_setNumLeafNodes'))

# Start of InfoNode_addChild

`InfoNode_addChild` = function(self, child)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(child, "ExternalReference")) child = slot(child,"ref"); 
  ;.Call('R_swig_InfoNode_addChild', self, child, PACKAGE='infomap');
  
}

attr(`InfoNode_addChild`, 'returnType') = 'void'
attr(`InfoNode_addChild`, "inputTypes") = c('_p_infomap__InfoNode', '_p_infomap__InfoNode')
class(`InfoNode_addChild`) = c("SWIGFunction", class('InfoNode_addChild'))

# Start of InfoNode_releaseChildren

`InfoNode_releaseChildren` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_releaseChildren', self, PACKAGE='infomap');
  
}

attr(`InfoNode_releaseChildren`, 'returnType') = 'void'
attr(`InfoNode_releaseChildren`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_releaseChildren`) = c("SWIGFunction", class('InfoNode_releaseChildren'))

# Start of InfoNode_replaceChildrenWithOneNode

`InfoNode_replaceChildrenWithOneNode` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfoNode_replaceChildrenWithOneNode', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfoNode_replaceChildrenWithOneNode`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfoNode_replaceChildrenWithOneNode`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_replaceChildrenWithOneNode`) = c("SWIGFunction", class('InfoNode_replaceChildrenWithOneNode'))

# Start of InfoNode_replaceWithChildren

`InfoNode_replaceWithChildren` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_replaceWithChildren', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfoNode_replaceWithChildren`, 'returnType') = 'integer'
attr(`InfoNode_replaceWithChildren`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_replaceWithChildren`) = c("SWIGFunction", class('InfoNode_replaceWithChildren'))

# Start of InfoNode_replaceWithChildrenDebug

`InfoNode_replaceWithChildrenDebug` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_replaceWithChildrenDebug', self, PACKAGE='infomap');
  
}

attr(`InfoNode_replaceWithChildrenDebug`, 'returnType') = 'void'
attr(`InfoNode_replaceWithChildrenDebug`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_replaceWithChildrenDebug`) = c("SWIGFunction", class('InfoNode_replaceWithChildrenDebug'))

# Start of InfoNode_replaceChildrenWithGrandChildren

`InfoNode_replaceChildrenWithGrandChildren` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_replaceChildrenWithGrandChildren', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfoNode_replaceChildrenWithGrandChildren`, 'returnType') = 'integer'
attr(`InfoNode_replaceChildrenWithGrandChildren`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_replaceChildrenWithGrandChildren`) = c("SWIGFunction", class('InfoNode_replaceChildrenWithGrandChildren'))

# Start of InfoNode_replaceChildrenWithGrandChildrenDebug

`InfoNode_replaceChildrenWithGrandChildrenDebug` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_replaceChildrenWithGrandChildrenDebug', self, PACKAGE='infomap');
  
}

attr(`InfoNode_replaceChildrenWithGrandChildrenDebug`, 'returnType') = 'void'
attr(`InfoNode_replaceChildrenWithGrandChildrenDebug`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_replaceChildrenWithGrandChildrenDebug`) = c("SWIGFunction", class('InfoNode_replaceChildrenWithGrandChildrenDebug'))

# Start of InfoNode_remove

`InfoNode_remove` = function(self, removeChildren)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  removeChildren = as.logical(removeChildren);
  ;.Call('R_swig_InfoNode_remove', self, removeChildren, PACKAGE='infomap');
  
}

attr(`InfoNode_remove`, 'returnType') = 'void'
attr(`InfoNode_remove`, "inputTypes") = c('_p_infomap__InfoNode', 'logical')
class(`InfoNode_remove`) = c("SWIGFunction", class('InfoNode_remove'))

# Start of InfoNode_deleteChildren

`InfoNode_deleteChildren` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfoNode_deleteChildren', self, PACKAGE='infomap');
  
}

attr(`InfoNode_deleteChildren`, 'returnType') = 'void'
attr(`InfoNode_deleteChildren`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfoNode_deleteChildren`) = c("SWIGFunction", class('InfoNode_deleteChildren'))

# Start of InfoNode_addOutEdge

`InfoNode_addOutEdge__SWIG_0` = function(self, target, weight, flow)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(target, "ExternalReference")) target = slot(target,"ref"); 
  
  
  ;ans = .Call('R_swig_InfoNode_addOutEdge__SWIG_0', self, target, weight, flow, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_EdgeT_infomap__InfoNode_t", ref=ans);
  
  ans
  
}

attr(`InfoNode_addOutEdge__SWIG_0`, 'returnType') = '_p_EdgeT_infomap__InfoNode_t'
attr(`InfoNode_addOutEdge__SWIG_0`, "inputTypes") = c('_p_infomap__InfoNode', '_p_infomap__InfoNode', 'numeric', 'numeric')
class(`InfoNode_addOutEdge__SWIG_0`) = c("SWIGFunction", class('InfoNode_addOutEdge__SWIG_0'))

# Start of InfoNode_addOutEdge

`InfoNode_addOutEdge__SWIG_1` = function(self, target, weight)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(target, "ExternalReference")) target = slot(target,"ref"); 
  
  ;ans = .Call('R_swig_InfoNode_addOutEdge__SWIG_1', self, target, weight, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_EdgeT_infomap__InfoNode_t", ref=ans);
  
  ans
  
}

attr(`InfoNode_addOutEdge__SWIG_1`, 'returnType') = '_p_EdgeT_infomap__InfoNode_t'
attr(`InfoNode_addOutEdge__SWIG_1`, "inputTypes") = c('_p_infomap__InfoNode', '_p_infomap__InfoNode', 'numeric')
class(`InfoNode_addOutEdge__SWIG_1`) = c("SWIGFunction", class('InfoNode_addOutEdge__SWIG_1'))

`InfoNode_addOutEdge` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 3) {
    if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]])) && extends(argtypes[2], '_p_infomap__InfoNode') && length(argv[[2]]) == 1 && ( is.numeric(argv[[3]]) && length(argv[[3]]) == 1 )) {
      f <- InfoNode_addOutEdge__SWIG_1; 
    }
  } else if (argc == 4) {
    if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]])) && extends(argtypes[2], '_p_infomap__InfoNode') && length(argv[[2]]) == 1 && ( is.numeric(argv[[3]]) && length(argv[[3]]) == 1 ) && ( is.numeric(argv[[4]]) && length(argv[[4]]) == 1 )) {
      f <- InfoNode_addOutEdge__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InfoNode_addOutEdge with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of accessor method for infomap::InfoNode
setMethod('$', '_p_infomap__InfoNode', function(x, name)

{
  accessorFuns = list('data' = InfoNode_data_get, 'index' = InfoNode_index_get, 'stateId' = InfoNode_stateId_get, 'physicalId' = InfoNode_physicalId_get, 'layerId' = InfoNode_layerId_get, 'metaData' = InfoNode_metaData_get, 'owner' = InfoNode_owner_get, 'parent' = InfoNode_parent_get, 'previous' = InfoNode_previous_get, '_next' = InfoNode__next_get, 'firstChild' = InfoNode_firstChild_get, 'lastChild' = InfoNode_lastChild_get, 'collapsedFirstChild' = InfoNode_collapsedFirstChild_get, 'collapsedLastChild' = InfoNode_collapsedLastChild_get, 'codelength' = InfoNode_codelength_get, 'dirty' = InfoNode_dirty_get, 'physicalNodes' = InfoNode_physicalNodes_get, 'metaCollection' = InfoNode_metaCollection_get, 'stateNodes' = InfoNode_stateNodes_get, 'Equal' = InfoNode_Equal, 'getMetaData' = InfoNode_getMetaData, 'getInfomap' = InfoNode_getInfomap, 'setInfomap' = InfoNode_setInfomap, 'getInfomapRoot' = InfoNode_getInfomapRoot, 'disposeInfomap' = InfoNode_disposeInfomap, 'numPhysicalNodes' = InfoNode_numPhysicalNodes, 'begin' = InfoNode_begin, 'end' = InfoNode_end, 'begin_child' = InfoNode_begin_child, 'end_child' = InfoNode_end_child, 'children' = InfoNode_children, 'infomap_children' = InfoNode_infomap_children, 'begin_post_depth_first' = InfoNode_begin_post_depth_first, 'begin_leaf_nodes' = InfoNode_begin_leaf_nodes, 'begin_leaf_modules' = InfoNode_begin_leaf_modules, 'begin_tree' = InfoNode_begin_tree, 'end_tree' = InfoNode_end_tree, 'infomapTree' = InfoNode_infomapTree, 'begin_outEdge' = InfoNode_begin_outEdge, 'end_outEdge' = InfoNode_end_outEdge, 'begin_inEdge' = InfoNode_begin_inEdge, 'end_inEdge' = InfoNode_end_inEdge, 'outEdges' = InfoNode_outEdges, 'inEdges' = InfoNode_inEdges, 'childDegree' = InfoNode_childDegree, 'isLeaf' = InfoNode_isLeaf, 'isLeafModule' = InfoNode_isLeafModule, 'isRoot' = InfoNode_isRoot, 'depth' = InfoNode_depth, 'firstDepthBelow' = InfoNode_firstDepthBelow, 'numLeafMembers' = InfoNode_numLeafMembers, 'isDangling' = InfoNode_isDangling, 'outDegree' = InfoNode_outDegree, 'inDegree' = InfoNode_inDegree, 'degree' = InfoNode_degree, 'isFirst' = InfoNode_isFirst, 'isLast' = InfoNode_isLast, 'childIndex' = InfoNode_childIndex, 'calculatePath' = InfoNode_calculatePath, 'infomapChildDegree' = InfoNode_infomapChildDegree, 'id' = InfoNode_id, 'EqualEqual' = InfoNode_EqualEqual, 'NotEqual' = InfoNode_NotEqual, 'initClean' = InfoNode_initClean, 'sortChildrenOnFlow' = InfoNode_sortChildrenOnFlow, 'collapseChildren' = InfoNode_collapseChildren, 'expandChildren' = InfoNode_expandChildren, 'setChildDegree' = InfoNode_setChildDegree, 'setNumLeafNodes' = InfoNode_setNumLeafNodes, 'addChild' = InfoNode_addChild, 'releaseChildren' = InfoNode_releaseChildren, 'replaceChildrenWithOneNode' = InfoNode_replaceChildrenWithOneNode, 'replaceWithChildren' = InfoNode_replaceWithChildren, 'replaceWithChildrenDebug' = InfoNode_replaceWithChildrenDebug, 'replaceChildrenWithGrandChildren' = InfoNode_replaceChildrenWithGrandChildren, 'replaceChildrenWithGrandChildrenDebug' = InfoNode_replaceChildrenWithGrandChildrenDebug, 'remove' = InfoNode_remove, 'deleteChildren' = InfoNode_deleteChildren, 'addOutEdge' = InfoNode_addOutEdge);
  vaccessors = c('data', 'index', 'stateId', 'physicalId', 'layerId', 'metaData', 'owner', 'parent', 'previous', '_next', 'firstChild', 'lastChild', 'collapsedFirstChild', 'collapsedLastChild', 'codelength', 'dirty', 'physicalNodes', 'metaCollection', 'stateNodes');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for infomap::InfoNode
# Start of accessor method for infomap::InfoNode
setMethod('$<-', '_p_infomap__InfoNode', function(x, name, value)

{
  accessorFuns = list('data' = InfoNode_data_set, 'index' = InfoNode_index_set, 'stateId' = InfoNode_stateId_set, 'physicalId' = InfoNode_physicalId_set, 'layerId' = InfoNode_layerId_set, 'metaData' = InfoNode_metaData_set, 'owner' = InfoNode_owner_set, 'parent' = InfoNode_parent_set, 'previous' = InfoNode_previous_set, '_next' = InfoNode__next_set, 'firstChild' = InfoNode_firstChild_set, 'lastChild' = InfoNode_lastChild_set, 'collapsedFirstChild' = InfoNode_collapsedFirstChild_set, 'collapsedLastChild' = InfoNode_collapsedLastChild_set, 'codelength' = InfoNode_codelength_set, 'dirty' = InfoNode_dirty_set, 'physicalNodes' = InfoNode_physicalNodes_set, 'metaCollection' = InfoNode_metaCollection_set, 'stateNodes' = InfoNode_stateNodes_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_infomap__InfoNode', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('data' = InfoNode_data_set, 'index' = InfoNode_index_set, 'stateId' = InfoNode_stateId_set, 'physicalId' = InfoNode_physicalId_set, 'layerId' = InfoNode_layerId_set, 'metaData' = InfoNode_metaData_set, 'owner' = InfoNode_owner_set, 'parent' = InfoNode_parent_set, 'previous' = InfoNode_previous_set, '_next' = InfoNode__next_set, 'firstChild' = InfoNode_firstChild_set, 'lastChild' = InfoNode_lastChild_set, 'collapsedFirstChild' = InfoNode_collapsedFirstChild_set, 'collapsedLastChild' = InfoNode_collapsedLastChild_set, 'codelength' = InfoNode_codelength_set, 'dirty' = InfoNode_dirty_set, 'physicalNodes' = InfoNode_physicalNodes_set, 'metaCollection' = InfoNode_metaCollection_set, 'stateNodes' = InfoNode_stateNodes_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for infomap::InfoNode
setMethod('delete', '_p_infomap__InfoNode', function(obj) {delete_infomap__InfoNode(obj)})
# Start of new_deque_uint

`deque_uint__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_deque_uint__SWIG_0', PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_deque_uint);
  ans
  
}

attr(`deque_uint__SWIG_0`, 'returnType') = '_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t'
class(`deque_uint__SWIG_0`) = c("SWIGFunction", class('deque_uint__SWIG_0'))

# Start of new_deque_uint

`deque_uint__SWIG_1` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_new_deque_uint__SWIG_1', other, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_deque_uint);
  ans
  
}

attr(`deque_uint__SWIG_1`, 'returnType') = '_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t'
attr(`deque_uint__SWIG_1`, "inputTypes") = c('_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t')
class(`deque_uint__SWIG_1`) = c("SWIGFunction", class('deque_uint__SWIG_1'))

# Start of deque_uint_empty

`deque_uint_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_deque_uint_empty', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`deque_uint_empty`, 'returnType') = 'logical'
attr(`deque_uint_empty`, "inputTypes") = c('_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t')
class(`deque_uint_empty`) = c("SWIGFunction", class('deque_uint_empty'))

# Start of deque_uint_size

`deque_uint_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_deque_uint_size', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`deque_uint_size`, 'returnType') = 'integer'
attr(`deque_uint_size`, "inputTypes") = c('_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t')
class(`deque_uint_size`) = c("SWIGFunction", class('deque_uint_size'))

# Start of deque_uint_swap

`deque_uint_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref"); 
  ;.Call('R_swig_deque_uint_swap', self, v, PACKAGE='infomap');
  
}

attr(`deque_uint_swap`, 'returnType') = 'void'
attr(`deque_uint_swap`, "inputTypes") = c('_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t', '_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t')
class(`deque_uint_swap`) = c("SWIGFunction", class('deque_uint_swap'))

# Start of deque_uint_clear

`deque_uint_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_deque_uint_clear', self, PACKAGE='infomap');
  
}

attr(`deque_uint_clear`, 'returnType') = 'void'
attr(`deque_uint_clear`, "inputTypes") = c('_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t')
class(`deque_uint_clear`) = c("SWIGFunction", class('deque_uint_clear'))

# Start of deque_uint_get_allocator

`deque_uint_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_deque_uint_get_allocator', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_unsigned_int_t", ref=ans);
  
  ans
  
}

attr(`deque_uint_get_allocator`, 'returnType') = '_p_std__allocatorT_unsigned_int_t'
attr(`deque_uint_get_allocator`, "inputTypes") = c('_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t')
class(`deque_uint_get_allocator`) = c("SWIGFunction", class('deque_uint_get_allocator'))

# Start of new_deque_uint

`deque_uint__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_deque_uint__SWIG_2', size, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_deque_uint);
  ans
  
}

attr(`deque_uint__SWIG_2`, 'returnType') = '_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t'
attr(`deque_uint__SWIG_2`, "inputTypes") = c('integer')
class(`deque_uint__SWIG_2`) = c("SWIGFunction", class('deque_uint__SWIG_2'))

# Start of deque_uint_pop_back

`deque_uint_pop_back` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_deque_uint_pop_back', self, PACKAGE='infomap');
  
}

attr(`deque_uint_pop_back`, 'returnType') = 'void'
attr(`deque_uint_pop_back`, "inputTypes") = c('_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t')
class(`deque_uint_pop_back`) = c("SWIGFunction", class('deque_uint_pop_back'))

# Start of deque_uint_resize

`deque_uint_resize__SWIG_0` = function(self, new_size)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_deque_uint_resize__SWIG_0', self, new_size, PACKAGE='infomap');
  
}

attr(`deque_uint_resize__SWIG_0`, 'returnType') = 'void'
attr(`deque_uint_resize__SWIG_0`, "inputTypes") = c('_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t', 'integer')
class(`deque_uint_resize__SWIG_0`) = c("SWIGFunction", class('deque_uint_resize__SWIG_0'))

# Start of new_deque_uint

`deque_uint__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  if (inherits(value, "ExternalReference")) value = slot(value,"ref"); 
  ;ans = .Call('R_swig_new_deque_uint__SWIG_3', size, value, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_deque_uint);
  ans
  
}

attr(`deque_uint__SWIG_3`, 'returnType') = '_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t'
attr(`deque_uint__SWIG_3`, "inputTypes") = c('integer', '_p_unsigned_int')
class(`deque_uint__SWIG_3`) = c("SWIGFunction", class('deque_uint__SWIG_3'))

`deque_uint` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- deque_uint__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- deque_uint__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t') && length(argv[[1]]) == 1) {
      f <- deque_uint__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && extends(argtypes[2], '_p_unsigned_int') && length(argv[[2]]) == 1) {
      f <- deque_uint__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for deque_uint with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of deque_uint_push_back

`deque_uint_push_back` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_deque_uint_push_back', self, x, PACKAGE='infomap');
  
}

attr(`deque_uint_push_back`, 'returnType') = 'void'
attr(`deque_uint_push_back`, "inputTypes") = c('_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t', '_p_unsigned_int')
class(`deque_uint_push_back`) = c("SWIGFunction", class('deque_uint_push_back'))

# Start of deque_uint_front

`deque_uint_front` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_deque_uint_front', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`deque_uint_front`, 'returnType') = '_p_unsigned_int'
attr(`deque_uint_front`, "inputTypes") = c('_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t')
class(`deque_uint_front`) = c("SWIGFunction", class('deque_uint_front'))

# Start of deque_uint_back

`deque_uint_back` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_deque_uint_back', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`deque_uint_back`, 'returnType') = '_p_unsigned_int'
attr(`deque_uint_back`, "inputTypes") = c('_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t')
class(`deque_uint_back`) = c("SWIGFunction", class('deque_uint_back'))

# Start of deque_uint_assign

`deque_uint_assign` = function(self, n, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_deque_uint_assign', self, n, x, PACKAGE='infomap');
  
}

attr(`deque_uint_assign`, 'returnType') = 'void'
attr(`deque_uint_assign`, "inputTypes") = c('_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t', 'integer', '_p_unsigned_int')
class(`deque_uint_assign`) = c("SWIGFunction", class('deque_uint_assign'))

# Start of deque_uint_resize

`deque_uint_resize__SWIG_1` = function(self, new_size, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_deque_uint_resize__SWIG_1', self, new_size, x, PACKAGE='infomap');
  
}

attr(`deque_uint_resize__SWIG_1`, 'returnType') = 'void'
attr(`deque_uint_resize__SWIG_1`, "inputTypes") = c('_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t', 'integer', '_p_unsigned_int')
class(`deque_uint_resize__SWIG_1`) = c("SWIGFunction", class('deque_uint_resize__SWIG_1'))

`deque_uint_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- deque_uint_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && extends(argtypes[3], '_p_unsigned_int') && length(argv[[3]]) == 1) {
      f <- deque_uint_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for deque_uint_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of deque_uint_pop_front

`deque_uint_pop_front` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_deque_uint_pop_front', self, PACKAGE='infomap');
  
}

attr(`deque_uint_pop_front`, 'returnType') = 'void'
attr(`deque_uint_pop_front`, "inputTypes") = c('_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t')
class(`deque_uint_pop_front`) = c("SWIGFunction", class('deque_uint_pop_front'))

# Start of deque_uint_push_front

`deque_uint_push_front` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_deque_uint_push_front', self, x, PACKAGE='infomap');
  
}

attr(`deque_uint_push_front`, 'returnType') = 'void'
attr(`deque_uint_push_front`, "inputTypes") = c('_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t', '_p_unsigned_int')
class(`deque_uint_push_front`) = c("SWIGFunction", class('deque_uint_push_front'))

# Start of delete_deque_uint

`delete_deque_uint` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_deque_uint', self, PACKAGE='infomap');
  
}

attr(`delete_deque_uint`, 'returnType') = 'void'
attr(`delete_deque_uint`, "inputTypes") = c('_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t')
class(`delete_deque_uint`) = c("SWIGFunction", class('delete_deque_uint'))

# Start of accessor method for std::deque< unsigned int >
setMethod('$', '_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t', function(x, name)

{
  accessorFuns = list('empty' = deque_uint_empty, 'size' = deque_uint_size, 'swap' = deque_uint_swap, 'clear' = deque_uint_clear, 'get_allocator' = deque_uint_get_allocator, 'pop_back' = deque_uint_pop_back, 'resize' = deque_uint_resize, 'push_back' = deque_uint_push_back, 'front' = deque_uint_front, 'back' = deque_uint_back, 'assign' = deque_uint_assign, 'pop_front' = deque_uint_pop_front, 'push_front' = deque_uint_push_front);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::deque< unsigned int >
setMethod('delete', '_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t', function(obj) {delete_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t(obj)})
# Start of new_InfomapIterator

`InfomapIterator__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_InfomapIterator__SWIG_0', PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapIterator", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfomapIterator);
  ans
  
}

attr(`InfomapIterator__SWIG_0`, 'returnType') = '_p_infomap__InfomapIterator'
class(`InfomapIterator__SWIG_0`) = c("SWIGFunction", class('InfomapIterator__SWIG_0'))

# Start of new_InfomapIterator

`InfomapIterator__SWIG_1` = function(nodePointer, moduleIndexLevel)
{
  if (inherits(nodePointer, "ExternalReference")) nodePointer = slot(nodePointer,"ref"); 
  moduleIndexLevel = as.integer(moduleIndexLevel);
  
  if(length(moduleIndexLevel) > 1) {
    warning("using only the first element of moduleIndexLevel");
  };
  
  ;ans = .Call('R_swig_new_InfomapIterator__SWIG_1', nodePointer, moduleIndexLevel, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapIterator", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfomapIterator);
  ans
  
}

attr(`InfomapIterator__SWIG_1`, 'returnType') = '_p_infomap__InfomapIterator'
attr(`InfomapIterator__SWIG_1`, "inputTypes") = c('_p_infomap__InfoNode', 'integer')
class(`InfomapIterator__SWIG_1`) = c("SWIGFunction", class('InfomapIterator__SWIG_1'))

# Start of new_InfomapIterator

`InfomapIterator__SWIG_2` = function(nodePointer)
{
  if (inherits(nodePointer, "ExternalReference")) nodePointer = slot(nodePointer,"ref"); 
  ;ans = .Call('R_swig_new_InfomapIterator__SWIG_2', nodePointer, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapIterator", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfomapIterator);
  ans
  
}

attr(`InfomapIterator__SWIG_2`, 'returnType') = '_p_infomap__InfomapIterator'
attr(`InfomapIterator__SWIG_2`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfomapIterator__SWIG_2`) = c("SWIGFunction", class('InfomapIterator__SWIG_2'))

# Start of new_InfomapIterator

`InfomapIterator__SWIG_3` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_new_InfomapIterator__SWIG_3', other, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapIterator", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfomapIterator);
  ans
  
}

attr(`InfomapIterator__SWIG_3`, 'returnType') = '_p_infomap__InfomapIterator'
attr(`InfomapIterator__SWIG_3`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator__SWIG_3`) = c("SWIGFunction", class('InfomapIterator__SWIG_3'))

`InfomapIterator` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- InfomapIterator__SWIG_0; 
  } else if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]]))) {
      f <- InfomapIterator__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_infomap__InfomapIterator') && length(argv[[1]]) == 1) {
      f <- InfomapIterator__SWIG_3; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- InfomapIterator__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapIterator with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_InfomapIterator

`delete_InfomapIterator` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_InfomapIterator', self, PACKAGE='infomap');
  
}

attr(`delete_InfomapIterator`, 'returnType') = 'void'
attr(`delete_InfomapIterator`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`delete_InfomapIterator`) = c("SWIGFunction", class('delete_InfomapIterator'))

# Start of InfomapIterator_Equal

`InfomapIterator_Equal` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_Equal', self, other, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapIterator", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_Equal`, 'returnType') = '_p_infomap__InfomapIterator'
attr(`InfomapIterator_Equal`, "inputTypes") = c('_p_infomap__InfomapIterator', '_p_infomap__InfomapIterator')
class(`InfomapIterator_Equal`) = c("SWIGFunction", class('InfomapIterator_Equal'))

# Start of InfomapIterator_current

`InfomapIterator_current__SWIG_0` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_current__SWIG_0', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_current__SWIG_0`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapIterator_current__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_current__SWIG_0`) = c("SWIGFunction", class('InfomapIterator_current__SWIG_0'))

# Start of InfomapIterator_current

`InfomapIterator_current__SWIG_1` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_current__SWIG_1', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_current__SWIG_1`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapIterator_current__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_current__SWIG_1`) = c("SWIGFunction", class('InfomapIterator_current__SWIG_1'))

`InfomapIterator_current` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapIterator') || is.null(argv[[1]]))) {
      f <- InfomapIterator_current__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapIterator') || is.null(argv[[1]]))) {
      f <- InfomapIterator_current__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapIterator_current with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapIterator___ref__

`InfomapIterator___ref____SWIG_0` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator___ref____SWIG_0', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapIterator___ref____SWIG_0`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapIterator___ref____SWIG_0`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator___ref____SWIG_0`) = c("SWIGFunction", class('InfomapIterator___ref____SWIG_0'))

# Start of InfomapIterator___ref__

`InfomapIterator___ref____SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator___ref____SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapIterator___ref____SWIG_1`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapIterator___ref____SWIG_1`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator___ref____SWIG_1`) = c("SWIGFunction", class('InfomapIterator___ref____SWIG_1'))

`InfomapIterator___ref__` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapIterator') || is.null(argv[[1]]))) {
      f <- InfomapIterator___ref____SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapIterator') || is.null(argv[[1]]))) {
      f <- InfomapIterator___ref____SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapIterator___ref__ with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapIterator___deref__

`InfomapIterator___deref____SWIG_0` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator___deref____SWIG_0', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapIterator___deref____SWIG_0`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapIterator___deref____SWIG_0`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator___deref____SWIG_0`) = c("SWIGFunction", class('InfomapIterator___deref____SWIG_0'))

# Start of InfomapIterator___deref__

`InfomapIterator___deref____SWIG_1` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator___deref____SWIG_1', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapIterator___deref____SWIG_1`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapIterator___deref____SWIG_1`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator___deref____SWIG_1`) = c("SWIGFunction", class('InfomapIterator___deref____SWIG_1'))

`InfomapIterator___deref__` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapIterator') || is.null(argv[[1]]))) {
      f <- InfomapIterator___deref____SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapIterator') || is.null(argv[[1]]))) {
      f <- InfomapIterator___deref____SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapIterator___deref__ with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapIterator_EqualEqual

`InfomapIterator_EqualEqual` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;.Call('R_swig_InfomapIterator_EqualEqual', self, other, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIterator_EqualEqual`, 'returnType') = 'logical'
attr(`InfomapIterator_EqualEqual`, "inputTypes") = c('_p_infomap__InfomapIterator', '_p_infomap__InfomapIterator')
class(`InfomapIterator_EqualEqual`) = c("SWIGFunction", class('InfomapIterator_EqualEqual'))

# Start of InfomapIterator_NotEqual

`InfomapIterator_NotEqual` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;.Call('R_swig_InfomapIterator_NotEqual', self, other, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIterator_NotEqual`, 'returnType') = 'logical'
attr(`InfomapIterator_NotEqual`, "inputTypes") = c('_p_infomap__InfomapIterator', '_p_infomap__InfomapIterator')
class(`InfomapIterator_NotEqual`) = c("SWIGFunction", class('InfomapIterator_NotEqual'))

# Start of InfomapIterator_PlusPlusPrefix

`InfomapIterator_PlusPlusPrefix` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_PlusPlusPrefix', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapIterator", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_PlusPlusPrefix`, 'returnType') = '_p_infomap__InfomapIterator'
attr(`InfomapIterator_PlusPlusPrefix`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_PlusPlusPrefix`) = c("SWIGFunction", class('InfomapIterator_PlusPlusPrefix'))

# Start of InfomapIterator_PlusPlusPostfix

`InfomapIterator_PlusPlusPostfix` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  ;ans = .Call('R_swig_InfomapIterator_PlusPlusPostfix', self, s_arg2, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapIterator", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_PlusPlusPostfix`, 'returnType') = '_p_infomap__InfomapIterator'
attr(`InfomapIterator_PlusPlusPostfix`, "inputTypes") = c('_p_infomap__InfomapIterator', 'integer')
class(`InfomapIterator_PlusPlusPostfix`) = c("SWIGFunction", class('InfomapIterator_PlusPlusPostfix'))

# Start of InfomapIterator_stepForward

`InfomapIterator_stepForward` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_stepForward', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapIterator", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_stepForward`, 'returnType') = '_p_infomap__InfomapIterator'
attr(`InfomapIterator_stepForward`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_stepForward`) = c("SWIGFunction", class('InfomapIterator_stepForward'))

# Start of InfomapIterator_path

`InfomapIterator_path` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_path', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_path`, 'returnType') = '_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t'
attr(`InfomapIterator_path`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_path`) = c("SWIGFunction", class('InfomapIterator_path'))

# Start of InfomapIterator_moduleIndex

`InfomapIterator_moduleIndex` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_moduleIndex', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIterator_moduleIndex`, 'returnType') = 'integer'
attr(`InfomapIterator_moduleIndex`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_moduleIndex`) = c("SWIGFunction", class('InfomapIterator_moduleIndex'))

# Start of InfomapIterator_moduleId

`InfomapIterator_moduleId` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_moduleId', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIterator_moduleId`, 'returnType') = 'integer'
attr(`InfomapIterator_moduleId`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_moduleId`) = c("SWIGFunction", class('InfomapIterator_moduleId'))

# Start of InfomapIterator_childIndex

`InfomapIterator_childIndex` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_childIndex', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIterator_childIndex`, 'returnType') = 'integer'
attr(`InfomapIterator_childIndex`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_childIndex`) = c("SWIGFunction", class('InfomapIterator_childIndex'))

# Start of InfomapIterator_depth

`InfomapIterator_depth` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_depth', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIterator_depth`, 'returnType') = 'integer'
attr(`InfomapIterator_depth`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_depth`) = c("SWIGFunction", class('InfomapIterator_depth'))

# Start of InfomapIterator_isEnd

`InfomapIterator_isEnd` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_isEnd', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIterator_isEnd`, 'returnType') = 'logical'
attr(`InfomapIterator_isEnd`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_isEnd`) = c("SWIGFunction", class('InfomapIterator_isEnd'))

# Start of InfomapIterator_data_set

`InfomapIterator_data_set` = function(self, s_data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_data, "ExternalReference")) s_data = slot(s_data,"ref"); 
  ;.Call('R_swig_InfomapIterator_data_set', self, s_data, PACKAGE='infomap');
  
}

attr(`InfomapIterator_data_set`, 'returnType') = 'void'
attr(`InfomapIterator_data_set`, "inputTypes") = c('_p_infomap__InfomapIterator', '_p_infomap__FlowData')
class(`InfomapIterator_data_set`) = c("SWIGFunction", class('InfomapIterator_data_set'))

# Start of InfomapIterator_data_get

`InfomapIterator_data_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_data_get', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__FlowData", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_data_get`, 'returnType') = '_p_infomap__FlowData'
attr(`InfomapIterator_data_get`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_data_get`) = c("SWIGFunction", class('InfomapIterator_data_get'))

# Start of InfomapIterator_index_set

`InfomapIterator_index_set` = function(self, s_index)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_index = as.integer(s_index);
  
  if(length(s_index) > 1) {
    warning("using only the first element of s_index");
  };
  
  ;.Call('R_swig_InfomapIterator_index_set', self, s_index, PACKAGE='infomap');
  
}

attr(`InfomapIterator_index_set`, 'returnType') = 'void'
attr(`InfomapIterator_index_set`, "inputTypes") = c('_p_infomap__InfomapIterator', 'integer')
class(`InfomapIterator_index_set`) = c("SWIGFunction", class('InfomapIterator_index_set'))

# Start of InfomapIterator_index_get

`InfomapIterator_index_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_index_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIterator_index_get`, 'returnType') = 'integer'
attr(`InfomapIterator_index_get`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_index_get`) = c("SWIGFunction", class('InfomapIterator_index_get'))

# Start of InfomapIterator_stateId_set

`InfomapIterator_stateId_set` = function(self, s_stateId)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_stateId = as.integer(s_stateId);
  
  if(length(s_stateId) > 1) {
    warning("using only the first element of s_stateId");
  };
  
  ;.Call('R_swig_InfomapIterator_stateId_set', self, s_stateId, PACKAGE='infomap');
  
}

attr(`InfomapIterator_stateId_set`, 'returnType') = 'void'
attr(`InfomapIterator_stateId_set`, "inputTypes") = c('_p_infomap__InfomapIterator', 'integer')
class(`InfomapIterator_stateId_set`) = c("SWIGFunction", class('InfomapIterator_stateId_set'))

# Start of InfomapIterator_stateId_get

`InfomapIterator_stateId_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_stateId_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIterator_stateId_get`, 'returnType') = 'integer'
attr(`InfomapIterator_stateId_get`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_stateId_get`) = c("SWIGFunction", class('InfomapIterator_stateId_get'))

# Start of InfomapIterator_physicalId_set

`InfomapIterator_physicalId_set` = function(self, s_physicalId)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_physicalId = as.integer(s_physicalId);
  
  if(length(s_physicalId) > 1) {
    warning("using only the first element of s_physicalId");
  };
  
  ;.Call('R_swig_InfomapIterator_physicalId_set', self, s_physicalId, PACKAGE='infomap');
  
}

attr(`InfomapIterator_physicalId_set`, 'returnType') = 'void'
attr(`InfomapIterator_physicalId_set`, "inputTypes") = c('_p_infomap__InfomapIterator', 'integer')
class(`InfomapIterator_physicalId_set`) = c("SWIGFunction", class('InfomapIterator_physicalId_set'))

# Start of InfomapIterator_physicalId_get

`InfomapIterator_physicalId_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_physicalId_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIterator_physicalId_get`, 'returnType') = 'integer'
attr(`InfomapIterator_physicalId_get`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_physicalId_get`) = c("SWIGFunction", class('InfomapIterator_physicalId_get'))

# Start of InfomapIterator_layerId_set

`InfomapIterator_layerId_set` = function(self, s_layerId)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_layerId = as.integer(s_layerId);
  
  if(length(s_layerId) > 1) {
    warning("using only the first element of s_layerId");
  };
  
  ;.Call('R_swig_InfomapIterator_layerId_set', self, s_layerId, PACKAGE='infomap');
  
}

attr(`InfomapIterator_layerId_set`, 'returnType') = 'void'
attr(`InfomapIterator_layerId_set`, "inputTypes") = c('_p_infomap__InfomapIterator', 'integer')
class(`InfomapIterator_layerId_set`) = c("SWIGFunction", class('InfomapIterator_layerId_set'))

# Start of InfomapIterator_layerId_get

`InfomapIterator_layerId_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_layerId_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIterator_layerId_get`, 'returnType') = 'integer'
attr(`InfomapIterator_layerId_get`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_layerId_get`) = c("SWIGFunction", class('InfomapIterator_layerId_get'))

# Start of InfomapIterator_metaData_set

`InfomapIterator_metaData_set` = function(self, s_metaData)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_metaData = as.integer(s_metaData);
  ;.Call('R_swig_InfomapIterator_metaData_set', self, s_metaData, PACKAGE='infomap');
  
}

attr(`InfomapIterator_metaData_set`, 'returnType') = 'void'
attr(`InfomapIterator_metaData_set`, "inputTypes") = c('_p_infomap__InfomapIterator', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`InfomapIterator_metaData_set`) = c("SWIGFunction", class('InfomapIterator_metaData_set'))

# Start of InfomapIterator_metaData_get

`InfomapIterator_metaData_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_metaData_get', self, PACKAGE='infomap');
  
}

attr(`InfomapIterator_metaData_get`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`InfomapIterator_metaData_get`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_metaData_get`) = c("SWIGFunction", class('InfomapIterator_metaData_get'))

# Start of InfomapIterator_owner_set

`InfomapIterator_owner_set` = function(self, s_owner)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_owner, "ExternalReference")) s_owner = slot(s_owner,"ref"); 
  ;.Call('R_swig_InfomapIterator_owner_set', self, s_owner, PACKAGE='infomap');
  
}

attr(`InfomapIterator_owner_set`, 'returnType') = 'void'
attr(`InfomapIterator_owner_set`, "inputTypes") = c('_p_infomap__InfomapIterator', '_p_infomap__InfoNode')
class(`InfomapIterator_owner_set`) = c("SWIGFunction", class('InfomapIterator_owner_set'))

# Start of InfomapIterator_owner_get

`InfomapIterator_owner_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_owner_get', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_owner_get`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapIterator_owner_get`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_owner_get`) = c("SWIGFunction", class('InfomapIterator_owner_get'))

# Start of InfomapIterator_parent_set

`InfomapIterator_parent_set` = function(self, s_parent)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_parent, "ExternalReference")) s_parent = slot(s_parent,"ref"); 
  ;.Call('R_swig_InfomapIterator_parent_set', self, s_parent, PACKAGE='infomap');
  
}

attr(`InfomapIterator_parent_set`, 'returnType') = 'void'
attr(`InfomapIterator_parent_set`, "inputTypes") = c('_p_infomap__InfomapIterator', '_p_infomap__InfoNode')
class(`InfomapIterator_parent_set`) = c("SWIGFunction", class('InfomapIterator_parent_set'))

# Start of InfomapIterator_parent_get

`InfomapIterator_parent_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_parent_get', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_parent_get`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapIterator_parent_get`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_parent_get`) = c("SWIGFunction", class('InfomapIterator_parent_get'))

# Start of InfomapIterator_previous_set

`InfomapIterator_previous_set` = function(self, s_previous)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_previous, "ExternalReference")) s_previous = slot(s_previous,"ref"); 
  ;.Call('R_swig_InfomapIterator_previous_set', self, s_previous, PACKAGE='infomap');
  
}

attr(`InfomapIterator_previous_set`, 'returnType') = 'void'
attr(`InfomapIterator_previous_set`, "inputTypes") = c('_p_infomap__InfomapIterator', '_p_infomap__InfoNode')
class(`InfomapIterator_previous_set`) = c("SWIGFunction", class('InfomapIterator_previous_set'))

# Start of InfomapIterator_previous_get

`InfomapIterator_previous_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_previous_get', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_previous_get`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapIterator_previous_get`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_previous_get`) = c("SWIGFunction", class('InfomapIterator_previous_get'))

# Start of InfomapIterator__next_set

`InfomapIterator__next_set` = function(self, s_arg2)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref"); 
  ;.Call('R_swig_InfomapIterator__next_set', self, s_arg2, PACKAGE='infomap');
  
}

attr(`InfomapIterator__next_set`, 'returnType') = 'void'
attr(`InfomapIterator__next_set`, "inputTypes") = c('_p_infomap__InfomapIterator', '_p_infomap__InfoNode')
class(`InfomapIterator__next_set`) = c("SWIGFunction", class('InfomapIterator__next_set'))

# Start of InfomapIterator__next_get

`InfomapIterator__next_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator__next_get', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapIterator__next_get`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapIterator__next_get`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator__next_get`) = c("SWIGFunction", class('InfomapIterator__next_get'))

# Start of InfomapIterator_firstChild_set

`InfomapIterator_firstChild_set` = function(self, s_firstChild)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_firstChild, "ExternalReference")) s_firstChild = slot(s_firstChild,"ref"); 
  ;.Call('R_swig_InfomapIterator_firstChild_set', self, s_firstChild, PACKAGE='infomap');
  
}

attr(`InfomapIterator_firstChild_set`, 'returnType') = 'void'
attr(`InfomapIterator_firstChild_set`, "inputTypes") = c('_p_infomap__InfomapIterator', '_p_infomap__InfoNode')
class(`InfomapIterator_firstChild_set`) = c("SWIGFunction", class('InfomapIterator_firstChild_set'))

# Start of InfomapIterator_firstChild_get

`InfomapIterator_firstChild_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_firstChild_get', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_firstChild_get`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapIterator_firstChild_get`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_firstChild_get`) = c("SWIGFunction", class('InfomapIterator_firstChild_get'))

# Start of InfomapIterator_lastChild_set

`InfomapIterator_lastChild_set` = function(self, s_lastChild)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_lastChild, "ExternalReference")) s_lastChild = slot(s_lastChild,"ref"); 
  ;.Call('R_swig_InfomapIterator_lastChild_set', self, s_lastChild, PACKAGE='infomap');
  
}

attr(`InfomapIterator_lastChild_set`, 'returnType') = 'void'
attr(`InfomapIterator_lastChild_set`, "inputTypes") = c('_p_infomap__InfomapIterator', '_p_infomap__InfoNode')
class(`InfomapIterator_lastChild_set`) = c("SWIGFunction", class('InfomapIterator_lastChild_set'))

# Start of InfomapIterator_lastChild_get

`InfomapIterator_lastChild_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_lastChild_get', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_lastChild_get`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapIterator_lastChild_get`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_lastChild_get`) = c("SWIGFunction", class('InfomapIterator_lastChild_get'))

# Start of InfomapIterator_collapsedFirstChild_set

`InfomapIterator_collapsedFirstChild_set` = function(self, s_collapsedFirstChild)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_collapsedFirstChild, "ExternalReference")) s_collapsedFirstChild = slot(s_collapsedFirstChild,"ref"); 
  ;.Call('R_swig_InfomapIterator_collapsedFirstChild_set', self, s_collapsedFirstChild, PACKAGE='infomap');
  
}

attr(`InfomapIterator_collapsedFirstChild_set`, 'returnType') = 'void'
attr(`InfomapIterator_collapsedFirstChild_set`, "inputTypes") = c('_p_infomap__InfomapIterator', '_p_infomap__InfoNode')
class(`InfomapIterator_collapsedFirstChild_set`) = c("SWIGFunction", class('InfomapIterator_collapsedFirstChild_set'))

# Start of InfomapIterator_collapsedFirstChild_get

`InfomapIterator_collapsedFirstChild_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_collapsedFirstChild_get', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_collapsedFirstChild_get`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapIterator_collapsedFirstChild_get`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_collapsedFirstChild_get`) = c("SWIGFunction", class('InfomapIterator_collapsedFirstChild_get'))

# Start of InfomapIterator_collapsedLastChild_set

`InfomapIterator_collapsedLastChild_set` = function(self, s_collapsedLastChild)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_collapsedLastChild, "ExternalReference")) s_collapsedLastChild = slot(s_collapsedLastChild,"ref"); 
  ;.Call('R_swig_InfomapIterator_collapsedLastChild_set', self, s_collapsedLastChild, PACKAGE='infomap');
  
}

attr(`InfomapIterator_collapsedLastChild_set`, 'returnType') = 'void'
attr(`InfomapIterator_collapsedLastChild_set`, "inputTypes") = c('_p_infomap__InfomapIterator', '_p_infomap__InfoNode')
class(`InfomapIterator_collapsedLastChild_set`) = c("SWIGFunction", class('InfomapIterator_collapsedLastChild_set'))

# Start of InfomapIterator_collapsedLastChild_get

`InfomapIterator_collapsedLastChild_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_collapsedLastChild_get', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_collapsedLastChild_get`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapIterator_collapsedLastChild_get`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_collapsedLastChild_get`) = c("SWIGFunction", class('InfomapIterator_collapsedLastChild_get'))

# Start of InfomapIterator_codelength_set

`InfomapIterator_codelength_set` = function(self, s_codelength)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_InfomapIterator_codelength_set', self, s_codelength, PACKAGE='infomap');
  
}

attr(`InfomapIterator_codelength_set`, 'returnType') = 'void'
attr(`InfomapIterator_codelength_set`, "inputTypes") = c('_p_infomap__InfomapIterator', 'numeric')
class(`InfomapIterator_codelength_set`) = c("SWIGFunction", class('InfomapIterator_codelength_set'))

# Start of InfomapIterator_codelength_get

`InfomapIterator_codelength_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_codelength_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIterator_codelength_get`, 'returnType') = 'numeric'
attr(`InfomapIterator_codelength_get`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_codelength_get`) = c("SWIGFunction", class('InfomapIterator_codelength_get'))

# Start of InfomapIterator_dirty_set

`InfomapIterator_dirty_set` = function(self, s_dirty)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_dirty = as.logical(s_dirty);
  ;.Call('R_swig_InfomapIterator_dirty_set', self, s_dirty, PACKAGE='infomap');
  
}

attr(`InfomapIterator_dirty_set`, 'returnType') = 'void'
attr(`InfomapIterator_dirty_set`, "inputTypes") = c('_p_infomap__InfomapIterator', 'logical')
class(`InfomapIterator_dirty_set`) = c("SWIGFunction", class('InfomapIterator_dirty_set'))

# Start of InfomapIterator_dirty_get

`InfomapIterator_dirty_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_dirty_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIterator_dirty_get`, 'returnType') = 'logical'
attr(`InfomapIterator_dirty_get`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_dirty_get`) = c("SWIGFunction", class('InfomapIterator_dirty_get'))

# Start of InfomapIterator_physicalNodes_set

`InfomapIterator_physicalNodes_set` = function(self, s_physicalNodes)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_physicalNodes, "ExternalReference")) s_physicalNodes = slot(s_physicalNodes,"ref"); 
  ;.Call('R_swig_InfomapIterator_physicalNodes_set', self, s_physicalNodes, PACKAGE='infomap');
  
}

attr(`InfomapIterator_physicalNodes_set`, 'returnType') = 'void'
attr(`InfomapIterator_physicalNodes_set`, "inputTypes") = c('_p_infomap__InfomapIterator', '_p_std__vectorT_infomap__PhysData_std__allocatorT_infomap__PhysData_t_t')
class(`InfomapIterator_physicalNodes_set`) = c("SWIGFunction", class('InfomapIterator_physicalNodes_set'))

# Start of InfomapIterator_physicalNodes_get

`InfomapIterator_physicalNodes_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_physicalNodes_get', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_infomap__PhysData_std__allocatorT_infomap__PhysData_t_t", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_physicalNodes_get`, 'returnType') = '_p_std__vectorT_infomap__PhysData_std__allocatorT_infomap__PhysData_t_t'
attr(`InfomapIterator_physicalNodes_get`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_physicalNodes_get`) = c("SWIGFunction", class('InfomapIterator_physicalNodes_get'))

# Start of InfomapIterator_metaCollection_set

`InfomapIterator_metaCollection_set` = function(self, s_metaCollection)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_metaCollection, "ExternalReference")) s_metaCollection = slot(s_metaCollection,"ref"); 
  ;.Call('R_swig_InfomapIterator_metaCollection_set', self, s_metaCollection, PACKAGE='infomap');
  
}

attr(`InfomapIterator_metaCollection_set`, 'returnType') = 'void'
attr(`InfomapIterator_metaCollection_set`, "inputTypes") = c('_p_infomap__InfomapIterator', '_p_MetaCollection')
class(`InfomapIterator_metaCollection_set`) = c("SWIGFunction", class('InfomapIterator_metaCollection_set'))

# Start of InfomapIterator_metaCollection_get

`InfomapIterator_metaCollection_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_metaCollection_get', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_MetaCollection", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_metaCollection_get`, 'returnType') = '_p_MetaCollection'
attr(`InfomapIterator_metaCollection_get`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_metaCollection_get`) = c("SWIGFunction", class('InfomapIterator_metaCollection_get'))

# Start of InfomapIterator_stateNodes_set

`InfomapIterator_stateNodes_set` = function(self, s_stateNodes)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_stateNodes = as.integer(s_stateNodes);
  ;.Call('R_swig_InfomapIterator_stateNodes_set', self, s_stateNodes, PACKAGE='infomap');
  
}

attr(`InfomapIterator_stateNodes_set`, 'returnType') = 'void'
attr(`InfomapIterator_stateNodes_set`, "inputTypes") = c('_p_infomap__InfomapIterator', 'integer')
class(`InfomapIterator_stateNodes_set`) = c("SWIGFunction", class('InfomapIterator_stateNodes_set'))

# Start of InfomapIterator_stateNodes_get

`InfomapIterator_stateNodes_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_stateNodes_get', self, PACKAGE='infomap');
  
}

attr(`InfomapIterator_stateNodes_get`, 'returnType') = 'integer'
attr(`InfomapIterator_stateNodes_get`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_stateNodes_get`) = c("SWIGFunction", class('InfomapIterator_stateNodes_get'))

# Start of InfomapIterator_getMetaData

`InfomapIterator_getMetaData__SWIG_0` = function(self, dimension, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  dimension = as.integer(dimension);
  
  if(length(dimension) > 1) {
    warning("using only the first element of dimension");
  };
  
  ;.Call('R_swig_InfomapIterator_getMetaData__SWIG_0', self, dimension, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIterator_getMetaData__SWIG_0`, 'returnType') = 'integer'
attr(`InfomapIterator_getMetaData__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapIterator', 'integer')
class(`InfomapIterator_getMetaData__SWIG_0`) = c("SWIGFunction", class('InfomapIterator_getMetaData__SWIG_0'))

# Start of InfomapIterator_getMetaData

`InfomapIterator_getMetaData__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_getMetaData__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIterator_getMetaData__SWIG_1`, 'returnType') = 'integer'
attr(`InfomapIterator_getMetaData__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_getMetaData__SWIG_1`) = c("SWIGFunction", class('InfomapIterator_getMetaData__SWIG_1'))

`InfomapIterator_getMetaData` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapIterator') || is.null(argv[[1]]))) {
      f <- InfomapIterator_getMetaData__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapIterator') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- InfomapIterator_getMetaData__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InfomapIterator_getMetaData with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapIterator_getInfomap

`InfomapIterator_getInfomap` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_getInfomap', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_getInfomap`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfomapIterator_getInfomap`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_getInfomap`) = c("SWIGFunction", class('InfomapIterator_getInfomap'))

# Start of InfomapIterator_setInfomap

`InfomapIterator_setInfomap` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_setInfomap', self, s_arg2, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_setInfomap`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfomapIterator_setInfomap`, "inputTypes") = c('_p_infomap__InfomapIterator', '_p_infomap__InfomapBase')
class(`InfomapIterator_setInfomap`) = c("SWIGFunction", class('InfomapIterator_setInfomap'))

# Start of InfomapIterator_getInfomapRoot

`InfomapIterator_getInfomapRoot__SWIG_0` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_getInfomapRoot__SWIG_0', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_getInfomapRoot__SWIG_0`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapIterator_getInfomapRoot__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_getInfomapRoot__SWIG_0`) = c("SWIGFunction", class('InfomapIterator_getInfomapRoot__SWIG_0'))

# Start of InfomapIterator_getInfomapRoot

`InfomapIterator_getInfomapRoot__SWIG_1` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_getInfomapRoot__SWIG_1', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_getInfomapRoot__SWIG_1`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapIterator_getInfomapRoot__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_getInfomapRoot__SWIG_1`) = c("SWIGFunction", class('InfomapIterator_getInfomapRoot__SWIG_1'))

`InfomapIterator_getInfomapRoot` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapIterator') || is.null(argv[[1]]))) {
      f <- InfomapIterator_getInfomapRoot__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapIterator') || is.null(argv[[1]]))) {
      f <- InfomapIterator_getInfomapRoot__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapIterator_getInfomapRoot with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapIterator_disposeInfomap

`InfomapIterator_disposeInfomap` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_disposeInfomap', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIterator_disposeInfomap`, 'returnType') = 'logical'
attr(`InfomapIterator_disposeInfomap`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_disposeInfomap`) = c("SWIGFunction", class('InfomapIterator_disposeInfomap'))

# Start of InfomapIterator_numPhysicalNodes

`InfomapIterator_numPhysicalNodes` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_numPhysicalNodes', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIterator_numPhysicalNodes`, 'returnType') = 'integer'
attr(`InfomapIterator_numPhysicalNodes`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_numPhysicalNodes`) = c("SWIGFunction", class('InfomapIterator_numPhysicalNodes'))

# Start of InfomapIterator_begin

`InfomapIterator_begin__SWIG_0` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_begin__SWIG_0', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_ChildIteratorT_infomap__InfoNode_p_t", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_begin__SWIG_0`, 'returnType') = '_p_ChildIteratorT_infomap__InfoNode_p_t'
attr(`InfomapIterator_begin__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_begin__SWIG_0`) = c("SWIGFunction", class('InfomapIterator_begin__SWIG_0'))

# Start of InfomapIterator_begin

`InfomapIterator_begin__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_begin__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_ChildIteratorT_infomap__InfoNode_const_p_t", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_begin__SWIG_1`, 'returnType') = '_p_ChildIteratorT_infomap__InfoNode_const_p_t'
attr(`InfomapIterator_begin__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_begin__SWIG_1`) = c("SWIGFunction", class('InfomapIterator_begin__SWIG_1'))

`InfomapIterator_begin` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapIterator') || is.null(argv[[1]]))) {
      f <- InfomapIterator_begin__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapIterator') || is.null(argv[[1]]))) {
      f <- InfomapIterator_begin__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapIterator_begin with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapIterator_end

`InfomapIterator_end__SWIG_0` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_end__SWIG_0', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_ChildIteratorT_infomap__InfoNode_p_t", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_end__SWIG_0`, 'returnType') = '_p_ChildIteratorT_infomap__InfoNode_p_t'
attr(`InfomapIterator_end__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_end__SWIG_0`) = c("SWIGFunction", class('InfomapIterator_end__SWIG_0'))

# Start of InfomapIterator_end

`InfomapIterator_end__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_end__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_ChildIteratorT_infomap__InfoNode_const_p_t", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_end__SWIG_1`, 'returnType') = '_p_ChildIteratorT_infomap__InfoNode_const_p_t'
attr(`InfomapIterator_end__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_end__SWIG_1`) = c("SWIGFunction", class('InfomapIterator_end__SWIG_1'))

`InfomapIterator_end` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapIterator') || is.null(argv[[1]]))) {
      f <- InfomapIterator_end__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapIterator') || is.null(argv[[1]]))) {
      f <- InfomapIterator_end__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapIterator_end with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapIterator_begin_child

`InfomapIterator_begin_child__SWIG_0` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_begin_child__SWIG_0', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_ChildIteratorT_infomap__InfoNode_p_t", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_begin_child__SWIG_0`, 'returnType') = '_p_ChildIteratorT_infomap__InfoNode_p_t'
attr(`InfomapIterator_begin_child__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_begin_child__SWIG_0`) = c("SWIGFunction", class('InfomapIterator_begin_child__SWIG_0'))

# Start of InfomapIterator_begin_child

`InfomapIterator_begin_child__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_begin_child__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_ChildIteratorT_infomap__InfoNode_const_p_t", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_begin_child__SWIG_1`, 'returnType') = '_p_ChildIteratorT_infomap__InfoNode_const_p_t'
attr(`InfomapIterator_begin_child__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_begin_child__SWIG_1`) = c("SWIGFunction", class('InfomapIterator_begin_child__SWIG_1'))

`InfomapIterator_begin_child` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapIterator') || is.null(argv[[1]]))) {
      f <- InfomapIterator_begin_child__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapIterator') || is.null(argv[[1]]))) {
      f <- InfomapIterator_begin_child__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapIterator_begin_child with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapIterator_end_child

`InfomapIterator_end_child__SWIG_0` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_end_child__SWIG_0', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_ChildIteratorT_infomap__InfoNode_p_t", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_end_child__SWIG_0`, 'returnType') = '_p_ChildIteratorT_infomap__InfoNode_p_t'
attr(`InfomapIterator_end_child__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_end_child__SWIG_0`) = c("SWIGFunction", class('InfomapIterator_end_child__SWIG_0'))

# Start of InfomapIterator_end_child

`InfomapIterator_end_child__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_end_child__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_ChildIteratorT_infomap__InfoNode_const_p_t", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_end_child__SWIG_1`, 'returnType') = '_p_ChildIteratorT_infomap__InfoNode_const_p_t'
attr(`InfomapIterator_end_child__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_end_child__SWIG_1`) = c("SWIGFunction", class('InfomapIterator_end_child__SWIG_1'))

`InfomapIterator_end_child` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapIterator') || is.null(argv[[1]]))) {
      f <- InfomapIterator_end_child__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapIterator') || is.null(argv[[1]]))) {
      f <- InfomapIterator_end_child__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapIterator_end_child with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapIterator_children

`InfomapIterator_children__SWIG_0` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_children__SWIG_0', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_IterWrapperT_ChildIteratorT_infomap__InfoNode_p_t_t", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_children__SWIG_0`, 'returnType') = '_p_IterWrapperT_ChildIteratorT_infomap__InfoNode_p_t_t'
attr(`InfomapIterator_children__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_children__SWIG_0`) = c("SWIGFunction", class('InfomapIterator_children__SWIG_0'))

# Start of InfomapIterator_children

`InfomapIterator_children__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_children__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_IterWrapperT_ChildIteratorT_infomap__InfoNode_const_p_t_t", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_children__SWIG_1`, 'returnType') = '_p_IterWrapperT_ChildIteratorT_infomap__InfoNode_const_p_t_t'
attr(`InfomapIterator_children__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_children__SWIG_1`) = c("SWIGFunction", class('InfomapIterator_children__SWIG_1'))

`InfomapIterator_children` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapIterator') || is.null(argv[[1]]))) {
      f <- InfomapIterator_children__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapIterator') || is.null(argv[[1]]))) {
      f <- InfomapIterator_children__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapIterator_children with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapIterator_infomap_children

`InfomapIterator_infomap_children__SWIG_0` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_infomap_children__SWIG_0', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_IterWrapperT_InfomapChildIteratorT_infomap__InfoNode_p_t_t", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_infomap_children__SWIG_0`, 'returnType') = '_p_IterWrapperT_InfomapChildIteratorT_infomap__InfoNode_p_t_t'
attr(`InfomapIterator_infomap_children__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_infomap_children__SWIG_0`) = c("SWIGFunction", class('InfomapIterator_infomap_children__SWIG_0'))

# Start of InfomapIterator_infomap_children

`InfomapIterator_infomap_children__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_infomap_children__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_IterWrapperT_InfomapChildIteratorT_infomap__InfoNode_const_p_t_t", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_infomap_children__SWIG_1`, 'returnType') = '_p_IterWrapperT_InfomapChildIteratorT_infomap__InfoNode_const_p_t_t'
attr(`InfomapIterator_infomap_children__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_infomap_children__SWIG_1`) = c("SWIGFunction", class('InfomapIterator_infomap_children__SWIG_1'))

`InfomapIterator_infomap_children` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapIterator') || is.null(argv[[1]]))) {
      f <- InfomapIterator_infomap_children__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapIterator') || is.null(argv[[1]]))) {
      f <- InfomapIterator_infomap_children__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapIterator_infomap_children with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapIterator_begin_post_depth_first

`InfomapIterator_begin_post_depth_first` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_begin_post_depth_first', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_DepthFirstIteratorT_infomap__InfoNode_p_false_t", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_begin_post_depth_first`, 'returnType') = '_p_DepthFirstIteratorT_infomap__InfoNode_p_false_t'
attr(`InfomapIterator_begin_post_depth_first`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_begin_post_depth_first`) = c("SWIGFunction", class('InfomapIterator_begin_post_depth_first'))

# Start of InfomapIterator_begin_leaf_nodes

`InfomapIterator_begin_leaf_nodes` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_begin_leaf_nodes', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_LeafNodeIteratorT_infomap__InfoNode_p_t", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_begin_leaf_nodes`, 'returnType') = '_p_LeafNodeIteratorT_infomap__InfoNode_p_t'
attr(`InfomapIterator_begin_leaf_nodes`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_begin_leaf_nodes`) = c("SWIGFunction", class('InfomapIterator_begin_leaf_nodes'))

# Start of InfomapIterator_begin_leaf_modules

`InfomapIterator_begin_leaf_modules` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_begin_leaf_modules', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_LeafModuleIteratorT_infomap__InfoNode_p_t", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_begin_leaf_modules`, 'returnType') = '_p_LeafModuleIteratorT_infomap__InfoNode_p_t'
attr(`InfomapIterator_begin_leaf_modules`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_begin_leaf_modules`) = c("SWIGFunction", class('InfomapIterator_begin_leaf_modules'))

# Start of InfomapIterator_begin_tree

`InfomapIterator_begin_tree__SWIG_0` = function(self, maxClusterLevel, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  maxClusterLevel = as.integer(maxClusterLevel);
  
  if(length(maxClusterLevel) > 1) {
    warning("using only the first element of maxClusterLevel");
  };
  
  ;ans = .Call('R_swig_InfomapIterator_begin_tree__SWIG_0', self, maxClusterLevel, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_TreeIteratorT_infomap__InfoNode_p_t", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_begin_tree__SWIG_0`, 'returnType') = '_p_TreeIteratorT_infomap__InfoNode_p_t'
attr(`InfomapIterator_begin_tree__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapIterator', 'integer')
class(`InfomapIterator_begin_tree__SWIG_0`) = c("SWIGFunction", class('InfomapIterator_begin_tree__SWIG_0'))

# Start of InfomapIterator_begin_tree

`InfomapIterator_begin_tree__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_begin_tree__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_TreeIteratorT_infomap__InfoNode_p_t", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_begin_tree__SWIG_1`, 'returnType') = '_p_TreeIteratorT_infomap__InfoNode_p_t'
attr(`InfomapIterator_begin_tree__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_begin_tree__SWIG_1`) = c("SWIGFunction", class('InfomapIterator_begin_tree__SWIG_1'))

# Start of InfomapIterator_begin_tree

`InfomapIterator_begin_tree__SWIG_2` = function(self, maxClusterLevel, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  maxClusterLevel = as.integer(maxClusterLevel);
  
  if(length(maxClusterLevel) > 1) {
    warning("using only the first element of maxClusterLevel");
  };
  
  ;ans = .Call('R_swig_InfomapIterator_begin_tree__SWIG_2', self, maxClusterLevel, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_TreeIteratorT_infomap__InfoNode_const_p_t", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_begin_tree__SWIG_2`, 'returnType') = '_p_TreeIteratorT_infomap__InfoNode_const_p_t'
attr(`InfomapIterator_begin_tree__SWIG_2`, "inputTypes") = c('_p_infomap__InfomapIterator', 'integer')
class(`InfomapIterator_begin_tree__SWIG_2`) = c("SWIGFunction", class('InfomapIterator_begin_tree__SWIG_2'))

# Start of InfomapIterator_begin_tree

`InfomapIterator_begin_tree__SWIG_3` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_begin_tree__SWIG_3', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_TreeIteratorT_infomap__InfoNode_const_p_t", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_begin_tree__SWIG_3`, 'returnType') = '_p_TreeIteratorT_infomap__InfoNode_const_p_t'
attr(`InfomapIterator_begin_tree__SWIG_3`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_begin_tree__SWIG_3`) = c("SWIGFunction", class('InfomapIterator_begin_tree__SWIG_3'))

`InfomapIterator_begin_tree` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapIterator') || is.null(argv[[1]]))) {
      f <- InfomapIterator_begin_tree__SWIG_1; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapIterator') || is.null(argv[[1]]))) {
      f <- InfomapIterator_begin_tree__SWIG_3; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapIterator') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- InfomapIterator_begin_tree__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapIterator') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- InfomapIterator_begin_tree__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for InfomapIterator_begin_tree with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapIterator_end_tree

`InfomapIterator_end_tree__SWIG_0` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_end_tree__SWIG_0', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_TreeIteratorT_infomap__InfoNode_p_t", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_end_tree__SWIG_0`, 'returnType') = '_p_TreeIteratorT_infomap__InfoNode_p_t'
attr(`InfomapIterator_end_tree__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_end_tree__SWIG_0`) = c("SWIGFunction", class('InfomapIterator_end_tree__SWIG_0'))

# Start of InfomapIterator_end_tree

`InfomapIterator_end_tree__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_end_tree__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_TreeIteratorT_infomap__InfoNode_const_p_t", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_end_tree__SWIG_1`, 'returnType') = '_p_TreeIteratorT_infomap__InfoNode_const_p_t'
attr(`InfomapIterator_end_tree__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_end_tree__SWIG_1`) = c("SWIGFunction", class('InfomapIterator_end_tree__SWIG_1'))

`InfomapIterator_end_tree` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapIterator') || is.null(argv[[1]]))) {
      f <- InfomapIterator_end_tree__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapIterator') || is.null(argv[[1]]))) {
      f <- InfomapIterator_end_tree__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapIterator_end_tree with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapIterator_infomapTree

`InfomapIterator_infomapTree__SWIG_0` = function(self, maxClusterLevel, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  maxClusterLevel = as.integer(maxClusterLevel);
  
  if(length(maxClusterLevel) > 1) {
    warning("using only the first element of maxClusterLevel");
  };
  
  ;ans = .Call('R_swig_InfomapIterator_infomapTree__SWIG_0', self, maxClusterLevel, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_p_t_t", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_infomapTree__SWIG_0`, 'returnType') = '_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_p_t_t'
attr(`InfomapIterator_infomapTree__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapIterator', 'integer')
class(`InfomapIterator_infomapTree__SWIG_0`) = c("SWIGFunction", class('InfomapIterator_infomapTree__SWIG_0'))

# Start of InfomapIterator_infomapTree

`InfomapIterator_infomapTree__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_infomapTree__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_p_t_t", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_infomapTree__SWIG_1`, 'returnType') = '_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_p_t_t'
attr(`InfomapIterator_infomapTree__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_infomapTree__SWIG_1`) = c("SWIGFunction", class('InfomapIterator_infomapTree__SWIG_1'))

# Start of InfomapIterator_infomapTree

`InfomapIterator_infomapTree__SWIG_2` = function(self, maxClusterLevel, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  maxClusterLevel = as.integer(maxClusterLevel);
  
  if(length(maxClusterLevel) > 1) {
    warning("using only the first element of maxClusterLevel");
  };
  
  ;ans = .Call('R_swig_InfomapIterator_infomapTree__SWIG_2', self, maxClusterLevel, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_const_p_t_t", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_infomapTree__SWIG_2`, 'returnType') = '_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_const_p_t_t'
attr(`InfomapIterator_infomapTree__SWIG_2`, "inputTypes") = c('_p_infomap__InfomapIterator', 'integer')
class(`InfomapIterator_infomapTree__SWIG_2`) = c("SWIGFunction", class('InfomapIterator_infomapTree__SWIG_2'))

# Start of InfomapIterator_infomapTree

`InfomapIterator_infomapTree__SWIG_3` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_infomapTree__SWIG_3', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_const_p_t_t", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_infomapTree__SWIG_3`, 'returnType') = '_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_const_p_t_t'
attr(`InfomapIterator_infomapTree__SWIG_3`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_infomapTree__SWIG_3`) = c("SWIGFunction", class('InfomapIterator_infomapTree__SWIG_3'))

`InfomapIterator_infomapTree` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapIterator') || is.null(argv[[1]]))) {
      f <- InfomapIterator_infomapTree__SWIG_1; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapIterator') || is.null(argv[[1]]))) {
      f <- InfomapIterator_infomapTree__SWIG_3; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapIterator') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- InfomapIterator_infomapTree__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapIterator') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- InfomapIterator_infomapTree__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for InfomapIterator_infomapTree with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapIterator_begin_outEdge

`InfomapIterator_begin_outEdge` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_begin_outEdge', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_begin_outEdge`, 'returnType') = '_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator'
attr(`InfomapIterator_begin_outEdge`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_begin_outEdge`) = c("SWIGFunction", class('InfomapIterator_begin_outEdge'))

# Start of InfomapIterator_end_outEdge

`InfomapIterator_end_outEdge` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_end_outEdge', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_end_outEdge`, 'returnType') = '_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator'
attr(`InfomapIterator_end_outEdge`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_end_outEdge`) = c("SWIGFunction", class('InfomapIterator_end_outEdge'))

# Start of InfomapIterator_begin_inEdge

`InfomapIterator_begin_inEdge` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_begin_inEdge', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_begin_inEdge`, 'returnType') = '_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator'
attr(`InfomapIterator_begin_inEdge`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_begin_inEdge`) = c("SWIGFunction", class('InfomapIterator_begin_inEdge'))

# Start of InfomapIterator_end_inEdge

`InfomapIterator_end_inEdge` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_end_inEdge', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_end_inEdge`, 'returnType') = '_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator'
attr(`InfomapIterator_end_inEdge`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_end_inEdge`) = c("SWIGFunction", class('InfomapIterator_end_inEdge'))

# Start of InfomapIterator_outEdges

`InfomapIterator_outEdges` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_outEdges', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_IterWrapperT_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator_t", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_outEdges`, 'returnType') = '_p_IterWrapperT_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator_t'
attr(`InfomapIterator_outEdges`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_outEdges`) = c("SWIGFunction", class('InfomapIterator_outEdges'))

# Start of InfomapIterator_inEdges

`InfomapIterator_inEdges` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_inEdges', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_IterWrapperT_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator_t", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_inEdges`, 'returnType') = '_p_IterWrapperT_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator_t'
attr(`InfomapIterator_inEdges`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_inEdges`) = c("SWIGFunction", class('InfomapIterator_inEdges'))

# Start of InfomapIterator_childDegree

`InfomapIterator_childDegree` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_childDegree', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIterator_childDegree`, 'returnType') = 'integer'
attr(`InfomapIterator_childDegree`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_childDegree`) = c("SWIGFunction", class('InfomapIterator_childDegree'))

# Start of InfomapIterator_isLeaf

`InfomapIterator_isLeaf` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_isLeaf', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIterator_isLeaf`, 'returnType') = 'logical'
attr(`InfomapIterator_isLeaf`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_isLeaf`) = c("SWIGFunction", class('InfomapIterator_isLeaf'))

# Start of InfomapIterator_isLeafModule

`InfomapIterator_isLeafModule` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_isLeafModule', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIterator_isLeafModule`, 'returnType') = 'logical'
attr(`InfomapIterator_isLeafModule`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_isLeafModule`) = c("SWIGFunction", class('InfomapIterator_isLeafModule'))

# Start of InfomapIterator_isRoot

`InfomapIterator_isRoot` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_isRoot', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIterator_isRoot`, 'returnType') = 'logical'
attr(`InfomapIterator_isRoot`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_isRoot`) = c("SWIGFunction", class('InfomapIterator_isRoot'))

# Start of InfomapIterator_firstDepthBelow

`InfomapIterator_firstDepthBelow` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_firstDepthBelow', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIterator_firstDepthBelow`, 'returnType') = 'integer'
attr(`InfomapIterator_firstDepthBelow`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_firstDepthBelow`) = c("SWIGFunction", class('InfomapIterator_firstDepthBelow'))

# Start of InfomapIterator_numLeafMembers

`InfomapIterator_numLeafMembers` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_numLeafMembers', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIterator_numLeafMembers`, 'returnType') = 'integer'
attr(`InfomapIterator_numLeafMembers`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_numLeafMembers`) = c("SWIGFunction", class('InfomapIterator_numLeafMembers'))

# Start of InfomapIterator_isDangling

`InfomapIterator_isDangling` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_isDangling', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIterator_isDangling`, 'returnType') = 'logical'
attr(`InfomapIterator_isDangling`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_isDangling`) = c("SWIGFunction", class('InfomapIterator_isDangling'))

# Start of InfomapIterator_outDegree

`InfomapIterator_outDegree` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_outDegree', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIterator_outDegree`, 'returnType') = 'integer'
attr(`InfomapIterator_outDegree`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_outDegree`) = c("SWIGFunction", class('InfomapIterator_outDegree'))

# Start of InfomapIterator_inDegree

`InfomapIterator_inDegree` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_inDegree', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIterator_inDegree`, 'returnType') = 'integer'
attr(`InfomapIterator_inDegree`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_inDegree`) = c("SWIGFunction", class('InfomapIterator_inDegree'))

# Start of InfomapIterator_degree

`InfomapIterator_degree` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_degree', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIterator_degree`, 'returnType') = 'integer'
attr(`InfomapIterator_degree`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_degree`) = c("SWIGFunction", class('InfomapIterator_degree'))

# Start of InfomapIterator_isFirst

`InfomapIterator_isFirst` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_isFirst', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIterator_isFirst`, 'returnType') = 'logical'
attr(`InfomapIterator_isFirst`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_isFirst`) = c("SWIGFunction", class('InfomapIterator_isFirst'))

# Start of InfomapIterator_isLast

`InfomapIterator_isLast` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_isLast', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIterator_isLast`, 'returnType') = 'logical'
attr(`InfomapIterator_isLast`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_isLast`) = c("SWIGFunction", class('InfomapIterator_isLast'))

# Start of InfomapIterator_calculatePath

`InfomapIterator_calculatePath` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_calculatePath', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIterator_calculatePath`, 'returnType') = 'integer'
attr(`InfomapIterator_calculatePath`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_calculatePath`) = c("SWIGFunction", class('InfomapIterator_calculatePath'))

# Start of InfomapIterator_infomapChildDegree

`InfomapIterator_infomapChildDegree` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_infomapChildDegree', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIterator_infomapChildDegree`, 'returnType') = 'integer'
attr(`InfomapIterator_infomapChildDegree`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_infomapChildDegree`) = c("SWIGFunction", class('InfomapIterator_infomapChildDegree'))

# Start of InfomapIterator_id

`InfomapIterator_id` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_id', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIterator_id`, 'returnType') = 'integer'
attr(`InfomapIterator_id`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_id`) = c("SWIGFunction", class('InfomapIterator_id'))

# Start of InfomapIterator_initClean

`InfomapIterator_initClean` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_initClean', self, PACKAGE='infomap');
  
}

attr(`InfomapIterator_initClean`, 'returnType') = 'void'
attr(`InfomapIterator_initClean`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_initClean`) = c("SWIGFunction", class('InfomapIterator_initClean'))

# Start of InfomapIterator_sortChildrenOnFlow

`InfomapIterator_sortChildrenOnFlow__SWIG_0` = function(self, recurse)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  recurse = as.logical(recurse);
  ;.Call('R_swig_InfomapIterator_sortChildrenOnFlow__SWIG_0', self, recurse, PACKAGE='infomap');
  
}

attr(`InfomapIterator_sortChildrenOnFlow__SWIG_0`, 'returnType') = 'void'
attr(`InfomapIterator_sortChildrenOnFlow__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapIterator', 'logical')
class(`InfomapIterator_sortChildrenOnFlow__SWIG_0`) = c("SWIGFunction", class('InfomapIterator_sortChildrenOnFlow__SWIG_0'))

# Start of InfomapIterator_sortChildrenOnFlow

`InfomapIterator_sortChildrenOnFlow__SWIG_1` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_sortChildrenOnFlow__SWIG_1', self, PACKAGE='infomap');
  
}

attr(`InfomapIterator_sortChildrenOnFlow__SWIG_1`, 'returnType') = 'void'
attr(`InfomapIterator_sortChildrenOnFlow__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_sortChildrenOnFlow__SWIG_1`) = c("SWIGFunction", class('InfomapIterator_sortChildrenOnFlow__SWIG_1'))

`InfomapIterator_sortChildrenOnFlow` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapIterator') || is.null(argv[[1]]))) {
      f <- InfomapIterator_sortChildrenOnFlow__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapIterator') || is.null(argv[[1]])) && ( is.logical(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- InfomapIterator_sortChildrenOnFlow__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InfomapIterator_sortChildrenOnFlow with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapIterator_collapseChildren

`InfomapIterator_collapseChildren` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_collapseChildren', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIterator_collapseChildren`, 'returnType') = 'integer'
attr(`InfomapIterator_collapseChildren`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_collapseChildren`) = c("SWIGFunction", class('InfomapIterator_collapseChildren'))

# Start of InfomapIterator_expandChildren

`InfomapIterator_expandChildren` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_expandChildren', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIterator_expandChildren`, 'returnType') = 'integer'
attr(`InfomapIterator_expandChildren`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_expandChildren`) = c("SWIGFunction", class('InfomapIterator_expandChildren'))

# Start of InfomapIterator_setChildDegree

`InfomapIterator_setChildDegree` = function(self, value)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  value = as.integer(value);
  
  if(length(value) > 1) {
    warning("using only the first element of value");
  };
  
  ;.Call('R_swig_InfomapIterator_setChildDegree', self, value, PACKAGE='infomap');
  
}

attr(`InfomapIterator_setChildDegree`, 'returnType') = 'void'
attr(`InfomapIterator_setChildDegree`, "inputTypes") = c('_p_infomap__InfomapIterator', 'integer')
class(`InfomapIterator_setChildDegree`) = c("SWIGFunction", class('InfomapIterator_setChildDegree'))

# Start of InfomapIterator_setNumLeafNodes

`InfomapIterator_setNumLeafNodes` = function(self, value)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  value = as.integer(value);
  
  if(length(value) > 1) {
    warning("using only the first element of value");
  };
  
  ;.Call('R_swig_InfomapIterator_setNumLeafNodes', self, value, PACKAGE='infomap');
  
}

attr(`InfomapIterator_setNumLeafNodes`, 'returnType') = 'void'
attr(`InfomapIterator_setNumLeafNodes`, "inputTypes") = c('_p_infomap__InfomapIterator', 'integer')
class(`InfomapIterator_setNumLeafNodes`) = c("SWIGFunction", class('InfomapIterator_setNumLeafNodes'))

# Start of InfomapIterator_addChild

`InfomapIterator_addChild` = function(self, child)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(child, "ExternalReference")) child = slot(child,"ref"); 
  ;.Call('R_swig_InfomapIterator_addChild', self, child, PACKAGE='infomap');
  
}

attr(`InfomapIterator_addChild`, 'returnType') = 'void'
attr(`InfomapIterator_addChild`, "inputTypes") = c('_p_infomap__InfomapIterator', '_p_infomap__InfoNode')
class(`InfomapIterator_addChild`) = c("SWIGFunction", class('InfomapIterator_addChild'))

# Start of InfomapIterator_releaseChildren

`InfomapIterator_releaseChildren` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_releaseChildren', self, PACKAGE='infomap');
  
}

attr(`InfomapIterator_releaseChildren`, 'returnType') = 'void'
attr(`InfomapIterator_releaseChildren`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_releaseChildren`) = c("SWIGFunction", class('InfomapIterator_releaseChildren'))

# Start of InfomapIterator_replaceChildrenWithOneNode

`InfomapIterator_replaceChildrenWithOneNode` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIterator_replaceChildrenWithOneNode', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_replaceChildrenWithOneNode`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapIterator_replaceChildrenWithOneNode`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_replaceChildrenWithOneNode`) = c("SWIGFunction", class('InfomapIterator_replaceChildrenWithOneNode'))

# Start of InfomapIterator_replaceWithChildren

`InfomapIterator_replaceWithChildren` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_replaceWithChildren', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIterator_replaceWithChildren`, 'returnType') = 'integer'
attr(`InfomapIterator_replaceWithChildren`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_replaceWithChildren`) = c("SWIGFunction", class('InfomapIterator_replaceWithChildren'))

# Start of InfomapIterator_replaceWithChildrenDebug

`InfomapIterator_replaceWithChildrenDebug` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_replaceWithChildrenDebug', self, PACKAGE='infomap');
  
}

attr(`InfomapIterator_replaceWithChildrenDebug`, 'returnType') = 'void'
attr(`InfomapIterator_replaceWithChildrenDebug`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_replaceWithChildrenDebug`) = c("SWIGFunction", class('InfomapIterator_replaceWithChildrenDebug'))

# Start of InfomapIterator_replaceChildrenWithGrandChildren

`InfomapIterator_replaceChildrenWithGrandChildren` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_replaceChildrenWithGrandChildren', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIterator_replaceChildrenWithGrandChildren`, 'returnType') = 'integer'
attr(`InfomapIterator_replaceChildrenWithGrandChildren`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_replaceChildrenWithGrandChildren`) = c("SWIGFunction", class('InfomapIterator_replaceChildrenWithGrandChildren'))

# Start of InfomapIterator_replaceChildrenWithGrandChildrenDebug

`InfomapIterator_replaceChildrenWithGrandChildrenDebug` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_replaceChildrenWithGrandChildrenDebug', self, PACKAGE='infomap');
  
}

attr(`InfomapIterator_replaceChildrenWithGrandChildrenDebug`, 'returnType') = 'void'
attr(`InfomapIterator_replaceChildrenWithGrandChildrenDebug`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_replaceChildrenWithGrandChildrenDebug`) = c("SWIGFunction", class('InfomapIterator_replaceChildrenWithGrandChildrenDebug'))

# Start of InfomapIterator_remove

`InfomapIterator_remove` = function(self, removeChildren)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  removeChildren = as.logical(removeChildren);
  ;.Call('R_swig_InfomapIterator_remove', self, removeChildren, PACKAGE='infomap');
  
}

attr(`InfomapIterator_remove`, 'returnType') = 'void'
attr(`InfomapIterator_remove`, "inputTypes") = c('_p_infomap__InfomapIterator', 'logical')
class(`InfomapIterator_remove`) = c("SWIGFunction", class('InfomapIterator_remove'))

# Start of InfomapIterator_deleteChildren

`InfomapIterator_deleteChildren` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIterator_deleteChildren', self, PACKAGE='infomap');
  
}

attr(`InfomapIterator_deleteChildren`, 'returnType') = 'void'
attr(`InfomapIterator_deleteChildren`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIterator_deleteChildren`) = c("SWIGFunction", class('InfomapIterator_deleteChildren'))

# Start of InfomapIterator_addOutEdge

`InfomapIterator_addOutEdge__SWIG_0` = function(self, target, weight, flow)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(target, "ExternalReference")) target = slot(target,"ref"); 
  
  
  ;ans = .Call('R_swig_InfomapIterator_addOutEdge__SWIG_0', self, target, weight, flow, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_EdgeT_infomap__InfoNode_t", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_addOutEdge__SWIG_0`, 'returnType') = '_p_EdgeT_infomap__InfoNode_t'
attr(`InfomapIterator_addOutEdge__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapIterator', '_p_infomap__InfoNode', 'numeric', 'numeric')
class(`InfomapIterator_addOutEdge__SWIG_0`) = c("SWIGFunction", class('InfomapIterator_addOutEdge__SWIG_0'))

# Start of InfomapIterator_addOutEdge

`InfomapIterator_addOutEdge__SWIG_1` = function(self, target, weight)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(target, "ExternalReference")) target = slot(target,"ref"); 
  
  ;ans = .Call('R_swig_InfomapIterator_addOutEdge__SWIG_1', self, target, weight, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_EdgeT_infomap__InfoNode_t", ref=ans);
  
  ans
  
}

attr(`InfomapIterator_addOutEdge__SWIG_1`, 'returnType') = '_p_EdgeT_infomap__InfoNode_t'
attr(`InfomapIterator_addOutEdge__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapIterator', '_p_infomap__InfoNode', 'numeric')
class(`InfomapIterator_addOutEdge__SWIG_1`) = c("SWIGFunction", class('InfomapIterator_addOutEdge__SWIG_1'))

`InfomapIterator_addOutEdge` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 3) {
    if ((extends(argtypes[1], '_p_infomap__InfomapIterator') || is.null(argv[[1]])) && extends(argtypes[2], '_p_infomap__InfoNode') && length(argv[[2]]) == 1 && ( is.numeric(argv[[3]]) && length(argv[[3]]) == 1 )) {
      f <- InfomapIterator_addOutEdge__SWIG_1; 
    }
  } else if (argc == 4) {
    if ((extends(argtypes[1], '_p_infomap__InfomapIterator') || is.null(argv[[1]])) && extends(argtypes[2], '_p_infomap__InfoNode') && length(argv[[2]]) == 1 && ( is.numeric(argv[[3]]) && length(argv[[3]]) == 1 ) && ( is.numeric(argv[[4]]) && length(argv[[4]]) == 1 )) {
      f <- InfomapIterator_addOutEdge__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InfomapIterator_addOutEdge with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of accessor method for infomap::InfomapIterator
setMethod('$', '_p_infomap__InfomapIterator', function(x, name)

{
  accessorFuns = list('Equal' = InfomapIterator_Equal, 'current' = InfomapIterator_current, '__ref__' = InfomapIterator___ref__, '__deref__' = InfomapIterator___deref__, 'EqualEqual' = InfomapIterator_EqualEqual, 'NotEqual' = InfomapIterator_NotEqual, 'PlusPlusPrefix' = InfomapIterator_PlusPlusPrefix, 'PlusPlusPostfix' = InfomapIterator_PlusPlusPostfix, 'stepForward' = InfomapIterator_stepForward, 'path' = InfomapIterator_path, 'moduleIndex' = InfomapIterator_moduleIndex, 'moduleId' = InfomapIterator_moduleId, 'childIndex' = InfomapIterator_childIndex, 'depth' = InfomapIterator_depth, 'isEnd' = InfomapIterator_isEnd, 'data' = InfomapIterator_data_get, 'index' = InfomapIterator_index_get, 'stateId' = InfomapIterator_stateId_get, 'physicalId' = InfomapIterator_physicalId_get, 'layerId' = InfomapIterator_layerId_get, 'metaData' = InfomapIterator_metaData_get, 'owner' = InfomapIterator_owner_get, 'parent' = InfomapIterator_parent_get, 'previous' = InfomapIterator_previous_get, '_next' = InfomapIterator__next_get, 'firstChild' = InfomapIterator_firstChild_get, 'lastChild' = InfomapIterator_lastChild_get, 'collapsedFirstChild' = InfomapIterator_collapsedFirstChild_get, 'collapsedLastChild' = InfomapIterator_collapsedLastChild_get, 'codelength' = InfomapIterator_codelength_get, 'dirty' = InfomapIterator_dirty_get, 'physicalNodes' = InfomapIterator_physicalNodes_get, 'metaCollection' = InfomapIterator_metaCollection_get, 'stateNodes' = InfomapIterator_stateNodes_get, 'getMetaData' = InfomapIterator_getMetaData, 'getInfomap' = InfomapIterator_getInfomap, 'setInfomap' = InfomapIterator_setInfomap, 'getInfomapRoot' = InfomapIterator_getInfomapRoot, 'disposeInfomap' = InfomapIterator_disposeInfomap, 'numPhysicalNodes' = InfomapIterator_numPhysicalNodes, 'begin' = InfomapIterator_begin, 'end' = InfomapIterator_end, 'begin_child' = InfomapIterator_begin_child, 'end_child' = InfomapIterator_end_child, 'children' = InfomapIterator_children, 'infomap_children' = InfomapIterator_infomap_children, 'begin_post_depth_first' = InfomapIterator_begin_post_depth_first, 'begin_leaf_nodes' = InfomapIterator_begin_leaf_nodes, 'begin_leaf_modules' = InfomapIterator_begin_leaf_modules, 'begin_tree' = InfomapIterator_begin_tree, 'end_tree' = InfomapIterator_end_tree, 'infomapTree' = InfomapIterator_infomapTree, 'begin_outEdge' = InfomapIterator_begin_outEdge, 'end_outEdge' = InfomapIterator_end_outEdge, 'begin_inEdge' = InfomapIterator_begin_inEdge, 'end_inEdge' = InfomapIterator_end_inEdge, 'outEdges' = InfomapIterator_outEdges, 'inEdges' = InfomapIterator_inEdges, 'childDegree' = InfomapIterator_childDegree, 'isLeaf' = InfomapIterator_isLeaf, 'isLeafModule' = InfomapIterator_isLeafModule, 'isRoot' = InfomapIterator_isRoot, 'firstDepthBelow' = InfomapIterator_firstDepthBelow, 'numLeafMembers' = InfomapIterator_numLeafMembers, 'isDangling' = InfomapIterator_isDangling, 'outDegree' = InfomapIterator_outDegree, 'inDegree' = InfomapIterator_inDegree, 'degree' = InfomapIterator_degree, 'isFirst' = InfomapIterator_isFirst, 'isLast' = InfomapIterator_isLast, 'calculatePath' = InfomapIterator_calculatePath, 'infomapChildDegree' = InfomapIterator_infomapChildDegree, 'id' = InfomapIterator_id, 'initClean' = InfomapIterator_initClean, 'sortChildrenOnFlow' = InfomapIterator_sortChildrenOnFlow, 'collapseChildren' = InfomapIterator_collapseChildren, 'expandChildren' = InfomapIterator_expandChildren, 'setChildDegree' = InfomapIterator_setChildDegree, 'setNumLeafNodes' = InfomapIterator_setNumLeafNodes, 'addChild' = InfomapIterator_addChild, 'releaseChildren' = InfomapIterator_releaseChildren, 'replaceChildrenWithOneNode' = InfomapIterator_replaceChildrenWithOneNode, 'replaceWithChildren' = InfomapIterator_replaceWithChildren, 'replaceWithChildrenDebug' = InfomapIterator_replaceWithChildrenDebug, 'replaceChildrenWithGrandChildren' = InfomapIterator_replaceChildrenWithGrandChildren, 'replaceChildrenWithGrandChildrenDebug' = InfomapIterator_replaceChildrenWithGrandChildrenDebug, 'remove' = InfomapIterator_remove, 'deleteChildren' = InfomapIterator_deleteChildren, 'addOutEdge' = InfomapIterator_addOutEdge);
  vaccessors = c('data', 'index', 'stateId', 'physicalId', 'layerId', 'metaData', 'owner', 'parent', 'previous', '_next', 'firstChild', 'lastChild', 'collapsedFirstChild', 'collapsedLastChild', 'codelength', 'dirty', 'physicalNodes', 'metaCollection', 'stateNodes');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for infomap::InfomapIterator
# Start of accessor method for infomap::InfomapIterator
setMethod('$<-', '_p_infomap__InfomapIterator', function(x, name, value)

{
  accessorFuns = list('data' = InfomapIterator_data_set, 'index' = InfomapIterator_index_set, 'stateId' = InfomapIterator_stateId_set, 'physicalId' = InfomapIterator_physicalId_set, 'layerId' = InfomapIterator_layerId_set, 'metaData' = InfomapIterator_metaData_set, 'owner' = InfomapIterator_owner_set, 'parent' = InfomapIterator_parent_set, 'previous' = InfomapIterator_previous_set, '_next' = InfomapIterator__next_set, 'firstChild' = InfomapIterator_firstChild_set, 'lastChild' = InfomapIterator_lastChild_set, 'collapsedFirstChild' = InfomapIterator_collapsedFirstChild_set, 'collapsedLastChild' = InfomapIterator_collapsedLastChild_set, 'codelength' = InfomapIterator_codelength_set, 'dirty' = InfomapIterator_dirty_set, 'physicalNodes' = InfomapIterator_physicalNodes_set, 'metaCollection' = InfomapIterator_metaCollection_set, 'stateNodes' = InfomapIterator_stateNodes_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_infomap__InfomapIterator', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('data' = InfomapIterator_data_set, 'index' = InfomapIterator_index_set, 'stateId' = InfomapIterator_stateId_set, 'physicalId' = InfomapIterator_physicalId_set, 'layerId' = InfomapIterator_layerId_set, 'metaData' = InfomapIterator_metaData_set, 'owner' = InfomapIterator_owner_set, 'parent' = InfomapIterator_parent_set, 'previous' = InfomapIterator_previous_set, '_next' = InfomapIterator__next_set, 'firstChild' = InfomapIterator_firstChild_set, 'lastChild' = InfomapIterator_lastChild_set, 'collapsedFirstChild' = InfomapIterator_collapsedFirstChild_set, 'collapsedLastChild' = InfomapIterator_collapsedLastChild_set, 'codelength' = InfomapIterator_codelength_set, 'dirty' = InfomapIterator_dirty_set, 'physicalNodes' = InfomapIterator_physicalNodes_set, 'metaCollection' = InfomapIterator_metaCollection_set, 'stateNodes' = InfomapIterator_stateNodes_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for infomap::InfomapIterator
setMethod('delete', '_p_infomap__InfomapIterator', function(obj) {delete_infomap__InfomapIterator(obj)})
# Start definition of copy functions & methods for infomap::InfomapIterator
CopyToR_infomap__InfomapIterator = function(value, obj = new("infomap::InfomapIterator"))
{
  obj@m_moduleIndexLevel = value$m_moduleIndexLevel;
  obj@m_moduleIndex = value$m_moduleIndex;
  obj@m_depth = value$m_depth;
  obj;
}



CopyToC_infomap__InfomapIterator = function(value, obj)
{
  obj$m_moduleIndexLevel = value@m_moduleIndexLevel;
  obj$m_moduleIndex = value@m_moduleIndex;
  obj$m_depth = value@m_depth;
  obj
}



# Start definition of copy methods for infomap::InfomapIterator
setMethod('copyToR', '_p_infomap::InfomapIterator', CopyToR_infomap__InfomapIterator);
setMethod('copyToC', 'infomap::InfomapIterator', CopyToC_infomap__InfomapIterator);

# End definition of copy methods for infomap::InfomapIterator
# End definition of copy functions & methods for infomap::InfomapIterator
# Start of new_InfomapModuleIterator

`InfomapModuleIterator__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_InfomapModuleIterator__SWIG_0', PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapModuleIterator", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfomapModuleIterator);
  ans
  
}

attr(`InfomapModuleIterator__SWIG_0`, 'returnType') = '_p_infomap__InfomapModuleIterator'
class(`InfomapModuleIterator__SWIG_0`) = c("SWIGFunction", class('InfomapModuleIterator__SWIG_0'))

# Start of new_InfomapModuleIterator

`InfomapModuleIterator__SWIG_1` = function(nodePointer, moduleIndexLevel)
{
  if (inherits(nodePointer, "ExternalReference")) nodePointer = slot(nodePointer,"ref"); 
  moduleIndexLevel = as.integer(moduleIndexLevel);
  
  if(length(moduleIndexLevel) > 1) {
    warning("using only the first element of moduleIndexLevel");
  };
  
  ;ans = .Call('R_swig_new_InfomapModuleIterator__SWIG_1', nodePointer, moduleIndexLevel, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapModuleIterator", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfomapModuleIterator);
  ans
  
}

attr(`InfomapModuleIterator__SWIG_1`, 'returnType') = '_p_infomap__InfomapModuleIterator'
attr(`InfomapModuleIterator__SWIG_1`, "inputTypes") = c('_p_infomap__InfoNode', 'integer')
class(`InfomapModuleIterator__SWIG_1`) = c("SWIGFunction", class('InfomapModuleIterator__SWIG_1'))

# Start of new_InfomapModuleIterator

`InfomapModuleIterator__SWIG_2` = function(nodePointer)
{
  if (inherits(nodePointer, "ExternalReference")) nodePointer = slot(nodePointer,"ref"); 
  ;ans = .Call('R_swig_new_InfomapModuleIterator__SWIG_2', nodePointer, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapModuleIterator", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfomapModuleIterator);
  ans
  
}

attr(`InfomapModuleIterator__SWIG_2`, 'returnType') = '_p_infomap__InfomapModuleIterator'
attr(`InfomapModuleIterator__SWIG_2`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfomapModuleIterator__SWIG_2`) = c("SWIGFunction", class('InfomapModuleIterator__SWIG_2'))

# Start of new_InfomapModuleIterator

`InfomapModuleIterator__SWIG_3` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_new_InfomapModuleIterator__SWIG_3', other, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapModuleIterator", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfomapModuleIterator);
  ans
  
}

attr(`InfomapModuleIterator__SWIG_3`, 'returnType') = '_p_infomap__InfomapModuleIterator'
attr(`InfomapModuleIterator__SWIG_3`, "inputTypes") = c('_p_infomap__InfomapModuleIterator')
class(`InfomapModuleIterator__SWIG_3`) = c("SWIGFunction", class('InfomapModuleIterator__SWIG_3'))

`InfomapModuleIterator` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- InfomapModuleIterator__SWIG_0; 
  } else if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]]))) {
      f <- InfomapModuleIterator__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_infomap__InfomapModuleIterator') && length(argv[[1]]) == 1) {
      f <- InfomapModuleIterator__SWIG_3; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- InfomapModuleIterator__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapModuleIterator with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapModuleIterator_Equal

`InfomapModuleIterator_Equal` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_InfomapModuleIterator_Equal', self, other, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapModuleIterator", ref=ans);
  
  ans
  
}

attr(`InfomapModuleIterator_Equal`, 'returnType') = '_p_infomap__InfomapModuleIterator'
attr(`InfomapModuleIterator_Equal`, "inputTypes") = c('_p_infomap__InfomapModuleIterator', '_p_infomap__InfomapModuleIterator')
class(`InfomapModuleIterator_Equal`) = c("SWIGFunction", class('InfomapModuleIterator_Equal'))

# Start of InfomapModuleIterator_PlusPlusPrefix

`InfomapModuleIterator_PlusPlusPrefix` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapModuleIterator_PlusPlusPrefix', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapIterator", ref=ans);
  
  ans
  
}

attr(`InfomapModuleIterator_PlusPlusPrefix`, 'returnType') = '_p_infomap__InfomapIterator'
attr(`InfomapModuleIterator_PlusPlusPrefix`, "inputTypes") = c('_p_infomap__InfomapModuleIterator')
class(`InfomapModuleIterator_PlusPlusPrefix`) = c("SWIGFunction", class('InfomapModuleIterator_PlusPlusPrefix'))

# Start of InfomapModuleIterator_PlusPlusPostfix

`InfomapModuleIterator_PlusPlusPostfix` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  ;ans = .Call('R_swig_InfomapModuleIterator_PlusPlusPostfix', self, s_arg2, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapIterator", ref=ans);
  
  ans
  
}

attr(`InfomapModuleIterator_PlusPlusPostfix`, 'returnType') = '_p_infomap__InfomapIterator'
attr(`InfomapModuleIterator_PlusPlusPostfix`, "inputTypes") = c('_p_infomap__InfomapModuleIterator', 'integer')
class(`InfomapModuleIterator_PlusPlusPostfix`) = c("SWIGFunction", class('InfomapModuleIterator_PlusPlusPostfix'))

# Start of InfomapModuleIterator_childIndex

`InfomapModuleIterator_childIndex` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapModuleIterator_childIndex', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapModuleIterator_childIndex`, 'returnType') = 'integer'
attr(`InfomapModuleIterator_childIndex`, "inputTypes") = c('_p_infomap__InfomapModuleIterator')
class(`InfomapModuleIterator_childIndex`) = c("SWIGFunction", class('InfomapModuleIterator_childIndex'))

# Start of InfomapModuleIterator_current

`InfomapModuleIterator_current_SWIG_0_0` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapModuleIterator_current_SWIG_0_0', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapModuleIterator_current_SWIG_0_0`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapModuleIterator_current_SWIG_0_0`, "inputTypes") = c('_p_infomap__InfomapModuleIterator')
class(`InfomapModuleIterator_current_SWIG_0_0`) = c("SWIGFunction", class('InfomapModuleIterator_current_SWIG_0_0'))

# Start of InfomapModuleIterator_current

`InfomapModuleIterator_current_SWIG_0_1` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapModuleIterator_current_SWIG_0_1', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapModuleIterator_current_SWIG_0_1`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapModuleIterator_current_SWIG_0_1`, "inputTypes") = c('_p_infomap__InfomapModuleIterator')
class(`InfomapModuleIterator_current_SWIG_0_1`) = c("SWIGFunction", class('InfomapModuleIterator_current_SWIG_0_1'))

`InfomapModuleIterator_current` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapModuleIterator') || is.null(argv[[1]]))) {
      f <- InfomapModuleIterator_current_SWIG_0_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapModuleIterator') || is.null(argv[[1]]))) {
      f <- InfomapModuleIterator_current_SWIG_0_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapModuleIterator_current with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapModuleIterator_depth

`InfomapModuleIterator_depth` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapModuleIterator_depth', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapModuleIterator_depth`, 'returnType') = 'integer'
attr(`InfomapModuleIterator_depth`, "inputTypes") = c('_p_infomap__InfomapModuleIterator')
class(`InfomapModuleIterator_depth`) = c("SWIGFunction", class('InfomapModuleIterator_depth'))

# Start of InfomapModuleIterator_path

`InfomapModuleIterator_path` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapModuleIterator_path', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t", ref=ans);
  
  ans
  
}

attr(`InfomapModuleIterator_path`, 'returnType') = '_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t'
attr(`InfomapModuleIterator_path`, "inputTypes") = c('_p_infomap__InfomapModuleIterator')
class(`InfomapModuleIterator_path`) = c("SWIGFunction", class('InfomapModuleIterator_path'))

# Start of delete_InfomapModuleIterator

`delete_InfomapModuleIterator` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_InfomapModuleIterator', self, PACKAGE='infomap');
  
}

attr(`delete_InfomapModuleIterator`, 'returnType') = 'void'
attr(`delete_InfomapModuleIterator`, "inputTypes") = c('_p_infomap__InfomapModuleIterator')
class(`delete_InfomapModuleIterator`) = c("SWIGFunction", class('delete_InfomapModuleIterator'))

# Start of accessor method for infomap::InfomapModuleIterator
setMethod('$', '_p_infomap__InfomapModuleIterator', function(x, name)

{
  accessorFuns = list('Equal' = InfomapModuleIterator_Equal, 'PlusPlusPrefix' = InfomapModuleIterator_PlusPlusPrefix, 'PlusPlusPostfix' = InfomapModuleIterator_PlusPlusPostfix, 'childIndex' = InfomapModuleIterator_childIndex, 'current' = InfomapModuleIterator_current, 'depth' = InfomapModuleIterator_depth, 'path' = InfomapModuleIterator_path);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for infomap::InfomapModuleIterator
setMethod('delete', '_p_infomap__InfomapModuleIterator', function(obj) {delete_infomap__InfomapModuleIterator(obj)})
# Start definition of copy functions & methods for infomap::InfomapModuleIterator
CopyToR_infomap__InfomapModuleIterator = function(value, obj = new("infomap::InfomapModuleIterator"))
{
  obj;
}



CopyToC_infomap__InfomapModuleIterator = function(value, obj)
{
  obj
}



# Start definition of copy methods for infomap::InfomapModuleIterator
setMethod('copyToR', '_p_infomap::InfomapModuleIterator', CopyToR_infomap__InfomapModuleIterator);
setMethod('copyToC', 'infomap::InfomapModuleIterator', CopyToC_infomap__InfomapModuleIterator);

# End definition of copy methods for infomap::InfomapModuleIterator
# End definition of copy functions & methods for infomap::InfomapModuleIterator
# Start of new_InfomapLeafModuleIterator

`InfomapLeafModuleIterator__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_InfomapLeafModuleIterator__SWIG_0', PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapLeafModuleIterator", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfomapLeafModuleIterator);
  ans
  
}

attr(`InfomapLeafModuleIterator__SWIG_0`, 'returnType') = '_p_infomap__InfomapLeafModuleIterator'
class(`InfomapLeafModuleIterator__SWIG_0`) = c("SWIGFunction", class('InfomapLeafModuleIterator__SWIG_0'))

# Start of new_InfomapLeafModuleIterator

`InfomapLeafModuleIterator__SWIG_1` = function(nodePointer, moduleIndexLevel)
{
  if (inherits(nodePointer, "ExternalReference")) nodePointer = slot(nodePointer,"ref"); 
  moduleIndexLevel = as.integer(moduleIndexLevel);
  
  if(length(moduleIndexLevel) > 1) {
    warning("using only the first element of moduleIndexLevel");
  };
  
  ;ans = .Call('R_swig_new_InfomapLeafModuleIterator__SWIG_1', nodePointer, moduleIndexLevel, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapLeafModuleIterator", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfomapLeafModuleIterator);
  ans
  
}

attr(`InfomapLeafModuleIterator__SWIG_1`, 'returnType') = '_p_infomap__InfomapLeafModuleIterator'
attr(`InfomapLeafModuleIterator__SWIG_1`, "inputTypes") = c('_p_infomap__InfoNode', 'integer')
class(`InfomapLeafModuleIterator__SWIG_1`) = c("SWIGFunction", class('InfomapLeafModuleIterator__SWIG_1'))

# Start of new_InfomapLeafModuleIterator

`InfomapLeafModuleIterator__SWIG_2` = function(nodePointer)
{
  if (inherits(nodePointer, "ExternalReference")) nodePointer = slot(nodePointer,"ref"); 
  ;ans = .Call('R_swig_new_InfomapLeafModuleIterator__SWIG_2', nodePointer, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapLeafModuleIterator", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfomapLeafModuleIterator);
  ans
  
}

attr(`InfomapLeafModuleIterator__SWIG_2`, 'returnType') = '_p_infomap__InfomapLeafModuleIterator'
attr(`InfomapLeafModuleIterator__SWIG_2`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfomapLeafModuleIterator__SWIG_2`) = c("SWIGFunction", class('InfomapLeafModuleIterator__SWIG_2'))

# Start of new_InfomapLeafModuleIterator

`InfomapLeafModuleIterator__SWIG_3` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_new_InfomapLeafModuleIterator__SWIG_3', other, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapLeafModuleIterator", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfomapLeafModuleIterator);
  ans
  
}

attr(`InfomapLeafModuleIterator__SWIG_3`, 'returnType') = '_p_infomap__InfomapLeafModuleIterator'
attr(`InfomapLeafModuleIterator__SWIG_3`, "inputTypes") = c('_p_infomap__InfomapLeafModuleIterator')
class(`InfomapLeafModuleIterator__SWIG_3`) = c("SWIGFunction", class('InfomapLeafModuleIterator__SWIG_3'))

`InfomapLeafModuleIterator` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- InfomapLeafModuleIterator__SWIG_0; 
  } else if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]]))) {
      f <- InfomapLeafModuleIterator__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_infomap__InfomapLeafModuleIterator') && length(argv[[1]]) == 1) {
      f <- InfomapLeafModuleIterator__SWIG_3; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- InfomapLeafModuleIterator__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapLeafModuleIterator with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapLeafModuleIterator_Equal

`InfomapLeafModuleIterator_Equal` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_InfomapLeafModuleIterator_Equal', self, other, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapLeafModuleIterator", ref=ans);
  
  ans
  
}

attr(`InfomapLeafModuleIterator_Equal`, 'returnType') = '_p_infomap__InfomapLeafModuleIterator'
attr(`InfomapLeafModuleIterator_Equal`, "inputTypes") = c('_p_infomap__InfomapLeafModuleIterator', '_p_infomap__InfomapLeafModuleIterator')
class(`InfomapLeafModuleIterator_Equal`) = c("SWIGFunction", class('InfomapLeafModuleIterator_Equal'))

# Start of InfomapLeafModuleIterator_init

`InfomapLeafModuleIterator_init` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapLeafModuleIterator_init', self, PACKAGE='infomap');
  
}

attr(`InfomapLeafModuleIterator_init`, 'returnType') = 'void'
attr(`InfomapLeafModuleIterator_init`, "inputTypes") = c('_p_infomap__InfomapLeafModuleIterator')
class(`InfomapLeafModuleIterator_init`) = c("SWIGFunction", class('InfomapLeafModuleIterator_init'))

# Start of InfomapLeafModuleIterator_PlusPlusPrefix

`InfomapLeafModuleIterator_PlusPlusPrefix` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapLeafModuleIterator_PlusPlusPrefix', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapIterator", ref=ans);
  
  ans
  
}

attr(`InfomapLeafModuleIterator_PlusPlusPrefix`, 'returnType') = '_p_infomap__InfomapIterator'
attr(`InfomapLeafModuleIterator_PlusPlusPrefix`, "inputTypes") = c('_p_infomap__InfomapLeafModuleIterator')
class(`InfomapLeafModuleIterator_PlusPlusPrefix`) = c("SWIGFunction", class('InfomapLeafModuleIterator_PlusPlusPrefix'))

# Start of InfomapLeafModuleIterator_PlusPlusPostfix

`InfomapLeafModuleIterator_PlusPlusPostfix` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  ;ans = .Call('R_swig_InfomapLeafModuleIterator_PlusPlusPostfix', self, s_arg2, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapIterator", ref=ans);
  
  ans
  
}

attr(`InfomapLeafModuleIterator_PlusPlusPostfix`, 'returnType') = '_p_infomap__InfomapIterator'
attr(`InfomapLeafModuleIterator_PlusPlusPostfix`, "inputTypes") = c('_p_infomap__InfomapLeafModuleIterator', 'integer')
class(`InfomapLeafModuleIterator_PlusPlusPostfix`) = c("SWIGFunction", class('InfomapLeafModuleIterator_PlusPlusPostfix'))

# Start of InfomapLeafModuleIterator_childIndex

`InfomapLeafModuleIterator_childIndex` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapLeafModuleIterator_childIndex', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapLeafModuleIterator_childIndex`, 'returnType') = 'integer'
attr(`InfomapLeafModuleIterator_childIndex`, "inputTypes") = c('_p_infomap__InfomapLeafModuleIterator')
class(`InfomapLeafModuleIterator_childIndex`) = c("SWIGFunction", class('InfomapLeafModuleIterator_childIndex'))

# Start of InfomapLeafModuleIterator_current

`InfomapLeafModuleIterator_current_SWIG_0_0` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapLeafModuleIterator_current_SWIG_0_0', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapLeafModuleIterator_current_SWIG_0_0`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapLeafModuleIterator_current_SWIG_0_0`, "inputTypes") = c('_p_infomap__InfomapLeafModuleIterator')
class(`InfomapLeafModuleIterator_current_SWIG_0_0`) = c("SWIGFunction", class('InfomapLeafModuleIterator_current_SWIG_0_0'))

# Start of InfomapLeafModuleIterator_current

`InfomapLeafModuleIterator_current_SWIG_0_1` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapLeafModuleIterator_current_SWIG_0_1', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapLeafModuleIterator_current_SWIG_0_1`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapLeafModuleIterator_current_SWIG_0_1`, "inputTypes") = c('_p_infomap__InfomapLeafModuleIterator')
class(`InfomapLeafModuleIterator_current_SWIG_0_1`) = c("SWIGFunction", class('InfomapLeafModuleIterator_current_SWIG_0_1'))

`InfomapLeafModuleIterator_current` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapLeafModuleIterator') || is.null(argv[[1]]))) {
      f <- InfomapLeafModuleIterator_current_SWIG_0_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapLeafModuleIterator') || is.null(argv[[1]]))) {
      f <- InfomapLeafModuleIterator_current_SWIG_0_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapLeafModuleIterator_current with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapLeafModuleIterator_depth

`InfomapLeafModuleIterator_depth` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapLeafModuleIterator_depth', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapLeafModuleIterator_depth`, 'returnType') = 'integer'
attr(`InfomapLeafModuleIterator_depth`, "inputTypes") = c('_p_infomap__InfomapLeafModuleIterator')
class(`InfomapLeafModuleIterator_depth`) = c("SWIGFunction", class('InfomapLeafModuleIterator_depth'))

# Start of InfomapLeafModuleIterator_path

`InfomapLeafModuleIterator_path` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapLeafModuleIterator_path', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t", ref=ans);
  
  ans
  
}

attr(`InfomapLeafModuleIterator_path`, 'returnType') = '_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t'
attr(`InfomapLeafModuleIterator_path`, "inputTypes") = c('_p_infomap__InfomapLeafModuleIterator')
class(`InfomapLeafModuleIterator_path`) = c("SWIGFunction", class('InfomapLeafModuleIterator_path'))

# Start of delete_InfomapLeafModuleIterator

`delete_InfomapLeafModuleIterator` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_InfomapLeafModuleIterator', self, PACKAGE='infomap');
  
}

attr(`delete_InfomapLeafModuleIterator`, 'returnType') = 'void'
attr(`delete_InfomapLeafModuleIterator`, "inputTypes") = c('_p_infomap__InfomapLeafModuleIterator')
class(`delete_InfomapLeafModuleIterator`) = c("SWIGFunction", class('delete_InfomapLeafModuleIterator'))

# Start of accessor method for infomap::InfomapLeafModuleIterator
setMethod('$', '_p_infomap__InfomapLeafModuleIterator', function(x, name)

{
  accessorFuns = list('Equal' = InfomapLeafModuleIterator_Equal, 'init' = InfomapLeafModuleIterator_init, 'PlusPlusPrefix' = InfomapLeafModuleIterator_PlusPlusPrefix, 'PlusPlusPostfix' = InfomapLeafModuleIterator_PlusPlusPostfix, 'childIndex' = InfomapLeafModuleIterator_childIndex, 'current' = InfomapLeafModuleIterator_current, 'depth' = InfomapLeafModuleIterator_depth, 'path' = InfomapLeafModuleIterator_path);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for infomap::InfomapLeafModuleIterator
setMethod('delete', '_p_infomap__InfomapLeafModuleIterator', function(obj) {delete_infomap__InfomapLeafModuleIterator(obj)})
# Start definition of copy functions & methods for infomap::InfomapLeafModuleIterator
CopyToR_infomap__InfomapLeafModuleIterator = function(value, obj = new("infomap::InfomapLeafModuleIterator"))
{
  obj;
}



CopyToC_infomap__InfomapLeafModuleIterator = function(value, obj)
{
  obj
}



# Start definition of copy methods for infomap::InfomapLeafModuleIterator
setMethod('copyToR', '_p_infomap::InfomapLeafModuleIterator', CopyToR_infomap__InfomapLeafModuleIterator);
setMethod('copyToC', 'infomap::InfomapLeafModuleIterator', CopyToC_infomap__InfomapLeafModuleIterator);

# End definition of copy methods for infomap::InfomapLeafModuleIterator
# End definition of copy functions & methods for infomap::InfomapLeafModuleIterator
# Start of new_InfomapLeafIterator

`InfomapLeafIterator__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_InfomapLeafIterator__SWIG_0', PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapLeafIterator", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfomapLeafIterator);
  ans
  
}

attr(`InfomapLeafIterator__SWIG_0`, 'returnType') = '_p_infomap__InfomapLeafIterator'
class(`InfomapLeafIterator__SWIG_0`) = c("SWIGFunction", class('InfomapLeafIterator__SWIG_0'))

# Start of new_InfomapLeafIterator

`InfomapLeafIterator__SWIG_1` = function(nodePointer, moduleIndexLevel)
{
  if (inherits(nodePointer, "ExternalReference")) nodePointer = slot(nodePointer,"ref"); 
  moduleIndexLevel = as.integer(moduleIndexLevel);
  
  if(length(moduleIndexLevel) > 1) {
    warning("using only the first element of moduleIndexLevel");
  };
  
  ;ans = .Call('R_swig_new_InfomapLeafIterator__SWIG_1', nodePointer, moduleIndexLevel, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapLeafIterator", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfomapLeafIterator);
  ans
  
}

attr(`InfomapLeafIterator__SWIG_1`, 'returnType') = '_p_infomap__InfomapLeafIterator'
attr(`InfomapLeafIterator__SWIG_1`, "inputTypes") = c('_p_infomap__InfoNode', 'integer')
class(`InfomapLeafIterator__SWIG_1`) = c("SWIGFunction", class('InfomapLeafIterator__SWIG_1'))

# Start of new_InfomapLeafIterator

`InfomapLeafIterator__SWIG_2` = function(nodePointer)
{
  if (inherits(nodePointer, "ExternalReference")) nodePointer = slot(nodePointer,"ref"); 
  ;ans = .Call('R_swig_new_InfomapLeafIterator__SWIG_2', nodePointer, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapLeafIterator", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfomapLeafIterator);
  ans
  
}

attr(`InfomapLeafIterator__SWIG_2`, 'returnType') = '_p_infomap__InfomapLeafIterator'
attr(`InfomapLeafIterator__SWIG_2`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfomapLeafIterator__SWIG_2`) = c("SWIGFunction", class('InfomapLeafIterator__SWIG_2'))

# Start of new_InfomapLeafIterator

`InfomapLeafIterator__SWIG_3` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_new_InfomapLeafIterator__SWIG_3', other, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapLeafIterator", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfomapLeafIterator);
  ans
  
}

attr(`InfomapLeafIterator__SWIG_3`, 'returnType') = '_p_infomap__InfomapLeafIterator'
attr(`InfomapLeafIterator__SWIG_3`, "inputTypes") = c('_p_infomap__InfomapLeafIterator')
class(`InfomapLeafIterator__SWIG_3`) = c("SWIGFunction", class('InfomapLeafIterator__SWIG_3'))

`InfomapLeafIterator` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- InfomapLeafIterator__SWIG_0; 
  } else if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]]))) {
      f <- InfomapLeafIterator__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_infomap__InfomapLeafIterator') && length(argv[[1]]) == 1) {
      f <- InfomapLeafIterator__SWIG_3; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- InfomapLeafIterator__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapLeafIterator with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapLeafIterator_Equal

`InfomapLeafIterator_Equal` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_InfomapLeafIterator_Equal', self, other, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapLeafIterator", ref=ans);
  
  ans
  
}

attr(`InfomapLeafIterator_Equal`, 'returnType') = '_p_infomap__InfomapLeafIterator'
attr(`InfomapLeafIterator_Equal`, "inputTypes") = c('_p_infomap__InfomapLeafIterator', '_p_infomap__InfomapLeafIterator')
class(`InfomapLeafIterator_Equal`) = c("SWIGFunction", class('InfomapLeafIterator_Equal'))

# Start of InfomapLeafIterator_init

`InfomapLeafIterator_init` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapLeafIterator_init', self, PACKAGE='infomap');
  
}

attr(`InfomapLeafIterator_init`, 'returnType') = 'void'
attr(`InfomapLeafIterator_init`, "inputTypes") = c('_p_infomap__InfomapLeafIterator')
class(`InfomapLeafIterator_init`) = c("SWIGFunction", class('InfomapLeafIterator_init'))

# Start of InfomapLeafIterator_PlusPlusPrefix

`InfomapLeafIterator_PlusPlusPrefix` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapLeafIterator_PlusPlusPrefix', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapIterator", ref=ans);
  
  ans
  
}

attr(`InfomapLeafIterator_PlusPlusPrefix`, 'returnType') = '_p_infomap__InfomapIterator'
attr(`InfomapLeafIterator_PlusPlusPrefix`, "inputTypes") = c('_p_infomap__InfomapLeafIterator')
class(`InfomapLeafIterator_PlusPlusPrefix`) = c("SWIGFunction", class('InfomapLeafIterator_PlusPlusPrefix'))

# Start of InfomapLeafIterator_PlusPlusPostfix

`InfomapLeafIterator_PlusPlusPostfix` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  ;ans = .Call('R_swig_InfomapLeafIterator_PlusPlusPostfix', self, s_arg2, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapIterator", ref=ans);
  
  ans
  
}

attr(`InfomapLeafIterator_PlusPlusPostfix`, 'returnType') = '_p_infomap__InfomapIterator'
attr(`InfomapLeafIterator_PlusPlusPostfix`, "inputTypes") = c('_p_infomap__InfomapLeafIterator', 'integer')
class(`InfomapLeafIterator_PlusPlusPostfix`) = c("SWIGFunction", class('InfomapLeafIterator_PlusPlusPostfix'))

# Start of InfomapLeafIterator_childIndex

`InfomapLeafIterator_childIndex` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapLeafIterator_childIndex', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapLeafIterator_childIndex`, 'returnType') = 'integer'
attr(`InfomapLeafIterator_childIndex`, "inputTypes") = c('_p_infomap__InfomapLeafIterator')
class(`InfomapLeafIterator_childIndex`) = c("SWIGFunction", class('InfomapLeafIterator_childIndex'))

# Start of InfomapLeafIterator_current

`InfomapLeafIterator_current_SWIG_0_0` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapLeafIterator_current_SWIG_0_0', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapLeafIterator_current_SWIG_0_0`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapLeafIterator_current_SWIG_0_0`, "inputTypes") = c('_p_infomap__InfomapLeafIterator')
class(`InfomapLeafIterator_current_SWIG_0_0`) = c("SWIGFunction", class('InfomapLeafIterator_current_SWIG_0_0'))

# Start of InfomapLeafIterator_current

`InfomapLeafIterator_current_SWIG_0_1` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapLeafIterator_current_SWIG_0_1', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapLeafIterator_current_SWIG_0_1`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapLeafIterator_current_SWIG_0_1`, "inputTypes") = c('_p_infomap__InfomapLeafIterator')
class(`InfomapLeafIterator_current_SWIG_0_1`) = c("SWIGFunction", class('InfomapLeafIterator_current_SWIG_0_1'))

`InfomapLeafIterator_current` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapLeafIterator') || is.null(argv[[1]]))) {
      f <- InfomapLeafIterator_current_SWIG_0_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapLeafIterator') || is.null(argv[[1]]))) {
      f <- InfomapLeafIterator_current_SWIG_0_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapLeafIterator_current with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapLeafIterator_depth

`InfomapLeafIterator_depth` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapLeafIterator_depth', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapLeafIterator_depth`, 'returnType') = 'integer'
attr(`InfomapLeafIterator_depth`, "inputTypes") = c('_p_infomap__InfomapLeafIterator')
class(`InfomapLeafIterator_depth`) = c("SWIGFunction", class('InfomapLeafIterator_depth'))

# Start of InfomapLeafIterator_path

`InfomapLeafIterator_path` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapLeafIterator_path', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t", ref=ans);
  
  ans
  
}

attr(`InfomapLeafIterator_path`, 'returnType') = '_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t'
attr(`InfomapLeafIterator_path`, "inputTypes") = c('_p_infomap__InfomapLeafIterator')
class(`InfomapLeafIterator_path`) = c("SWIGFunction", class('InfomapLeafIterator_path'))

# Start of delete_InfomapLeafIterator

`delete_InfomapLeafIterator` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_InfomapLeafIterator', self, PACKAGE='infomap');
  
}

attr(`delete_InfomapLeafIterator`, 'returnType') = 'void'
attr(`delete_InfomapLeafIterator`, "inputTypes") = c('_p_infomap__InfomapLeafIterator')
class(`delete_InfomapLeafIterator`) = c("SWIGFunction", class('delete_InfomapLeafIterator'))

# Start of accessor method for infomap::InfomapLeafIterator
setMethod('$', '_p_infomap__InfomapLeafIterator', function(x, name)

{
  accessorFuns = list('Equal' = InfomapLeafIterator_Equal, 'init' = InfomapLeafIterator_init, 'PlusPlusPrefix' = InfomapLeafIterator_PlusPlusPrefix, 'PlusPlusPostfix' = InfomapLeafIterator_PlusPlusPostfix, 'childIndex' = InfomapLeafIterator_childIndex, 'current' = InfomapLeafIterator_current, 'depth' = InfomapLeafIterator_depth, 'path' = InfomapLeafIterator_path);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for infomap::InfomapLeafIterator
setMethod('delete', '_p_infomap__InfomapLeafIterator', function(obj) {delete_infomap__InfomapLeafIterator(obj)})
# Start definition of copy functions & methods for infomap::InfomapLeafIterator
CopyToR_infomap__InfomapLeafIterator = function(value, obj = new("infomap::InfomapLeafIterator"))
{
  obj;
}



CopyToC_infomap__InfomapLeafIterator = function(value, obj)
{
  obj
}



# Start definition of copy methods for infomap::InfomapLeafIterator
setMethod('copyToR', '_p_infomap::InfomapLeafIterator', CopyToR_infomap__InfomapLeafIterator);
setMethod('copyToC', 'infomap::InfomapLeafIterator', CopyToC_infomap__InfomapLeafIterator);

# End definition of copy methods for infomap::InfomapLeafIterator
# End definition of copy functions & methods for infomap::InfomapLeafIterator
# Start of new_InfomapIteratorPhysical

`InfomapIteratorPhysical__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_InfomapIteratorPhysical__SWIG_0', PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapIteratorPhysical", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfomapIteratorPhysical);
  ans
  
}

attr(`InfomapIteratorPhysical__SWIG_0`, 'returnType') = '_p_infomap__InfomapIteratorPhysical'
class(`InfomapIteratorPhysical__SWIG_0`) = c("SWIGFunction", class('InfomapIteratorPhysical__SWIG_0'))

# Start of new_InfomapIteratorPhysical

`InfomapIteratorPhysical__SWIG_1` = function(nodePointer, moduleIndexLevel)
{
  if (inherits(nodePointer, "ExternalReference")) nodePointer = slot(nodePointer,"ref"); 
  moduleIndexLevel = as.integer(moduleIndexLevel);
  
  if(length(moduleIndexLevel) > 1) {
    warning("using only the first element of moduleIndexLevel");
  };
  
  ;ans = .Call('R_swig_new_InfomapIteratorPhysical__SWIG_1', nodePointer, moduleIndexLevel, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapIteratorPhysical", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfomapIteratorPhysical);
  ans
  
}

attr(`InfomapIteratorPhysical__SWIG_1`, 'returnType') = '_p_infomap__InfomapIteratorPhysical'
attr(`InfomapIteratorPhysical__SWIG_1`, "inputTypes") = c('_p_infomap__InfoNode', 'integer')
class(`InfomapIteratorPhysical__SWIG_1`) = c("SWIGFunction", class('InfomapIteratorPhysical__SWIG_1'))

# Start of new_InfomapIteratorPhysical

`InfomapIteratorPhysical__SWIG_2` = function(nodePointer)
{
  if (inherits(nodePointer, "ExternalReference")) nodePointer = slot(nodePointer,"ref"); 
  ;ans = .Call('R_swig_new_InfomapIteratorPhysical__SWIG_2', nodePointer, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapIteratorPhysical", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfomapIteratorPhysical);
  ans
  
}

attr(`InfomapIteratorPhysical__SWIG_2`, 'returnType') = '_p_infomap__InfomapIteratorPhysical'
attr(`InfomapIteratorPhysical__SWIG_2`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfomapIteratorPhysical__SWIG_2`) = c("SWIGFunction", class('InfomapIteratorPhysical__SWIG_2'))

# Start of new_InfomapIteratorPhysical

`InfomapIteratorPhysical__SWIG_3` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_new_InfomapIteratorPhysical__SWIG_3', other, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapIteratorPhysical", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfomapIteratorPhysical);
  ans
  
}

attr(`InfomapIteratorPhysical__SWIG_3`, 'returnType') = '_p_infomap__InfomapIteratorPhysical'
attr(`InfomapIteratorPhysical__SWIG_3`, "inputTypes") = c('_p_infomap__InfomapIteratorPhysical')
class(`InfomapIteratorPhysical__SWIG_3`) = c("SWIGFunction", class('InfomapIteratorPhysical__SWIG_3'))

# Start of new_InfomapIteratorPhysical

`InfomapIteratorPhysical__SWIG_4` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_new_InfomapIteratorPhysical__SWIG_4', other, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapIteratorPhysical", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfomapIteratorPhysical);
  ans
  
}

attr(`InfomapIteratorPhysical__SWIG_4`, 'returnType') = '_p_infomap__InfomapIteratorPhysical'
attr(`InfomapIteratorPhysical__SWIG_4`, "inputTypes") = c('_p_infomap__InfomapIterator')
class(`InfomapIteratorPhysical__SWIG_4`) = c("SWIGFunction", class('InfomapIteratorPhysical__SWIG_4'))

`InfomapIteratorPhysical` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 5
  if (argc == 0) {
    f <- InfomapIteratorPhysical__SWIG_0; 
  } else if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]]))) {
      f <- InfomapIteratorPhysical__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_infomap__InfomapIteratorPhysical') && length(argv[[1]]) == 1) {
      f <- InfomapIteratorPhysical__SWIG_3; 
    }
    else if (extends(argtypes[1], '_p_infomap__InfomapIterator') && length(argv[[1]]) == 1) {
      f <- InfomapIteratorPhysical__SWIG_4; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- InfomapIteratorPhysical__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapIteratorPhysical with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapIteratorPhysical_Equal

`InfomapIteratorPhysical_Equal__SWIG_0` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_InfomapIteratorPhysical_Equal__SWIG_0', self, other, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapIteratorPhysical", ref=ans);
  
  ans
  
}

attr(`InfomapIteratorPhysical_Equal__SWIG_0`, 'returnType') = '_p_infomap__InfomapIteratorPhysical'
attr(`InfomapIteratorPhysical_Equal__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapIteratorPhysical', '_p_infomap__InfomapIteratorPhysical')
class(`InfomapIteratorPhysical_Equal__SWIG_0`) = c("SWIGFunction", class('InfomapIteratorPhysical_Equal__SWIG_0'))

# Start of InfomapIteratorPhysical_Equal

`InfomapIteratorPhysical_Equal__SWIG_1` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_InfomapIteratorPhysical_Equal__SWIG_1', self, other, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapIteratorPhysical", ref=ans);
  
  ans
  
}

attr(`InfomapIteratorPhysical_Equal__SWIG_1`, 'returnType') = '_p_infomap__InfomapIteratorPhysical'
attr(`InfomapIteratorPhysical_Equal__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapIteratorPhysical', '_p_infomap__InfomapIterator')
class(`InfomapIteratorPhysical_Equal__SWIG_1`) = c("SWIGFunction", class('InfomapIteratorPhysical_Equal__SWIG_1'))

`InfomapIteratorPhysical_Equal` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapIteratorPhysical') || is.null(argv[[1]])) && extends(argtypes[2], '_p_infomap__InfomapIteratorPhysical') && length(argv[[2]]) == 1) {
      f <- InfomapIteratorPhysical_Equal__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapIteratorPhysical') || is.null(argv[[1]])) && extends(argtypes[2], '_p_infomap__InfomapIterator') && length(argv[[2]]) == 1) {
      f <- InfomapIteratorPhysical_Equal__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapIteratorPhysical_Equal with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapIteratorPhysical_PlusPlusPrefix

`InfomapIteratorPhysical_PlusPlusPrefix` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIteratorPhysical_PlusPlusPrefix', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapIterator", ref=ans);
  
  ans
  
}

attr(`InfomapIteratorPhysical_PlusPlusPrefix`, 'returnType') = '_p_infomap__InfomapIterator'
attr(`InfomapIteratorPhysical_PlusPlusPrefix`, "inputTypes") = c('_p_infomap__InfomapIteratorPhysical')
class(`InfomapIteratorPhysical_PlusPlusPrefix`) = c("SWIGFunction", class('InfomapIteratorPhysical_PlusPlusPrefix'))

# Start of InfomapIteratorPhysical_PlusPlusPostfix

`InfomapIteratorPhysical_PlusPlusPostfix` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  ;ans = .Call('R_swig_InfomapIteratorPhysical_PlusPlusPostfix', self, s_arg2, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapIterator", ref=ans);
  
  ans
  
}

attr(`InfomapIteratorPhysical_PlusPlusPostfix`, 'returnType') = '_p_infomap__InfomapIterator'
attr(`InfomapIteratorPhysical_PlusPlusPostfix`, "inputTypes") = c('_p_infomap__InfomapIteratorPhysical', 'integer')
class(`InfomapIteratorPhysical_PlusPlusPostfix`) = c("SWIGFunction", class('InfomapIteratorPhysical_PlusPlusPostfix'))

# Start of InfomapIteratorPhysical_childIndex

`InfomapIteratorPhysical_childIndex` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIteratorPhysical_childIndex', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIteratorPhysical_childIndex`, 'returnType') = 'integer'
attr(`InfomapIteratorPhysical_childIndex`, "inputTypes") = c('_p_infomap__InfomapIteratorPhysical')
class(`InfomapIteratorPhysical_childIndex`) = c("SWIGFunction", class('InfomapIteratorPhysical_childIndex'))

# Start of InfomapIteratorPhysical_current

`InfomapIteratorPhysical_current_SWIG_0_0` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIteratorPhysical_current_SWIG_0_0', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapIteratorPhysical_current_SWIG_0_0`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapIteratorPhysical_current_SWIG_0_0`, "inputTypes") = c('_p_infomap__InfomapIteratorPhysical')
class(`InfomapIteratorPhysical_current_SWIG_0_0`) = c("SWIGFunction", class('InfomapIteratorPhysical_current_SWIG_0_0'))

# Start of InfomapIteratorPhysical_current

`InfomapIteratorPhysical_current_SWIG_0_1` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIteratorPhysical_current_SWIG_0_1', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapIteratorPhysical_current_SWIG_0_1`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapIteratorPhysical_current_SWIG_0_1`, "inputTypes") = c('_p_infomap__InfomapIteratorPhysical')
class(`InfomapIteratorPhysical_current_SWIG_0_1`) = c("SWIGFunction", class('InfomapIteratorPhysical_current_SWIG_0_1'))

`InfomapIteratorPhysical_current` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapIteratorPhysical') || is.null(argv[[1]]))) {
      f <- InfomapIteratorPhysical_current_SWIG_0_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapIteratorPhysical') || is.null(argv[[1]]))) {
      f <- InfomapIteratorPhysical_current_SWIG_0_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapIteratorPhysical_current with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapIteratorPhysical_depth

`InfomapIteratorPhysical_depth` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapIteratorPhysical_depth', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapIteratorPhysical_depth`, 'returnType') = 'integer'
attr(`InfomapIteratorPhysical_depth`, "inputTypes") = c('_p_infomap__InfomapIteratorPhysical')
class(`InfomapIteratorPhysical_depth`) = c("SWIGFunction", class('InfomapIteratorPhysical_depth'))

# Start of InfomapIteratorPhysical_path

`InfomapIteratorPhysical_path` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapIteratorPhysical_path', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t", ref=ans);
  
  ans
  
}

attr(`InfomapIteratorPhysical_path`, 'returnType') = '_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t'
attr(`InfomapIteratorPhysical_path`, "inputTypes") = c('_p_infomap__InfomapIteratorPhysical')
class(`InfomapIteratorPhysical_path`) = c("SWIGFunction", class('InfomapIteratorPhysical_path'))

# Start of delete_InfomapIteratorPhysical

`delete_InfomapIteratorPhysical` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_InfomapIteratorPhysical', self, PACKAGE='infomap');
  
}

attr(`delete_InfomapIteratorPhysical`, 'returnType') = 'void'
attr(`delete_InfomapIteratorPhysical`, "inputTypes") = c('_p_infomap__InfomapIteratorPhysical')
class(`delete_InfomapIteratorPhysical`) = c("SWIGFunction", class('delete_InfomapIteratorPhysical'))

# Start of accessor method for infomap::InfomapIteratorPhysical
setMethod('$', '_p_infomap__InfomapIteratorPhysical', function(x, name)

{
  accessorFuns = list('Equal' = InfomapIteratorPhysical_Equal, 'PlusPlusPrefix' = InfomapIteratorPhysical_PlusPlusPrefix, 'PlusPlusPostfix' = InfomapIteratorPhysical_PlusPlusPostfix, 'childIndex' = InfomapIteratorPhysical_childIndex, 'current' = InfomapIteratorPhysical_current, 'depth' = InfomapIteratorPhysical_depth, 'path' = InfomapIteratorPhysical_path);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for infomap::InfomapIteratorPhysical
setMethod('delete', '_p_infomap__InfomapIteratorPhysical', function(obj) {delete_infomap__InfomapIteratorPhysical(obj)})
# Start definition of copy functions & methods for infomap::InfomapIteratorPhysical
CopyToR_infomap__InfomapIteratorPhysical = function(value, obj = new("infomap::InfomapIteratorPhysical"))
{
  obj;
}



CopyToC_infomap__InfomapIteratorPhysical = function(value, obj)
{
  obj
}



# Start definition of copy methods for infomap::InfomapIteratorPhysical
setMethod('copyToR', '_p_infomap::InfomapIteratorPhysical', CopyToR_infomap__InfomapIteratorPhysical);
setMethod('copyToC', 'infomap::InfomapIteratorPhysical', CopyToC_infomap__InfomapIteratorPhysical);

# End definition of copy methods for infomap::InfomapIteratorPhysical
# End definition of copy functions & methods for infomap::InfomapIteratorPhysical
# Start of new_InfomapLeafIteratorPhysical

`InfomapLeafIteratorPhysical__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_InfomapLeafIteratorPhysical__SWIG_0', PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapLeafIteratorPhysical", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfomapLeafIteratorPhysical);
  ans
  
}

attr(`InfomapLeafIteratorPhysical__SWIG_0`, 'returnType') = '_p_infomap__InfomapLeafIteratorPhysical'
class(`InfomapLeafIteratorPhysical__SWIG_0`) = c("SWIGFunction", class('InfomapLeafIteratorPhysical__SWIG_0'))

# Start of new_InfomapLeafIteratorPhysical

`InfomapLeafIteratorPhysical__SWIG_1` = function(nodePointer, moduleIndexLevel)
{
  if (inherits(nodePointer, "ExternalReference")) nodePointer = slot(nodePointer,"ref"); 
  moduleIndexLevel = as.integer(moduleIndexLevel);
  
  if(length(moduleIndexLevel) > 1) {
    warning("using only the first element of moduleIndexLevel");
  };
  
  ;ans = .Call('R_swig_new_InfomapLeafIteratorPhysical__SWIG_1', nodePointer, moduleIndexLevel, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapLeafIteratorPhysical", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfomapLeafIteratorPhysical);
  ans
  
}

attr(`InfomapLeafIteratorPhysical__SWIG_1`, 'returnType') = '_p_infomap__InfomapLeafIteratorPhysical'
attr(`InfomapLeafIteratorPhysical__SWIG_1`, "inputTypes") = c('_p_infomap__InfoNode', 'integer')
class(`InfomapLeafIteratorPhysical__SWIG_1`) = c("SWIGFunction", class('InfomapLeafIteratorPhysical__SWIG_1'))

# Start of new_InfomapLeafIteratorPhysical

`InfomapLeafIteratorPhysical__SWIG_2` = function(nodePointer)
{
  if (inherits(nodePointer, "ExternalReference")) nodePointer = slot(nodePointer,"ref"); 
  ;ans = .Call('R_swig_new_InfomapLeafIteratorPhysical__SWIG_2', nodePointer, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapLeafIteratorPhysical", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfomapLeafIteratorPhysical);
  ans
  
}

attr(`InfomapLeafIteratorPhysical__SWIG_2`, 'returnType') = '_p_infomap__InfomapLeafIteratorPhysical'
attr(`InfomapLeafIteratorPhysical__SWIG_2`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfomapLeafIteratorPhysical__SWIG_2`) = c("SWIGFunction", class('InfomapLeafIteratorPhysical__SWIG_2'))

# Start of new_InfomapLeafIteratorPhysical

`InfomapLeafIteratorPhysical__SWIG_3` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_new_InfomapLeafIteratorPhysical__SWIG_3', other, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapLeafIteratorPhysical", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfomapLeafIteratorPhysical);
  ans
  
}

attr(`InfomapLeafIteratorPhysical__SWIG_3`, 'returnType') = '_p_infomap__InfomapLeafIteratorPhysical'
attr(`InfomapLeafIteratorPhysical__SWIG_3`, "inputTypes") = c('_p_infomap__InfomapLeafIteratorPhysical')
class(`InfomapLeafIteratorPhysical__SWIG_3`) = c("SWIGFunction", class('InfomapLeafIteratorPhysical__SWIG_3'))

`InfomapLeafIteratorPhysical` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- InfomapLeafIteratorPhysical__SWIG_0; 
  } else if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]]))) {
      f <- InfomapLeafIteratorPhysical__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_infomap__InfomapLeafIteratorPhysical') && length(argv[[1]]) == 1) {
      f <- InfomapLeafIteratorPhysical__SWIG_3; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- InfomapLeafIteratorPhysical__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapLeafIteratorPhysical with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapLeafIteratorPhysical_Equal

`InfomapLeafIteratorPhysical_Equal` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_InfomapLeafIteratorPhysical_Equal', self, other, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapLeafIteratorPhysical", ref=ans);
  
  ans
  
}

attr(`InfomapLeafIteratorPhysical_Equal`, 'returnType') = '_p_infomap__InfomapLeafIteratorPhysical'
attr(`InfomapLeafIteratorPhysical_Equal`, "inputTypes") = c('_p_infomap__InfomapLeafIteratorPhysical', '_p_infomap__InfomapLeafIteratorPhysical')
class(`InfomapLeafIteratorPhysical_Equal`) = c("SWIGFunction", class('InfomapLeafIteratorPhysical_Equal'))

# Start of InfomapLeafIteratorPhysical_init

`InfomapLeafIteratorPhysical_init` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapLeafIteratorPhysical_init', self, PACKAGE='infomap');
  
}

attr(`InfomapLeafIteratorPhysical_init`, 'returnType') = 'void'
attr(`InfomapLeafIteratorPhysical_init`, "inputTypes") = c('_p_infomap__InfomapLeafIteratorPhysical')
class(`InfomapLeafIteratorPhysical_init`) = c("SWIGFunction", class('InfomapLeafIteratorPhysical_init'))

# Start of InfomapLeafIteratorPhysical_PlusPlusPrefix

`InfomapLeafIteratorPhysical_PlusPlusPrefix` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapLeafIteratorPhysical_PlusPlusPrefix', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapIterator", ref=ans);
  
  ans
  
}

attr(`InfomapLeafIteratorPhysical_PlusPlusPrefix`, 'returnType') = '_p_infomap__InfomapIterator'
attr(`InfomapLeafIteratorPhysical_PlusPlusPrefix`, "inputTypes") = c('_p_infomap__InfomapLeafIteratorPhysical')
class(`InfomapLeafIteratorPhysical_PlusPlusPrefix`) = c("SWIGFunction", class('InfomapLeafIteratorPhysical_PlusPlusPrefix'))

# Start of InfomapLeafIteratorPhysical_PlusPlusPostfix

`InfomapLeafIteratorPhysical_PlusPlusPostfix` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  ;ans = .Call('R_swig_InfomapLeafIteratorPhysical_PlusPlusPostfix', self, s_arg2, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapIterator", ref=ans);
  
  ans
  
}

attr(`InfomapLeafIteratorPhysical_PlusPlusPostfix`, 'returnType') = '_p_infomap__InfomapIterator'
attr(`InfomapLeafIteratorPhysical_PlusPlusPostfix`, "inputTypes") = c('_p_infomap__InfomapLeafIteratorPhysical', 'integer')
class(`InfomapLeafIteratorPhysical_PlusPlusPostfix`) = c("SWIGFunction", class('InfomapLeafIteratorPhysical_PlusPlusPostfix'))

# Start of InfomapLeafIteratorPhysical_childIndex

`InfomapLeafIteratorPhysical_childIndex` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapLeafIteratorPhysical_childIndex', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapLeafIteratorPhysical_childIndex`, 'returnType') = 'integer'
attr(`InfomapLeafIteratorPhysical_childIndex`, "inputTypes") = c('_p_infomap__InfomapLeafIteratorPhysical')
class(`InfomapLeafIteratorPhysical_childIndex`) = c("SWIGFunction", class('InfomapLeafIteratorPhysical_childIndex'))

# Start of InfomapLeafIteratorPhysical_current

`InfomapLeafIteratorPhysical_current_SWIG_0_0` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapLeafIteratorPhysical_current_SWIG_0_0', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapLeafIteratorPhysical_current_SWIG_0_0`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapLeafIteratorPhysical_current_SWIG_0_0`, "inputTypes") = c('_p_infomap__InfomapLeafIteratorPhysical')
class(`InfomapLeafIteratorPhysical_current_SWIG_0_0`) = c("SWIGFunction", class('InfomapLeafIteratorPhysical_current_SWIG_0_0'))

# Start of InfomapLeafIteratorPhysical_current

`InfomapLeafIteratorPhysical_current_SWIG_0_1` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapLeafIteratorPhysical_current_SWIG_0_1', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapLeafIteratorPhysical_current_SWIG_0_1`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapLeafIteratorPhysical_current_SWIG_0_1`, "inputTypes") = c('_p_infomap__InfomapLeafIteratorPhysical')
class(`InfomapLeafIteratorPhysical_current_SWIG_0_1`) = c("SWIGFunction", class('InfomapLeafIteratorPhysical_current_SWIG_0_1'))

`InfomapLeafIteratorPhysical_current` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapLeafIteratorPhysical') || is.null(argv[[1]]))) {
      f <- InfomapLeafIteratorPhysical_current_SWIG_0_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapLeafIteratorPhysical') || is.null(argv[[1]]))) {
      f <- InfomapLeafIteratorPhysical_current_SWIG_0_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapLeafIteratorPhysical_current with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapLeafIteratorPhysical_depth

`InfomapLeafIteratorPhysical_depth` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapLeafIteratorPhysical_depth', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapLeafIteratorPhysical_depth`, 'returnType') = 'integer'
attr(`InfomapLeafIteratorPhysical_depth`, "inputTypes") = c('_p_infomap__InfomapLeafIteratorPhysical')
class(`InfomapLeafIteratorPhysical_depth`) = c("SWIGFunction", class('InfomapLeafIteratorPhysical_depth'))

# Start of InfomapLeafIteratorPhysical_path

`InfomapLeafIteratorPhysical_path` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapLeafIteratorPhysical_path', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t", ref=ans);
  
  ans
  
}

attr(`InfomapLeafIteratorPhysical_path`, 'returnType') = '_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t'
attr(`InfomapLeafIteratorPhysical_path`, "inputTypes") = c('_p_infomap__InfomapLeafIteratorPhysical')
class(`InfomapLeafIteratorPhysical_path`) = c("SWIGFunction", class('InfomapLeafIteratorPhysical_path'))

# Start of delete_InfomapLeafIteratorPhysical

`delete_InfomapLeafIteratorPhysical` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_InfomapLeafIteratorPhysical', self, PACKAGE='infomap');
  
}

attr(`delete_InfomapLeafIteratorPhysical`, 'returnType') = 'void'
attr(`delete_InfomapLeafIteratorPhysical`, "inputTypes") = c('_p_infomap__InfomapLeafIteratorPhysical')
class(`delete_InfomapLeafIteratorPhysical`) = c("SWIGFunction", class('delete_InfomapLeafIteratorPhysical'))

# Start of accessor method for infomap::InfomapLeafIteratorPhysical
setMethod('$', '_p_infomap__InfomapLeafIteratorPhysical', function(x, name)

{
  accessorFuns = list('Equal' = InfomapLeafIteratorPhysical_Equal, 'init' = InfomapLeafIteratorPhysical_init, 'PlusPlusPrefix' = InfomapLeafIteratorPhysical_PlusPlusPrefix, 'PlusPlusPostfix' = InfomapLeafIteratorPhysical_PlusPlusPostfix, 'childIndex' = InfomapLeafIteratorPhysical_childIndex, 'current' = InfomapLeafIteratorPhysical_current, 'depth' = InfomapLeafIteratorPhysical_depth, 'path' = InfomapLeafIteratorPhysical_path);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for infomap::InfomapLeafIteratorPhysical
setMethod('delete', '_p_infomap__InfomapLeafIteratorPhysical', function(obj) {delete_infomap__InfomapLeafIteratorPhysical(obj)})
# Start definition of copy functions & methods for infomap::InfomapLeafIteratorPhysical
CopyToR_infomap__InfomapLeafIteratorPhysical = function(value, obj = new("infomap::InfomapLeafIteratorPhysical"))
{
  obj;
}



CopyToC_infomap__InfomapLeafIteratorPhysical = function(value, obj)
{
  obj
}



# Start definition of copy methods for infomap::InfomapLeafIteratorPhysical
setMethod('copyToR', '_p_infomap::InfomapLeafIteratorPhysical', CopyToR_infomap__InfomapLeafIteratorPhysical);
setMethod('copyToC', 'infomap::InfomapLeafIteratorPhysical', CopyToC_infomap__InfomapLeafIteratorPhysical);

# End definition of copy methods for infomap::InfomapLeafIteratorPhysical
# End definition of copy functions & methods for infomap::InfomapLeafIteratorPhysical
# Start of new_InfomapParentIterator

`InfomapParentIterator__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_InfomapParentIterator__SWIG_0', PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapParentIterator", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfomapParentIterator);
  ans
  
}

attr(`InfomapParentIterator__SWIG_0`, 'returnType') = '_p_infomap__InfomapParentIterator'
class(`InfomapParentIterator__SWIG_0`) = c("SWIGFunction", class('InfomapParentIterator__SWIG_0'))

# Start of new_InfomapParentIterator

`InfomapParentIterator__SWIG_1` = function(nodePointer)
{
  if (inherits(nodePointer, "ExternalReference")) nodePointer = slot(nodePointer,"ref"); 
  ;ans = .Call('R_swig_new_InfomapParentIterator__SWIG_1', nodePointer, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapParentIterator", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfomapParentIterator);
  ans
  
}

attr(`InfomapParentIterator__SWIG_1`, 'returnType') = '_p_infomap__InfomapParentIterator'
attr(`InfomapParentIterator__SWIG_1`, "inputTypes") = c('_p_infomap__InfoNode')
class(`InfomapParentIterator__SWIG_1`) = c("SWIGFunction", class('InfomapParentIterator__SWIG_1'))

# Start of new_InfomapParentIterator

`InfomapParentIterator__SWIG_2` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_new_InfomapParentIterator__SWIG_2', other, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapParentIterator", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfomapParentIterator);
  ans
  
}

attr(`InfomapParentIterator__SWIG_2`, 'returnType') = '_p_infomap__InfomapParentIterator'
attr(`InfomapParentIterator__SWIG_2`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator__SWIG_2`) = c("SWIGFunction", class('InfomapParentIterator__SWIG_2'))

`InfomapParentIterator` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 0) {
    f <- InfomapParentIterator__SWIG_0; 
  } else if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfoNode') || is.null(argv[[1]]))) {
      f <- InfomapParentIterator__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_infomap__InfomapParentIterator') && length(argv[[1]]) == 1) {
      f <- InfomapParentIterator__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for InfomapParentIterator with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_InfomapParentIterator

`delete_InfomapParentIterator` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_InfomapParentIterator', self, PACKAGE='infomap');
  
}

attr(`delete_InfomapParentIterator`, 'returnType') = 'void'
attr(`delete_InfomapParentIterator`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`delete_InfomapParentIterator`) = c("SWIGFunction", class('delete_InfomapParentIterator'))

# Start of InfomapParentIterator_Equal

`InfomapParentIterator_Equal` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_Equal', self, other, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapParentIterator", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_Equal`, 'returnType') = '_p_infomap__InfomapParentIterator'
attr(`InfomapParentIterator_Equal`, "inputTypes") = c('_p_infomap__InfomapParentIterator', '_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_Equal`) = c("SWIGFunction", class('InfomapParentIterator_Equal'))

# Start of InfomapParentIterator_current

`InfomapParentIterator_current__SWIG_0` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_current__SWIG_0', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_current__SWIG_0`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapParentIterator_current__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_current__SWIG_0`) = c("SWIGFunction", class('InfomapParentIterator_current__SWIG_0'))

# Start of InfomapParentIterator_current

`InfomapParentIterator_current__SWIG_1` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_current__SWIG_1', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_current__SWIG_1`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapParentIterator_current__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_current__SWIG_1`) = c("SWIGFunction", class('InfomapParentIterator_current__SWIG_1'))

`InfomapParentIterator_current` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapParentIterator') || is.null(argv[[1]]))) {
      f <- InfomapParentIterator_current__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapParentIterator') || is.null(argv[[1]]))) {
      f <- InfomapParentIterator_current__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapParentIterator_current with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapParentIterator___ref__

`InfomapParentIterator___ref____SWIG_0` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator___ref____SWIG_0', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator___ref____SWIG_0`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapParentIterator___ref____SWIG_0`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator___ref____SWIG_0`) = c("SWIGFunction", class('InfomapParentIterator___ref____SWIG_0'))

# Start of InfomapParentIterator___ref__

`InfomapParentIterator___ref____SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator___ref____SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator___ref____SWIG_1`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapParentIterator___ref____SWIG_1`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator___ref____SWIG_1`) = c("SWIGFunction", class('InfomapParentIterator___ref____SWIG_1'))

`InfomapParentIterator___ref__` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapParentIterator') || is.null(argv[[1]]))) {
      f <- InfomapParentIterator___ref____SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapParentIterator') || is.null(argv[[1]]))) {
      f <- InfomapParentIterator___ref____SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapParentIterator___ref__ with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapParentIterator___deref__

`InfomapParentIterator___deref____SWIG_0` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator___deref____SWIG_0', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator___deref____SWIG_0`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapParentIterator___deref____SWIG_0`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator___deref____SWIG_0`) = c("SWIGFunction", class('InfomapParentIterator___deref____SWIG_0'))

# Start of InfomapParentIterator___deref__

`InfomapParentIterator___deref____SWIG_1` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator___deref____SWIG_1', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator___deref____SWIG_1`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapParentIterator___deref____SWIG_1`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator___deref____SWIG_1`) = c("SWIGFunction", class('InfomapParentIterator___deref____SWIG_1'))

`InfomapParentIterator___deref__` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapParentIterator') || is.null(argv[[1]]))) {
      f <- InfomapParentIterator___deref____SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapParentIterator') || is.null(argv[[1]]))) {
      f <- InfomapParentIterator___deref____SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapParentIterator___deref__ with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapParentIterator_EqualEqual

`InfomapParentIterator_EqualEqual` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_EqualEqual', self, other, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_EqualEqual`, 'returnType') = 'logical'
attr(`InfomapParentIterator_EqualEqual`, "inputTypes") = c('_p_infomap__InfomapParentIterator', '_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_EqualEqual`) = c("SWIGFunction", class('InfomapParentIterator_EqualEqual'))

# Start of InfomapParentIterator_NotEqual

`InfomapParentIterator_NotEqual` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_NotEqual', self, other, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_NotEqual`, 'returnType') = 'logical'
attr(`InfomapParentIterator_NotEqual`, "inputTypes") = c('_p_infomap__InfomapParentIterator', '_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_NotEqual`) = c("SWIGFunction", class('InfomapParentIterator_NotEqual'))

# Start of InfomapParentIterator_PlusPlusPrefix

`InfomapParentIterator_PlusPlusPrefix` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_PlusPlusPrefix', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapParentIterator", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_PlusPlusPrefix`, 'returnType') = '_p_infomap__InfomapParentIterator'
attr(`InfomapParentIterator_PlusPlusPrefix`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_PlusPlusPrefix`) = c("SWIGFunction", class('InfomapParentIterator_PlusPlusPrefix'))

# Start of InfomapParentIterator_PlusPlusPostfix

`InfomapParentIterator_PlusPlusPostfix` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_arg2 = as.integer(s_arg2);
  
  if(length(s_arg2) > 1) {
    warning("using only the first element of s_arg2");
  };
  
  ;ans = .Call('R_swig_InfomapParentIterator_PlusPlusPostfix', self, s_arg2, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapParentIterator", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_PlusPlusPostfix`, 'returnType') = '_p_infomap__InfomapParentIterator'
attr(`InfomapParentIterator_PlusPlusPostfix`, "inputTypes") = c('_p_infomap__InfomapParentIterator', 'integer')
class(`InfomapParentIterator_PlusPlusPostfix`) = c("SWIGFunction", class('InfomapParentIterator_PlusPlusPostfix'))

# Start of InfomapParentIterator_stepForward

`InfomapParentIterator_stepForward` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_stepForward', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapParentIterator", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_stepForward`, 'returnType') = '_p_infomap__InfomapParentIterator'
attr(`InfomapParentIterator_stepForward`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_stepForward`) = c("SWIGFunction", class('InfomapParentIterator_stepForward'))

# Start of InfomapParentIterator_isEnd

`InfomapParentIterator_isEnd` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_isEnd', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_isEnd`, 'returnType') = 'logical'
attr(`InfomapParentIterator_isEnd`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_isEnd`) = c("SWIGFunction", class('InfomapParentIterator_isEnd'))

# Start of InfomapParentIterator_data_set

`InfomapParentIterator_data_set` = function(self, s_data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_data, "ExternalReference")) s_data = slot(s_data,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_data_set', self, s_data, PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_data_set`, 'returnType') = 'void'
attr(`InfomapParentIterator_data_set`, "inputTypes") = c('_p_infomap__InfomapParentIterator', '_p_infomap__FlowData')
class(`InfomapParentIterator_data_set`) = c("SWIGFunction", class('InfomapParentIterator_data_set'))

# Start of InfomapParentIterator_data_get

`InfomapParentIterator_data_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_data_get', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__FlowData", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_data_get`, 'returnType') = '_p_infomap__FlowData'
attr(`InfomapParentIterator_data_get`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_data_get`) = c("SWIGFunction", class('InfomapParentIterator_data_get'))

# Start of InfomapParentIterator_index_set

`InfomapParentIterator_index_set` = function(self, s_index)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_index = as.integer(s_index);
  
  if(length(s_index) > 1) {
    warning("using only the first element of s_index");
  };
  
  ;.Call('R_swig_InfomapParentIterator_index_set', self, s_index, PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_index_set`, 'returnType') = 'void'
attr(`InfomapParentIterator_index_set`, "inputTypes") = c('_p_infomap__InfomapParentIterator', 'integer')
class(`InfomapParentIterator_index_set`) = c("SWIGFunction", class('InfomapParentIterator_index_set'))

# Start of InfomapParentIterator_index_get

`InfomapParentIterator_index_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_index_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_index_get`, 'returnType') = 'integer'
attr(`InfomapParentIterator_index_get`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_index_get`) = c("SWIGFunction", class('InfomapParentIterator_index_get'))

# Start of InfomapParentIterator_stateId_set

`InfomapParentIterator_stateId_set` = function(self, s_stateId)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_stateId = as.integer(s_stateId);
  
  if(length(s_stateId) > 1) {
    warning("using only the first element of s_stateId");
  };
  
  ;.Call('R_swig_InfomapParentIterator_stateId_set', self, s_stateId, PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_stateId_set`, 'returnType') = 'void'
attr(`InfomapParentIterator_stateId_set`, "inputTypes") = c('_p_infomap__InfomapParentIterator', 'integer')
class(`InfomapParentIterator_stateId_set`) = c("SWIGFunction", class('InfomapParentIterator_stateId_set'))

# Start of InfomapParentIterator_stateId_get

`InfomapParentIterator_stateId_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_stateId_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_stateId_get`, 'returnType') = 'integer'
attr(`InfomapParentIterator_stateId_get`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_stateId_get`) = c("SWIGFunction", class('InfomapParentIterator_stateId_get'))

# Start of InfomapParentIterator_physicalId_set

`InfomapParentIterator_physicalId_set` = function(self, s_physicalId)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_physicalId = as.integer(s_physicalId);
  
  if(length(s_physicalId) > 1) {
    warning("using only the first element of s_physicalId");
  };
  
  ;.Call('R_swig_InfomapParentIterator_physicalId_set', self, s_physicalId, PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_physicalId_set`, 'returnType') = 'void'
attr(`InfomapParentIterator_physicalId_set`, "inputTypes") = c('_p_infomap__InfomapParentIterator', 'integer')
class(`InfomapParentIterator_physicalId_set`) = c("SWIGFunction", class('InfomapParentIterator_physicalId_set'))

# Start of InfomapParentIterator_physicalId_get

`InfomapParentIterator_physicalId_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_physicalId_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_physicalId_get`, 'returnType') = 'integer'
attr(`InfomapParentIterator_physicalId_get`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_physicalId_get`) = c("SWIGFunction", class('InfomapParentIterator_physicalId_get'))

# Start of InfomapParentIterator_layerId_set

`InfomapParentIterator_layerId_set` = function(self, s_layerId)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_layerId = as.integer(s_layerId);
  
  if(length(s_layerId) > 1) {
    warning("using only the first element of s_layerId");
  };
  
  ;.Call('R_swig_InfomapParentIterator_layerId_set', self, s_layerId, PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_layerId_set`, 'returnType') = 'void'
attr(`InfomapParentIterator_layerId_set`, "inputTypes") = c('_p_infomap__InfomapParentIterator', 'integer')
class(`InfomapParentIterator_layerId_set`) = c("SWIGFunction", class('InfomapParentIterator_layerId_set'))

# Start of InfomapParentIterator_layerId_get

`InfomapParentIterator_layerId_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_layerId_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_layerId_get`, 'returnType') = 'integer'
attr(`InfomapParentIterator_layerId_get`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_layerId_get`) = c("SWIGFunction", class('InfomapParentIterator_layerId_get'))

# Start of InfomapParentIterator_metaData_set

`InfomapParentIterator_metaData_set` = function(self, s_metaData)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_metaData = as.integer(s_metaData);
  ;.Call('R_swig_InfomapParentIterator_metaData_set', self, s_metaData, PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_metaData_set`, 'returnType') = 'void'
attr(`InfomapParentIterator_metaData_set`, "inputTypes") = c('_p_infomap__InfomapParentIterator', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`InfomapParentIterator_metaData_set`) = c("SWIGFunction", class('InfomapParentIterator_metaData_set'))

# Start of InfomapParentIterator_metaData_get

`InfomapParentIterator_metaData_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_metaData_get', self, PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_metaData_get`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`InfomapParentIterator_metaData_get`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_metaData_get`) = c("SWIGFunction", class('InfomapParentIterator_metaData_get'))

# Start of InfomapParentIterator_owner_set

`InfomapParentIterator_owner_set` = function(self, s_owner)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_owner, "ExternalReference")) s_owner = slot(s_owner,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_owner_set', self, s_owner, PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_owner_set`, 'returnType') = 'void'
attr(`InfomapParentIterator_owner_set`, "inputTypes") = c('_p_infomap__InfomapParentIterator', '_p_infomap__InfoNode')
class(`InfomapParentIterator_owner_set`) = c("SWIGFunction", class('InfomapParentIterator_owner_set'))

# Start of InfomapParentIterator_owner_get

`InfomapParentIterator_owner_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_owner_get', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_owner_get`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapParentIterator_owner_get`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_owner_get`) = c("SWIGFunction", class('InfomapParentIterator_owner_get'))

# Start of InfomapParentIterator_parent_set

`InfomapParentIterator_parent_set` = function(self, s_parent)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_parent, "ExternalReference")) s_parent = slot(s_parent,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_parent_set', self, s_parent, PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_parent_set`, 'returnType') = 'void'
attr(`InfomapParentIterator_parent_set`, "inputTypes") = c('_p_infomap__InfomapParentIterator', '_p_infomap__InfoNode')
class(`InfomapParentIterator_parent_set`) = c("SWIGFunction", class('InfomapParentIterator_parent_set'))

# Start of InfomapParentIterator_parent_get

`InfomapParentIterator_parent_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_parent_get', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_parent_get`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapParentIterator_parent_get`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_parent_get`) = c("SWIGFunction", class('InfomapParentIterator_parent_get'))

# Start of InfomapParentIterator_previous_set

`InfomapParentIterator_previous_set` = function(self, s_previous)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_previous, "ExternalReference")) s_previous = slot(s_previous,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_previous_set', self, s_previous, PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_previous_set`, 'returnType') = 'void'
attr(`InfomapParentIterator_previous_set`, "inputTypes") = c('_p_infomap__InfomapParentIterator', '_p_infomap__InfoNode')
class(`InfomapParentIterator_previous_set`) = c("SWIGFunction", class('InfomapParentIterator_previous_set'))

# Start of InfomapParentIterator_previous_get

`InfomapParentIterator_previous_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_previous_get', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_previous_get`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapParentIterator_previous_get`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_previous_get`) = c("SWIGFunction", class('InfomapParentIterator_previous_get'))

# Start of InfomapParentIterator__next_set

`InfomapParentIterator__next_set` = function(self, s_arg2)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref"); 
  ;.Call('R_swig_InfomapParentIterator__next_set', self, s_arg2, PACKAGE='infomap');
  
}

attr(`InfomapParentIterator__next_set`, 'returnType') = 'void'
attr(`InfomapParentIterator__next_set`, "inputTypes") = c('_p_infomap__InfomapParentIterator', '_p_infomap__InfoNode')
class(`InfomapParentIterator__next_set`) = c("SWIGFunction", class('InfomapParentIterator__next_set'))

# Start of InfomapParentIterator__next_get

`InfomapParentIterator__next_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator__next_get', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator__next_get`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapParentIterator__next_get`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator__next_get`) = c("SWIGFunction", class('InfomapParentIterator__next_get'))

# Start of InfomapParentIterator_firstChild_set

`InfomapParentIterator_firstChild_set` = function(self, s_firstChild)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_firstChild, "ExternalReference")) s_firstChild = slot(s_firstChild,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_firstChild_set', self, s_firstChild, PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_firstChild_set`, 'returnType') = 'void'
attr(`InfomapParentIterator_firstChild_set`, "inputTypes") = c('_p_infomap__InfomapParentIterator', '_p_infomap__InfoNode')
class(`InfomapParentIterator_firstChild_set`) = c("SWIGFunction", class('InfomapParentIterator_firstChild_set'))

# Start of InfomapParentIterator_firstChild_get

`InfomapParentIterator_firstChild_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_firstChild_get', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_firstChild_get`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapParentIterator_firstChild_get`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_firstChild_get`) = c("SWIGFunction", class('InfomapParentIterator_firstChild_get'))

# Start of InfomapParentIterator_lastChild_set

`InfomapParentIterator_lastChild_set` = function(self, s_lastChild)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_lastChild, "ExternalReference")) s_lastChild = slot(s_lastChild,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_lastChild_set', self, s_lastChild, PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_lastChild_set`, 'returnType') = 'void'
attr(`InfomapParentIterator_lastChild_set`, "inputTypes") = c('_p_infomap__InfomapParentIterator', '_p_infomap__InfoNode')
class(`InfomapParentIterator_lastChild_set`) = c("SWIGFunction", class('InfomapParentIterator_lastChild_set'))

# Start of InfomapParentIterator_lastChild_get

`InfomapParentIterator_lastChild_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_lastChild_get', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_lastChild_get`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapParentIterator_lastChild_get`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_lastChild_get`) = c("SWIGFunction", class('InfomapParentIterator_lastChild_get'))

# Start of InfomapParentIterator_collapsedFirstChild_set

`InfomapParentIterator_collapsedFirstChild_set` = function(self, s_collapsedFirstChild)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_collapsedFirstChild, "ExternalReference")) s_collapsedFirstChild = slot(s_collapsedFirstChild,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_collapsedFirstChild_set', self, s_collapsedFirstChild, PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_collapsedFirstChild_set`, 'returnType') = 'void'
attr(`InfomapParentIterator_collapsedFirstChild_set`, "inputTypes") = c('_p_infomap__InfomapParentIterator', '_p_infomap__InfoNode')
class(`InfomapParentIterator_collapsedFirstChild_set`) = c("SWIGFunction", class('InfomapParentIterator_collapsedFirstChild_set'))

# Start of InfomapParentIterator_collapsedFirstChild_get

`InfomapParentIterator_collapsedFirstChild_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_collapsedFirstChild_get', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_collapsedFirstChild_get`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapParentIterator_collapsedFirstChild_get`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_collapsedFirstChild_get`) = c("SWIGFunction", class('InfomapParentIterator_collapsedFirstChild_get'))

# Start of InfomapParentIterator_collapsedLastChild_set

`InfomapParentIterator_collapsedLastChild_set` = function(self, s_collapsedLastChild)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_collapsedLastChild, "ExternalReference")) s_collapsedLastChild = slot(s_collapsedLastChild,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_collapsedLastChild_set', self, s_collapsedLastChild, PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_collapsedLastChild_set`, 'returnType') = 'void'
attr(`InfomapParentIterator_collapsedLastChild_set`, "inputTypes") = c('_p_infomap__InfomapParentIterator', '_p_infomap__InfoNode')
class(`InfomapParentIterator_collapsedLastChild_set`) = c("SWIGFunction", class('InfomapParentIterator_collapsedLastChild_set'))

# Start of InfomapParentIterator_collapsedLastChild_get

`InfomapParentIterator_collapsedLastChild_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_collapsedLastChild_get', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_collapsedLastChild_get`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapParentIterator_collapsedLastChild_get`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_collapsedLastChild_get`) = c("SWIGFunction", class('InfomapParentIterator_collapsedLastChild_get'))

# Start of InfomapParentIterator_codelength_set

`InfomapParentIterator_codelength_set` = function(self, s_codelength)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_InfomapParentIterator_codelength_set', self, s_codelength, PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_codelength_set`, 'returnType') = 'void'
attr(`InfomapParentIterator_codelength_set`, "inputTypes") = c('_p_infomap__InfomapParentIterator', 'numeric')
class(`InfomapParentIterator_codelength_set`) = c("SWIGFunction", class('InfomapParentIterator_codelength_set'))

# Start of InfomapParentIterator_codelength_get

`InfomapParentIterator_codelength_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_codelength_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_codelength_get`, 'returnType') = 'numeric'
attr(`InfomapParentIterator_codelength_get`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_codelength_get`) = c("SWIGFunction", class('InfomapParentIterator_codelength_get'))

# Start of InfomapParentIterator_dirty_set

`InfomapParentIterator_dirty_set` = function(self, s_dirty)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_dirty = as.logical(s_dirty);
  ;.Call('R_swig_InfomapParentIterator_dirty_set', self, s_dirty, PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_dirty_set`, 'returnType') = 'void'
attr(`InfomapParentIterator_dirty_set`, "inputTypes") = c('_p_infomap__InfomapParentIterator', 'logical')
class(`InfomapParentIterator_dirty_set`) = c("SWIGFunction", class('InfomapParentIterator_dirty_set'))

# Start of InfomapParentIterator_dirty_get

`InfomapParentIterator_dirty_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_dirty_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_dirty_get`, 'returnType') = 'logical'
attr(`InfomapParentIterator_dirty_get`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_dirty_get`) = c("SWIGFunction", class('InfomapParentIterator_dirty_get'))

# Start of InfomapParentIterator_physicalNodes_set

`InfomapParentIterator_physicalNodes_set` = function(self, s_physicalNodes)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_physicalNodes, "ExternalReference")) s_physicalNodes = slot(s_physicalNodes,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_physicalNodes_set', self, s_physicalNodes, PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_physicalNodes_set`, 'returnType') = 'void'
attr(`InfomapParentIterator_physicalNodes_set`, "inputTypes") = c('_p_infomap__InfomapParentIterator', '_p_std__vectorT_infomap__PhysData_std__allocatorT_infomap__PhysData_t_t')
class(`InfomapParentIterator_physicalNodes_set`) = c("SWIGFunction", class('InfomapParentIterator_physicalNodes_set'))

# Start of InfomapParentIterator_physicalNodes_get

`InfomapParentIterator_physicalNodes_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_physicalNodes_get', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_infomap__PhysData_std__allocatorT_infomap__PhysData_t_t", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_physicalNodes_get`, 'returnType') = '_p_std__vectorT_infomap__PhysData_std__allocatorT_infomap__PhysData_t_t'
attr(`InfomapParentIterator_physicalNodes_get`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_physicalNodes_get`) = c("SWIGFunction", class('InfomapParentIterator_physicalNodes_get'))

# Start of InfomapParentIterator_metaCollection_set

`InfomapParentIterator_metaCollection_set` = function(self, s_metaCollection)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_metaCollection, "ExternalReference")) s_metaCollection = slot(s_metaCollection,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_metaCollection_set', self, s_metaCollection, PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_metaCollection_set`, 'returnType') = 'void'
attr(`InfomapParentIterator_metaCollection_set`, "inputTypes") = c('_p_infomap__InfomapParentIterator', '_p_MetaCollection')
class(`InfomapParentIterator_metaCollection_set`) = c("SWIGFunction", class('InfomapParentIterator_metaCollection_set'))

# Start of InfomapParentIterator_metaCollection_get

`InfomapParentIterator_metaCollection_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_metaCollection_get', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_MetaCollection", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_metaCollection_get`, 'returnType') = '_p_MetaCollection'
attr(`InfomapParentIterator_metaCollection_get`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_metaCollection_get`) = c("SWIGFunction", class('InfomapParentIterator_metaCollection_get'))

# Start of InfomapParentIterator_stateNodes_set

`InfomapParentIterator_stateNodes_set` = function(self, s_stateNodes)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_stateNodes = as.integer(s_stateNodes);
  ;.Call('R_swig_InfomapParentIterator_stateNodes_set', self, s_stateNodes, PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_stateNodes_set`, 'returnType') = 'void'
attr(`InfomapParentIterator_stateNodes_set`, "inputTypes") = c('_p_infomap__InfomapParentIterator', 'integer')
class(`InfomapParentIterator_stateNodes_set`) = c("SWIGFunction", class('InfomapParentIterator_stateNodes_set'))

# Start of InfomapParentIterator_stateNodes_get

`InfomapParentIterator_stateNodes_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_stateNodes_get', self, PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_stateNodes_get`, 'returnType') = 'integer'
attr(`InfomapParentIterator_stateNodes_get`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_stateNodes_get`) = c("SWIGFunction", class('InfomapParentIterator_stateNodes_get'))

# Start of InfomapParentIterator_getMetaData

`InfomapParentIterator_getMetaData__SWIG_0` = function(self, dimension, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  dimension = as.integer(dimension);
  
  if(length(dimension) > 1) {
    warning("using only the first element of dimension");
  };
  
  ;.Call('R_swig_InfomapParentIterator_getMetaData__SWIG_0', self, dimension, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_getMetaData__SWIG_0`, 'returnType') = 'integer'
attr(`InfomapParentIterator_getMetaData__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapParentIterator', 'integer')
class(`InfomapParentIterator_getMetaData__SWIG_0`) = c("SWIGFunction", class('InfomapParentIterator_getMetaData__SWIG_0'))

# Start of InfomapParentIterator_getMetaData

`InfomapParentIterator_getMetaData__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_getMetaData__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_getMetaData__SWIG_1`, 'returnType') = 'integer'
attr(`InfomapParentIterator_getMetaData__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_getMetaData__SWIG_1`) = c("SWIGFunction", class('InfomapParentIterator_getMetaData__SWIG_1'))

`InfomapParentIterator_getMetaData` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapParentIterator') || is.null(argv[[1]]))) {
      f <- InfomapParentIterator_getMetaData__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapParentIterator') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- InfomapParentIterator_getMetaData__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InfomapParentIterator_getMetaData with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapParentIterator_getInfomap

`InfomapParentIterator_getInfomap` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_getInfomap', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_getInfomap`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfomapParentIterator_getInfomap`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_getInfomap`) = c("SWIGFunction", class('InfomapParentIterator_getInfomap'))

# Start of InfomapParentIterator_setInfomap

`InfomapParentIterator_setInfomap` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_setInfomap', self, s_arg2, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_setInfomap`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfomapParentIterator_setInfomap`, "inputTypes") = c('_p_infomap__InfomapParentIterator', '_p_infomap__InfomapBase')
class(`InfomapParentIterator_setInfomap`) = c("SWIGFunction", class('InfomapParentIterator_setInfomap'))

# Start of InfomapParentIterator_getInfomapRoot

`InfomapParentIterator_getInfomapRoot__SWIG_0` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_getInfomapRoot__SWIG_0', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_getInfomapRoot__SWIG_0`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapParentIterator_getInfomapRoot__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_getInfomapRoot__SWIG_0`) = c("SWIGFunction", class('InfomapParentIterator_getInfomapRoot__SWIG_0'))

# Start of InfomapParentIterator_getInfomapRoot

`InfomapParentIterator_getInfomapRoot__SWIG_1` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_getInfomapRoot__SWIG_1', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_getInfomapRoot__SWIG_1`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapParentIterator_getInfomapRoot__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_getInfomapRoot__SWIG_1`) = c("SWIGFunction", class('InfomapParentIterator_getInfomapRoot__SWIG_1'))

`InfomapParentIterator_getInfomapRoot` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapParentIterator') || is.null(argv[[1]]))) {
      f <- InfomapParentIterator_getInfomapRoot__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapParentIterator') || is.null(argv[[1]]))) {
      f <- InfomapParentIterator_getInfomapRoot__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapParentIterator_getInfomapRoot with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapParentIterator_disposeInfomap

`InfomapParentIterator_disposeInfomap` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_disposeInfomap', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_disposeInfomap`, 'returnType') = 'logical'
attr(`InfomapParentIterator_disposeInfomap`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_disposeInfomap`) = c("SWIGFunction", class('InfomapParentIterator_disposeInfomap'))

# Start of InfomapParentIterator_numPhysicalNodes

`InfomapParentIterator_numPhysicalNodes` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_numPhysicalNodes', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_numPhysicalNodes`, 'returnType') = 'integer'
attr(`InfomapParentIterator_numPhysicalNodes`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_numPhysicalNodes`) = c("SWIGFunction", class('InfomapParentIterator_numPhysicalNodes'))

# Start of InfomapParentIterator_begin

`InfomapParentIterator_begin__SWIG_0` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_begin__SWIG_0', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_ChildIteratorT_infomap__InfoNode_p_t", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_begin__SWIG_0`, 'returnType') = '_p_ChildIteratorT_infomap__InfoNode_p_t'
attr(`InfomapParentIterator_begin__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_begin__SWIG_0`) = c("SWIGFunction", class('InfomapParentIterator_begin__SWIG_0'))

# Start of InfomapParentIterator_begin

`InfomapParentIterator_begin__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_begin__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_ChildIteratorT_infomap__InfoNode_const_p_t", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_begin__SWIG_1`, 'returnType') = '_p_ChildIteratorT_infomap__InfoNode_const_p_t'
attr(`InfomapParentIterator_begin__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_begin__SWIG_1`) = c("SWIGFunction", class('InfomapParentIterator_begin__SWIG_1'))

`InfomapParentIterator_begin` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapParentIterator') || is.null(argv[[1]]))) {
      f <- InfomapParentIterator_begin__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapParentIterator') || is.null(argv[[1]]))) {
      f <- InfomapParentIterator_begin__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapParentIterator_begin with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapParentIterator_end

`InfomapParentIterator_end__SWIG_0` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_end__SWIG_0', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_ChildIteratorT_infomap__InfoNode_p_t", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_end__SWIG_0`, 'returnType') = '_p_ChildIteratorT_infomap__InfoNode_p_t'
attr(`InfomapParentIterator_end__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_end__SWIG_0`) = c("SWIGFunction", class('InfomapParentIterator_end__SWIG_0'))

# Start of InfomapParentIterator_end

`InfomapParentIterator_end__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_end__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_ChildIteratorT_infomap__InfoNode_const_p_t", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_end__SWIG_1`, 'returnType') = '_p_ChildIteratorT_infomap__InfoNode_const_p_t'
attr(`InfomapParentIterator_end__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_end__SWIG_1`) = c("SWIGFunction", class('InfomapParentIterator_end__SWIG_1'))

`InfomapParentIterator_end` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapParentIterator') || is.null(argv[[1]]))) {
      f <- InfomapParentIterator_end__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapParentIterator') || is.null(argv[[1]]))) {
      f <- InfomapParentIterator_end__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapParentIterator_end with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapParentIterator_begin_child

`InfomapParentIterator_begin_child__SWIG_0` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_begin_child__SWIG_0', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_ChildIteratorT_infomap__InfoNode_p_t", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_begin_child__SWIG_0`, 'returnType') = '_p_ChildIteratorT_infomap__InfoNode_p_t'
attr(`InfomapParentIterator_begin_child__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_begin_child__SWIG_0`) = c("SWIGFunction", class('InfomapParentIterator_begin_child__SWIG_0'))

# Start of InfomapParentIterator_begin_child

`InfomapParentIterator_begin_child__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_begin_child__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_ChildIteratorT_infomap__InfoNode_const_p_t", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_begin_child__SWIG_1`, 'returnType') = '_p_ChildIteratorT_infomap__InfoNode_const_p_t'
attr(`InfomapParentIterator_begin_child__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_begin_child__SWIG_1`) = c("SWIGFunction", class('InfomapParentIterator_begin_child__SWIG_1'))

`InfomapParentIterator_begin_child` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapParentIterator') || is.null(argv[[1]]))) {
      f <- InfomapParentIterator_begin_child__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapParentIterator') || is.null(argv[[1]]))) {
      f <- InfomapParentIterator_begin_child__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapParentIterator_begin_child with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapParentIterator_end_child

`InfomapParentIterator_end_child__SWIG_0` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_end_child__SWIG_0', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_ChildIteratorT_infomap__InfoNode_p_t", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_end_child__SWIG_0`, 'returnType') = '_p_ChildIteratorT_infomap__InfoNode_p_t'
attr(`InfomapParentIterator_end_child__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_end_child__SWIG_0`) = c("SWIGFunction", class('InfomapParentIterator_end_child__SWIG_0'))

# Start of InfomapParentIterator_end_child

`InfomapParentIterator_end_child__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_end_child__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_ChildIteratorT_infomap__InfoNode_const_p_t", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_end_child__SWIG_1`, 'returnType') = '_p_ChildIteratorT_infomap__InfoNode_const_p_t'
attr(`InfomapParentIterator_end_child__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_end_child__SWIG_1`) = c("SWIGFunction", class('InfomapParentIterator_end_child__SWIG_1'))

`InfomapParentIterator_end_child` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapParentIterator') || is.null(argv[[1]]))) {
      f <- InfomapParentIterator_end_child__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapParentIterator') || is.null(argv[[1]]))) {
      f <- InfomapParentIterator_end_child__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapParentIterator_end_child with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapParentIterator_children

`InfomapParentIterator_children__SWIG_0` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_children__SWIG_0', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_IterWrapperT_ChildIteratorT_infomap__InfoNode_p_t_t", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_children__SWIG_0`, 'returnType') = '_p_IterWrapperT_ChildIteratorT_infomap__InfoNode_p_t_t'
attr(`InfomapParentIterator_children__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_children__SWIG_0`) = c("SWIGFunction", class('InfomapParentIterator_children__SWIG_0'))

# Start of InfomapParentIterator_children

`InfomapParentIterator_children__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_children__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_IterWrapperT_ChildIteratorT_infomap__InfoNode_const_p_t_t", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_children__SWIG_1`, 'returnType') = '_p_IterWrapperT_ChildIteratorT_infomap__InfoNode_const_p_t_t'
attr(`InfomapParentIterator_children__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_children__SWIG_1`) = c("SWIGFunction", class('InfomapParentIterator_children__SWIG_1'))

`InfomapParentIterator_children` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapParentIterator') || is.null(argv[[1]]))) {
      f <- InfomapParentIterator_children__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapParentIterator') || is.null(argv[[1]]))) {
      f <- InfomapParentIterator_children__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapParentIterator_children with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapParentIterator_infomap_children

`InfomapParentIterator_infomap_children__SWIG_0` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_infomap_children__SWIG_0', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_IterWrapperT_InfomapChildIteratorT_infomap__InfoNode_p_t_t", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_infomap_children__SWIG_0`, 'returnType') = '_p_IterWrapperT_InfomapChildIteratorT_infomap__InfoNode_p_t_t'
attr(`InfomapParentIterator_infomap_children__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_infomap_children__SWIG_0`) = c("SWIGFunction", class('InfomapParentIterator_infomap_children__SWIG_0'))

# Start of InfomapParentIterator_infomap_children

`InfomapParentIterator_infomap_children__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_infomap_children__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_IterWrapperT_InfomapChildIteratorT_infomap__InfoNode_const_p_t_t", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_infomap_children__SWIG_1`, 'returnType') = '_p_IterWrapperT_InfomapChildIteratorT_infomap__InfoNode_const_p_t_t'
attr(`InfomapParentIterator_infomap_children__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_infomap_children__SWIG_1`) = c("SWIGFunction", class('InfomapParentIterator_infomap_children__SWIG_1'))

`InfomapParentIterator_infomap_children` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapParentIterator') || is.null(argv[[1]]))) {
      f <- InfomapParentIterator_infomap_children__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapParentIterator') || is.null(argv[[1]]))) {
      f <- InfomapParentIterator_infomap_children__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapParentIterator_infomap_children with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapParentIterator_begin_post_depth_first

`InfomapParentIterator_begin_post_depth_first` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_begin_post_depth_first', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_DepthFirstIteratorT_infomap__InfoNode_p_false_t", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_begin_post_depth_first`, 'returnType') = '_p_DepthFirstIteratorT_infomap__InfoNode_p_false_t'
attr(`InfomapParentIterator_begin_post_depth_first`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_begin_post_depth_first`) = c("SWIGFunction", class('InfomapParentIterator_begin_post_depth_first'))

# Start of InfomapParentIterator_begin_leaf_nodes

`InfomapParentIterator_begin_leaf_nodes` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_begin_leaf_nodes', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_LeafNodeIteratorT_infomap__InfoNode_p_t", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_begin_leaf_nodes`, 'returnType') = '_p_LeafNodeIteratorT_infomap__InfoNode_p_t'
attr(`InfomapParentIterator_begin_leaf_nodes`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_begin_leaf_nodes`) = c("SWIGFunction", class('InfomapParentIterator_begin_leaf_nodes'))

# Start of InfomapParentIterator_begin_leaf_modules

`InfomapParentIterator_begin_leaf_modules` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_begin_leaf_modules', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_LeafModuleIteratorT_infomap__InfoNode_p_t", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_begin_leaf_modules`, 'returnType') = '_p_LeafModuleIteratorT_infomap__InfoNode_p_t'
attr(`InfomapParentIterator_begin_leaf_modules`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_begin_leaf_modules`) = c("SWIGFunction", class('InfomapParentIterator_begin_leaf_modules'))

# Start of InfomapParentIterator_begin_tree

`InfomapParentIterator_begin_tree__SWIG_0` = function(self, maxClusterLevel, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  maxClusterLevel = as.integer(maxClusterLevel);
  
  if(length(maxClusterLevel) > 1) {
    warning("using only the first element of maxClusterLevel");
  };
  
  ;ans = .Call('R_swig_InfomapParentIterator_begin_tree__SWIG_0', self, maxClusterLevel, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_TreeIteratorT_infomap__InfoNode_p_t", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_begin_tree__SWIG_0`, 'returnType') = '_p_TreeIteratorT_infomap__InfoNode_p_t'
attr(`InfomapParentIterator_begin_tree__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapParentIterator', 'integer')
class(`InfomapParentIterator_begin_tree__SWIG_0`) = c("SWIGFunction", class('InfomapParentIterator_begin_tree__SWIG_0'))

# Start of InfomapParentIterator_begin_tree

`InfomapParentIterator_begin_tree__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_begin_tree__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_TreeIteratorT_infomap__InfoNode_p_t", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_begin_tree__SWIG_1`, 'returnType') = '_p_TreeIteratorT_infomap__InfoNode_p_t'
attr(`InfomapParentIterator_begin_tree__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_begin_tree__SWIG_1`) = c("SWIGFunction", class('InfomapParentIterator_begin_tree__SWIG_1'))

# Start of InfomapParentIterator_begin_tree

`InfomapParentIterator_begin_tree__SWIG_2` = function(self, maxClusterLevel, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  maxClusterLevel = as.integer(maxClusterLevel);
  
  if(length(maxClusterLevel) > 1) {
    warning("using only the first element of maxClusterLevel");
  };
  
  ;ans = .Call('R_swig_InfomapParentIterator_begin_tree__SWIG_2', self, maxClusterLevel, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_TreeIteratorT_infomap__InfoNode_const_p_t", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_begin_tree__SWIG_2`, 'returnType') = '_p_TreeIteratorT_infomap__InfoNode_const_p_t'
attr(`InfomapParentIterator_begin_tree__SWIG_2`, "inputTypes") = c('_p_infomap__InfomapParentIterator', 'integer')
class(`InfomapParentIterator_begin_tree__SWIG_2`) = c("SWIGFunction", class('InfomapParentIterator_begin_tree__SWIG_2'))

# Start of InfomapParentIterator_begin_tree

`InfomapParentIterator_begin_tree__SWIG_3` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_begin_tree__SWIG_3', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_TreeIteratorT_infomap__InfoNode_const_p_t", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_begin_tree__SWIG_3`, 'returnType') = '_p_TreeIteratorT_infomap__InfoNode_const_p_t'
attr(`InfomapParentIterator_begin_tree__SWIG_3`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_begin_tree__SWIG_3`) = c("SWIGFunction", class('InfomapParentIterator_begin_tree__SWIG_3'))

`InfomapParentIterator_begin_tree` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapParentIterator') || is.null(argv[[1]]))) {
      f <- InfomapParentIterator_begin_tree__SWIG_1; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapParentIterator') || is.null(argv[[1]]))) {
      f <- InfomapParentIterator_begin_tree__SWIG_3; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapParentIterator') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- InfomapParentIterator_begin_tree__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapParentIterator') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- InfomapParentIterator_begin_tree__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for InfomapParentIterator_begin_tree with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapParentIterator_end_tree

`InfomapParentIterator_end_tree__SWIG_0` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_end_tree__SWIG_0', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_TreeIteratorT_infomap__InfoNode_p_t", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_end_tree__SWIG_0`, 'returnType') = '_p_TreeIteratorT_infomap__InfoNode_p_t'
attr(`InfomapParentIterator_end_tree__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_end_tree__SWIG_0`) = c("SWIGFunction", class('InfomapParentIterator_end_tree__SWIG_0'))

# Start of InfomapParentIterator_end_tree

`InfomapParentIterator_end_tree__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_end_tree__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_TreeIteratorT_infomap__InfoNode_const_p_t", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_end_tree__SWIG_1`, 'returnType') = '_p_TreeIteratorT_infomap__InfoNode_const_p_t'
attr(`InfomapParentIterator_end_tree__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_end_tree__SWIG_1`) = c("SWIGFunction", class('InfomapParentIterator_end_tree__SWIG_1'))

`InfomapParentIterator_end_tree` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapParentIterator') || is.null(argv[[1]]))) {
      f <- InfomapParentIterator_end_tree__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapParentIterator') || is.null(argv[[1]]))) {
      f <- InfomapParentIterator_end_tree__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapParentIterator_end_tree with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapParentIterator_infomapTree

`InfomapParentIterator_infomapTree__SWIG_0` = function(self, maxClusterLevel, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  maxClusterLevel = as.integer(maxClusterLevel);
  
  if(length(maxClusterLevel) > 1) {
    warning("using only the first element of maxClusterLevel");
  };
  
  ;ans = .Call('R_swig_InfomapParentIterator_infomapTree__SWIG_0', self, maxClusterLevel, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_p_t_t", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_infomapTree__SWIG_0`, 'returnType') = '_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_p_t_t'
attr(`InfomapParentIterator_infomapTree__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapParentIterator', 'integer')
class(`InfomapParentIterator_infomapTree__SWIG_0`) = c("SWIGFunction", class('InfomapParentIterator_infomapTree__SWIG_0'))

# Start of InfomapParentIterator_infomapTree

`InfomapParentIterator_infomapTree__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_infomapTree__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_p_t_t", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_infomapTree__SWIG_1`, 'returnType') = '_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_p_t_t'
attr(`InfomapParentIterator_infomapTree__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_infomapTree__SWIG_1`) = c("SWIGFunction", class('InfomapParentIterator_infomapTree__SWIG_1'))

# Start of InfomapParentIterator_infomapTree

`InfomapParentIterator_infomapTree__SWIG_2` = function(self, maxClusterLevel, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  maxClusterLevel = as.integer(maxClusterLevel);
  
  if(length(maxClusterLevel) > 1) {
    warning("using only the first element of maxClusterLevel");
  };
  
  ;ans = .Call('R_swig_InfomapParentIterator_infomapTree__SWIG_2', self, maxClusterLevel, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_const_p_t_t", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_infomapTree__SWIG_2`, 'returnType') = '_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_const_p_t_t'
attr(`InfomapParentIterator_infomapTree__SWIG_2`, "inputTypes") = c('_p_infomap__InfomapParentIterator', 'integer')
class(`InfomapParentIterator_infomapTree__SWIG_2`) = c("SWIGFunction", class('InfomapParentIterator_infomapTree__SWIG_2'))

# Start of InfomapParentIterator_infomapTree

`InfomapParentIterator_infomapTree__SWIG_3` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_infomapTree__SWIG_3', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_const_p_t_t", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_infomapTree__SWIG_3`, 'returnType') = '_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_const_p_t_t'
attr(`InfomapParentIterator_infomapTree__SWIG_3`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_infomapTree__SWIG_3`) = c("SWIGFunction", class('InfomapParentIterator_infomapTree__SWIG_3'))

`InfomapParentIterator_infomapTree` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapParentIterator') || is.null(argv[[1]]))) {
      f <- InfomapParentIterator_infomapTree__SWIG_1; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapParentIterator') || is.null(argv[[1]]))) {
      f <- InfomapParentIterator_infomapTree__SWIG_3; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapParentIterator') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- InfomapParentIterator_infomapTree__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapParentIterator') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- InfomapParentIterator_infomapTree__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for InfomapParentIterator_infomapTree with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapParentIterator_begin_outEdge

`InfomapParentIterator_begin_outEdge` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_begin_outEdge', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_begin_outEdge`, 'returnType') = '_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator'
attr(`InfomapParentIterator_begin_outEdge`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_begin_outEdge`) = c("SWIGFunction", class('InfomapParentIterator_begin_outEdge'))

# Start of InfomapParentIterator_end_outEdge

`InfomapParentIterator_end_outEdge` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_end_outEdge', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_end_outEdge`, 'returnType') = '_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator'
attr(`InfomapParentIterator_end_outEdge`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_end_outEdge`) = c("SWIGFunction", class('InfomapParentIterator_end_outEdge'))

# Start of InfomapParentIterator_begin_inEdge

`InfomapParentIterator_begin_inEdge` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_begin_inEdge', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_begin_inEdge`, 'returnType') = '_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator'
attr(`InfomapParentIterator_begin_inEdge`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_begin_inEdge`) = c("SWIGFunction", class('InfomapParentIterator_begin_inEdge'))

# Start of InfomapParentIterator_end_inEdge

`InfomapParentIterator_end_inEdge` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_end_inEdge', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_end_inEdge`, 'returnType') = '_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator'
attr(`InfomapParentIterator_end_inEdge`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_end_inEdge`) = c("SWIGFunction", class('InfomapParentIterator_end_inEdge'))

# Start of InfomapParentIterator_outEdges

`InfomapParentIterator_outEdges` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_outEdges', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_IterWrapperT_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator_t", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_outEdges`, 'returnType') = '_p_IterWrapperT_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator_t'
attr(`InfomapParentIterator_outEdges`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_outEdges`) = c("SWIGFunction", class('InfomapParentIterator_outEdges'))

# Start of InfomapParentIterator_inEdges

`InfomapParentIterator_inEdges` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_inEdges', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_IterWrapperT_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator_t", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_inEdges`, 'returnType') = '_p_IterWrapperT_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator_t'
attr(`InfomapParentIterator_inEdges`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_inEdges`) = c("SWIGFunction", class('InfomapParentIterator_inEdges'))

# Start of InfomapParentIterator_childDegree

`InfomapParentIterator_childDegree` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_childDegree', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_childDegree`, 'returnType') = 'integer'
attr(`InfomapParentIterator_childDegree`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_childDegree`) = c("SWIGFunction", class('InfomapParentIterator_childDegree'))

# Start of InfomapParentIterator_isLeaf

`InfomapParentIterator_isLeaf` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_isLeaf', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_isLeaf`, 'returnType') = 'logical'
attr(`InfomapParentIterator_isLeaf`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_isLeaf`) = c("SWIGFunction", class('InfomapParentIterator_isLeaf'))

# Start of InfomapParentIterator_isLeafModule

`InfomapParentIterator_isLeafModule` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_isLeafModule', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_isLeafModule`, 'returnType') = 'logical'
attr(`InfomapParentIterator_isLeafModule`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_isLeafModule`) = c("SWIGFunction", class('InfomapParentIterator_isLeafModule'))

# Start of InfomapParentIterator_isRoot

`InfomapParentIterator_isRoot` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_isRoot', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_isRoot`, 'returnType') = 'logical'
attr(`InfomapParentIterator_isRoot`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_isRoot`) = c("SWIGFunction", class('InfomapParentIterator_isRoot'))

# Start of InfomapParentIterator_depth

`InfomapParentIterator_depth` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_depth', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_depth`, 'returnType') = 'integer'
attr(`InfomapParentIterator_depth`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_depth`) = c("SWIGFunction", class('InfomapParentIterator_depth'))

# Start of InfomapParentIterator_firstDepthBelow

`InfomapParentIterator_firstDepthBelow` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_firstDepthBelow', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_firstDepthBelow`, 'returnType') = 'integer'
attr(`InfomapParentIterator_firstDepthBelow`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_firstDepthBelow`) = c("SWIGFunction", class('InfomapParentIterator_firstDepthBelow'))

# Start of InfomapParentIterator_numLeafMembers

`InfomapParentIterator_numLeafMembers` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_numLeafMembers', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_numLeafMembers`, 'returnType') = 'integer'
attr(`InfomapParentIterator_numLeafMembers`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_numLeafMembers`) = c("SWIGFunction", class('InfomapParentIterator_numLeafMembers'))

# Start of InfomapParentIterator_isDangling

`InfomapParentIterator_isDangling` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_isDangling', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_isDangling`, 'returnType') = 'logical'
attr(`InfomapParentIterator_isDangling`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_isDangling`) = c("SWIGFunction", class('InfomapParentIterator_isDangling'))

# Start of InfomapParentIterator_outDegree

`InfomapParentIterator_outDegree` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_outDegree', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_outDegree`, 'returnType') = 'integer'
attr(`InfomapParentIterator_outDegree`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_outDegree`) = c("SWIGFunction", class('InfomapParentIterator_outDegree'))

# Start of InfomapParentIterator_inDegree

`InfomapParentIterator_inDegree` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_inDegree', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_inDegree`, 'returnType') = 'integer'
attr(`InfomapParentIterator_inDegree`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_inDegree`) = c("SWIGFunction", class('InfomapParentIterator_inDegree'))

# Start of InfomapParentIterator_degree

`InfomapParentIterator_degree` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_degree', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_degree`, 'returnType') = 'integer'
attr(`InfomapParentIterator_degree`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_degree`) = c("SWIGFunction", class('InfomapParentIterator_degree'))

# Start of InfomapParentIterator_isFirst

`InfomapParentIterator_isFirst` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_isFirst', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_isFirst`, 'returnType') = 'logical'
attr(`InfomapParentIterator_isFirst`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_isFirst`) = c("SWIGFunction", class('InfomapParentIterator_isFirst'))

# Start of InfomapParentIterator_isLast

`InfomapParentIterator_isLast` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_isLast', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_isLast`, 'returnType') = 'logical'
attr(`InfomapParentIterator_isLast`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_isLast`) = c("SWIGFunction", class('InfomapParentIterator_isLast'))

# Start of InfomapParentIterator_childIndex

`InfomapParentIterator_childIndex` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_childIndex', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_childIndex`, 'returnType') = 'integer'
attr(`InfomapParentIterator_childIndex`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_childIndex`) = c("SWIGFunction", class('InfomapParentIterator_childIndex'))

# Start of InfomapParentIterator_calculatePath

`InfomapParentIterator_calculatePath` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_calculatePath', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_calculatePath`, 'returnType') = 'integer'
attr(`InfomapParentIterator_calculatePath`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_calculatePath`) = c("SWIGFunction", class('InfomapParentIterator_calculatePath'))

# Start of InfomapParentIterator_infomapChildDegree

`InfomapParentIterator_infomapChildDegree` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_infomapChildDegree', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_infomapChildDegree`, 'returnType') = 'integer'
attr(`InfomapParentIterator_infomapChildDegree`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_infomapChildDegree`) = c("SWIGFunction", class('InfomapParentIterator_infomapChildDegree'))

# Start of InfomapParentIterator_id

`InfomapParentIterator_id` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_id', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_id`, 'returnType') = 'integer'
attr(`InfomapParentIterator_id`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_id`) = c("SWIGFunction", class('InfomapParentIterator_id'))

# Start of InfomapParentIterator_initClean

`InfomapParentIterator_initClean` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_initClean', self, PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_initClean`, 'returnType') = 'void'
attr(`InfomapParentIterator_initClean`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_initClean`) = c("SWIGFunction", class('InfomapParentIterator_initClean'))

# Start of InfomapParentIterator_sortChildrenOnFlow

`InfomapParentIterator_sortChildrenOnFlow__SWIG_0` = function(self, recurse)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  recurse = as.logical(recurse);
  ;.Call('R_swig_InfomapParentIterator_sortChildrenOnFlow__SWIG_0', self, recurse, PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_sortChildrenOnFlow__SWIG_0`, 'returnType') = 'void'
attr(`InfomapParentIterator_sortChildrenOnFlow__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapParentIterator', 'logical')
class(`InfomapParentIterator_sortChildrenOnFlow__SWIG_0`) = c("SWIGFunction", class('InfomapParentIterator_sortChildrenOnFlow__SWIG_0'))

# Start of InfomapParentIterator_sortChildrenOnFlow

`InfomapParentIterator_sortChildrenOnFlow__SWIG_1` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_sortChildrenOnFlow__SWIG_1', self, PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_sortChildrenOnFlow__SWIG_1`, 'returnType') = 'void'
attr(`InfomapParentIterator_sortChildrenOnFlow__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_sortChildrenOnFlow__SWIG_1`) = c("SWIGFunction", class('InfomapParentIterator_sortChildrenOnFlow__SWIG_1'))

`InfomapParentIterator_sortChildrenOnFlow` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapParentIterator') || is.null(argv[[1]]))) {
      f <- InfomapParentIterator_sortChildrenOnFlow__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapParentIterator') || is.null(argv[[1]])) && ( is.logical(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- InfomapParentIterator_sortChildrenOnFlow__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InfomapParentIterator_sortChildrenOnFlow with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapParentIterator_collapseChildren

`InfomapParentIterator_collapseChildren` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_collapseChildren', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_collapseChildren`, 'returnType') = 'integer'
attr(`InfomapParentIterator_collapseChildren`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_collapseChildren`) = c("SWIGFunction", class('InfomapParentIterator_collapseChildren'))

# Start of InfomapParentIterator_expandChildren

`InfomapParentIterator_expandChildren` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_expandChildren', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_expandChildren`, 'returnType') = 'integer'
attr(`InfomapParentIterator_expandChildren`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_expandChildren`) = c("SWIGFunction", class('InfomapParentIterator_expandChildren'))

# Start of InfomapParentIterator_setChildDegree

`InfomapParentIterator_setChildDegree` = function(self, value)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  value = as.integer(value);
  
  if(length(value) > 1) {
    warning("using only the first element of value");
  };
  
  ;.Call('R_swig_InfomapParentIterator_setChildDegree', self, value, PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_setChildDegree`, 'returnType') = 'void'
attr(`InfomapParentIterator_setChildDegree`, "inputTypes") = c('_p_infomap__InfomapParentIterator', 'integer')
class(`InfomapParentIterator_setChildDegree`) = c("SWIGFunction", class('InfomapParentIterator_setChildDegree'))

# Start of InfomapParentIterator_setNumLeafNodes

`InfomapParentIterator_setNumLeafNodes` = function(self, value)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  value = as.integer(value);
  
  if(length(value) > 1) {
    warning("using only the first element of value");
  };
  
  ;.Call('R_swig_InfomapParentIterator_setNumLeafNodes', self, value, PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_setNumLeafNodes`, 'returnType') = 'void'
attr(`InfomapParentIterator_setNumLeafNodes`, "inputTypes") = c('_p_infomap__InfomapParentIterator', 'integer')
class(`InfomapParentIterator_setNumLeafNodes`) = c("SWIGFunction", class('InfomapParentIterator_setNumLeafNodes'))

# Start of InfomapParentIterator_addChild

`InfomapParentIterator_addChild` = function(self, child)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(child, "ExternalReference")) child = slot(child,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_addChild', self, child, PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_addChild`, 'returnType') = 'void'
attr(`InfomapParentIterator_addChild`, "inputTypes") = c('_p_infomap__InfomapParentIterator', '_p_infomap__InfoNode')
class(`InfomapParentIterator_addChild`) = c("SWIGFunction", class('InfomapParentIterator_addChild'))

# Start of InfomapParentIterator_releaseChildren

`InfomapParentIterator_releaseChildren` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_releaseChildren', self, PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_releaseChildren`, 'returnType') = 'void'
attr(`InfomapParentIterator_releaseChildren`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_releaseChildren`) = c("SWIGFunction", class('InfomapParentIterator_releaseChildren'))

# Start of InfomapParentIterator_replaceChildrenWithOneNode

`InfomapParentIterator_replaceChildrenWithOneNode` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapParentIterator_replaceChildrenWithOneNode', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_replaceChildrenWithOneNode`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapParentIterator_replaceChildrenWithOneNode`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_replaceChildrenWithOneNode`) = c("SWIGFunction", class('InfomapParentIterator_replaceChildrenWithOneNode'))

# Start of InfomapParentIterator_replaceWithChildren

`InfomapParentIterator_replaceWithChildren` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_replaceWithChildren', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_replaceWithChildren`, 'returnType') = 'integer'
attr(`InfomapParentIterator_replaceWithChildren`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_replaceWithChildren`) = c("SWIGFunction", class('InfomapParentIterator_replaceWithChildren'))

# Start of InfomapParentIterator_replaceWithChildrenDebug

`InfomapParentIterator_replaceWithChildrenDebug` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_replaceWithChildrenDebug', self, PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_replaceWithChildrenDebug`, 'returnType') = 'void'
attr(`InfomapParentIterator_replaceWithChildrenDebug`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_replaceWithChildrenDebug`) = c("SWIGFunction", class('InfomapParentIterator_replaceWithChildrenDebug'))

# Start of InfomapParentIterator_replaceChildrenWithGrandChildren

`InfomapParentIterator_replaceChildrenWithGrandChildren` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_replaceChildrenWithGrandChildren', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_replaceChildrenWithGrandChildren`, 'returnType') = 'integer'
attr(`InfomapParentIterator_replaceChildrenWithGrandChildren`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_replaceChildrenWithGrandChildren`) = c("SWIGFunction", class('InfomapParentIterator_replaceChildrenWithGrandChildren'))

# Start of InfomapParentIterator_replaceChildrenWithGrandChildrenDebug

`InfomapParentIterator_replaceChildrenWithGrandChildrenDebug` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_replaceChildrenWithGrandChildrenDebug', self, PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_replaceChildrenWithGrandChildrenDebug`, 'returnType') = 'void'
attr(`InfomapParentIterator_replaceChildrenWithGrandChildrenDebug`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_replaceChildrenWithGrandChildrenDebug`) = c("SWIGFunction", class('InfomapParentIterator_replaceChildrenWithGrandChildrenDebug'))

# Start of InfomapParentIterator_remove

`InfomapParentIterator_remove` = function(self, removeChildren)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  removeChildren = as.logical(removeChildren);
  ;.Call('R_swig_InfomapParentIterator_remove', self, removeChildren, PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_remove`, 'returnType') = 'void'
attr(`InfomapParentIterator_remove`, "inputTypes") = c('_p_infomap__InfomapParentIterator', 'logical')
class(`InfomapParentIterator_remove`) = c("SWIGFunction", class('InfomapParentIterator_remove'))

# Start of InfomapParentIterator_deleteChildren

`InfomapParentIterator_deleteChildren` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapParentIterator_deleteChildren', self, PACKAGE='infomap');
  
}

attr(`InfomapParentIterator_deleteChildren`, 'returnType') = 'void'
attr(`InfomapParentIterator_deleteChildren`, "inputTypes") = c('_p_infomap__InfomapParentIterator')
class(`InfomapParentIterator_deleteChildren`) = c("SWIGFunction", class('InfomapParentIterator_deleteChildren'))

# Start of InfomapParentIterator_addOutEdge

`InfomapParentIterator_addOutEdge__SWIG_0` = function(self, target, weight, flow)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(target, "ExternalReference")) target = slot(target,"ref"); 
  
  
  ;ans = .Call('R_swig_InfomapParentIterator_addOutEdge__SWIG_0', self, target, weight, flow, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_EdgeT_infomap__InfoNode_t", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_addOutEdge__SWIG_0`, 'returnType') = '_p_EdgeT_infomap__InfoNode_t'
attr(`InfomapParentIterator_addOutEdge__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapParentIterator', '_p_infomap__InfoNode', 'numeric', 'numeric')
class(`InfomapParentIterator_addOutEdge__SWIG_0`) = c("SWIGFunction", class('InfomapParentIterator_addOutEdge__SWIG_0'))

# Start of InfomapParentIterator_addOutEdge

`InfomapParentIterator_addOutEdge__SWIG_1` = function(self, target, weight)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(target, "ExternalReference")) target = slot(target,"ref"); 
  
  ;ans = .Call('R_swig_InfomapParentIterator_addOutEdge__SWIG_1', self, target, weight, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_EdgeT_infomap__InfoNode_t", ref=ans);
  
  ans
  
}

attr(`InfomapParentIterator_addOutEdge__SWIG_1`, 'returnType') = '_p_EdgeT_infomap__InfoNode_t'
attr(`InfomapParentIterator_addOutEdge__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapParentIterator', '_p_infomap__InfoNode', 'numeric')
class(`InfomapParentIterator_addOutEdge__SWIG_1`) = c("SWIGFunction", class('InfomapParentIterator_addOutEdge__SWIG_1'))

`InfomapParentIterator_addOutEdge` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 3) {
    if ((extends(argtypes[1], '_p_infomap__InfomapParentIterator') || is.null(argv[[1]])) && extends(argtypes[2], '_p_infomap__InfoNode') && length(argv[[2]]) == 1 && ( is.numeric(argv[[3]]) && length(argv[[3]]) == 1 )) {
      f <- InfomapParentIterator_addOutEdge__SWIG_1; 
    }
  } else if (argc == 4) {
    if ((extends(argtypes[1], '_p_infomap__InfomapParentIterator') || is.null(argv[[1]])) && extends(argtypes[2], '_p_infomap__InfoNode') && length(argv[[2]]) == 1 && ( is.numeric(argv[[3]]) && length(argv[[3]]) == 1 ) && ( is.numeric(argv[[4]]) && length(argv[[4]]) == 1 )) {
      f <- InfomapParentIterator_addOutEdge__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InfomapParentIterator_addOutEdge with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of accessor method for infomap::InfomapParentIterator
setMethod('$', '_p_infomap__InfomapParentIterator', function(x, name)

{
  accessorFuns = list('Equal' = InfomapParentIterator_Equal, 'current' = InfomapParentIterator_current, '__ref__' = InfomapParentIterator___ref__, '__deref__' = InfomapParentIterator___deref__, 'EqualEqual' = InfomapParentIterator_EqualEqual, 'NotEqual' = InfomapParentIterator_NotEqual, 'PlusPlusPrefix' = InfomapParentIterator_PlusPlusPrefix, 'PlusPlusPostfix' = InfomapParentIterator_PlusPlusPostfix, 'stepForward' = InfomapParentIterator_stepForward, 'isEnd' = InfomapParentIterator_isEnd, 'data' = InfomapParentIterator_data_get, 'index' = InfomapParentIterator_index_get, 'stateId' = InfomapParentIterator_stateId_get, 'physicalId' = InfomapParentIterator_physicalId_get, 'layerId' = InfomapParentIterator_layerId_get, 'metaData' = InfomapParentIterator_metaData_get, 'owner' = InfomapParentIterator_owner_get, 'parent' = InfomapParentIterator_parent_get, 'previous' = InfomapParentIterator_previous_get, '_next' = InfomapParentIterator__next_get, 'firstChild' = InfomapParentIterator_firstChild_get, 'lastChild' = InfomapParentIterator_lastChild_get, 'collapsedFirstChild' = InfomapParentIterator_collapsedFirstChild_get, 'collapsedLastChild' = InfomapParentIterator_collapsedLastChild_get, 'codelength' = InfomapParentIterator_codelength_get, 'dirty' = InfomapParentIterator_dirty_get, 'physicalNodes' = InfomapParentIterator_physicalNodes_get, 'metaCollection' = InfomapParentIterator_metaCollection_get, 'stateNodes' = InfomapParentIterator_stateNodes_get, 'getMetaData' = InfomapParentIterator_getMetaData, 'getInfomap' = InfomapParentIterator_getInfomap, 'setInfomap' = InfomapParentIterator_setInfomap, 'getInfomapRoot' = InfomapParentIterator_getInfomapRoot, 'disposeInfomap' = InfomapParentIterator_disposeInfomap, 'numPhysicalNodes' = InfomapParentIterator_numPhysicalNodes, 'begin' = InfomapParentIterator_begin, 'end' = InfomapParentIterator_end, 'begin_child' = InfomapParentIterator_begin_child, 'end_child' = InfomapParentIterator_end_child, 'children' = InfomapParentIterator_children, 'infomap_children' = InfomapParentIterator_infomap_children, 'begin_post_depth_first' = InfomapParentIterator_begin_post_depth_first, 'begin_leaf_nodes' = InfomapParentIterator_begin_leaf_nodes, 'begin_leaf_modules' = InfomapParentIterator_begin_leaf_modules, 'begin_tree' = InfomapParentIterator_begin_tree, 'end_tree' = InfomapParentIterator_end_tree, 'infomapTree' = InfomapParentIterator_infomapTree, 'begin_outEdge' = InfomapParentIterator_begin_outEdge, 'end_outEdge' = InfomapParentIterator_end_outEdge, 'begin_inEdge' = InfomapParentIterator_begin_inEdge, 'end_inEdge' = InfomapParentIterator_end_inEdge, 'outEdges' = InfomapParentIterator_outEdges, 'inEdges' = InfomapParentIterator_inEdges, 'childDegree' = InfomapParentIterator_childDegree, 'isLeaf' = InfomapParentIterator_isLeaf, 'isLeafModule' = InfomapParentIterator_isLeafModule, 'isRoot' = InfomapParentIterator_isRoot, 'depth' = InfomapParentIterator_depth, 'firstDepthBelow' = InfomapParentIterator_firstDepthBelow, 'numLeafMembers' = InfomapParentIterator_numLeafMembers, 'isDangling' = InfomapParentIterator_isDangling, 'outDegree' = InfomapParentIterator_outDegree, 'inDegree' = InfomapParentIterator_inDegree, 'degree' = InfomapParentIterator_degree, 'isFirst' = InfomapParentIterator_isFirst, 'isLast' = InfomapParentIterator_isLast, 'childIndex' = InfomapParentIterator_childIndex, 'calculatePath' = InfomapParentIterator_calculatePath, 'infomapChildDegree' = InfomapParentIterator_infomapChildDegree, 'id' = InfomapParentIterator_id, 'initClean' = InfomapParentIterator_initClean, 'sortChildrenOnFlow' = InfomapParentIterator_sortChildrenOnFlow, 'collapseChildren' = InfomapParentIterator_collapseChildren, 'expandChildren' = InfomapParentIterator_expandChildren, 'setChildDegree' = InfomapParentIterator_setChildDegree, 'setNumLeafNodes' = InfomapParentIterator_setNumLeafNodes, 'addChild' = InfomapParentIterator_addChild, 'releaseChildren' = InfomapParentIterator_releaseChildren, 'replaceChildrenWithOneNode' = InfomapParentIterator_replaceChildrenWithOneNode, 'replaceWithChildren' = InfomapParentIterator_replaceWithChildren, 'replaceWithChildrenDebug' = InfomapParentIterator_replaceWithChildrenDebug, 'replaceChildrenWithGrandChildren' = InfomapParentIterator_replaceChildrenWithGrandChildren, 'replaceChildrenWithGrandChildrenDebug' = InfomapParentIterator_replaceChildrenWithGrandChildrenDebug, 'remove' = InfomapParentIterator_remove, 'deleteChildren' = InfomapParentIterator_deleteChildren, 'addOutEdge' = InfomapParentIterator_addOutEdge);
  vaccessors = c('data', 'index', 'stateId', 'physicalId', 'layerId', 'metaData', 'owner', 'parent', 'previous', '_next', 'firstChild', 'lastChild', 'collapsedFirstChild', 'collapsedLastChild', 'codelength', 'dirty', 'physicalNodes', 'metaCollection', 'stateNodes');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for infomap::InfomapParentIterator
# Start of accessor method for infomap::InfomapParentIterator
setMethod('$<-', '_p_infomap__InfomapParentIterator', function(x, name, value)

{
  accessorFuns = list('data' = InfomapParentIterator_data_set, 'index' = InfomapParentIterator_index_set, 'stateId' = InfomapParentIterator_stateId_set, 'physicalId' = InfomapParentIterator_physicalId_set, 'layerId' = InfomapParentIterator_layerId_set, 'metaData' = InfomapParentIterator_metaData_set, 'owner' = InfomapParentIterator_owner_set, 'parent' = InfomapParentIterator_parent_set, 'previous' = InfomapParentIterator_previous_set, '_next' = InfomapParentIterator__next_set, 'firstChild' = InfomapParentIterator_firstChild_set, 'lastChild' = InfomapParentIterator_lastChild_set, 'collapsedFirstChild' = InfomapParentIterator_collapsedFirstChild_set, 'collapsedLastChild' = InfomapParentIterator_collapsedLastChild_set, 'codelength' = InfomapParentIterator_codelength_set, 'dirty' = InfomapParentIterator_dirty_set, 'physicalNodes' = InfomapParentIterator_physicalNodes_set, 'metaCollection' = InfomapParentIterator_metaCollection_set, 'stateNodes' = InfomapParentIterator_stateNodes_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_infomap__InfomapParentIterator', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('data' = InfomapParentIterator_data_set, 'index' = InfomapParentIterator_index_set, 'stateId' = InfomapParentIterator_stateId_set, 'physicalId' = InfomapParentIterator_physicalId_set, 'layerId' = InfomapParentIterator_layerId_set, 'metaData' = InfomapParentIterator_metaData_set, 'owner' = InfomapParentIterator_owner_set, 'parent' = InfomapParentIterator_parent_set, 'previous' = InfomapParentIterator_previous_set, '_next' = InfomapParentIterator__next_set, 'firstChild' = InfomapParentIterator_firstChild_set, 'lastChild' = InfomapParentIterator_lastChild_set, 'collapsedFirstChild' = InfomapParentIterator_collapsedFirstChild_set, 'collapsedLastChild' = InfomapParentIterator_collapsedLastChild_set, 'codelength' = InfomapParentIterator_codelength_set, 'dirty' = InfomapParentIterator_dirty_set, 'physicalNodes' = InfomapParentIterator_physicalNodes_set, 'metaCollection' = InfomapParentIterator_metaCollection_set, 'stateNodes' = InfomapParentIterator_stateNodes_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for infomap::InfomapParentIterator
setMethod('delete', '_p_infomap__InfomapParentIterator', function(obj) {delete_infomap__InfomapParentIterator(obj)})
# Start definition of copy functions & methods for infomap::InfomapParentIterator
CopyToR_infomap__InfomapParentIterator = function(value, obj = new("infomap::InfomapParentIterator"))
{
  obj;
}



CopyToC_infomap__InfomapParentIterator = function(value, obj)
{
  obj
}



# Start definition of copy methods for infomap::InfomapParentIterator
setMethod('copyToR', '_p_infomap::InfomapParentIterator', CopyToR_infomap__InfomapParentIterator);
setMethod('copyToC', 'infomap::InfomapParentIterator', CopyToC_infomap__InfomapParentIterator);

# End definition of copy methods for infomap::InfomapParentIterator
# End definition of copy functions & methods for infomap::InfomapParentIterator
# Start of new_StateNetwork

`StateNetwork__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_StateNetwork__SWIG_0', PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__StateNetwork", ref=ans);
  
  reg.finalizer(ans@ref, delete_StateNetwork);
  ans
  
}

attr(`StateNetwork__SWIG_0`, 'returnType') = '_p_infomap__StateNetwork'
class(`StateNetwork__SWIG_0`) = c("SWIGFunction", class('StateNetwork__SWIG_0'))

# Start of new_StateNetwork

`StateNetwork__SWIG_1` = function(config)
{
  if (inherits(config, "ExternalReference")) config = slot(config,"ref"); 
  ;ans = .Call('R_swig_new_StateNetwork__SWIG_1', config, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__StateNetwork", ref=ans);
  
  reg.finalizer(ans@ref, delete_StateNetwork);
  ans
  
}

attr(`StateNetwork__SWIG_1`, 'returnType') = '_p_infomap__StateNetwork'
attr(`StateNetwork__SWIG_1`, "inputTypes") = c('_p_infomap__Config')
class(`StateNetwork__SWIG_1`) = c("SWIGFunction", class('StateNetwork__SWIG_1'))

`StateNetwork` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- StateNetwork__SWIG_0; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_infomap__Config') && length(argv[[1]]) == 1) {
      f <- StateNetwork__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for StateNetwork with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_StateNetwork

`delete_StateNetwork` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_StateNetwork', self, PACKAGE='infomap');
  
}

attr(`delete_StateNetwork`, 'returnType') = 'void'
attr(`delete_StateNetwork`, "inputTypes") = c('_p_infomap__StateNetwork')
class(`delete_StateNetwork`) = c("SWIGFunction", class('delete_StateNetwork'))

# Start of StateNetwork_setConfig

`StateNetwork_setConfig` = function(self, config)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(config, "ExternalReference")) config = slot(config,"ref"); 
  ;.Call('R_swig_StateNetwork_setConfig', self, config, PACKAGE='infomap');
  
}

attr(`StateNetwork_setConfig`, 'returnType') = 'void'
attr(`StateNetwork_setConfig`, "inputTypes") = c('_p_infomap__StateNetwork', '_p_infomap__Config')
class(`StateNetwork_setConfig`) = c("SWIGFunction", class('StateNetwork_setConfig'))

# Start of StateNetwork_getConfig

`StateNetwork_getConfig` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_StateNetwork_getConfig', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__Config", ref=ans);
  
  ans
  
}

attr(`StateNetwork_getConfig`, 'returnType') = '_p_infomap__Config'
attr(`StateNetwork_getConfig`, "inputTypes") = c('_p_infomap__StateNetwork')
class(`StateNetwork_getConfig`) = c("SWIGFunction", class('StateNetwork_getConfig'))

# Start of StateNetwork_addStateNode

`StateNetwork_addStateNode__SWIG_0` = function(self, node, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(node, "ExternalReference")) node = slot(node,"ref"); 
  ;ans = .Call('R_swig_StateNetwork_addStateNode__SWIG_0', self, node, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__pairT_std__mapT_unsigned_int_infomap__StateNetwork__StateNode_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_infomap__StateNetwork__StateNode_t_t_t__iterator_bool_t", ref=ans);
  
  ans
  
}

attr(`StateNetwork_addStateNode__SWIG_0`, 'returnType') = '_p_std__pairT_std__mapT_unsigned_int_infomap__StateNetwork__StateNode_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_infomap__StateNetwork__StateNode_t_t_t__iterator_bool_t'
attr(`StateNetwork_addStateNode__SWIG_0`, "inputTypes") = c('_p_infomap__StateNetwork', '_p_infomap__StateNetwork__StateNode')
class(`StateNetwork_addStateNode__SWIG_0`) = c("SWIGFunction", class('StateNetwork_addStateNode__SWIG_0'))

# Start of StateNetwork_addStateNode

`StateNetwork_addStateNode__SWIG_1` = function(self, id, physId, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  id = as.integer(id);
  
  if(length(id) > 1) {
    warning("using only the first element of id");
  };
  
  physId = as.integer(physId);
  
  if(length(physId) > 1) {
    warning("using only the first element of physId");
  };
  
  ;ans = .Call('R_swig_StateNetwork_addStateNode__SWIG_1', self, id, physId, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__pairT_std__mapT_unsigned_int_infomap__StateNetwork__StateNode_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_infomap__StateNetwork__StateNode_t_t_t__iterator_bool_t", ref=ans);
  
  ans
  
}

attr(`StateNetwork_addStateNode__SWIG_1`, 'returnType') = '_p_std__pairT_std__mapT_unsigned_int_infomap__StateNetwork__StateNode_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_infomap__StateNetwork__StateNode_t_t_t__iterator_bool_t'
attr(`StateNetwork_addStateNode__SWIG_1`, "inputTypes") = c('_p_infomap__StateNetwork', 'integer', 'integer')
class(`StateNetwork_addStateNode__SWIG_1`) = c("SWIGFunction", class('StateNetwork_addStateNode__SWIG_1'))

`StateNetwork_addStateNode` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__StateNetwork') || is.null(argv[[1]])) && extends(argtypes[2], '_p_infomap__StateNetwork__StateNode') && length(argv[[2]]) == 1) {
      f <- StateNetwork_addStateNode__SWIG_0; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_infomap__StateNetwork') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 )) {
      f <- StateNetwork_addStateNode__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for StateNetwork_addStateNode with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of StateNetwork_addNode

`StateNetwork_addNode__SWIG_0` = function(self, id, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  id = as.integer(id);
  
  if(length(id) > 1) {
    warning("using only the first element of id");
  };
  
  ;ans = .Call('R_swig_StateNetwork_addNode__SWIG_0', self, id, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__pairT_std__mapT_unsigned_int_infomap__StateNetwork__StateNode_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_infomap__StateNetwork__StateNode_t_t_t__iterator_bool_t", ref=ans);
  
  ans
  
}

attr(`StateNetwork_addNode__SWIG_0`, 'returnType') = '_p_std__pairT_std__mapT_unsigned_int_infomap__StateNetwork__StateNode_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_infomap__StateNetwork__StateNode_t_t_t__iterator_bool_t'
attr(`StateNetwork_addNode__SWIG_0`, "inputTypes") = c('_p_infomap__StateNetwork', 'integer')
class(`StateNetwork_addNode__SWIG_0`) = c("SWIGFunction", class('StateNetwork_addNode__SWIG_0'))

# Start of StateNetwork_addNode

`StateNetwork_addNode__SWIG_1` = function(self, id, name, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  id = as.integer(id);
  
  if(length(id) > 1) {
    warning("using only the first element of id");
  };
  
  name = as(name, "character"); 
  ;ans = .Call('R_swig_StateNetwork_addNode__SWIG_1', self, id, name, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__pairT_std__mapT_unsigned_int_infomap__StateNetwork__StateNode_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_infomap__StateNetwork__StateNode_t_t_t__iterator_bool_t", ref=ans);
  
  ans
  
}

attr(`StateNetwork_addNode__SWIG_1`, 'returnType') = '_p_std__pairT_std__mapT_unsigned_int_infomap__StateNetwork__StateNode_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_infomap__StateNetwork__StateNode_t_t_t__iterator_bool_t'
attr(`StateNetwork_addNode__SWIG_1`, "inputTypes") = c('_p_infomap__StateNetwork', 'integer', 'character')
class(`StateNetwork_addNode__SWIG_1`) = c("SWIGFunction", class('StateNetwork_addNode__SWIG_1'))

# Start of StateNetwork_addNode

`StateNetwork_addNode__SWIG_2` = function(self, id, weight, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  id = as.integer(id);
  
  if(length(id) > 1) {
    warning("using only the first element of id");
  };
  
  
  ;ans = .Call('R_swig_StateNetwork_addNode__SWIG_2', self, id, weight, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__pairT_std__mapT_unsigned_int_infomap__StateNetwork__StateNode_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_infomap__StateNetwork__StateNode_t_t_t__iterator_bool_t", ref=ans);
  
  ans
  
}

attr(`StateNetwork_addNode__SWIG_2`, 'returnType') = '_p_std__pairT_std__mapT_unsigned_int_infomap__StateNetwork__StateNode_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_infomap__StateNetwork__StateNode_t_t_t__iterator_bool_t'
attr(`StateNetwork_addNode__SWIG_2`, "inputTypes") = c('_p_infomap__StateNetwork', 'integer', 'numeric')
class(`StateNetwork_addNode__SWIG_2`) = c("SWIGFunction", class('StateNetwork_addNode__SWIG_2'))

# Start of StateNetwork_addNode

`StateNetwork_addNode__SWIG_3` = function(self, id, s_arg3, weight, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  id = as.integer(id);
  
  if(length(id) > 1) {
    warning("using only the first element of id");
  };
  
  s_arg3 = as(s_arg3, "character"); 
  
  ;ans = .Call('R_swig_StateNetwork_addNode__SWIG_3', self, id, s_arg3, weight, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__pairT_std__mapT_unsigned_int_infomap__StateNetwork__StateNode_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_infomap__StateNetwork__StateNode_t_t_t__iterator_bool_t", ref=ans);
  
  ans
  
}

attr(`StateNetwork_addNode__SWIG_3`, 'returnType') = '_p_std__pairT_std__mapT_unsigned_int_infomap__StateNetwork__StateNode_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_infomap__StateNetwork__StateNode_t_t_t__iterator_bool_t'
attr(`StateNetwork_addNode__SWIG_3`, "inputTypes") = c('_p_infomap__StateNetwork', 'integer', 'character', 'numeric')
class(`StateNetwork_addNode__SWIG_3`) = c("SWIGFunction", class('StateNetwork_addNode__SWIG_3'))

`StateNetwork_addNode` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__StateNetwork') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- StateNetwork_addNode__SWIG_0; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_infomap__StateNetwork') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.numeric(argv[[3]]) && length(argv[[3]]) == 1 )) {
      f <- StateNetwork_addNode__SWIG_2; 
    }
    else if ((extends(argtypes[1], '_p_infomap__StateNetwork') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && is.character(argv[[3]]) && length(argv[[3]]) == 1) {
      f <- StateNetwork_addNode__SWIG_1; 
    }
  } else if (argc == 4) {
    if ((extends(argtypes[1], '_p_infomap__StateNetwork') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && is.character(argv[[3]]) && length(argv[[3]]) == 1 && ( is.numeric(argv[[4]]) && length(argv[[4]]) == 1 )) {
      f <- StateNetwork_addNode__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for StateNetwork_addNode with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of StateNetwork_addPhysicalNode

`StateNetwork_addPhysicalNode__SWIG_0` = function(self, physId, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  physId = as.integer(physId);
  
  if(length(physId) > 1) {
    warning("using only the first element of physId");
  };
  
  ;ans = .Call('R_swig_StateNetwork_addPhysicalNode__SWIG_0', self, physId, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__StateNetwork__PhysNode", ref=ans);
  
  ans
  
}

attr(`StateNetwork_addPhysicalNode__SWIG_0`, 'returnType') = '_p_infomap__StateNetwork__PhysNode'
attr(`StateNetwork_addPhysicalNode__SWIG_0`, "inputTypes") = c('_p_infomap__StateNetwork', 'integer')
class(`StateNetwork_addPhysicalNode__SWIG_0`) = c("SWIGFunction", class('StateNetwork_addPhysicalNode__SWIG_0'))

# Start of StateNetwork_addPhysicalNode

`StateNetwork_addPhysicalNode__SWIG_1` = function(self, physId, weight, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  physId = as.integer(physId);
  
  if(length(physId) > 1) {
    warning("using only the first element of physId");
  };
  
  
  ;ans = .Call('R_swig_StateNetwork_addPhysicalNode__SWIG_1', self, physId, weight, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__StateNetwork__PhysNode", ref=ans);
  
  ans
  
}

attr(`StateNetwork_addPhysicalNode__SWIG_1`, 'returnType') = '_p_infomap__StateNetwork__PhysNode'
attr(`StateNetwork_addPhysicalNode__SWIG_1`, "inputTypes") = c('_p_infomap__StateNetwork', 'integer', 'numeric')
class(`StateNetwork_addPhysicalNode__SWIG_1`) = c("SWIGFunction", class('StateNetwork_addPhysicalNode__SWIG_1'))

# Start of StateNetwork_addPhysicalNode

`StateNetwork_addPhysicalNode__SWIG_2` = function(self, physId, name, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  physId = as.integer(physId);
  
  if(length(physId) > 1) {
    warning("using only the first element of physId");
  };
  
  name = as(name, "character"); 
  ;ans = .Call('R_swig_StateNetwork_addPhysicalNode__SWIG_2', self, physId, name, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__StateNetwork__PhysNode", ref=ans);
  
  ans
  
}

attr(`StateNetwork_addPhysicalNode__SWIG_2`, 'returnType') = '_p_infomap__StateNetwork__PhysNode'
attr(`StateNetwork_addPhysicalNode__SWIG_2`, "inputTypes") = c('_p_infomap__StateNetwork', 'integer', 'character')
class(`StateNetwork_addPhysicalNode__SWIG_2`) = c("SWIGFunction", class('StateNetwork_addPhysicalNode__SWIG_2'))

# Start of StateNetwork_addPhysicalNode

`StateNetwork_addPhysicalNode__SWIG_3` = function(self, physId, weight, name, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  physId = as.integer(physId);
  
  if(length(physId) > 1) {
    warning("using only the first element of physId");
  };
  
  
  name = as(name, "character"); 
  ;ans = .Call('R_swig_StateNetwork_addPhysicalNode__SWIG_3', self, physId, weight, name, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__StateNetwork__PhysNode", ref=ans);
  
  ans
  
}

attr(`StateNetwork_addPhysicalNode__SWIG_3`, 'returnType') = '_p_infomap__StateNetwork__PhysNode'
attr(`StateNetwork_addPhysicalNode__SWIG_3`, "inputTypes") = c('_p_infomap__StateNetwork', 'integer', 'numeric', 'character')
class(`StateNetwork_addPhysicalNode__SWIG_3`) = c("SWIGFunction", class('StateNetwork_addPhysicalNode__SWIG_3'))

`StateNetwork_addPhysicalNode` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__StateNetwork') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- StateNetwork_addPhysicalNode__SWIG_0; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_infomap__StateNetwork') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.numeric(argv[[3]]) && length(argv[[3]]) == 1 )) {
      f <- StateNetwork_addPhysicalNode__SWIG_1; 
    }
    else if ((extends(argtypes[1], '_p_infomap__StateNetwork') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && is.character(argv[[3]]) && length(argv[[3]]) == 1) {
      f <- StateNetwork_addPhysicalNode__SWIG_2; 
    }
  } else if (argc == 4) {
    if ((extends(argtypes[1], '_p_infomap__StateNetwork') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.numeric(argv[[3]]) && length(argv[[3]]) == 1 ) && is.character(argv[[4]]) && length(argv[[4]]) == 1) {
      f <- StateNetwork_addPhysicalNode__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for StateNetwork_addPhysicalNode with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of StateNetwork_addName

`StateNetwork_addName` = function(self, id, s_arg3, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  id = as.integer(id);
  
  if(length(id) > 1) {
    warning("using only the first element of id");
  };
  
  s_arg3 = as(s_arg3, "character"); 
  ;ans = .Call('R_swig_StateNetwork_addName', self, id, s_arg3, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__pairT_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t__iterator_bool_t", ref=ans);
  
  ans
  
}

attr(`StateNetwork_addName`, 'returnType') = '_p_std__pairT_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t__iterator_bool_t'
attr(`StateNetwork_addName`, "inputTypes") = c('_p_infomap__StateNetwork', 'integer', 'character')
class(`StateNetwork_addName`) = c("SWIGFunction", class('StateNetwork_addName'))

# Start of StateNetwork_addLink

`StateNetwork_addLink__SWIG_0` = function(self, sourceId, targetId, weight, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  sourceId = as.integer(sourceId);
  
  if(length(sourceId) > 1) {
    warning("using only the first element of sourceId");
  };
  
  targetId = as.integer(targetId);
  
  if(length(targetId) > 1) {
    warning("using only the first element of targetId");
  };
  
  
  ;.Call('R_swig_StateNetwork_addLink__SWIG_0', self, sourceId, targetId, weight, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`StateNetwork_addLink__SWIG_0`, 'returnType') = 'logical'
attr(`StateNetwork_addLink__SWIG_0`, "inputTypes") = c('_p_infomap__StateNetwork', 'integer', 'integer', 'numeric')
class(`StateNetwork_addLink__SWIG_0`) = c("SWIGFunction", class('StateNetwork_addLink__SWIG_0'))

# Start of StateNetwork_addLink

`StateNetwork_addLink__SWIG_1` = function(self, sourceId, targetId, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  sourceId = as.integer(sourceId);
  
  if(length(sourceId) > 1) {
    warning("using only the first element of sourceId");
  };
  
  targetId = as.integer(targetId);
  
  if(length(targetId) > 1) {
    warning("using only the first element of targetId");
  };
  
  ;.Call('R_swig_StateNetwork_addLink__SWIG_1', self, sourceId, targetId, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`StateNetwork_addLink__SWIG_1`, 'returnType') = 'logical'
attr(`StateNetwork_addLink__SWIG_1`, "inputTypes") = c('_p_infomap__StateNetwork', 'integer', 'integer')
class(`StateNetwork_addLink__SWIG_1`) = c("SWIGFunction", class('StateNetwork_addLink__SWIG_1'))

# Start of StateNetwork_addLink

`StateNetwork_addLink__SWIG_2` = function(self, sourceId, targetId, weight, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  sourceId = as.integer(sourceId);
  
  if(length(sourceId) > 1) {
    warning("using only the first element of sourceId");
  };
  
  targetId = as.integer(targetId);
  
  if(length(targetId) > 1) {
    warning("using only the first element of targetId");
  };
  
  weight = as.integer(weight);
  
  if(length(weight) > 1) {
    warning("using only the first element of weight");
  };
  
  ;.Call('R_swig_StateNetwork_addLink__SWIG_2', self, sourceId, targetId, weight, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`StateNetwork_addLink__SWIG_2`, 'returnType') = 'logical'
attr(`StateNetwork_addLink__SWIG_2`, "inputTypes") = c('_p_infomap__StateNetwork', 'integer', 'integer', 'integer')
class(`StateNetwork_addLink__SWIG_2`) = c("SWIGFunction", class('StateNetwork_addLink__SWIG_2'))

`StateNetwork_addLink` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 3) {
    if ((extends(argtypes[1], '_p_infomap__StateNetwork') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 )) {
      f <- StateNetwork_addLink__SWIG_1; 
    }
  } else if (argc == 4) {
    if ((extends(argtypes[1], '_p_infomap__StateNetwork') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 )) {
      f <- StateNetwork_addLink__SWIG_2; 
    }
    else if ((extends(argtypes[1], '_p_infomap__StateNetwork') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( is.numeric(argv[[4]]) && length(argv[[4]]) == 1 )) {
      f <- StateNetwork_addLink__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for StateNetwork_addLink with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of StateNetwork_removeLink

`StateNetwork_removeLink` = function(self, sourceId, targetId, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  sourceId = as.integer(sourceId);
  
  if(length(sourceId) > 1) {
    warning("using only the first element of sourceId");
  };
  
  targetId = as.integer(targetId);
  
  if(length(targetId) > 1) {
    warning("using only the first element of targetId");
  };
  
  ;.Call('R_swig_StateNetwork_removeLink', self, sourceId, targetId, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`StateNetwork_removeLink`, 'returnType') = 'logical'
attr(`StateNetwork_removeLink`, "inputTypes") = c('_p_infomap__StateNetwork', 'integer', 'integer')
class(`StateNetwork_removeLink`) = c("SWIGFunction", class('StateNetwork_removeLink'))

# Start of StateNetwork_undirectedToDirected

`StateNetwork_undirectedToDirected` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_StateNetwork_undirectedToDirected', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`StateNetwork_undirectedToDirected`, 'returnType') = 'logical'
attr(`StateNetwork_undirectedToDirected`, "inputTypes") = c('_p_infomap__StateNetwork')
class(`StateNetwork_undirectedToDirected`) = c("SWIGFunction", class('StateNetwork_undirectedToDirected'))

# Start of StateNetwork_calculateFlow

`StateNetwork_calculateFlow` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_StateNetwork_calculateFlow', self, PACKAGE='infomap');
  
}

attr(`StateNetwork_calculateFlow`, 'returnType') = 'void'
attr(`StateNetwork_calculateFlow`, "inputTypes") = c('_p_infomap__StateNetwork')
class(`StateNetwork_calculateFlow`) = c("SWIGFunction", class('StateNetwork_calculateFlow'))

# Start of StateNetwork_clear

`StateNetwork_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_StateNetwork_clear', self, PACKAGE='infomap');
  
}

attr(`StateNetwork_clear`, 'returnType') = 'void'
attr(`StateNetwork_clear`, "inputTypes") = c('_p_infomap__StateNetwork')
class(`StateNetwork_clear`) = c("SWIGFunction", class('StateNetwork_clear'))

# Start of StateNetwork_clearLinks

`StateNetwork_clearLinks` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_StateNetwork_clearLinks', self, PACKAGE='infomap');
  
}

attr(`StateNetwork_clearLinks`, 'returnType') = 'void'
attr(`StateNetwork_clearLinks`, "inputTypes") = c('_p_infomap__StateNetwork')
class(`StateNetwork_clearLinks`) = c("SWIGFunction", class('StateNetwork_clearLinks'))

# Start of StateNetwork_nodes

`StateNetwork_nodes` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_StateNetwork_nodes', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__mapT_unsigned_int_infomap__StateNetwork__StateNode_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_infomap__StateNetwork__StateNode_t_t_t", ref=ans);
  
  ans
  
}

attr(`StateNetwork_nodes`, 'returnType') = '_p_std__mapT_unsigned_int_infomap__StateNetwork__StateNode_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_infomap__StateNetwork__StateNode_t_t_t'
attr(`StateNetwork_nodes`, "inputTypes") = c('_p_infomap__StateNetwork')
class(`StateNetwork_nodes`) = c("SWIGFunction", class('StateNetwork_nodes'))

# Start of StateNetwork_numNodes

`StateNetwork_numNodes` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_StateNetwork_numNodes', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`StateNetwork_numNodes`, 'returnType') = 'integer'
attr(`StateNetwork_numNodes`, "inputTypes") = c('_p_infomap__StateNetwork')
class(`StateNetwork_numNodes`) = c("SWIGFunction", class('StateNetwork_numNodes'))

# Start of StateNetwork_numPhysicalNodes

`StateNetwork_numPhysicalNodes` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_StateNetwork_numPhysicalNodes', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`StateNetwork_numPhysicalNodes`, 'returnType') = 'integer'
attr(`StateNetwork_numPhysicalNodes`, "inputTypes") = c('_p_infomap__StateNetwork')
class(`StateNetwork_numPhysicalNodes`) = c("SWIGFunction", class('StateNetwork_numPhysicalNodes'))

# Start of StateNetwork_nodeLinkMap

`StateNetwork_nodeLinkMap__SWIG_0` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_StateNetwork_nodeLinkMap__SWIG_0', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__mapT_infomap__StateNetwork__StateNode_std__mapT_infomap__StateNetwork__StateNode_infomap__StateNetwork__LinkData_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_infomap__StateNetwork__LinkData_t_t_t_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_std__mapT_infomap__StateNetwork__StateNode_infomap__StateNetwork__LinkData_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_infomap__StateNetwork__LinkData_t_t_t_t_t_t", ref=ans);
  
  ans
  
}

attr(`StateNetwork_nodeLinkMap__SWIG_0`, 'returnType') = '_p_std__mapT_infomap__StateNetwork__StateNode_std__mapT_infomap__StateNetwork__StateNode_infomap__StateNetwork__LinkData_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_infomap__StateNetwork__LinkData_t_t_t_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_std__mapT_infomap__StateNetwork__StateNode_infomap__StateNetwork__LinkData_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_infomap__StateNetwork__LinkData_t_t_t_t_t_t'
attr(`StateNetwork_nodeLinkMap__SWIG_0`, "inputTypes") = c('_p_infomap__StateNetwork')
class(`StateNetwork_nodeLinkMap__SWIG_0`) = c("SWIGFunction", class('StateNetwork_nodeLinkMap__SWIG_0'))

# Start of StateNetwork_nodeLinkMap

`StateNetwork_nodeLinkMap__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_StateNetwork_nodeLinkMap__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__mapT_infomap__StateNetwork__StateNode_std__mapT_infomap__StateNetwork__StateNode_infomap__StateNetwork__LinkData_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_infomap__StateNetwork__LinkData_t_t_t_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_std__mapT_infomap__StateNetwork__StateNode_infomap__StateNetwork__LinkData_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_infomap__StateNetwork__LinkData_t_t_t_t_t_t", ref=ans);
  
  ans
  
}

attr(`StateNetwork_nodeLinkMap__SWIG_1`, 'returnType') = '_p_std__mapT_infomap__StateNetwork__StateNode_std__mapT_infomap__StateNetwork__StateNode_infomap__StateNetwork__LinkData_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_infomap__StateNetwork__LinkData_t_t_t_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_std__mapT_infomap__StateNetwork__StateNode_infomap__StateNetwork__LinkData_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_infomap__StateNetwork__LinkData_t_t_t_t_t_t'
attr(`StateNetwork_nodeLinkMap__SWIG_1`, "inputTypes") = c('_p_infomap__StateNetwork')
class(`StateNetwork_nodeLinkMap__SWIG_1`) = c("SWIGFunction", class('StateNetwork_nodeLinkMap__SWIG_1'))

`StateNetwork_nodeLinkMap` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__StateNetwork') || is.null(argv[[1]]))) {
      f <- StateNetwork_nodeLinkMap__SWIG_1; 
    }
    else if ((extends(argtypes[1], '_p_infomap__StateNetwork') || is.null(argv[[1]]))) {
      f <- StateNetwork_nodeLinkMap__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for StateNetwork_nodeLinkMap with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of StateNetwork_numLinks

`StateNetwork_numLinks` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_StateNetwork_numLinks', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`StateNetwork_numLinks`, 'returnType') = 'integer'
attr(`StateNetwork_numLinks`, "inputTypes") = c('_p_infomap__StateNetwork')
class(`StateNetwork_numLinks`) = c("SWIGFunction", class('StateNetwork_numLinks'))

# Start of StateNetwork_sumLinkWeight

`StateNetwork_sumLinkWeight` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_StateNetwork_sumLinkWeight', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`StateNetwork_sumLinkWeight`, 'returnType') = 'numeric'
attr(`StateNetwork_sumLinkWeight`, "inputTypes") = c('_p_infomap__StateNetwork')
class(`StateNetwork_sumLinkWeight`) = c("SWIGFunction", class('StateNetwork_sumLinkWeight'))

# Start of StateNetwork_sumSelfLinkWeight

`StateNetwork_sumSelfLinkWeight` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_StateNetwork_sumSelfLinkWeight', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`StateNetwork_sumSelfLinkWeight`, 'returnType') = 'numeric'
attr(`StateNetwork_sumSelfLinkWeight`, "inputTypes") = c('_p_infomap__StateNetwork')
class(`StateNetwork_sumSelfLinkWeight`) = c("SWIGFunction", class('StateNetwork_sumSelfLinkWeight'))

# Start of StateNetwork_outWeights

`StateNetwork_outWeights` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_StateNetwork_outWeights', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__mapT_unsigned_int_double_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_double_t_t_t", ref=ans);
  
  ans
  
}

attr(`StateNetwork_outWeights`, 'returnType') = '_p_std__mapT_unsigned_int_double_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_double_t_t_t'
attr(`StateNetwork_outWeights`, "inputTypes") = c('_p_infomap__StateNetwork')
class(`StateNetwork_outWeights`) = c("SWIGFunction", class('StateNetwork_outWeights'))

# Start of StateNetwork_names

`StateNetwork_names__SWIG_0` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_StateNetwork_names__SWIG_0', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t", ref=ans);
  
  ans
  
}

attr(`StateNetwork_names__SWIG_0`, 'returnType') = '_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t'
attr(`StateNetwork_names__SWIG_0`, "inputTypes") = c('_p_infomap__StateNetwork')
class(`StateNetwork_names__SWIG_0`) = c("SWIGFunction", class('StateNetwork_names__SWIG_0'))

# Start of StateNetwork_names

`StateNetwork_names__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_StateNetwork_names__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t", ref=ans);
  
  ans
  
}

attr(`StateNetwork_names__SWIG_1`, 'returnType') = '_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t'
attr(`StateNetwork_names__SWIG_1`, "inputTypes") = c('_p_infomap__StateNetwork')
class(`StateNetwork_names__SWIG_1`) = c("SWIGFunction", class('StateNetwork_names__SWIG_1'))

`StateNetwork_names` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__StateNetwork') || is.null(argv[[1]]))) {
      f <- StateNetwork_names__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__StateNetwork') || is.null(argv[[1]]))) {
      f <- StateNetwork_names__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for StateNetwork_names with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of StateNetwork_haveDirectedInput

`StateNetwork_haveDirectedInput` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_StateNetwork_haveDirectedInput', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`StateNetwork_haveDirectedInput`, 'returnType') = 'logical'
attr(`StateNetwork_haveDirectedInput`, "inputTypes") = c('_p_infomap__StateNetwork')
class(`StateNetwork_haveDirectedInput`) = c("SWIGFunction", class('StateNetwork_haveDirectedInput'))

# Start of StateNetwork_haveMemoryInput

`StateNetwork_haveMemoryInput` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_StateNetwork_haveMemoryInput', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`StateNetwork_haveMemoryInput`, 'returnType') = 'logical'
attr(`StateNetwork_haveMemoryInput`, "inputTypes") = c('_p_infomap__StateNetwork')
class(`StateNetwork_haveMemoryInput`) = c("SWIGFunction", class('StateNetwork_haveMemoryInput'))

# Start of StateNetwork_isBipartite

`StateNetwork_isBipartite` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_StateNetwork_isBipartite', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`StateNetwork_isBipartite`, 'returnType') = 'logical'
attr(`StateNetwork_isBipartite`, "inputTypes") = c('_p_infomap__StateNetwork')
class(`StateNetwork_isBipartite`) = c("SWIGFunction", class('StateNetwork_isBipartite'))

# Start of StateNetwork_bipartiteStartId

`StateNetwork_bipartiteStartId` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_StateNetwork_bipartiteStartId', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`StateNetwork_bipartiteStartId`, 'returnType') = 'integer'
attr(`StateNetwork_bipartiteStartId`, "inputTypes") = c('_p_infomap__StateNetwork')
class(`StateNetwork_bipartiteStartId`) = c("SWIGFunction", class('StateNetwork_bipartiteStartId'))

# Start of StateNetwork_setBipartiteStartId

`StateNetwork_setBipartiteStartId` = function(self, value)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  value = as.integer(value);
  
  if(length(value) > 1) {
    warning("using only the first element of value");
  };
  
  ;.Call('R_swig_StateNetwork_setBipartiteStartId', self, value, PACKAGE='infomap');
  
}

attr(`StateNetwork_setBipartiteStartId`, 'returnType') = 'void'
attr(`StateNetwork_setBipartiteStartId`, "inputTypes") = c('_p_infomap__StateNetwork', 'integer')
class(`StateNetwork_setBipartiteStartId`) = c("SWIGFunction", class('StateNetwork_setBipartiteStartId'))

# Start of StateNetwork_writeStateNetwork

`StateNetwork_writeStateNetwork` = function(self, filename)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  filename = as(filename, "character"); 
  ;.Call('R_swig_StateNetwork_writeStateNetwork', self, filename, PACKAGE='infomap');
  
}

attr(`StateNetwork_writeStateNetwork`, 'returnType') = 'void'
attr(`StateNetwork_writeStateNetwork`, "inputTypes") = c('_p_infomap__StateNetwork', 'character')
class(`StateNetwork_writeStateNetwork`) = c("SWIGFunction", class('StateNetwork_writeStateNetwork'))

# Start of StateNetwork_writePajekNetwork

`StateNetwork_writePajekNetwork` = function(self, filename)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  filename = as(filename, "character"); 
  ;.Call('R_swig_StateNetwork_writePajekNetwork', self, filename, PACKAGE='infomap');
  
}

attr(`StateNetwork_writePajekNetwork`, 'returnType') = 'void'
attr(`StateNetwork_writePajekNetwork`, "inputTypes") = c('_p_infomap__StateNetwork', 'character')
class(`StateNetwork_writePajekNetwork`) = c("SWIGFunction", class('StateNetwork_writePajekNetwork'))

# Start of accessor method for infomap::StateNetwork
setMethod('$', '_p_infomap__StateNetwork', function(x, name)

{
  accessorFuns = list('setConfig' = StateNetwork_setConfig, 'getConfig' = StateNetwork_getConfig, 'addStateNode' = StateNetwork_addStateNode, 'addNode' = StateNetwork_addNode, 'addPhysicalNode' = StateNetwork_addPhysicalNode, 'addName' = StateNetwork_addName, 'addLink' = StateNetwork_addLink, 'removeLink' = StateNetwork_removeLink, 'undirectedToDirected' = StateNetwork_undirectedToDirected, 'calculateFlow' = StateNetwork_calculateFlow, 'clear' = StateNetwork_clear, 'clearLinks' = StateNetwork_clearLinks, 'nodes' = StateNetwork_nodes, 'numNodes' = StateNetwork_numNodes, 'numPhysicalNodes' = StateNetwork_numPhysicalNodes, 'nodeLinkMap' = StateNetwork_nodeLinkMap, 'numLinks' = StateNetwork_numLinks, 'sumLinkWeight' = StateNetwork_sumLinkWeight, 'sumSelfLinkWeight' = StateNetwork_sumSelfLinkWeight, 'outWeights' = StateNetwork_outWeights, 'names' = StateNetwork_names, 'haveDirectedInput' = StateNetwork_haveDirectedInput, 'haveMemoryInput' = StateNetwork_haveMemoryInput, 'isBipartite' = StateNetwork_isBipartite, 'bipartiteStartId' = StateNetwork_bipartiteStartId, 'setBipartiteStartId' = StateNetwork_setBipartiteStartId, 'writeStateNetwork' = StateNetwork_writeStateNetwork, 'writePajekNetwork' = StateNetwork_writePajekNetwork);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for infomap::StateNetwork
setMethod('delete', '_p_infomap__StateNetwork', function(obj) {delete_infomap__StateNetwork(obj)})
# Start of new_Network

`Network__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_Network__SWIG_0', PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__Network", ref=ans);
  
  reg.finalizer(ans@ref, delete_Network);
  ans
  
}

attr(`Network__SWIG_0`, 'returnType') = '_p_infomap__Network'
class(`Network__SWIG_0`) = c("SWIGFunction", class('Network__SWIG_0'))

# Start of new_Network

`Network__SWIG_1` = function(config)
{
  if (inherits(config, "ExternalReference")) config = slot(config,"ref"); 
  ;ans = .Call('R_swig_new_Network__SWIG_1', config, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__Network", ref=ans);
  
  reg.finalizer(ans@ref, delete_Network);
  ans
  
}

attr(`Network__SWIG_1`, 'returnType') = '_p_infomap__Network'
attr(`Network__SWIG_1`, "inputTypes") = c('_p_infomap__Config')
class(`Network__SWIG_1`) = c("SWIGFunction", class('Network__SWIG_1'))

# Start of new_Network

`Network__SWIG_2` = function(flags)
{
  flags = as(flags, "character"); 
  ;ans = .Call('R_swig_new_Network__SWIG_2', flags, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__Network", ref=ans);
  
  reg.finalizer(ans@ref, delete_Network);
  ans
  
}

attr(`Network__SWIG_2`, 'returnType') = '_p_infomap__Network'
attr(`Network__SWIG_2`, "inputTypes") = c('character')
class(`Network__SWIG_2`) = c("SWIGFunction", class('Network__SWIG_2'))

`Network` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 0) {
    f <- Network__SWIG_0; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_infomap__Config') && length(argv[[1]]) == 1) {
      f <- Network__SWIG_1; 
    }
    else if (is.character(argv[[1]]) && length(argv[[1]]) == 1) {
      f <- Network__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for Network with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_Network

`delete_Network` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_Network', self, PACKAGE='infomap');
  
}

attr(`delete_Network`, 'returnType') = 'void'
attr(`delete_Network`, "inputTypes") = c('_p_infomap__Network')
class(`delete_Network`) = c("SWIGFunction", class('delete_Network'))

# Start of Network_clear

`Network_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Network_clear', self, PACKAGE='infomap');
  
}

attr(`Network_clear`, 'returnType') = 'void'
attr(`Network_clear`, "inputTypes") = c('_p_infomap__Network')
class(`Network_clear`) = c("SWIGFunction", class('Network_clear'))

# Start of Network_readInputData

`Network_readInputData__SWIG_0` = function(self, filename, accumulate)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  filename = as(filename, "character"); 
  accumulate = as.logical(accumulate);
  ;.Call('R_swig_Network_readInputData__SWIG_0', self, filename, accumulate, PACKAGE='infomap');
  
}

attr(`Network_readInputData__SWIG_0`, 'returnType') = 'void'
attr(`Network_readInputData__SWIG_0`, "inputTypes") = c('_p_infomap__Network', 'character', 'logical')
class(`Network_readInputData__SWIG_0`) = c("SWIGFunction", class('Network_readInputData__SWIG_0'))

# Start of Network_readInputData

`Network_readInputData__SWIG_1` = function(self, filename)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  filename = as(filename, "character"); 
  ;.Call('R_swig_Network_readInputData__SWIG_1', self, filename, PACKAGE='infomap');
  
}

attr(`Network_readInputData__SWIG_1`, 'returnType') = 'void'
attr(`Network_readInputData__SWIG_1`, "inputTypes") = c('_p_infomap__Network', 'character')
class(`Network_readInputData__SWIG_1`) = c("SWIGFunction", class('Network_readInputData__SWIG_1'))

# Start of Network_readInputData

`Network_readInputData__SWIG_2` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Network_readInputData__SWIG_2', self, PACKAGE='infomap');
  
}

attr(`Network_readInputData__SWIG_2`, 'returnType') = 'void'
attr(`Network_readInputData__SWIG_2`, "inputTypes") = c('_p_infomap__Network')
class(`Network_readInputData__SWIG_2`) = c("SWIGFunction", class('Network_readInputData__SWIG_2'))

`Network_readInputData` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__Network') || is.null(argv[[1]]))) {
      f <- Network_readInputData__SWIG_2; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__Network') || is.null(argv[[1]])) && is.character(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- Network_readInputData__SWIG_1; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_infomap__Network') || is.null(argv[[1]])) && is.character(argv[[2]]) && length(argv[[2]]) == 1 && ( is.logical(argv[[3]]) && length(argv[[3]]) == 1 )) {
      f <- Network_readInputData__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Network_readInputData with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Network_readMetaData

`Network_readMetaData` = function(self, filename)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  filename = as(filename, "character"); 
  ;.Call('R_swig_Network_readMetaData', self, filename, PACKAGE='infomap');
  
}

attr(`Network_readMetaData`, 'returnType') = 'void'
attr(`Network_readMetaData`, "inputTypes") = c('_p_infomap__Network', 'character')
class(`Network_readMetaData`) = c("SWIGFunction", class('Network_readMetaData'))

# Start of Network_numMetaDataColumns

`Network_numMetaDataColumns` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Network_numMetaDataColumns', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Network_numMetaDataColumns`, 'returnType') = 'integer'
attr(`Network_numMetaDataColumns`, "inputTypes") = c('_p_infomap__Network')
class(`Network_numMetaDataColumns`) = c("SWIGFunction", class('Network_numMetaDataColumns'))

# Start of Network_metaData

`Network_metaData` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_Network_metaData', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__mapT_unsigned_int_std__vectorT_int_std__allocatorT_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_int_std__allocatorT_int_t_t_t_t_t", ref=ans);
  
  ans
  
}

attr(`Network_metaData`, 'returnType') = '_p_std__mapT_unsigned_int_std__vectorT_int_std__allocatorT_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_int_std__allocatorT_int_t_t_t_t_t'
attr(`Network_metaData`, "inputTypes") = c('_p_infomap__Network')
class(`Network_metaData`) = c("SWIGFunction", class('Network_metaData'))

# Start of Network_isMultilayerNetwork

`Network_isMultilayerNetwork` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Network_isMultilayerNetwork', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Network_isMultilayerNetwork`, 'returnType') = 'logical'
attr(`Network_isMultilayerNetwork`, "inputTypes") = c('_p_infomap__Network')
class(`Network_isMultilayerNetwork`) = c("SWIGFunction", class('Network_isMultilayerNetwork'))

# Start of Network_generateStateNetworkFromMultilayer

`Network_generateStateNetworkFromMultilayer` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Network_generateStateNetworkFromMultilayer', self, PACKAGE='infomap');
  
}

attr(`Network_generateStateNetworkFromMultilayer`, 'returnType') = 'void'
attr(`Network_generateStateNetworkFromMultilayer`, "inputTypes") = c('_p_infomap__Network')
class(`Network_generateStateNetworkFromMultilayer`) = c("SWIGFunction", class('Network_generateStateNetworkFromMultilayer'))

# Start of Network_generateStateNetworkFromMultilayerWithInterLinks

`Network_generateStateNetworkFromMultilayerWithInterLinks` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Network_generateStateNetworkFromMultilayerWithInterLinks', self, PACKAGE='infomap');
  
}

attr(`Network_generateStateNetworkFromMultilayerWithInterLinks`, 'returnType') = 'void'
attr(`Network_generateStateNetworkFromMultilayerWithInterLinks`, "inputTypes") = c('_p_infomap__Network')
class(`Network_generateStateNetworkFromMultilayerWithInterLinks`) = c("SWIGFunction", class('Network_generateStateNetworkFromMultilayerWithInterLinks'))

# Start of Network_generateStateNetworkFromMultilayerWithSimulatedInterLinks

`Network_generateStateNetworkFromMultilayerWithSimulatedInterLinks` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Network_generateStateNetworkFromMultilayerWithSimulatedInterLinks', self, PACKAGE='infomap');
  
}

attr(`Network_generateStateNetworkFromMultilayerWithSimulatedInterLinks`, 'returnType') = 'void'
attr(`Network_generateStateNetworkFromMultilayerWithSimulatedInterLinks`, "inputTypes") = c('_p_infomap__Network')
class(`Network_generateStateNetworkFromMultilayerWithSimulatedInterLinks`) = c("SWIGFunction", class('Network_generateStateNetworkFromMultilayerWithSimulatedInterLinks'))

# Start of Network_simulateInterLayerLinks

`Network_simulateInterLayerLinks` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Network_simulateInterLayerLinks', self, PACKAGE='infomap');
  
}

attr(`Network_simulateInterLayerLinks`, 'returnType') = 'void'
attr(`Network_simulateInterLayerLinks`, "inputTypes") = c('_p_infomap__Network')
class(`Network_simulateInterLayerLinks`) = c("SWIGFunction", class('Network_simulateInterLayerLinks'))

# Start of Network_addMultilayerLink

`Network_addMultilayerLink` = function(self, layer1, n1, layer2, n2, weight)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  layer1 = as.integer(layer1);
  
  if(length(layer1) > 1) {
    warning("using only the first element of layer1");
  };
  
  n1 = as.integer(n1);
  
  if(length(n1) > 1) {
    warning("using only the first element of n1");
  };
  
  layer2 = as.integer(layer2);
  
  if(length(layer2) > 1) {
    warning("using only the first element of layer2");
  };
  
  n2 = as.integer(n2);
  
  if(length(n2) > 1) {
    warning("using only the first element of n2");
  };
  
  
  ;.Call('R_swig_Network_addMultilayerLink', self, layer1, n1, layer2, n2, weight, PACKAGE='infomap');
  
}

attr(`Network_addMultilayerLink`, 'returnType') = 'void'
attr(`Network_addMultilayerLink`, "inputTypes") = c('_p_infomap__Network', 'integer', 'integer', 'integer', 'integer', 'numeric')
class(`Network_addMultilayerLink`) = c("SWIGFunction", class('Network_addMultilayerLink'))

# Start of Network_addMultilayerIntraLink

`Network_addMultilayerIntraLink` = function(self, layer, n1, n2, weight)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  layer = as.integer(layer);
  
  if(length(layer) > 1) {
    warning("using only the first element of layer");
  };
  
  n1 = as.integer(n1);
  
  if(length(n1) > 1) {
    warning("using only the first element of n1");
  };
  
  n2 = as.integer(n2);
  
  if(length(n2) > 1) {
    warning("using only the first element of n2");
  };
  
  
  ;.Call('R_swig_Network_addMultilayerIntraLink', self, layer, n1, n2, weight, PACKAGE='infomap');
  
}

attr(`Network_addMultilayerIntraLink`, 'returnType') = 'void'
attr(`Network_addMultilayerIntraLink`, "inputTypes") = c('_p_infomap__Network', 'integer', 'integer', 'integer', 'numeric')
class(`Network_addMultilayerIntraLink`) = c("SWIGFunction", class('Network_addMultilayerIntraLink'))

# Start of Network_addMultilayerInterLink

`Network_addMultilayerInterLink` = function(self, layer1, n, layer2, interWeight)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  layer1 = as.integer(layer1);
  
  if(length(layer1) > 1) {
    warning("using only the first element of layer1");
  };
  
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  layer2 = as.integer(layer2);
  
  if(length(layer2) > 1) {
    warning("using only the first element of layer2");
  };
  
  
  ;.Call('R_swig_Network_addMultilayerInterLink', self, layer1, n, layer2, interWeight, PACKAGE='infomap');
  
}

attr(`Network_addMultilayerInterLink`, 'returnType') = 'void'
attr(`Network_addMultilayerInterLink`, "inputTypes") = c('_p_infomap__Network', 'integer', 'integer', 'integer', 'numeric')
class(`Network_addMultilayerInterLink`) = c("SWIGFunction", class('Network_addMultilayerInterLink'))

# Start of Network_addMetaData

`Network_addMetaData__SWIG_0` = function(self, nodeId, meta)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  nodeId = as.integer(nodeId);
  
  if(length(nodeId) > 1) {
    warning("using only the first element of nodeId");
  };
  
  meta = as.integer(meta);
  
  if(length(meta) > 1) {
    warning("using only the first element of meta");
  };
  
  ;.Call('R_swig_Network_addMetaData__SWIG_0', self, nodeId, meta, PACKAGE='infomap');
  
}

attr(`Network_addMetaData__SWIG_0`, 'returnType') = 'void'
attr(`Network_addMetaData__SWIG_0`, "inputTypes") = c('_p_infomap__Network', 'integer', 'integer')
class(`Network_addMetaData__SWIG_0`) = c("SWIGFunction", class('Network_addMetaData__SWIG_0'))

# Start of Network_addMetaData

`Network_addMetaData__SWIG_1` = function(self, nodeId, metaData)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  nodeId = as.integer(nodeId);
  
  if(length(nodeId) > 1) {
    warning("using only the first element of nodeId");
  };
  
  metaData = as.integer(metaData);
  ;.Call('R_swig_Network_addMetaData__SWIG_1', self, nodeId, metaData, PACKAGE='infomap');
  
}

attr(`Network_addMetaData__SWIG_1`, 'returnType') = 'void'
attr(`Network_addMetaData__SWIG_1`, "inputTypes") = c('_p_infomap__Network', 'integer', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`Network_addMetaData__SWIG_1`) = c("SWIGFunction", class('Network_addMetaData__SWIG_1'))

`Network_addMetaData` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 3) {
    if ((extends(argtypes[1], '_p_infomap__Network') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 )) {
      f <- Network_addMetaData__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__Network') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.integer(argv[[3]]) || is.numeric(argv[[3]]) )) {
      f <- Network_addMetaData__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for Network_addMetaData with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of accessor method for infomap::Network
setMethod('$', '_p_infomap__Network', function(x, name)

{
  accessorFuns = list('clear' = Network_clear, 'readInputData' = Network_readInputData, 'readMetaData' = Network_readMetaData, 'numMetaDataColumns' = Network_numMetaDataColumns, 'metaData' = Network_metaData, 'isMultilayerNetwork' = Network_isMultilayerNetwork, 'generateStateNetworkFromMultilayer' = Network_generateStateNetworkFromMultilayer, 'generateStateNetworkFromMultilayerWithInterLinks' = Network_generateStateNetworkFromMultilayerWithInterLinks, 'generateStateNetworkFromMultilayerWithSimulatedInterLinks' = Network_generateStateNetworkFromMultilayerWithSimulatedInterLinks, 'simulateInterLayerLinks' = Network_simulateInterLayerLinks, 'addMultilayerLink' = Network_addMultilayerLink, 'addMultilayerIntraLink' = Network_addMultilayerIntraLink, 'addMultilayerInterLink' = Network_addMultilayerInterLink, 'addMetaData' = Network_addMetaData);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for infomap::Network
setMethod('delete', '_p_infomap__Network', function(obj) {delete_infomap__Network(obj)})
# Start of LayerNode_layer_set

`LayerNode_layer_set` = function(self, s_layer)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_layer = as.integer(s_layer);
  
  if(length(s_layer) > 1) {
    warning("using only the first element of s_layer");
  };
  
  ;.Call('R_swig_LayerNode_layer_set', self, s_layer, PACKAGE='infomap');
  
}

attr(`LayerNode_layer_set`, 'returnType') = 'void'
attr(`LayerNode_layer_set`, "inputTypes") = c('_p_infomap__LayerNode', 'integer')
class(`LayerNode_layer_set`) = c("SWIGFunction", class('LayerNode_layer_set'))

# Start of LayerNode_layer_get

`LayerNode_layer_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_LayerNode_layer_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`LayerNode_layer_get`, 'returnType') = 'integer'
attr(`LayerNode_layer_get`, "inputTypes") = c('_p_infomap__LayerNode')
class(`LayerNode_layer_get`) = c("SWIGFunction", class('LayerNode_layer_get'))

# Start of LayerNode_node_set

`LayerNode_node_set` = function(self, s_node)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_node = as.integer(s_node);
  
  if(length(s_node) > 1) {
    warning("using only the first element of s_node");
  };
  
  ;.Call('R_swig_LayerNode_node_set', self, s_node, PACKAGE='infomap');
  
}

attr(`LayerNode_node_set`, 'returnType') = 'void'
attr(`LayerNode_node_set`, "inputTypes") = c('_p_infomap__LayerNode', 'integer')
class(`LayerNode_node_set`) = c("SWIGFunction", class('LayerNode_node_set'))

# Start of LayerNode_node_get

`LayerNode_node_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_LayerNode_node_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`LayerNode_node_get`, 'returnType') = 'integer'
attr(`LayerNode_node_get`, "inputTypes") = c('_p_infomap__LayerNode')
class(`LayerNode_node_get`) = c("SWIGFunction", class('LayerNode_node_get'))

# Start of new_LayerNode

`LayerNode__SWIG_0` = function(layer, node)
{
  layer = as.integer(layer);
  
  if(length(layer) > 1) {
    warning("using only the first element of layer");
  };
  
  node = as.integer(node);
  
  if(length(node) > 1) {
    warning("using only the first element of node");
  };
  
  ;ans = .Call('R_swig_new_LayerNode__SWIG_0', layer, node, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__LayerNode", ref=ans);
  
  reg.finalizer(ans@ref, delete_LayerNode);
  ans
  
}

attr(`LayerNode__SWIG_0`, 'returnType') = '_p_infomap__LayerNode'
attr(`LayerNode__SWIG_0`, "inputTypes") = c('integer', 'integer')
class(`LayerNode__SWIG_0`) = c("SWIGFunction", class('LayerNode__SWIG_0'))

# Start of new_LayerNode

`LayerNode__SWIG_1` = function(layer)
{
  layer = as.integer(layer);
  
  if(length(layer) > 1) {
    warning("using only the first element of layer");
  };
  
  ;ans = .Call('R_swig_new_LayerNode__SWIG_1', layer, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__LayerNode", ref=ans);
  
  reg.finalizer(ans@ref, delete_LayerNode);
  ans
  
}

attr(`LayerNode__SWIG_1`, 'returnType') = '_p_infomap__LayerNode'
attr(`LayerNode__SWIG_1`, "inputTypes") = c('integer')
class(`LayerNode__SWIG_1`) = c("SWIGFunction", class('LayerNode__SWIG_1'))

# Start of new_LayerNode

`LayerNode__SWIG_2` = function()
{
  ;ans = .Call('R_swig_new_LayerNode__SWIG_2', PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__LayerNode", ref=ans);
  
  reg.finalizer(ans@ref, delete_LayerNode);
  ans
  
}

attr(`LayerNode__SWIG_2`, 'returnType') = '_p_infomap__LayerNode'
class(`LayerNode__SWIG_2`) = c("SWIGFunction", class('LayerNode__SWIG_2'))

`LayerNode` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 0) {
    f <- LayerNode__SWIG_2; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- LayerNode__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- LayerNode__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for LayerNode with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of LayerNode_LessThan

`LayerNode_LessThan` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;.Call('R_swig_LayerNode_LessThan', self, other, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`LayerNode_LessThan`, 'returnType') = 'logical'
attr(`LayerNode_LessThan`, "inputTypes") = c('_p_infomap__LayerNode', '_p_infomap__LayerNode')
class(`LayerNode_LessThan`) = c("SWIGFunction", class('LayerNode_LessThan'))

# Start of delete_LayerNode

`delete_LayerNode` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_LayerNode', self, PACKAGE='infomap');
  
}

attr(`delete_LayerNode`, 'returnType') = 'void'
attr(`delete_LayerNode`, "inputTypes") = c('_p_infomap__LayerNode')
class(`delete_LayerNode`) = c("SWIGFunction", class('delete_LayerNode'))

# Start of accessor method for infomap::LayerNode
setMethod('$', '_p_infomap__LayerNode', function(x, name)

{
  accessorFuns = list('layer' = LayerNode_layer_get, 'node' = LayerNode_node_get, 'LessThan' = LayerNode_LessThan);
  vaccessors = c('layer', 'node');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for infomap::LayerNode
# Start of accessor method for infomap::LayerNode
setMethod('$<-', '_p_infomap__LayerNode', function(x, name, value)

{
  accessorFuns = list('layer' = LayerNode_layer_set, 'node' = LayerNode_node_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_infomap__LayerNode', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('layer' = LayerNode_layer_set, 'node' = LayerNode_node_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for infomap::LayerNode
setMethod('delete', '_p_infomap__LayerNode', function(obj) {delete_infomap__LayerNode(obj)})
# Start definition of copy functions & methods for infomap::LayerNode
CopyToR_infomap__LayerNode = function(value, obj = new("infomap::LayerNode"))
{
  obj@layer = value$layer;
  obj@node = value$node;
  obj;
}



CopyToC_infomap__LayerNode = function(value, obj)
{
  obj$layer = value@layer;
  obj$node = value@node;
  obj
}



# Start definition of copy methods for infomap::LayerNode
setMethod('copyToR', '_p_infomap::LayerNode', CopyToR_infomap__LayerNode);
setMethod('copyToC', 'infomap::LayerNode', CopyToC_infomap__LayerNode);

# End definition of copy methods for infomap::LayerNode
# End definition of copy functions & methods for infomap::LayerNode
# Start of Bigram_first_set

`Bigram_first_set` = function(self, s_first)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_first = as.integer(s_first);
  
  if(length(s_first) > 1) {
    warning("using only the first element of s_first");
  };
  
  ;.Call('R_swig_Bigram_first_set', self, s_first, PACKAGE='infomap');
  
}

attr(`Bigram_first_set`, 'returnType') = 'void'
attr(`Bigram_first_set`, "inputTypes") = c('_p_infomap__Bigram', 'integer')
class(`Bigram_first_set`) = c("SWIGFunction", class('Bigram_first_set'))

# Start of Bigram_first_get

`Bigram_first_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Bigram_first_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Bigram_first_get`, 'returnType') = 'integer'
attr(`Bigram_first_get`, "inputTypes") = c('_p_infomap__Bigram')
class(`Bigram_first_get`) = c("SWIGFunction", class('Bigram_first_get'))

# Start of Bigram_second_set

`Bigram_second_set` = function(self, s_second)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_second = as.integer(s_second);
  
  if(length(s_second) > 1) {
    warning("using only the first element of s_second");
  };
  
  ;.Call('R_swig_Bigram_second_set', self, s_second, PACKAGE='infomap');
  
}

attr(`Bigram_second_set`, 'returnType') = 'void'
attr(`Bigram_second_set`, "inputTypes") = c('_p_infomap__Bigram', 'integer')
class(`Bigram_second_set`) = c("SWIGFunction", class('Bigram_second_set'))

# Start of Bigram_second_get

`Bigram_second_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Bigram_second_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Bigram_second_get`, 'returnType') = 'integer'
attr(`Bigram_second_get`, "inputTypes") = c('_p_infomap__Bigram')
class(`Bigram_second_get`) = c("SWIGFunction", class('Bigram_second_get'))

# Start of new_Bigram

`Bigram__SWIG_0` = function(first, second)
{
  first = as.integer(first);
  
  if(length(first) > 1) {
    warning("using only the first element of first");
  };
  
  second = as.integer(second);
  
  if(length(second) > 1) {
    warning("using only the first element of second");
  };
  
  ;ans = .Call('R_swig_new_Bigram__SWIG_0', first, second, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__Bigram", ref=ans);
  
  reg.finalizer(ans@ref, delete_Bigram);
  ans
  
}

attr(`Bigram__SWIG_0`, 'returnType') = '_p_infomap__Bigram'
attr(`Bigram__SWIG_0`, "inputTypes") = c('integer', 'integer')
class(`Bigram__SWIG_0`) = c("SWIGFunction", class('Bigram__SWIG_0'))

# Start of new_Bigram

`Bigram__SWIG_1` = function(first)
{
  first = as.integer(first);
  
  if(length(first) > 1) {
    warning("using only the first element of first");
  };
  
  ;ans = .Call('R_swig_new_Bigram__SWIG_1', first, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__Bigram", ref=ans);
  
  reg.finalizer(ans@ref, delete_Bigram);
  ans
  
}

attr(`Bigram__SWIG_1`, 'returnType') = '_p_infomap__Bigram'
attr(`Bigram__SWIG_1`, "inputTypes") = c('integer')
class(`Bigram__SWIG_1`) = c("SWIGFunction", class('Bigram__SWIG_1'))

# Start of new_Bigram

`Bigram__SWIG_2` = function()
{
  ;ans = .Call('R_swig_new_Bigram__SWIG_2', PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__Bigram", ref=ans);
  
  reg.finalizer(ans@ref, delete_Bigram);
  ans
  
}

attr(`Bigram__SWIG_2`, 'returnType') = '_p_infomap__Bigram'
class(`Bigram__SWIG_2`) = c("SWIGFunction", class('Bigram__SWIG_2'))

`Bigram` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 0) {
    f <- Bigram__SWIG_2; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- Bigram__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- Bigram__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Bigram with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Bigram_LessThan

`Bigram_LessThan` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;.Call('R_swig_Bigram_LessThan', self, other, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Bigram_LessThan`, 'returnType') = 'logical'
attr(`Bigram_LessThan`, "inputTypes") = c('_p_infomap__Bigram', '_p_infomap__Bigram')
class(`Bigram_LessThan`) = c("SWIGFunction", class('Bigram_LessThan'))

# Start of delete_Bigram

`delete_Bigram` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_Bigram', self, PACKAGE='infomap');
  
}

attr(`delete_Bigram`, 'returnType') = 'void'
attr(`delete_Bigram`, "inputTypes") = c('_p_infomap__Bigram')
class(`delete_Bigram`) = c("SWIGFunction", class('delete_Bigram'))

# Start of accessor method for infomap::Bigram
setMethod('$', '_p_infomap__Bigram', function(x, name)

{
  accessorFuns = list('first' = Bigram_first_get, 'second' = Bigram_second_get, 'LessThan' = Bigram_LessThan);
  vaccessors = c('first', 'second');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for infomap::Bigram
# Start of accessor method for infomap::Bigram
setMethod('$<-', '_p_infomap__Bigram', function(x, name, value)

{
  accessorFuns = list('first' = Bigram_first_set, 'second' = Bigram_second_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_infomap__Bigram', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('first' = Bigram_first_set, 'second' = Bigram_second_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for infomap::Bigram
setMethod('delete', '_p_infomap__Bigram', function(obj) {delete_infomap__Bigram(obj)})
# Start definition of copy functions & methods for infomap::Bigram
CopyToR_infomap__Bigram = function(value, obj = new("infomap::Bigram"))
{
  obj@first = value$first;
  obj@second = value$second;
  obj;
}



CopyToC_infomap__Bigram = function(value, obj)
{
  obj$first = value@first;
  obj$second = value@second;
  obj
}



# Start definition of copy methods for infomap::Bigram
setMethod('copyToR', '_p_infomap::Bigram', CopyToR_infomap__Bigram);
setMethod('copyToC', 'infomap::Bigram', CopyToC_infomap__Bigram);

# End definition of copy methods for infomap::Bigram
# End definition of copy functions & methods for infomap::Bigram
# Start of BipartiteLink_featureNode_set

`BipartiteLink_featureNode_set` = function(self, s_featureNode)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_featureNode = as.integer(s_featureNode);
  
  if(length(s_featureNode) > 1) {
    warning("using only the first element of s_featureNode");
  };
  
  ;.Call('R_swig_BipartiteLink_featureNode_set', self, s_featureNode, PACKAGE='infomap');
  
}

attr(`BipartiteLink_featureNode_set`, 'returnType') = 'void'
attr(`BipartiteLink_featureNode_set`, "inputTypes") = c('_p_infomap__BipartiteLink', 'integer')
class(`BipartiteLink_featureNode_set`) = c("SWIGFunction", class('BipartiteLink_featureNode_set'))

# Start of BipartiteLink_featureNode_get

`BipartiteLink_featureNode_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_BipartiteLink_featureNode_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`BipartiteLink_featureNode_get`, 'returnType') = 'integer'
attr(`BipartiteLink_featureNode_get`, "inputTypes") = c('_p_infomap__BipartiteLink')
class(`BipartiteLink_featureNode_get`) = c("SWIGFunction", class('BipartiteLink_featureNode_get'))

# Start of BipartiteLink_node_set

`BipartiteLink_node_set` = function(self, s_node)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_node = as.integer(s_node);
  
  if(length(s_node) > 1) {
    warning("using only the first element of s_node");
  };
  
  ;.Call('R_swig_BipartiteLink_node_set', self, s_node, PACKAGE='infomap');
  
}

attr(`BipartiteLink_node_set`, 'returnType') = 'void'
attr(`BipartiteLink_node_set`, "inputTypes") = c('_p_infomap__BipartiteLink', 'integer')
class(`BipartiteLink_node_set`) = c("SWIGFunction", class('BipartiteLink_node_set'))

# Start of BipartiteLink_node_get

`BipartiteLink_node_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_BipartiteLink_node_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`BipartiteLink_node_get`, 'returnType') = 'integer'
attr(`BipartiteLink_node_get`, "inputTypes") = c('_p_infomap__BipartiteLink')
class(`BipartiteLink_node_get`) = c("SWIGFunction", class('BipartiteLink_node_get'))

# Start of BipartiteLink_swapOrder_set

`BipartiteLink_swapOrder_set` = function(self, s_swapOrder)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_swapOrder = as.logical(s_swapOrder);
  ;.Call('R_swig_BipartiteLink_swapOrder_set', self, s_swapOrder, PACKAGE='infomap');
  
}

attr(`BipartiteLink_swapOrder_set`, 'returnType') = 'void'
attr(`BipartiteLink_swapOrder_set`, "inputTypes") = c('_p_infomap__BipartiteLink', 'logical')
class(`BipartiteLink_swapOrder_set`) = c("SWIGFunction", class('BipartiteLink_swapOrder_set'))

# Start of BipartiteLink_swapOrder_get

`BipartiteLink_swapOrder_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_BipartiteLink_swapOrder_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`BipartiteLink_swapOrder_get`, 'returnType') = 'logical'
attr(`BipartiteLink_swapOrder_get`, "inputTypes") = c('_p_infomap__BipartiteLink')
class(`BipartiteLink_swapOrder_get`) = c("SWIGFunction", class('BipartiteLink_swapOrder_get'))

# Start of new_BipartiteLink

`BipartiteLink__SWIG_0` = function(featureNode, node, swapOrder)
{
  featureNode = as.integer(featureNode);
  
  if(length(featureNode) > 1) {
    warning("using only the first element of featureNode");
  };
  
  node = as.integer(node);
  
  if(length(node) > 1) {
    warning("using only the first element of node");
  };
  
  swapOrder = as.logical(swapOrder);
  ;ans = .Call('R_swig_new_BipartiteLink__SWIG_0', featureNode, node, swapOrder, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__BipartiteLink", ref=ans);
  
  reg.finalizer(ans@ref, delete_BipartiteLink);
  ans
  
}

attr(`BipartiteLink__SWIG_0`, 'returnType') = '_p_infomap__BipartiteLink'
attr(`BipartiteLink__SWIG_0`, "inputTypes") = c('integer', 'integer', 'logical')
class(`BipartiteLink__SWIG_0`) = c("SWIGFunction", class('BipartiteLink__SWIG_0'))

# Start of new_BipartiteLink

`BipartiteLink__SWIG_1` = function(featureNode, node)
{
  featureNode = as.integer(featureNode);
  
  if(length(featureNode) > 1) {
    warning("using only the first element of featureNode");
  };
  
  node = as.integer(node);
  
  if(length(node) > 1) {
    warning("using only the first element of node");
  };
  
  ;ans = .Call('R_swig_new_BipartiteLink__SWIG_1', featureNode, node, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__BipartiteLink", ref=ans);
  
  reg.finalizer(ans@ref, delete_BipartiteLink);
  ans
  
}

attr(`BipartiteLink__SWIG_1`, 'returnType') = '_p_infomap__BipartiteLink'
attr(`BipartiteLink__SWIG_1`, "inputTypes") = c('integer', 'integer')
class(`BipartiteLink__SWIG_1`) = c("SWIGFunction", class('BipartiteLink__SWIG_1'))

# Start of new_BipartiteLink

`BipartiteLink__SWIG_2` = function(featureNode)
{
  featureNode = as.integer(featureNode);
  
  if(length(featureNode) > 1) {
    warning("using only the first element of featureNode");
  };
  
  ;ans = .Call('R_swig_new_BipartiteLink__SWIG_2', featureNode, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__BipartiteLink", ref=ans);
  
  reg.finalizer(ans@ref, delete_BipartiteLink);
  ans
  
}

attr(`BipartiteLink__SWIG_2`, 'returnType') = '_p_infomap__BipartiteLink'
attr(`BipartiteLink__SWIG_2`, "inputTypes") = c('integer')
class(`BipartiteLink__SWIG_2`) = c("SWIGFunction", class('BipartiteLink__SWIG_2'))

# Start of new_BipartiteLink

`BipartiteLink__SWIG_3` = function()
{
  ;ans = .Call('R_swig_new_BipartiteLink__SWIG_3', PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__BipartiteLink", ref=ans);
  
  reg.finalizer(ans@ref, delete_BipartiteLink);
  ans
  
}

attr(`BipartiteLink__SWIG_3`, 'returnType') = '_p_infomap__BipartiteLink'
class(`BipartiteLink__SWIG_3`) = c("SWIGFunction", class('BipartiteLink__SWIG_3'))

`BipartiteLink` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- BipartiteLink__SWIG_3; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- BipartiteLink__SWIG_2; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- BipartiteLink__SWIG_1; 
    }
  } else if (argc == 3) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.logical(argv[[3]]) && length(argv[[3]]) == 1 )) {
      f <- BipartiteLink__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for BipartiteLink with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of BipartiteLink_LessThan

`BipartiteLink_LessThan` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;.Call('R_swig_BipartiteLink_LessThan', self, other, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`BipartiteLink_LessThan`, 'returnType') = 'logical'
attr(`BipartiteLink_LessThan`, "inputTypes") = c('_p_infomap__BipartiteLink', '_p_infomap__BipartiteLink')
class(`BipartiteLink_LessThan`) = c("SWIGFunction", class('BipartiteLink_LessThan'))

# Start of delete_BipartiteLink

`delete_BipartiteLink` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_BipartiteLink', self, PACKAGE='infomap');
  
}

attr(`delete_BipartiteLink`, 'returnType') = 'void'
attr(`delete_BipartiteLink`, "inputTypes") = c('_p_infomap__BipartiteLink')
class(`delete_BipartiteLink`) = c("SWIGFunction", class('delete_BipartiteLink'))

# Start of accessor method for infomap::BipartiteLink
setMethod('$', '_p_infomap__BipartiteLink', function(x, name)

{
  accessorFuns = list('featureNode' = BipartiteLink_featureNode_get, 'node' = BipartiteLink_node_get, 'swapOrder' = BipartiteLink_swapOrder_get, 'LessThan' = BipartiteLink_LessThan);
  vaccessors = c('featureNode', 'node', 'swapOrder');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for infomap::BipartiteLink
# Start of accessor method for infomap::BipartiteLink
setMethod('$<-', '_p_infomap__BipartiteLink', function(x, name, value)

{
  accessorFuns = list('featureNode' = BipartiteLink_featureNode_set, 'node' = BipartiteLink_node_set, 'swapOrder' = BipartiteLink_swapOrder_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_infomap__BipartiteLink', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('featureNode' = BipartiteLink_featureNode_set, 'node' = BipartiteLink_node_set, 'swapOrder' = BipartiteLink_swapOrder_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for infomap::BipartiteLink
setMethod('delete', '_p_infomap__BipartiteLink', function(obj) {delete_infomap__BipartiteLink(obj)})
# Start definition of copy functions & methods for infomap::BipartiteLink
CopyToR_infomap__BipartiteLink = function(value, obj = new("infomap::BipartiteLink"))
{
  obj@featureNode = value$featureNode;
  obj@node = value$node;
  obj@swapOrder = value$swapOrder;
  obj;
}



CopyToC_infomap__BipartiteLink = function(value, obj)
{
  obj$featureNode = value@featureNode;
  obj$node = value@node;
  obj$swapOrder = value@swapOrder;
  obj
}



# Start definition of copy methods for infomap::BipartiteLink
setMethod('copyToR', '_p_infomap::BipartiteLink', CopyToR_infomap__BipartiteLink);
setMethod('copyToC', 'infomap::BipartiteLink', CopyToC_infomap__BipartiteLink);

# End definition of copy methods for infomap::BipartiteLink
# End definition of copy functions & methods for infomap::BipartiteLink
# Start of Weight_weight_set

`Weight_weight_set` = function(self, s_weight)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_Weight_weight_set', self, s_weight, PACKAGE='infomap');
  
}

attr(`Weight_weight_set`, 'returnType') = 'void'
attr(`Weight_weight_set`, "inputTypes") = c('_p_infomap__Weight', 'numeric')
class(`Weight_weight_set`) = c("SWIGFunction", class('Weight_weight_set'))

# Start of Weight_weight_get

`Weight_weight_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Weight_weight_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Weight_weight_get`, 'returnType') = 'numeric'
attr(`Weight_weight_get`, "inputTypes") = c('_p_infomap__Weight')
class(`Weight_weight_get`) = c("SWIGFunction", class('Weight_weight_get'))

# Start of new_Weight

`Weight__SWIG_0` = function(weight)
{
  ;ans = .Call('R_swig_new_Weight__SWIG_0', weight, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__Weight", ref=ans);
  
  reg.finalizer(ans@ref, delete_Weight);
  ans
  
}

attr(`Weight__SWIG_0`, 'returnType') = '_p_infomap__Weight'
attr(`Weight__SWIG_0`, "inputTypes") = c('numeric')
class(`Weight__SWIG_0`) = c("SWIGFunction", class('Weight__SWIG_0'))

# Start of new_Weight

`Weight__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_Weight__SWIG_1', PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__Weight", ref=ans);
  
  reg.finalizer(ans@ref, delete_Weight);
  ans
  
}

attr(`Weight__SWIG_1`, 'returnType') = '_p_infomap__Weight'
class(`Weight__SWIG_1`) = c("SWIGFunction", class('Weight__SWIG_1'))

`Weight` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- Weight__SWIG_1; 
  } else if (argc == 1) {
    if (( is.numeric(argv[[1]]) && length(argv[[1]]) == 1 )) {
      f <- Weight__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Weight with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Weight_PlusEqual

`Weight_PlusEqual` = function(self, w, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;ans = .Call('R_swig_Weight_PlusEqual', self, w, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__Weight", ref=ans);
  
  ans
  
}

attr(`Weight_PlusEqual`, 'returnType') = '_p_infomap__Weight'
attr(`Weight_PlusEqual`, "inputTypes") = c('_p_infomap__Weight', 'numeric')
class(`Weight_PlusEqual`) = c("SWIGFunction", class('Weight_PlusEqual'))

# Start of delete_Weight

`delete_Weight` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_Weight', self, PACKAGE='infomap');
  
}

attr(`delete_Weight`, 'returnType') = 'void'
attr(`delete_Weight`, "inputTypes") = c('_p_infomap__Weight')
class(`delete_Weight`) = c("SWIGFunction", class('delete_Weight'))

# Start of accessor method for infomap::Weight
setMethod('$', '_p_infomap__Weight', function(x, name)

{
  accessorFuns = list('weight' = Weight_weight_get, 'PlusEqual' = Weight_PlusEqual);
  vaccessors = c('weight');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for infomap::Weight
# Start of accessor method for infomap::Weight
setMethod('$<-', '_p_infomap__Weight', function(x, name, value)

{
  accessorFuns = list('weight' = Weight_weight_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_infomap__Weight', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('weight' = Weight_weight_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for infomap::Weight
setMethod('delete', '_p_infomap__Weight', function(obj) {delete_infomap__Weight(obj)})
# Start definition of copy functions & methods for infomap::Weight
CopyToR_infomap__Weight = function(value, obj = new("infomap::Weight"))
{
  obj@weight = value$weight;
  obj;
}



CopyToC_infomap__Weight = function(value, obj)
{
  obj$weight = value@weight;
  obj
}



# Start definition of copy methods for infomap::Weight
setMethod('copyToR', '_p_infomap::Weight', CopyToR_infomap__Weight);
setMethod('copyToC', 'infomap::Weight', CopyToC_infomap__Weight);

# End definition of copy methods for infomap::Weight
# End definition of copy functions & methods for infomap::Weight
# Start of new_Triple

`Triple__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_Triple__SWIG_0', PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__Triple", ref=ans);
  
  reg.finalizer(ans@ref, delete_Triple);
  ans
  
}

attr(`Triple__SWIG_0`, 'returnType') = '_p_infomap__Triple'
class(`Triple__SWIG_0`) = c("SWIGFunction", class('Triple__SWIG_0'))

# Start of new_Triple

`Triple__SWIG_1` = function(value1, value2, value3)
{
  value1 = as.integer(value1);
  
  if(length(value1) > 1) {
    warning("using only the first element of value1");
  };
  
  value2 = as.integer(value2);
  
  if(length(value2) > 1) {
    warning("using only the first element of value2");
  };
  
  value3 = as.integer(value3);
  
  if(length(value3) > 1) {
    warning("using only the first element of value3");
  };
  
  ;ans = .Call('R_swig_new_Triple__SWIG_1', value1, value2, value3, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__Triple", ref=ans);
  
  reg.finalizer(ans@ref, delete_Triple);
  ans
  
}

attr(`Triple__SWIG_1`, 'returnType') = '_p_infomap__Triple'
attr(`Triple__SWIG_1`, "inputTypes") = c('integer', 'integer', 'integer')
class(`Triple__SWIG_1`) = c("SWIGFunction", class('Triple__SWIG_1'))

# Start of new_Triple

`Triple__SWIG_2` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_new_Triple__SWIG_2', other, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__Triple", ref=ans);
  
  reg.finalizer(ans@ref, delete_Triple);
  ans
  
}

attr(`Triple__SWIG_2`, 'returnType') = '_p_infomap__Triple'
attr(`Triple__SWIG_2`, "inputTypes") = c('_p_infomap__Triple')
class(`Triple__SWIG_2`) = c("SWIGFunction", class('Triple__SWIG_2'))

`Triple` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 0) {
    f <- Triple__SWIG_0; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_infomap__Triple') && length(argv[[1]]) == 1) {
      f <- Triple__SWIG_2; 
    }
  } else if (argc == 3) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 )) {
      f <- Triple__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for Triple with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Triple_LessThan

`Triple_LessThan` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;.Call('R_swig_Triple_LessThan', self, other, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Triple_LessThan`, 'returnType') = 'logical'
attr(`Triple_LessThan`, "inputTypes") = c('_p_infomap__Triple', '_p_infomap__Triple')
class(`Triple_LessThan`) = c("SWIGFunction", class('Triple_LessThan'))

# Start of Triple_EqualEqual

`Triple_EqualEqual` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;.Call('R_swig_Triple_EqualEqual', self, other, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Triple_EqualEqual`, 'returnType') = 'logical'
attr(`Triple_EqualEqual`, "inputTypes") = c('_p_infomap__Triple', '_p_infomap__Triple')
class(`Triple_EqualEqual`) = c("SWIGFunction", class('Triple_EqualEqual'))

# Start of Triple_n1_set

`Triple_n1_set` = function(self, s_n1)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_n1 = as.integer(s_n1);
  
  if(length(s_n1) > 1) {
    warning("using only the first element of s_n1");
  };
  
  ;.Call('R_swig_Triple_n1_set', self, s_n1, PACKAGE='infomap');
  
}

attr(`Triple_n1_set`, 'returnType') = 'void'
attr(`Triple_n1_set`, "inputTypes") = c('_p_infomap__Triple', 'integer')
class(`Triple_n1_set`) = c("SWIGFunction", class('Triple_n1_set'))

# Start of Triple_n1_get

`Triple_n1_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Triple_n1_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Triple_n1_get`, 'returnType') = 'integer'
attr(`Triple_n1_get`, "inputTypes") = c('_p_infomap__Triple')
class(`Triple_n1_get`) = c("SWIGFunction", class('Triple_n1_get'))

# Start of Triple_n2_set

`Triple_n2_set` = function(self, s_n2)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_n2 = as.integer(s_n2);
  
  if(length(s_n2) > 1) {
    warning("using only the first element of s_n2");
  };
  
  ;.Call('R_swig_Triple_n2_set', self, s_n2, PACKAGE='infomap');
  
}

attr(`Triple_n2_set`, 'returnType') = 'void'
attr(`Triple_n2_set`, "inputTypes") = c('_p_infomap__Triple', 'integer')
class(`Triple_n2_set`) = c("SWIGFunction", class('Triple_n2_set'))

# Start of Triple_n2_get

`Triple_n2_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Triple_n2_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Triple_n2_get`, 'returnType') = 'integer'
attr(`Triple_n2_get`, "inputTypes") = c('_p_infomap__Triple')
class(`Triple_n2_get`) = c("SWIGFunction", class('Triple_n2_get'))

# Start of Triple_n3_set

`Triple_n3_set` = function(self, s_n3)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_n3 = as.integer(s_n3);
  
  if(length(s_n3) > 1) {
    warning("using only the first element of s_n3");
  };
  
  ;.Call('R_swig_Triple_n3_set', self, s_n3, PACKAGE='infomap');
  
}

attr(`Triple_n3_set`, 'returnType') = 'void'
attr(`Triple_n3_set`, "inputTypes") = c('_p_infomap__Triple', 'integer')
class(`Triple_n3_set`) = c("SWIGFunction", class('Triple_n3_set'))

# Start of Triple_n3_get

`Triple_n3_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_Triple_n3_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`Triple_n3_get`, 'returnType') = 'integer'
attr(`Triple_n3_get`, "inputTypes") = c('_p_infomap__Triple')
class(`Triple_n3_get`) = c("SWIGFunction", class('Triple_n3_get'))

# Start of delete_Triple

`delete_Triple` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_Triple', self, PACKAGE='infomap');
  
}

attr(`delete_Triple`, 'returnType') = 'void'
attr(`delete_Triple`, "inputTypes") = c('_p_infomap__Triple')
class(`delete_Triple`) = c("SWIGFunction", class('delete_Triple'))

# Start of accessor method for infomap::Triple
setMethod('$', '_p_infomap__Triple', function(x, name)

{
  accessorFuns = list('LessThan' = Triple_LessThan, 'EqualEqual' = Triple_EqualEqual, 'n1' = Triple_n1_get, 'n2' = Triple_n2_get, 'n3' = Triple_n3_get);
  vaccessors = c('n1', 'n2', 'n3');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for infomap::Triple
# Start of accessor method for infomap::Triple
setMethod('$<-', '_p_infomap__Triple', function(x, name, value)

{
  accessorFuns = list('n1' = Triple_n1_set, 'n2' = Triple_n2_set, 'n3' = Triple_n3_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_infomap__Triple', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('n1' = Triple_n1_set, 'n2' = Triple_n2_set, 'n3' = Triple_n3_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for infomap::Triple
setMethod('delete', '_p_infomap__Triple', function(obj) {delete_infomap__Triple(obj)})
# Start definition of copy functions & methods for infomap::Triple
CopyToR_infomap__Triple = function(value, obj = new("infomap::Triple"))
{
  obj@n1 = value$n1;
  obj@n2 = value$n2;
  obj@n3 = value$n3;
  obj;
}



CopyToC_infomap__Triple = function(value, obj)
{
  obj$n1 = value@n1;
  obj$n2 = value@n2;
  obj$n3 = value@n3;
  obj
}



# Start definition of copy methods for infomap::Triple
setMethod('copyToR', '_p_infomap::Triple', CopyToR_infomap__Triple);
setMethod('copyToC', 'infomap::Triple', CopyToC_infomap__Triple);

# End definition of copy methods for infomap::Triple
# End definition of copy functions & methods for infomap::Triple
# Start of new_map_uint_uint

`map_uint_uint__SWIG_0` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_new_map_uint_uint__SWIG_0', other, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_map_uint_uint);
  ans
  
}

attr(`map_uint_uint__SWIG_0`, 'returnType') = '_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t'
attr(`map_uint_uint__SWIG_0`, "inputTypes") = c('_p_std__lessT_unsigned_int_t')
class(`map_uint_uint__SWIG_0`) = c("SWIGFunction", class('map_uint_uint__SWIG_0'))

# Start of new_map_uint_uint

`map_uint_uint__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_map_uint_uint__SWIG_1', PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_map_uint_uint);
  ans
  
}

attr(`map_uint_uint__SWIG_1`, 'returnType') = '_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t'
class(`map_uint_uint__SWIG_1`) = c("SWIGFunction", class('map_uint_uint__SWIG_1'))

# Start of new_map_uint_uint

`map_uint_uint__SWIG_2` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_new_map_uint_uint__SWIG_2', other, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_map_uint_uint);
  ans
  
}

attr(`map_uint_uint__SWIG_2`, 'returnType') = '_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t'
attr(`map_uint_uint__SWIG_2`, "inputTypes") = c('_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t')
class(`map_uint_uint__SWIG_2`) = c("SWIGFunction", class('map_uint_uint__SWIG_2'))

`map_uint_uint` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 0) {
    f <- map_uint_uint__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_std__lessT_unsigned_int_t') && length(argv[[1]]) == 1) {
      f <- map_uint_uint__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t') && length(argv[[1]]) == 1) {
      f <- map_uint_uint__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for map_uint_uint with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of map_uint_uint_empty

`map_uint_uint_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_map_uint_uint_empty', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`map_uint_uint_empty`, 'returnType') = 'logical'
attr(`map_uint_uint_empty`, "inputTypes") = c('_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t')
class(`map_uint_uint_empty`) = c("SWIGFunction", class('map_uint_uint_empty'))

# Start of map_uint_uint_size

`map_uint_uint_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_map_uint_uint_size', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`map_uint_uint_size`, 'returnType') = 'integer'
attr(`map_uint_uint_size`, "inputTypes") = c('_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t')
class(`map_uint_uint_size`) = c("SWIGFunction", class('map_uint_uint_size'))

# Start of map_uint_uint_swap

`map_uint_uint_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref"); 
  ;.Call('R_swig_map_uint_uint_swap', self, v, PACKAGE='infomap');
  
}

attr(`map_uint_uint_swap`, 'returnType') = 'void'
attr(`map_uint_uint_swap`, "inputTypes") = c('_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t', '_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t')
class(`map_uint_uint_swap`) = c("SWIGFunction", class('map_uint_uint_swap'))

# Start of map_uint_uint_clear

`map_uint_uint_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_map_uint_uint_clear', self, PACKAGE='infomap');
  
}

attr(`map_uint_uint_clear`, 'returnType') = 'void'
attr(`map_uint_uint_clear`, "inputTypes") = c('_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t')
class(`map_uint_uint_clear`) = c("SWIGFunction", class('map_uint_uint_clear'))

# Start of map_uint_uint_get_allocator

`map_uint_uint_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_map_uint_uint_get_allocator', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t", ref=ans);
  
  ans
  
}

attr(`map_uint_uint_get_allocator`, 'returnType') = '_p_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t'
attr(`map_uint_uint_get_allocator`, "inputTypes") = c('_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t')
class(`map_uint_uint_get_allocator`) = c("SWIGFunction", class('map_uint_uint_get_allocator'))

# Start of map_uint_uint_erase

`map_uint_uint_erase` = function(self, x, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_map_uint_uint_erase', self, x, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`map_uint_uint_erase`, 'returnType') = 'integer'
attr(`map_uint_uint_erase`, "inputTypes") = c('_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t', '_p_unsigned_int')
class(`map_uint_uint_erase`) = c("SWIGFunction", class('map_uint_uint_erase'))

# Start of map_uint_uint_count

`map_uint_uint_count` = function(self, x, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_map_uint_uint_count', self, x, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`map_uint_uint_count`, 'returnType') = 'integer'
attr(`map_uint_uint_count`, "inputTypes") = c('_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t', '_p_unsigned_int')
class(`map_uint_uint_count`) = c("SWIGFunction", class('map_uint_uint_count'))

# Start of delete_map_uint_uint

`delete_map_uint_uint` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_map_uint_uint', self, PACKAGE='infomap');
  
}

attr(`delete_map_uint_uint`, 'returnType') = 'void'
attr(`delete_map_uint_uint`, "inputTypes") = c('_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t')
class(`delete_map_uint_uint`) = c("SWIGFunction", class('delete_map_uint_uint'))

# Start of accessor method for std::map< unsigned int,unsigned int >
setMethod('$', '_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t', function(x, name)

{
  accessorFuns = list('empty' = map_uint_uint_empty, 'size' = map_uint_uint_size, 'swap' = map_uint_uint_swap, 'clear' = map_uint_uint_clear, 'get_allocator' = map_uint_uint_get_allocator, 'erase' = map_uint_uint_erase, 'count' = map_uint_uint_count);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::map< unsigned int,unsigned int >
setMethod('delete', '_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t', function(obj) {delete_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t(obj)})
# Start of vector_double___nonzero__

`vector_double___nonzero__` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_vector_double___nonzero__', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`vector_double___nonzero__`, 'returnType') = 'logical'
attr(`vector_double___nonzero__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`vector_double___nonzero__`) = c("SWIGFunction", class('vector_double___nonzero__'))

# Start of vector_double___len__

`vector_double___len__` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_vector_double___len__', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`vector_double___len__`, 'returnType') = 'integer'
attr(`vector_double___len__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`vector_double___len__`) = c("SWIGFunction", class('vector_double___len__'))

# Start of vector_double_pop

`vector_double_pop` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_vector_double_pop', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`vector_double_pop`, 'returnType') = 'numeric'
attr(`vector_double_pop`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`vector_double_pop`) = c("SWIGFunction", class('vector_double_pop'))

# Start of vector_double___getslice__

`vector_double___getslice__` = function(self, i, j)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_vector_double___getslice__', self, i, j, PACKAGE='infomap');
  
}

attr(`vector_double___getslice__`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`vector_double___getslice__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'integer')
class(`vector_double___getslice__`) = c("SWIGFunction", class('vector_double___getslice__'))

# Start of vector_double___setslice__

`vector_double___setslice__` = function(self, i, j, v)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  v = as.numeric(v);
  ;.Call('R_swig_vector_double___setslice__', self, i, j, v, PACKAGE='infomap');
  
}

attr(`vector_double___setslice__`, 'returnType') = 'void'
attr(`vector_double___setslice__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`vector_double___setslice__`) = c("SWIGFunction", class('vector_double___setslice__'))

# Start of vector_double___delslice__

`vector_double___delslice__` = function(self, i, j)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_vector_double___delslice__', self, i, j, PACKAGE='infomap');
  
}

attr(`vector_double___delslice__`, 'returnType') = 'void'
attr(`vector_double___delslice__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'integer')
class(`vector_double___delslice__`) = c("SWIGFunction", class('vector_double___delslice__'))

# Start of vector_double___delitem__

`vector_double___delitem__` = function(self, i)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_vector_double___delitem__', self, i, PACKAGE='infomap');
  
}

attr(`vector_double___delitem__`, 'returnType') = 'void'
attr(`vector_double___delitem__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`vector_double___delitem__`) = c("SWIGFunction", class('vector_double___delitem__'))

# Start of vector_double___getitem__

`vector_double___getitem__` = function(self, i, .copy = FALSE)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_vector_double___getitem__', self, i, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`vector_double___getitem__`, 'returnType') = 'numeric'
attr(`vector_double___getitem__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`vector_double___getitem__`) = c("SWIGFunction", class('vector_double___getitem__'))

# Start of vector_double___setitem__

`vector_double___setitem__` = function(self, i, x)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_vector_double___setitem__', self, i, x, PACKAGE='infomap');
  
}

attr(`vector_double___setitem__`, 'returnType') = 'void'
attr(`vector_double___setitem__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'numeric')
class(`vector_double___setitem__`) = c("SWIGFunction", class('vector_double___setitem__'))

# Start of vector_double_append

`vector_double_append` = function(self, x)
{
  self = as.numeric(self);
  
  ;.Call('R_swig_vector_double_append', self, x, PACKAGE='infomap');
  
}

attr(`vector_double_append`, 'returnType') = 'void'
attr(`vector_double_append`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'numeric')
class(`vector_double_append`) = c("SWIGFunction", class('vector_double_append'))

# Start of new_vector_double

`vector_double__SWIG_0` = function()
{
  ;.Call('R_swig_new_vector_double__SWIG_0', PACKAGE='infomap');
  
}

attr(`vector_double__SWIG_0`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
class(`vector_double__SWIG_0`) = c("SWIGFunction", class('vector_double__SWIG_0'))

# Start of new_vector_double

`vector_double__SWIG_1` = function(other)
{
  other = as.numeric(other);
  ;.Call('R_swig_new_vector_double__SWIG_1', other, PACKAGE='infomap');
  
}

attr(`vector_double__SWIG_1`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`vector_double__SWIG_1`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`vector_double__SWIG_1`) = c("SWIGFunction", class('vector_double__SWIG_1'))

# Start of vector_double_empty

`vector_double_empty` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_vector_double_empty', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`vector_double_empty`, 'returnType') = 'logical'
attr(`vector_double_empty`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`vector_double_empty`) = c("SWIGFunction", class('vector_double_empty'))

# Start of vector_double_size

`vector_double_size` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_vector_double_size', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`vector_double_size`, 'returnType') = 'integer'
attr(`vector_double_size`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`vector_double_size`) = c("SWIGFunction", class('vector_double_size'))

# Start of vector_double_swap

`vector_double_swap` = function(self, v)
{
  self = as.numeric(self);
  v = as.numeric(v);
  ;.Call('R_swig_vector_double_swap', self, v, PACKAGE='infomap');
  
}

attr(`vector_double_swap`, 'returnType') = 'void'
attr(`vector_double_swap`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`vector_double_swap`) = c("SWIGFunction", class('vector_double_swap'))

# Start of vector_double_clear

`vector_double_clear` = function(self)
{
  self = as.numeric(self);
  ;.Call('R_swig_vector_double_clear', self, PACKAGE='infomap');
  
}

attr(`vector_double_clear`, 'returnType') = 'void'
attr(`vector_double_clear`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`vector_double_clear`) = c("SWIGFunction", class('vector_double_clear'))

# Start of vector_double_get_allocator

`vector_double_get_allocator` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;ans = .Call('R_swig_vector_double_get_allocator', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_double_t", ref=ans);
  
  ans
  
}

attr(`vector_double_get_allocator`, 'returnType') = '_p_std__allocatorT_double_t'
attr(`vector_double_get_allocator`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`vector_double_get_allocator`) = c("SWIGFunction", class('vector_double_get_allocator'))

# Start of new_vector_double

`vector_double__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;.Call('R_swig_new_vector_double__SWIG_2', size, PACKAGE='infomap');
  
}

attr(`vector_double__SWIG_2`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`vector_double__SWIG_2`, "inputTypes") = c('integer')
class(`vector_double__SWIG_2`) = c("SWIGFunction", class('vector_double__SWIG_2'))

# Start of vector_double_pop_back

`vector_double_pop_back` = function(self)
{
  self = as.numeric(self);
  ;.Call('R_swig_vector_double_pop_back', self, PACKAGE='infomap');
  
}

attr(`vector_double_pop_back`, 'returnType') = 'void'
attr(`vector_double_pop_back`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`vector_double_pop_back`) = c("SWIGFunction", class('vector_double_pop_back'))

# Start of vector_double_resize

`vector_double_resize__SWIG_0` = function(self, new_size)
{
  self = as.numeric(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_vector_double_resize__SWIG_0', self, new_size, PACKAGE='infomap');
  
}

attr(`vector_double_resize__SWIG_0`, 'returnType') = 'void'
attr(`vector_double_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`vector_double_resize__SWIG_0`) = c("SWIGFunction", class('vector_double_resize__SWIG_0'))

# Start of new_vector_double

`vector_double__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  
  ;.Call('R_swig_new_vector_double__SWIG_3', size, value, PACKAGE='infomap');
  
}

attr(`vector_double__SWIG_3`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`vector_double__SWIG_3`, "inputTypes") = c('integer', 'numeric')
class(`vector_double__SWIG_3`) = c("SWIGFunction", class('vector_double__SWIG_3'))

`vector_double` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- vector_double__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- vector_double__SWIG_2; 
    }
    else if (( is.numeric(argv[[1]]) )) {
      f <- vector_double__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && is.numeric(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- vector_double__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for vector_double with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of vector_double_push_back

`vector_double_push_back` = function(self, x)
{
  self = as.numeric(self);
  
  ;.Call('R_swig_vector_double_push_back', self, x, PACKAGE='infomap');
  
}

attr(`vector_double_push_back`, 'returnType') = 'void'
attr(`vector_double_push_back`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'numeric')
class(`vector_double_push_back`) = c("SWIGFunction", class('vector_double_push_back'))

# Start of vector_double_front

`vector_double_front` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_vector_double_front', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`vector_double_front`, 'returnType') = 'numeric'
attr(`vector_double_front`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`vector_double_front`) = c("SWIGFunction", class('vector_double_front'))

# Start of vector_double_back

`vector_double_back` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_vector_double_back', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`vector_double_back`, 'returnType') = 'numeric'
attr(`vector_double_back`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`vector_double_back`) = c("SWIGFunction", class('vector_double_back'))

# Start of vector_double_assign

`vector_double_assign` = function(self, n, x)
{
  self = as.numeric(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;.Call('R_swig_vector_double_assign', self, n, x, PACKAGE='infomap');
  
}

attr(`vector_double_assign`, 'returnType') = 'void'
attr(`vector_double_assign`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'numeric')
class(`vector_double_assign`) = c("SWIGFunction", class('vector_double_assign'))

# Start of vector_double_resize

`vector_double_resize__SWIG_1` = function(self, new_size, x)
{
  self = as.numeric(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  
  ;.Call('R_swig_vector_double_resize__SWIG_1', self, new_size, x, PACKAGE='infomap');
  
}

attr(`vector_double_resize__SWIG_1`, 'returnType') = 'void'
attr(`vector_double_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'numeric')
class(`vector_double_resize__SWIG_1`) = c("SWIGFunction", class('vector_double_resize__SWIG_1'))

`vector_double_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (( is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- vector_double_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (( is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && is.numeric(argv[[3]]) && length(argv[[3]]) == 1) {
      f <- vector_double_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for vector_double_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of vector_double_reserve

`vector_double_reserve` = function(self, n)
{
  self = as.numeric(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_vector_double_reserve', self, n, PACKAGE='infomap');
  
}

attr(`vector_double_reserve`, 'returnType') = 'void'
attr(`vector_double_reserve`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`vector_double_reserve`) = c("SWIGFunction", class('vector_double_reserve'))

# Start of vector_double_capacity

`vector_double_capacity` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_vector_double_capacity', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`vector_double_capacity`, 'returnType') = 'integer'
attr(`vector_double_capacity`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`vector_double_capacity`) = c("SWIGFunction", class('vector_double_capacity'))

# Start of delete_vector_double

`delete_vector_double` = function(self)
{
  self = as.numeric(self);
  ;.Call('R_swig_delete_vector_double', self, PACKAGE='infomap');
  
}

attr(`delete_vector_double`, 'returnType') = 'void'
attr(`delete_vector_double`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`delete_vector_double`) = c("SWIGFunction", class('delete_vector_double'))

# Start of accessor method for std::vector< double >
setMethod('$', '_p_std__vectorT_double_std__allocatorT_double_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = vector_double___nonzero__, '__len__' = vector_double___len__, 'pop' = vector_double_pop, '__getslice__' = vector_double___getslice__, '__setslice__' = vector_double___setslice__, '__delslice__' = vector_double___delslice__, '__delitem__' = vector_double___delitem__, '__getitem__' = vector_double___getitem__, '__setitem__' = vector_double___setitem__, 'append' = vector_double_append, 'empty' = vector_double_empty, 'size' = vector_double_size, 'swap' = vector_double_swap, 'clear' = vector_double_clear, 'get_allocator' = vector_double_get_allocator, 'pop_back' = vector_double_pop_back, 'resize' = vector_double_resize, 'push_back' = vector_double_push_back, 'front' = vector_double_front, 'back' = vector_double_back, 'assign' = vector_double_assign, 'reserve' = vector_double_reserve, 'capacity' = vector_double_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector< double >
setMethod('delete', '_p_std__vectorT_double_std__allocatorT_double_t_t', function(obj) {delete_std__vectorT_double_std__allocatorT_double_t_t(obj)})
# Start of new_InfomapConfigInfomapBase

`InfomapConfigInfomapBase__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_InfomapConfigInfomapBase__SWIG_0', PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapConfigT_infomap__InfomapBase_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfomapConfigInfomapBase);
  ans
  
}

attr(`InfomapConfigInfomapBase__SWIG_0`, 'returnType') = '_p_infomap__InfomapConfigT_infomap__InfomapBase_t'
class(`InfomapConfigInfomapBase__SWIG_0`) = c("SWIGFunction", class('InfomapConfigInfomapBase__SWIG_0'))

# Start of new_InfomapConfigInfomapBase

`InfomapConfigInfomapBase__SWIG_1` = function(flags)
{
  flags = as(flags, "character"); 
  ;ans = .Call('R_swig_new_InfomapConfigInfomapBase__SWIG_1', flags, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapConfigT_infomap__InfomapBase_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfomapConfigInfomapBase);
  ans
  
}

attr(`InfomapConfigInfomapBase__SWIG_1`, 'returnType') = '_p_infomap__InfomapConfigT_infomap__InfomapBase_t'
attr(`InfomapConfigInfomapBase__SWIG_1`, "inputTypes") = c('character')
class(`InfomapConfigInfomapBase__SWIG_1`) = c("SWIGFunction", class('InfomapConfigInfomapBase__SWIG_1'))

# Start of new_InfomapConfigInfomapBase

`InfomapConfigInfomapBase__SWIG_2` = function(conf)
{
  if (inherits(conf, "ExternalReference")) conf = slot(conf,"ref"); 
  ;ans = .Call('R_swig_new_InfomapConfigInfomapBase__SWIG_2', conf, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapConfigT_infomap__InfomapBase_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfomapConfigInfomapBase);
  ans
  
}

attr(`InfomapConfigInfomapBase__SWIG_2`, 'returnType') = '_p_infomap__InfomapConfigT_infomap__InfomapBase_t'
attr(`InfomapConfigInfomapBase__SWIG_2`, "inputTypes") = c('_p_infomap__Config')
class(`InfomapConfigInfomapBase__SWIG_2`) = c("SWIGFunction", class('InfomapConfigInfomapBase__SWIG_2'))

`InfomapConfigInfomapBase` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 0) {
    f <- InfomapConfigInfomapBase__SWIG_0; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_infomap__Config') && length(argv[[1]]) == 1) {
      f <- InfomapConfigInfomapBase__SWIG_2; 
    }
    else if (is.character(argv[[1]]) && length(argv[[1]]) == 1) {
      f <- InfomapConfigInfomapBase__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapConfigInfomapBase with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_InfomapConfigInfomapBase

`delete_InfomapConfigInfomapBase` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_InfomapConfigInfomapBase', self, PACKAGE='infomap');
  
}

attr(`delete_InfomapConfigInfomapBase`, 'returnType') = 'void'
attr(`delete_InfomapConfigInfomapBase`, "inputTypes") = c('_p_infomap__InfomapConfigT_infomap__InfomapBase_t')
class(`delete_InfomapConfigInfomapBase`) = c("SWIGFunction", class('delete_InfomapConfigInfomapBase'))

# Start of InfomapConfigInfomapBase_getConfig

`InfomapConfigInfomapBase_getConfig__SWIG_0` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapConfigInfomapBase_getConfig__SWIG_0', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__Config", ref=ans);
  
  ans
  
}

attr(`InfomapConfigInfomapBase_getConfig__SWIG_0`, 'returnType') = '_p_infomap__Config'
attr(`InfomapConfigInfomapBase_getConfig__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapConfigT_infomap__InfomapBase_t')
class(`InfomapConfigInfomapBase_getConfig__SWIG_0`) = c("SWIGFunction", class('InfomapConfigInfomapBase_getConfig__SWIG_0'))

# Start of InfomapConfigInfomapBase_getConfig

`InfomapConfigInfomapBase_getConfig__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapConfigInfomapBase_getConfig__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__Config", ref=ans);
  
  ans
  
}

attr(`InfomapConfigInfomapBase_getConfig__SWIG_1`, 'returnType') = '_p_infomap__Config'
attr(`InfomapConfigInfomapBase_getConfig__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapConfigT_infomap__InfomapBase_t')
class(`InfomapConfigInfomapBase_getConfig__SWIG_1`) = c("SWIGFunction", class('InfomapConfigInfomapBase_getConfig__SWIG_1'))

`InfomapConfigInfomapBase_getConfig` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapConfigT_infomap__InfomapBase_t') || is.null(argv[[1]]))) {
      f <- InfomapConfigInfomapBase_getConfig__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapConfigT_infomap__InfomapBase_t') || is.null(argv[[1]]))) {
      f <- InfomapConfigInfomapBase_getConfig__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapConfigInfomapBase_getConfig with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapConfigInfomapBase_setConfig

`InfomapConfigInfomapBase_setConfig` = function(self, conf, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(conf, "ExternalReference")) conf = slot(conf,"ref"); 
  ;ans = .Call('R_swig_InfomapConfigInfomapBase_setConfig', self, conf, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfomapConfigInfomapBase_setConfig`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfomapConfigInfomapBase_setConfig`, "inputTypes") = c('_p_infomap__InfomapConfigT_infomap__InfomapBase_t', '_p_infomap__Config')
class(`InfomapConfigInfomapBase_setConfig`) = c("SWIGFunction", class('InfomapConfigInfomapBase_setConfig'))

# Start of InfomapConfigInfomapBase_setNonMainConfig

`InfomapConfigInfomapBase_setNonMainConfig` = function(self, conf, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(conf, "ExternalReference")) conf = slot(conf,"ref"); 
  ;ans = .Call('R_swig_InfomapConfigInfomapBase_setNonMainConfig', self, conf, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfomapConfigInfomapBase_setNonMainConfig`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfomapConfigInfomapBase_setNonMainConfig`, "inputTypes") = c('_p_infomap__InfomapConfigT_infomap__InfomapBase_t', '_p_infomap__Config')
class(`InfomapConfigInfomapBase_setNonMainConfig`) = c("SWIGFunction", class('InfomapConfigInfomapBase_setNonMainConfig'))

# Start of InfomapConfigInfomapBase_setNumTrials

`InfomapConfigInfomapBase_setNumTrials` = function(self, N, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  N = as.integer(N);
  
  if(length(N) > 1) {
    warning("using only the first element of N");
  };
  
  ;ans = .Call('R_swig_InfomapConfigInfomapBase_setNumTrials', self, N, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfomapConfigInfomapBase_setNumTrials`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfomapConfigInfomapBase_setNumTrials`, "inputTypes") = c('_p_infomap__InfomapConfigT_infomap__InfomapBase_t', 'integer')
class(`InfomapConfigInfomapBase_setNumTrials`) = c("SWIGFunction", class('InfomapConfigInfomapBase_setNumTrials'))

# Start of InfomapConfigInfomapBase_setVerbosity

`InfomapConfigInfomapBase_setVerbosity` = function(self, level, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  level = as.integer(level);
  
  if(length(level) > 1) {
    warning("using only the first element of level");
  };
  
  ;ans = .Call('R_swig_InfomapConfigInfomapBase_setVerbosity', self, level, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfomapConfigInfomapBase_setVerbosity`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfomapConfigInfomapBase_setVerbosity`, "inputTypes") = c('_p_infomap__InfomapConfigT_infomap__InfomapBase_t', 'integer')
class(`InfomapConfigInfomapBase_setVerbosity`) = c("SWIGFunction", class('InfomapConfigInfomapBase_setVerbosity'))

# Start of InfomapConfigInfomapBase_setTwoLevel

`InfomapConfigInfomapBase_setTwoLevel` = function(self, value, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  value = as.logical(value);
  ;ans = .Call('R_swig_InfomapConfigInfomapBase_setTwoLevel', self, value, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfomapConfigInfomapBase_setTwoLevel`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfomapConfigInfomapBase_setTwoLevel`, "inputTypes") = c('_p_infomap__InfomapConfigT_infomap__InfomapBase_t', 'logical')
class(`InfomapConfigInfomapBase_setTwoLevel`) = c("SWIGFunction", class('InfomapConfigInfomapBase_setTwoLevel'))

# Start of InfomapConfigInfomapBase_setTuneIterationLimit

`InfomapConfigInfomapBase_setTuneIterationLimit` = function(self, value, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  value = as.integer(value);
  
  if(length(value) > 1) {
    warning("using only the first element of value");
  };
  
  ;ans = .Call('R_swig_InfomapConfigInfomapBase_setTuneIterationLimit', self, value, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfomapConfigInfomapBase_setTuneIterationLimit`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfomapConfigInfomapBase_setTuneIterationLimit`, "inputTypes") = c('_p_infomap__InfomapConfigT_infomap__InfomapBase_t', 'integer')
class(`InfomapConfigInfomapBase_setTuneIterationLimit`) = c("SWIGFunction", class('InfomapConfigInfomapBase_setTuneIterationLimit'))

# Start of InfomapConfigInfomapBase_setFastHierarchicalSolution

`InfomapConfigInfomapBase_setFastHierarchicalSolution` = function(self, level, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  level = as.integer(level);
  
  if(length(level) > 1) {
    warning("using only the first element of level");
  };
  
  ;ans = .Call('R_swig_InfomapConfigInfomapBase_setFastHierarchicalSolution', self, level, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfomapConfigInfomapBase_setFastHierarchicalSolution`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfomapConfigInfomapBase_setFastHierarchicalSolution`, "inputTypes") = c('_p_infomap__InfomapConfigT_infomap__InfomapBase_t', 'integer')
class(`InfomapConfigInfomapBase_setFastHierarchicalSolution`) = c("SWIGFunction", class('InfomapConfigInfomapBase_setFastHierarchicalSolution'))

# Start of InfomapConfigInfomapBase_setOnlySuperModules

`InfomapConfigInfomapBase_setOnlySuperModules` = function(self, value, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  value = as.logical(value);
  ;ans = .Call('R_swig_InfomapConfigInfomapBase_setOnlySuperModules', self, value, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfomapConfigInfomapBase_setOnlySuperModules`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfomapConfigInfomapBase_setOnlySuperModules`, "inputTypes") = c('_p_infomap__InfomapConfigT_infomap__InfomapBase_t', 'logical')
class(`InfomapConfigInfomapBase_setOnlySuperModules`) = c("SWIGFunction", class('InfomapConfigInfomapBase_setOnlySuperModules'))

# Start of InfomapConfigInfomapBase_setNoCoarseTune

`InfomapConfigInfomapBase_setNoCoarseTune` = function(self, value, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  value = as.logical(value);
  ;ans = .Call('R_swig_InfomapConfigInfomapBase_setNoCoarseTune', self, value, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfomapConfigInfomapBase_setNoCoarseTune`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfomapConfigInfomapBase_setNoCoarseTune`, "inputTypes") = c('_p_infomap__InfomapConfigT_infomap__InfomapBase_t', 'logical')
class(`InfomapConfigInfomapBase_setNoCoarseTune`) = c("SWIGFunction", class('InfomapConfigInfomapBase_setNoCoarseTune'))

# Start of InfomapConfigInfomapBase_setNoInfomap

`InfomapConfigInfomapBase_setNoInfomap__SWIG_0` = function(self, value, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  value = as.logical(value);
  ;ans = .Call('R_swig_InfomapConfigInfomapBase_setNoInfomap__SWIG_0', self, value, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfomapConfigInfomapBase_setNoInfomap__SWIG_0`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfomapConfigInfomapBase_setNoInfomap__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapConfigT_infomap__InfomapBase_t', 'logical')
class(`InfomapConfigInfomapBase_setNoInfomap__SWIG_0`) = c("SWIGFunction", class('InfomapConfigInfomapBase_setNoInfomap__SWIG_0'))

# Start of InfomapConfigInfomapBase_setNoInfomap

`InfomapConfigInfomapBase_setNoInfomap__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapConfigInfomapBase_setNoInfomap__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfomapConfigInfomapBase_setNoInfomap__SWIG_1`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfomapConfigInfomapBase_setNoInfomap__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapConfigT_infomap__InfomapBase_t')
class(`InfomapConfigInfomapBase_setNoInfomap__SWIG_1`) = c("SWIGFunction", class('InfomapConfigInfomapBase_setNoInfomap__SWIG_1'))

`InfomapConfigInfomapBase_setNoInfomap` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapConfigT_infomap__InfomapBase_t') || is.null(argv[[1]]))) {
      f <- InfomapConfigInfomapBase_setNoInfomap__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapConfigT_infomap__InfomapBase_t') || is.null(argv[[1]])) && ( is.logical(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- InfomapConfigInfomapBase_setNoInfomap__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InfomapConfigInfomapBase_setNoInfomap with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapConfigInfomapBase_setMarkovTime

`InfomapConfigInfomapBase_setMarkovTime` = function(self, codeRate, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;ans = .Call('R_swig_InfomapConfigInfomapBase_setMarkovTime', self, codeRate, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfomapConfigInfomapBase_setMarkovTime`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfomapConfigInfomapBase_setMarkovTime`, "inputTypes") = c('_p_infomap__InfomapConfigT_infomap__InfomapBase_t', 'numeric')
class(`InfomapConfigInfomapBase_setMarkovTime`) = c("SWIGFunction", class('InfomapConfigInfomapBase_setMarkovTime'))

# Start of InfomapConfigInfomapBase_reseed

`InfomapConfigInfomapBase_reseed` = function(self, seed, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  seed = as.integer(seed);
  
  if(length(seed) > 1) {
    warning("using only the first element of seed");
  };
  
  ;ans = .Call('R_swig_InfomapConfigInfomapBase_reseed', self, seed, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfomapConfigInfomapBase_reseed`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfomapConfigInfomapBase_reseed`, "inputTypes") = c('_p_infomap__InfomapConfigT_infomap__InfomapBase_t', 'integer')
class(`InfomapConfigInfomapBase_reseed`) = c("SWIGFunction", class('InfomapConfigInfomapBase_reseed'))

# Start of accessor method for infomap::InfomapConfig< infomap::InfomapBase >
setMethod('$', '_p_infomap__InfomapConfigT_infomap__InfomapBase_t', function(x, name)

{
  accessorFuns = list('getConfig' = InfomapConfigInfomapBase_getConfig, 'setConfig' = InfomapConfigInfomapBase_setConfig, 'setNonMainConfig' = InfomapConfigInfomapBase_setNonMainConfig, 'setNumTrials' = InfomapConfigInfomapBase_setNumTrials, 'setVerbosity' = InfomapConfigInfomapBase_setVerbosity, 'setTwoLevel' = InfomapConfigInfomapBase_setTwoLevel, 'setTuneIterationLimit' = InfomapConfigInfomapBase_setTuneIterationLimit, 'setFastHierarchicalSolution' = InfomapConfigInfomapBase_setFastHierarchicalSolution, 'setOnlySuperModules' = InfomapConfigInfomapBase_setOnlySuperModules, 'setNoCoarseTune' = InfomapConfigInfomapBase_setNoCoarseTune, 'setNoInfomap' = InfomapConfigInfomapBase_setNoInfomap, 'setMarkovTime' = InfomapConfigInfomapBase_setMarkovTime, 'reseed' = InfomapConfigInfomapBase_reseed);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for infomap::InfomapConfig< infomap::InfomapBase >
setMethod('delete', '_p_infomap__InfomapConfigT_infomap__InfomapBase_t', function(obj) {delete_infomap__InfomapConfigT_infomap__InfomapBase_t(obj)})
# Start of delete_InfomapBase

`delete_InfomapBase` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_InfomapBase', self, PACKAGE='infomap');
  
}

attr(`delete_InfomapBase`, 'returnType') = 'void'
attr(`delete_InfomapBase`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`delete_InfomapBase`) = c("SWIGFunction", class('delete_InfomapBase'))

# Start of InfomapBase_network

`InfomapBase_network__SWIG_0` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapBase_network__SWIG_0', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__Network", ref=ans);
  
  ans
  
}

attr(`InfomapBase_network__SWIG_0`, 'returnType') = '_p_infomap__Network'
attr(`InfomapBase_network__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_network__SWIG_0`) = c("SWIGFunction", class('InfomapBase_network__SWIG_0'))

# Start of InfomapBase_network

`InfomapBase_network__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapBase_network__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__Network", ref=ans);
  
  ans
  
}

attr(`InfomapBase_network__SWIG_1`, 'returnType') = '_p_infomap__Network'
attr(`InfomapBase_network__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_network__SWIG_1`) = c("SWIGFunction", class('InfomapBase_network__SWIG_1'))

`InfomapBase_network` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]]))) {
      f <- InfomapBase_network__SWIG_1; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]]))) {
      f <- InfomapBase_network__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InfomapBase_network with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapBase_root

`InfomapBase_root__SWIG_0` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapBase_root__SWIG_0', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapBase_root__SWIG_0`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapBase_root__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_root__SWIG_0`) = c("SWIGFunction", class('InfomapBase_root__SWIG_0'))

# Start of InfomapBase_root

`InfomapBase_root__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapBase_root__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfoNode", ref=ans);
  
  ans
  
}

attr(`InfomapBase_root__SWIG_1`, 'returnType') = '_p_infomap__InfoNode'
attr(`InfomapBase_root__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_root__SWIG_1`) = c("SWIGFunction", class('InfomapBase_root__SWIG_1'))

`InfomapBase_root` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]]))) {
      f <- InfomapBase_root__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]]))) {
      f <- InfomapBase_root__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapBase_root with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapBase_iterTree

`InfomapBase_iterTree__SWIG_0` = function(self, maxClusterLevel, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  maxClusterLevel = as.integer(maxClusterLevel);
  
  if(length(maxClusterLevel) > 1) {
    warning("using only the first element of maxClusterLevel");
  };
  
  ;ans = .Call('R_swig_InfomapBase_iterTree__SWIG_0', self, maxClusterLevel, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapIterator", ref=ans);
  
  ans
  
}

attr(`InfomapBase_iterTree__SWIG_0`, 'returnType') = '_p_infomap__InfomapIterator'
attr(`InfomapBase_iterTree__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapBase', 'integer')
class(`InfomapBase_iterTree__SWIG_0`) = c("SWIGFunction", class('InfomapBase_iterTree__SWIG_0'))

# Start of InfomapBase_iterTree

`InfomapBase_iterTree__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapBase_iterTree__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapIterator", ref=ans);
  
  ans
  
}

attr(`InfomapBase_iterTree__SWIG_1`, 'returnType') = '_p_infomap__InfomapIterator'
attr(`InfomapBase_iterTree__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_iterTree__SWIG_1`) = c("SWIGFunction", class('InfomapBase_iterTree__SWIG_1'))

`InfomapBase_iterTree` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]]))) {
      f <- InfomapBase_iterTree__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- InfomapBase_iterTree__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InfomapBase_iterTree with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapBase_iterTreePhysical

`InfomapBase_iterTreePhysical__SWIG_0` = function(self, maxClusterLevel, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  maxClusterLevel = as.integer(maxClusterLevel);
  
  if(length(maxClusterLevel) > 1) {
    warning("using only the first element of maxClusterLevel");
  };
  
  ;ans = .Call('R_swig_InfomapBase_iterTreePhysical__SWIG_0', self, maxClusterLevel, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapIteratorPhysical", ref=ans);
  
  ans
  
}

attr(`InfomapBase_iterTreePhysical__SWIG_0`, 'returnType') = '_p_infomap__InfomapIteratorPhysical'
attr(`InfomapBase_iterTreePhysical__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapBase', 'integer')
class(`InfomapBase_iterTreePhysical__SWIG_0`) = c("SWIGFunction", class('InfomapBase_iterTreePhysical__SWIG_0'))

# Start of InfomapBase_iterTreePhysical

`InfomapBase_iterTreePhysical__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapBase_iterTreePhysical__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapIteratorPhysical", ref=ans);
  
  ans
  
}

attr(`InfomapBase_iterTreePhysical__SWIG_1`, 'returnType') = '_p_infomap__InfomapIteratorPhysical'
attr(`InfomapBase_iterTreePhysical__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_iterTreePhysical__SWIG_1`) = c("SWIGFunction", class('InfomapBase_iterTreePhysical__SWIG_1'))

`InfomapBase_iterTreePhysical` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]]))) {
      f <- InfomapBase_iterTreePhysical__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- InfomapBase_iterTreePhysical__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InfomapBase_iterTreePhysical with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapBase_iterModules

`InfomapBase_iterModules__SWIG_0` = function(self, maxClusterLevel, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  maxClusterLevel = as.integer(maxClusterLevel);
  
  if(length(maxClusterLevel) > 1) {
    warning("using only the first element of maxClusterLevel");
  };
  
  ;ans = .Call('R_swig_InfomapBase_iterModules__SWIG_0', self, maxClusterLevel, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapModuleIterator", ref=ans);
  
  ans
  
}

attr(`InfomapBase_iterModules__SWIG_0`, 'returnType') = '_p_infomap__InfomapModuleIterator'
attr(`InfomapBase_iterModules__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapBase', 'integer')
class(`InfomapBase_iterModules__SWIG_0`) = c("SWIGFunction", class('InfomapBase_iterModules__SWIG_0'))

# Start of InfomapBase_iterModules

`InfomapBase_iterModules__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapBase_iterModules__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapModuleIterator", ref=ans);
  
  ans
  
}

attr(`InfomapBase_iterModules__SWIG_1`, 'returnType') = '_p_infomap__InfomapModuleIterator'
attr(`InfomapBase_iterModules__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_iterModules__SWIG_1`) = c("SWIGFunction", class('InfomapBase_iterModules__SWIG_1'))

`InfomapBase_iterModules` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]]))) {
      f <- InfomapBase_iterModules__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- InfomapBase_iterModules__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InfomapBase_iterModules with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapBase_iterLeafModules

`InfomapBase_iterLeafModules__SWIG_0` = function(self, maxClusterLevel, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  maxClusterLevel = as.integer(maxClusterLevel);
  
  if(length(maxClusterLevel) > 1) {
    warning("using only the first element of maxClusterLevel");
  };
  
  ;ans = .Call('R_swig_InfomapBase_iterLeafModules__SWIG_0', self, maxClusterLevel, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapLeafModuleIterator", ref=ans);
  
  ans
  
}

attr(`InfomapBase_iterLeafModules__SWIG_0`, 'returnType') = '_p_infomap__InfomapLeafModuleIterator'
attr(`InfomapBase_iterLeafModules__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapBase', 'integer')
class(`InfomapBase_iterLeafModules__SWIG_0`) = c("SWIGFunction", class('InfomapBase_iterLeafModules__SWIG_0'))

# Start of InfomapBase_iterLeafModules

`InfomapBase_iterLeafModules__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapBase_iterLeafModules__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapLeafModuleIterator", ref=ans);
  
  ans
  
}

attr(`InfomapBase_iterLeafModules__SWIG_1`, 'returnType') = '_p_infomap__InfomapLeafModuleIterator'
attr(`InfomapBase_iterLeafModules__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_iterLeafModules__SWIG_1`) = c("SWIGFunction", class('InfomapBase_iterLeafModules__SWIG_1'))

`InfomapBase_iterLeafModules` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]]))) {
      f <- InfomapBase_iterLeafModules__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- InfomapBase_iterLeafModules__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InfomapBase_iterLeafModules with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapBase_iterLeafNodes

`InfomapBase_iterLeafNodes__SWIG_0` = function(self, maxClusterLevel, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  maxClusterLevel = as.integer(maxClusterLevel);
  
  if(length(maxClusterLevel) > 1) {
    warning("using only the first element of maxClusterLevel");
  };
  
  ;ans = .Call('R_swig_InfomapBase_iterLeafNodes__SWIG_0', self, maxClusterLevel, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapLeafIterator", ref=ans);
  
  ans
  
}

attr(`InfomapBase_iterLeafNodes__SWIG_0`, 'returnType') = '_p_infomap__InfomapLeafIterator'
attr(`InfomapBase_iterLeafNodes__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapBase', 'integer')
class(`InfomapBase_iterLeafNodes__SWIG_0`) = c("SWIGFunction", class('InfomapBase_iterLeafNodes__SWIG_0'))

# Start of InfomapBase_iterLeafNodes

`InfomapBase_iterLeafNodes__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapBase_iterLeafNodes__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapLeafIterator", ref=ans);
  
  ans
  
}

attr(`InfomapBase_iterLeafNodes__SWIG_1`, 'returnType') = '_p_infomap__InfomapLeafIterator'
attr(`InfomapBase_iterLeafNodes__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_iterLeafNodes__SWIG_1`) = c("SWIGFunction", class('InfomapBase_iterLeafNodes__SWIG_1'))

`InfomapBase_iterLeafNodes` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]]))) {
      f <- InfomapBase_iterLeafNodes__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- InfomapBase_iterLeafNodes__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InfomapBase_iterLeafNodes with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapBase_iterLeafNodesPhysical

`InfomapBase_iterLeafNodesPhysical__SWIG_0` = function(self, maxClusterLevel, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  maxClusterLevel = as.integer(maxClusterLevel);
  
  if(length(maxClusterLevel) > 1) {
    warning("using only the first element of maxClusterLevel");
  };
  
  ;ans = .Call('R_swig_InfomapBase_iterLeafNodesPhysical__SWIG_0', self, maxClusterLevel, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapLeafIteratorPhysical", ref=ans);
  
  ans
  
}

attr(`InfomapBase_iterLeafNodesPhysical__SWIG_0`, 'returnType') = '_p_infomap__InfomapLeafIteratorPhysical'
attr(`InfomapBase_iterLeafNodesPhysical__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapBase', 'integer')
class(`InfomapBase_iterLeafNodesPhysical__SWIG_0`) = c("SWIGFunction", class('InfomapBase_iterLeafNodesPhysical__SWIG_0'))

# Start of InfomapBase_iterLeafNodesPhysical

`InfomapBase_iterLeafNodesPhysical__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapBase_iterLeafNodesPhysical__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapLeafIteratorPhysical", ref=ans);
  
  ans
  
}

attr(`InfomapBase_iterLeafNodesPhysical__SWIG_1`, 'returnType') = '_p_infomap__InfomapLeafIteratorPhysical'
attr(`InfomapBase_iterLeafNodesPhysical__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_iterLeafNodesPhysical__SWIG_1`) = c("SWIGFunction", class('InfomapBase_iterLeafNodesPhysical__SWIG_1'))

`InfomapBase_iterLeafNodesPhysical` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]]))) {
      f <- InfomapBase_iterLeafNodesPhysical__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- InfomapBase_iterLeafNodesPhysical__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InfomapBase_iterLeafNodesPhysical with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapBase_begin

`InfomapBase_begin__SWIG_0` = function(self, maxClusterLevel, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  maxClusterLevel = as.integer(maxClusterLevel);
  
  if(length(maxClusterLevel) > 1) {
    warning("using only the first element of maxClusterLevel");
  };
  
  ;ans = .Call('R_swig_InfomapBase_begin__SWIG_0', self, maxClusterLevel, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapIterator", ref=ans);
  
  ans
  
}

attr(`InfomapBase_begin__SWIG_0`, 'returnType') = '_p_infomap__InfomapIterator'
attr(`InfomapBase_begin__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapBase', 'integer')
class(`InfomapBase_begin__SWIG_0`) = c("SWIGFunction", class('InfomapBase_begin__SWIG_0'))

# Start of InfomapBase_begin

`InfomapBase_begin__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapBase_begin__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapIterator", ref=ans);
  
  ans
  
}

attr(`InfomapBase_begin__SWIG_1`, 'returnType') = '_p_infomap__InfomapIterator'
attr(`InfomapBase_begin__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_begin__SWIG_1`) = c("SWIGFunction", class('InfomapBase_begin__SWIG_1'))

`InfomapBase_begin` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]]))) {
      f <- InfomapBase_begin__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- InfomapBase_begin__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InfomapBase_begin with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapBase_end

`InfomapBase_end` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapBase_end', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapIterator", ref=ans);
  
  ans
  
}

attr(`InfomapBase_end`, 'returnType') = '_p_infomap__InfomapIterator'
attr(`InfomapBase_end`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_end`) = c("SWIGFunction", class('InfomapBase_end'))

# Start of InfomapBase_numLeafNodes

`InfomapBase_numLeafNodes` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_numLeafNodes', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_numLeafNodes`, 'returnType') = 'integer'
attr(`InfomapBase_numLeafNodes`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_numLeafNodes`) = c("SWIGFunction", class('InfomapBase_numLeafNodes'))

# Start of InfomapBase_leafNodes

`InfomapBase_leafNodes` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapBase_leafNodes', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_infomap__InfoNode_p_std__allocatorT_infomap__InfoNode_p_t_t", ref=ans);
  
  ans
  
}

attr(`InfomapBase_leafNodes`, 'returnType') = '_p_std__vectorT_infomap__InfoNode_p_std__allocatorT_infomap__InfoNode_p_t_t'
attr(`InfomapBase_leafNodes`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_leafNodes`) = c("SWIGFunction", class('InfomapBase_leafNodes'))

# Start of InfomapBase_numTopModules

`InfomapBase_numTopModules` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_numTopModules', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_numTopModules`, 'returnType') = 'integer'
attr(`InfomapBase_numTopModules`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_numTopModules`) = c("SWIGFunction", class('InfomapBase_numTopModules'))

# Start of InfomapBase_numActiveModules

`InfomapBase_numActiveModules` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_numActiveModules', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_numActiveModules`, 'returnType') = 'integer'
attr(`InfomapBase_numActiveModules`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_numActiveModules`) = c("SWIGFunction", class('InfomapBase_numActiveModules'))

# Start of InfomapBase_numNonTrivialTopModules

`InfomapBase_numNonTrivialTopModules` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_numNonTrivialTopModules', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_numNonTrivialTopModules`, 'returnType') = 'integer'
attr(`InfomapBase_numNonTrivialTopModules`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_numNonTrivialTopModules`) = c("SWIGFunction", class('InfomapBase_numNonTrivialTopModules'))

# Start of InfomapBase_haveModules

`InfomapBase_haveModules` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_haveModules', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_haveModules`, 'returnType') = 'logical'
attr(`InfomapBase_haveModules`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_haveModules`) = c("SWIGFunction", class('InfomapBase_haveModules'))

# Start of InfomapBase_haveNonTrivialModules

`InfomapBase_haveNonTrivialModules` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_haveNonTrivialModules', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_haveNonTrivialModules`, 'returnType') = 'logical'
attr(`InfomapBase_haveNonTrivialModules`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_haveNonTrivialModules`) = c("SWIGFunction", class('InfomapBase_haveNonTrivialModules'))

# Start of InfomapBase_numLevels

`InfomapBase_numLevels` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_numLevels', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_numLevels`, 'returnType') = 'integer'
attr(`InfomapBase_numLevels`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_numLevels`) = c("SWIGFunction", class('InfomapBase_numLevels'))

# Start of InfomapBase_maxTreeDepth

`InfomapBase_maxTreeDepth` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_maxTreeDepth', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_maxTreeDepth`, 'returnType') = 'integer'
attr(`InfomapBase_maxTreeDepth`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_maxTreeDepth`) = c("SWIGFunction", class('InfomapBase_maxTreeDepth'))

# Start of InfomapBase_getCodelength

`InfomapBase_getCodelength` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_getCodelength', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_getCodelength`, 'returnType') = 'numeric'
attr(`InfomapBase_getCodelength`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_getCodelength`) = c("SWIGFunction", class('InfomapBase_getCodelength'))

# Start of InfomapBase_getMetaCodelength

`InfomapBase_getMetaCodelength__SWIG_0` = function(self, unweighted, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  unweighted = as.logical(unweighted);
  ;.Call('R_swig_InfomapBase_getMetaCodelength__SWIG_0', self, unweighted, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_getMetaCodelength__SWIG_0`, 'returnType') = 'numeric'
attr(`InfomapBase_getMetaCodelength__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapBase', 'logical')
class(`InfomapBase_getMetaCodelength__SWIG_0`) = c("SWIGFunction", class('InfomapBase_getMetaCodelength__SWIG_0'))

# Start of InfomapBase_getMetaCodelength

`InfomapBase_getMetaCodelength__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_getMetaCodelength__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_getMetaCodelength__SWIG_1`, 'returnType') = 'numeric'
attr(`InfomapBase_getMetaCodelength__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_getMetaCodelength__SWIG_1`) = c("SWIGFunction", class('InfomapBase_getMetaCodelength__SWIG_1'))

`InfomapBase_getMetaCodelength` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]]))) {
      f <- InfomapBase_getMetaCodelength__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && ( is.logical(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- InfomapBase_getMetaCodelength__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InfomapBase_getMetaCodelength with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapBase_codelength

`InfomapBase_codelength` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_codelength', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_codelength`, 'returnType') = 'numeric'
attr(`InfomapBase_codelength`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_codelength`) = c("SWIGFunction", class('InfomapBase_codelength'))

# Start of InfomapBase_codelengths

`InfomapBase_codelengths` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_codelengths', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_codelengths`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`InfomapBase_codelengths`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_codelengths`) = c("SWIGFunction", class('InfomapBase_codelengths'))

# Start of InfomapBase_getIndexCodelength

`InfomapBase_getIndexCodelength` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_getIndexCodelength', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_getIndexCodelength`, 'returnType') = 'numeric'
attr(`InfomapBase_getIndexCodelength`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_getIndexCodelength`) = c("SWIGFunction", class('InfomapBase_getIndexCodelength'))

# Start of InfomapBase_getModuleCodelength

`InfomapBase_getModuleCodelength` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_getModuleCodelength', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_getModuleCodelength`, 'returnType') = 'numeric'
attr(`InfomapBase_getModuleCodelength`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_getModuleCodelength`) = c("SWIGFunction", class('InfomapBase_getModuleCodelength'))

# Start of InfomapBase_getHierarchicalCodelength

`InfomapBase_getHierarchicalCodelength` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_getHierarchicalCodelength', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_getHierarchicalCodelength`, 'returnType') = 'numeric'
attr(`InfomapBase_getHierarchicalCodelength`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_getHierarchicalCodelength`) = c("SWIGFunction", class('InfomapBase_getHierarchicalCodelength'))

# Start of InfomapBase_getOneLevelCodelength

`InfomapBase_getOneLevelCodelength` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_getOneLevelCodelength', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_getOneLevelCodelength`, 'returnType') = 'numeric'
attr(`InfomapBase_getOneLevelCodelength`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_getOneLevelCodelength`) = c("SWIGFunction", class('InfomapBase_getOneLevelCodelength'))

# Start of InfomapBase_getRelativeCodelengthSavings

`InfomapBase_getRelativeCodelengthSavings` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_getRelativeCodelengthSavings', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_getRelativeCodelengthSavings`, 'returnType') = 'numeric'
attr(`InfomapBase_getRelativeCodelengthSavings`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_getRelativeCodelengthSavings`) = c("SWIGFunction", class('InfomapBase_getRelativeCodelengthSavings'))

# Start of InfomapBase_isFullNetwork

`InfomapBase_isFullNetwork` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_isFullNetwork', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_isFullNetwork`, 'returnType') = 'logical'
attr(`InfomapBase_isFullNetwork`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_isFullNetwork`) = c("SWIGFunction", class('InfomapBase_isFullNetwork'))

# Start of InfomapBase_isFirstLoop

`InfomapBase_isFirstLoop` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_isFirstLoop', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_isFirstLoop`, 'returnType') = 'logical'
attr(`InfomapBase_isFirstLoop`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_isFirstLoop`) = c("SWIGFunction", class('InfomapBase_isFirstLoop'))

# Start of InfomapBase_getNewInfomapInstance

`InfomapBase_getNewInfomapInstance` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapBase_getNewInfomapInstance', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfomapBase_getNewInfomapInstance`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfomapBase_getNewInfomapInstance`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_getNewInfomapInstance`) = c("SWIGFunction", class('InfomapBase_getNewInfomapInstance'))

# Start of InfomapBase_getNewInfomapInstanceWithoutMemory

`InfomapBase_getNewInfomapInstanceWithoutMemory` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapBase_getNewInfomapInstanceWithoutMemory', self, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfomapBase_getNewInfomapInstanceWithoutMemory`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfomapBase_getNewInfomapInstanceWithoutMemory`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_getNewInfomapInstanceWithoutMemory`) = c("SWIGFunction", class('InfomapBase_getNewInfomapInstanceWithoutMemory'))

# Start of InfomapBase_getSubInfomap

`InfomapBase_getSubInfomap` = function(self, node, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(node, "ExternalReference")) node = slot(node,"ref"); 
  ;ans = .Call('R_swig_InfomapBase_getSubInfomap', self, node, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfomapBase_getSubInfomap`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfomapBase_getSubInfomap`, "inputTypes") = c('_p_infomap__InfomapBase', '_p_infomap__InfoNode')
class(`InfomapBase_getSubInfomap`) = c("SWIGFunction", class('InfomapBase_getSubInfomap'))

# Start of InfomapBase_getSuperInfomap

`InfomapBase_getSuperInfomap` = function(self, node, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(node, "ExternalReference")) node = slot(node,"ref"); 
  ;ans = .Call('R_swig_InfomapBase_getSuperInfomap', self, node, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfomapBase_getSuperInfomap`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfomapBase_getSuperInfomap`, "inputTypes") = c('_p_infomap__InfomapBase', '_p_infomap__InfoNode')
class(`InfomapBase_getSuperInfomap`) = c("SWIGFunction", class('InfomapBase_getSuperInfomap'))

# Start of InfomapBase_setIsMain

`InfomapBase_setIsMain` = function(self, isMain, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  isMain = as.logical(isMain);
  ;ans = .Call('R_swig_InfomapBase_setIsMain', self, isMain, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfomapBase_setIsMain`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfomapBase_setIsMain`, "inputTypes") = c('_p_infomap__InfomapBase', 'logical')
class(`InfomapBase_setIsMain`) = c("SWIGFunction", class('InfomapBase_setIsMain'))

# Start of InfomapBase_setSubLevel

`InfomapBase_setSubLevel` = function(self, level, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  level = as.integer(level);
  
  if(length(level) > 1) {
    warning("using only the first element of level");
  };
  
  ;ans = .Call('R_swig_InfomapBase_setSubLevel', self, level, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfomapBase_setSubLevel`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfomapBase_setSubLevel`, "inputTypes") = c('_p_infomap__InfomapBase', 'integer')
class(`InfomapBase_setSubLevel`) = c("SWIGFunction", class('InfomapBase_setSubLevel'))

# Start of InfomapBase_isTopLevel

`InfomapBase_isTopLevel` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_isTopLevel', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_isTopLevel`, 'returnType') = 'logical'
attr(`InfomapBase_isTopLevel`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_isTopLevel`) = c("SWIGFunction", class('InfomapBase_isTopLevel'))

# Start of InfomapBase_isSuperLevelOnTopLevel

`InfomapBase_isSuperLevelOnTopLevel` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_isSuperLevelOnTopLevel', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_isSuperLevelOnTopLevel`, 'returnType') = 'logical'
attr(`InfomapBase_isSuperLevelOnTopLevel`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_isSuperLevelOnTopLevel`) = c("SWIGFunction", class('InfomapBase_isSuperLevelOnTopLevel'))

# Start of InfomapBase_isMainInfomap

`InfomapBase_isMainInfomap` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_isMainInfomap', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_isMainInfomap`, 'returnType') = 'logical'
attr(`InfomapBase_isMainInfomap`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_isMainInfomap`) = c("SWIGFunction", class('InfomapBase_isMainInfomap'))

# Start of InfomapBase_haveHardPartition

`InfomapBase_haveHardPartition` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_haveHardPartition', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_haveHardPartition`, 'returnType') = 'logical'
attr(`InfomapBase_haveHardPartition`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_haveHardPartition`) = c("SWIGFunction", class('InfomapBase_haveHardPartition'))

# Start of InfomapBase_activeNetwork

`InfomapBase_activeNetwork` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapBase_activeNetwork', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_infomap__InfoNode_p_std__allocatorT_infomap__InfoNode_p_t_t", ref=ans);
  
  ans
  
}

attr(`InfomapBase_activeNetwork`, 'returnType') = '_p_std__vectorT_infomap__InfoNode_p_std__allocatorT_infomap__InfoNode_p_t_t'
attr(`InfomapBase_activeNetwork`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_activeNetwork`) = c("SWIGFunction", class('InfomapBase_activeNetwork'))

# Start of InfomapBase_toString

`InfomapBase_toString` = function(self, out, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(out, "ExternalReference")) out = slot(out,"ref"); 
  ;ans = .Call('R_swig_InfomapBase_toString', self, out, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__ostream", ref=ans);
  
  ans
  
}

attr(`InfomapBase_toString`, 'returnType') = '_p_std__ostream'
attr(`InfomapBase_toString`, "inputTypes") = c('_p_infomap__InfomapBase', '_p_std__ostream')
class(`InfomapBase_toString`) = c("SWIGFunction", class('InfomapBase_toString'))

# Start of InfomapBase_getInitialPartition

`InfomapBase_getInitialPartition` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapBase_getInitialPartition', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t", ref=ans);
  
  ans
  
}

attr(`InfomapBase_getInitialPartition`, 'returnType') = '_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t'
attr(`InfomapBase_getInitialPartition`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_getInitialPartition`) = c("SWIGFunction", class('InfomapBase_getInitialPartition'))

# Start of InfomapBase_calcEntropyRate

`InfomapBase_calcEntropyRate` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_calcEntropyRate', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_calcEntropyRate`, 'returnType') = 'numeric'
attr(`InfomapBase_calcEntropyRate`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_calcEntropyRate`) = c("SWIGFunction", class('InfomapBase_calcEntropyRate'))

# Start of InfomapBase_setInitialPartition

`InfomapBase_setInitialPartition` = function(self, moduleIds, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(moduleIds, "ExternalReference")) moduleIds = slot(moduleIds,"ref"); 
  ;ans = .Call('R_swig_InfomapBase_setInitialPartition', self, moduleIds, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfomapBase_setInitialPartition`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfomapBase_setInitialPartition`, "inputTypes") = c('_p_infomap__InfomapBase', '_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t')
class(`InfomapBase_setInitialPartition`) = c("SWIGFunction", class('InfomapBase_setInitialPartition'))

# Start of InfomapBase_run

`InfomapBase_run__SWIG_0` = function(self, parameters)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  parameters = as(parameters, "character"); 
  ;.Call('R_swig_InfomapBase_run__SWIG_0', self, parameters, PACKAGE='infomap');
  
}

attr(`InfomapBase_run__SWIG_0`, 'returnType') = 'void'
attr(`InfomapBase_run__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapBase', 'character')
class(`InfomapBase_run__SWIG_0`) = c("SWIGFunction", class('InfomapBase_run__SWIG_0'))

# Start of InfomapBase_run

`InfomapBase_run__SWIG_1` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_run__SWIG_1', self, PACKAGE='infomap');
  
}

attr(`InfomapBase_run__SWIG_1`, 'returnType') = 'void'
attr(`InfomapBase_run__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_run__SWIG_1`) = c("SWIGFunction", class('InfomapBase_run__SWIG_1'))

# Start of InfomapBase_run

`InfomapBase_run__SWIG_2` = function(self, network)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(network, "ExternalReference")) network = slot(network,"ref"); 
  ;.Call('R_swig_InfomapBase_run__SWIG_2', self, network, PACKAGE='infomap');
  
}

attr(`InfomapBase_run__SWIG_2`, 'returnType') = 'void'
attr(`InfomapBase_run__SWIG_2`, "inputTypes") = c('_p_infomap__InfomapBase', '_p_infomap__Network')
class(`InfomapBase_run__SWIG_2`) = c("SWIGFunction", class('InfomapBase_run__SWIG_2'))

`InfomapBase_run` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]]))) {
      f <- InfomapBase_run__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && extends(argtypes[2], '_p_infomap__Network') && length(argv[[2]]) == 1) {
      f <- InfomapBase_run__SWIG_2; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && is.character(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- InfomapBase_run__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InfomapBase_run with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapBase_initNetwork

`InfomapBase_initNetwork__SWIG_0` = function(self, network, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(network, "ExternalReference")) network = slot(network,"ref"); 
  ;ans = .Call('R_swig_InfomapBase_initNetwork__SWIG_0', self, network, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfomapBase_initNetwork__SWIG_0`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfomapBase_initNetwork__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapBase', '_p_infomap__Network')
class(`InfomapBase_initNetwork__SWIG_0`) = c("SWIGFunction", class('InfomapBase_initNetwork__SWIG_0'))

# Start of InfomapBase_initNetwork

`InfomapBase_initNetwork__SWIG_1` = function(self, parent, asSuperNetwork, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(parent, "ExternalReference")) parent = slot(parent,"ref"); 
  asSuperNetwork = as.logical(asSuperNetwork);
  ;ans = .Call('R_swig_InfomapBase_initNetwork__SWIG_1', self, parent, asSuperNetwork, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfomapBase_initNetwork__SWIG_1`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfomapBase_initNetwork__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapBase', '_p_infomap__InfoNode', 'logical')
class(`InfomapBase_initNetwork__SWIG_1`) = c("SWIGFunction", class('InfomapBase_initNetwork__SWIG_1'))

# Start of InfomapBase_initNetwork

`InfomapBase_initNetwork__SWIG_2` = function(self, parent, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(parent, "ExternalReference")) parent = slot(parent,"ref"); 
  ;ans = .Call('R_swig_InfomapBase_initNetwork__SWIG_2', self, parent, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfomapBase_initNetwork__SWIG_2`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfomapBase_initNetwork__SWIG_2`, "inputTypes") = c('_p_infomap__InfomapBase', '_p_infomap__InfoNode')
class(`InfomapBase_initNetwork__SWIG_2`) = c("SWIGFunction", class('InfomapBase_initNetwork__SWIG_2'))

# Start of InfomapBase_generateSubNetwork

`InfomapBase_generateSubNetwork__SWIG_0` = function(self, network)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(network, "ExternalReference")) network = slot(network,"ref"); 
  ;.Call('R_swig_InfomapBase_generateSubNetwork__SWIG_0', self, network, PACKAGE='infomap');
  
}

attr(`InfomapBase_generateSubNetwork__SWIG_0`, 'returnType') = 'void'
attr(`InfomapBase_generateSubNetwork__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapBase', '_p_infomap__Network')
class(`InfomapBase_generateSubNetwork__SWIG_0`) = c("SWIGFunction", class('InfomapBase_generateSubNetwork__SWIG_0'))

# Start of InfomapBase_generateSubNetwork

`InfomapBase_generateSubNetwork__SWIG_1` = function(self, parent)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(parent, "ExternalReference")) parent = slot(parent,"ref"); 
  ;.Call('R_swig_InfomapBase_generateSubNetwork__SWIG_1', self, parent, PACKAGE='infomap');
  
}

attr(`InfomapBase_generateSubNetwork__SWIG_1`, 'returnType') = 'void'
attr(`InfomapBase_generateSubNetwork__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapBase', '_p_infomap__InfoNode')
class(`InfomapBase_generateSubNetwork__SWIG_1`) = c("SWIGFunction", class('InfomapBase_generateSubNetwork__SWIG_1'))

`InfomapBase_generateSubNetwork` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && extends(argtypes[2], '_p_infomap__Network') && length(argv[[2]]) == 1) {
      f <- InfomapBase_generateSubNetwork__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && extends(argtypes[2], '_p_infomap__InfoNode') && length(argv[[2]]) == 1) {
      f <- InfomapBase_generateSubNetwork__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapBase_generateSubNetwork with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapBase_initMetaData

`InfomapBase_initMetaData` = function(self, metaDataFile, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  metaDataFile = as(metaDataFile, "character"); 
  ;ans = .Call('R_swig_InfomapBase_initMetaData', self, metaDataFile, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfomapBase_initMetaData`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfomapBase_initMetaData`, "inputTypes") = c('_p_infomap__InfomapBase', 'character')
class(`InfomapBase_initMetaData`) = c("SWIGFunction", class('InfomapBase_initMetaData'))

# Start of InfomapBase_initPartition

`InfomapBase_initPartition__SWIG_0` = function(self, clusterDataFile, hard, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  clusterDataFile = as(clusterDataFile, "character"); 
  hard = as.logical(hard);
  ;ans = .Call('R_swig_InfomapBase_initPartition__SWIG_0', self, clusterDataFile, hard, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfomapBase_initPartition__SWIG_0`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfomapBase_initPartition__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapBase', 'character', 'logical')
class(`InfomapBase_initPartition__SWIG_0`) = c("SWIGFunction", class('InfomapBase_initPartition__SWIG_0'))

# Start of InfomapBase_initPartition

`InfomapBase_initPartition__SWIG_1` = function(self, clusterDataFile, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  clusterDataFile = as(clusterDataFile, "character"); 
  ;ans = .Call('R_swig_InfomapBase_initPartition__SWIG_1', self, clusterDataFile, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfomapBase_initPartition__SWIG_1`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfomapBase_initPartition__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapBase', 'character')
class(`InfomapBase_initPartition__SWIG_1`) = c("SWIGFunction", class('InfomapBase_initPartition__SWIG_1'))

# Start of InfomapBase_initPartition

`InfomapBase_initPartition__SWIG_2` = function(self, clusterIds, hard, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(clusterIds, "ExternalReference")) clusterIds = slot(clusterIds,"ref"); 
  hard = as.logical(hard);
  ;ans = .Call('R_swig_InfomapBase_initPartition__SWIG_2', self, clusterIds, hard, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfomapBase_initPartition__SWIG_2`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfomapBase_initPartition__SWIG_2`, "inputTypes") = c('_p_infomap__InfomapBase', '_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t', 'logical')
class(`InfomapBase_initPartition__SWIG_2`) = c("SWIGFunction", class('InfomapBase_initPartition__SWIG_2'))

# Start of InfomapBase_initPartition

`InfomapBase_initPartition__SWIG_3` = function(self, clusterIds, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(clusterIds, "ExternalReference")) clusterIds = slot(clusterIds,"ref"); 
  ;ans = .Call('R_swig_InfomapBase_initPartition__SWIG_3', self, clusterIds, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfomapBase_initPartition__SWIG_3`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfomapBase_initPartition__SWIG_3`, "inputTypes") = c('_p_infomap__InfomapBase', '_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t')
class(`InfomapBase_initPartition__SWIG_3`) = c("SWIGFunction", class('InfomapBase_initPartition__SWIG_3'))

# Start of InfomapBase_initPartition

`InfomapBase_initPartition__SWIG_4` = function(self, clusters, hard, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  clusters = lapply(clusters, as.integer);
  hard = as.logical(hard);
  ;ans = .Call('R_swig_InfomapBase_initPartition__SWIG_4', self, clusters, hard, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfomapBase_initPartition__SWIG_4`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfomapBase_initPartition__SWIG_4`, "inputTypes") = c('_p_infomap__InfomapBase', 'list', 'logical')
class(`InfomapBase_initPartition__SWIG_4`) = c("SWIGFunction", class('InfomapBase_initPartition__SWIG_4'))

# Start of InfomapBase_initPartition

`InfomapBase_initPartition__SWIG_5` = function(self, clusters, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  clusters = lapply(clusters, as.integer);
  ;ans = .Call('R_swig_InfomapBase_initPartition__SWIG_5', self, clusters, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfomapBase_initPartition__SWIG_5`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfomapBase_initPartition__SWIG_5`, "inputTypes") = c('_p_infomap__InfomapBase', 'list')
class(`InfomapBase_initPartition__SWIG_5`) = c("SWIGFunction", class('InfomapBase_initPartition__SWIG_5'))

# Start of InfomapBase_initPartition

`InfomapBase_initPartition__SWIG_6` = function(self, modules, hard, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  modules = as.integer(modules);
  hard = as.logical(hard);
  ;ans = .Call('R_swig_InfomapBase_initPartition__SWIG_6', self, modules, hard, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfomapBase_initPartition__SWIG_6`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfomapBase_initPartition__SWIG_6`, "inputTypes") = c('_p_infomap__InfomapBase', 'integer', 'logical')
class(`InfomapBase_initPartition__SWIG_6`) = c("SWIGFunction", class('InfomapBase_initPartition__SWIG_6'))

# Start of InfomapBase_initPartition

`InfomapBase_initPartition__SWIG_7` = function(self, modules, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  modules = as.integer(modules);
  ;ans = .Call('R_swig_InfomapBase_initPartition__SWIG_7', self, modules, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfomapBase_initPartition__SWIG_7`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfomapBase_initPartition__SWIG_7`, "inputTypes") = c('_p_infomap__InfomapBase', 'integer')
class(`InfomapBase_initPartition__SWIG_7`) = c("SWIGFunction", class('InfomapBase_initPartition__SWIG_7'))

# Start of InfomapBase_initTree

`InfomapBase_initTree` = function(self, tree, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(tree, "ExternalReference")) tree = slot(tree,"ref"); 
  ;ans = .Call('R_swig_InfomapBase_initTree', self, tree, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapBase", ref=ans);
  
  ans
  
}

attr(`InfomapBase_initTree`, 'returnType') = '_p_infomap__InfomapBase'
attr(`InfomapBase_initTree`, "inputTypes") = c('_p_infomap__InfomapBase', '_p_NodePaths')
class(`InfomapBase_initTree`) = c("SWIGFunction", class('InfomapBase_initTree'))

# Start of InfomapBase_init

`InfomapBase_init` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_init', self, PACKAGE='infomap');
  
}

attr(`InfomapBase_init`, 'returnType') = 'void'
attr(`InfomapBase_init`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_init`) = c("SWIGFunction", class('InfomapBase_init'))

# Start of InfomapBase_runPartition

`InfomapBase_runPartition` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_runPartition', self, PACKAGE='infomap');
  
}

attr(`InfomapBase_runPartition`, 'returnType') = 'void'
attr(`InfomapBase_runPartition`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_runPartition`) = c("SWIGFunction", class('InfomapBase_runPartition'))

# Start of InfomapBase_restoreHardPartition

`InfomapBase_restoreHardPartition` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_restoreHardPartition', self, PACKAGE='infomap');
  
}

attr(`InfomapBase_restoreHardPartition`, 'returnType') = 'void'
attr(`InfomapBase_restoreHardPartition`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_restoreHardPartition`) = c("SWIGFunction", class('InfomapBase_restoreHardPartition'))

# Start of InfomapBase_sortTreeOnFlow

`InfomapBase_sortTreeOnFlow` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_sortTreeOnFlow', self, PACKAGE='infomap');
  
}

attr(`InfomapBase_sortTreeOnFlow`, 'returnType') = 'void'
attr(`InfomapBase_sortTreeOnFlow`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_sortTreeOnFlow`) = c("SWIGFunction", class('InfomapBase_sortTreeOnFlow'))

# Start of InfomapBase_writeResult

`InfomapBase_writeResult` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_writeResult', self, PACKAGE='infomap');
  
}

attr(`InfomapBase_writeResult`, 'returnType') = 'void'
attr(`InfomapBase_writeResult`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_writeResult`) = c("SWIGFunction", class('InfomapBase_writeResult'))

# Start of InfomapBase_hierarchicalPartition

`InfomapBase_hierarchicalPartition` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_hierarchicalPartition', self, PACKAGE='infomap');
  
}

attr(`InfomapBase_hierarchicalPartition`, 'returnType') = 'void'
attr(`InfomapBase_hierarchicalPartition`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_hierarchicalPartition`) = c("SWIGFunction", class('InfomapBase_hierarchicalPartition'))

# Start of InfomapBase_partition

`InfomapBase_partition` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_partition', self, PACKAGE='infomap');
  
}

attr(`InfomapBase_partition`, 'returnType') = 'void'
attr(`InfomapBase_partition`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_partition`) = c("SWIGFunction", class('InfomapBase_partition'))

# Start of InfomapBase_initEnterExitFlow

`InfomapBase_initEnterExitFlow` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_initEnterExitFlow', self, PACKAGE='infomap');
  
}

attr(`InfomapBase_initEnterExitFlow`, 'returnType') = 'void'
attr(`InfomapBase_initEnterExitFlow`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_initEnterExitFlow`) = c("SWIGFunction", class('InfomapBase_initEnterExitFlow'))

# Start of InfomapBase_aggregateFlowValuesFromLeafToRoot

`InfomapBase_aggregateFlowValuesFromLeafToRoot` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_aggregateFlowValuesFromLeafToRoot', self, PACKAGE='infomap');
  
}

attr(`InfomapBase_aggregateFlowValuesFromLeafToRoot`, 'returnType') = 'void'
attr(`InfomapBase_aggregateFlowValuesFromLeafToRoot`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_aggregateFlowValuesFromLeafToRoot`) = c("SWIGFunction", class('InfomapBase_aggregateFlowValuesFromLeafToRoot'))

# Start of InfomapBase_initNetwork

`InfomapBase_initNetwork__SWIG_3` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_initNetwork__SWIG_3', self, PACKAGE='infomap');
  
}

attr(`InfomapBase_initNetwork__SWIG_3`, 'returnType') = 'void'
attr(`InfomapBase_initNetwork__SWIG_3`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_initNetwork__SWIG_3`) = c("SWIGFunction", class('InfomapBase_initNetwork__SWIG_3'))

`InfomapBase_initNetwork` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]]))) {
      f <- InfomapBase_initNetwork__SWIG_3; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && extends(argtypes[2], '_p_infomap__InfoNode') && length(argv[[2]]) == 1) {
      f <- InfomapBase_initNetwork__SWIG_2; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && extends(argtypes[2], '_p_infomap__Network') && length(argv[[2]]) == 1) {
      f <- InfomapBase_initNetwork__SWIG_0; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && extends(argtypes[2], '_p_infomap__InfoNode') && length(argv[[2]]) == 1 && ( is.logical(argv[[3]]) && length(argv[[3]]) == 1 )) {
      f <- InfomapBase_initNetwork__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapBase_initNetwork with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapBase_initSuperNetwork

`InfomapBase_initSuperNetwork` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_initSuperNetwork', self, PACKAGE='infomap');
  
}

attr(`InfomapBase_initSuperNetwork`, 'returnType') = 'void'
attr(`InfomapBase_initSuperNetwork`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_initSuperNetwork`) = c("SWIGFunction", class('InfomapBase_initSuperNetwork'))

# Start of InfomapBase_calcCodelength

`InfomapBase_calcCodelength` = function(self, parent, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(parent, "ExternalReference")) parent = slot(parent,"ref"); 
  ;.Call('R_swig_InfomapBase_calcCodelength', self, parent, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_calcCodelength`, 'returnType') = 'numeric'
attr(`InfomapBase_calcCodelength`, "inputTypes") = c('_p_infomap__InfomapBase', '_p_infomap__InfoNode')
class(`InfomapBase_calcCodelength`) = c("SWIGFunction", class('InfomapBase_calcCodelength'))

# Start of InfomapBase_calcCodelengthOnTree

`InfomapBase_calcCodelengthOnTree__SWIG_0` = function(self, includeRoot, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  includeRoot = as.logical(includeRoot);
  ;.Call('R_swig_InfomapBase_calcCodelengthOnTree__SWIG_0', self, includeRoot, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_calcCodelengthOnTree__SWIG_0`, 'returnType') = 'numeric'
attr(`InfomapBase_calcCodelengthOnTree__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapBase', 'logical')
class(`InfomapBase_calcCodelengthOnTree__SWIG_0`) = c("SWIGFunction", class('InfomapBase_calcCodelengthOnTree__SWIG_0'))

# Start of InfomapBase_calcCodelengthOnTree

`InfomapBase_calcCodelengthOnTree__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_calcCodelengthOnTree__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_calcCodelengthOnTree__SWIG_1`, 'returnType') = 'numeric'
attr(`InfomapBase_calcCodelengthOnTree__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_calcCodelengthOnTree__SWIG_1`) = c("SWIGFunction", class('InfomapBase_calcCodelengthOnTree__SWIG_1'))

`InfomapBase_calcCodelengthOnTree` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]]))) {
      f <- InfomapBase_calcCodelengthOnTree__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && ( is.logical(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- InfomapBase_calcCodelengthOnTree__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InfomapBase_calcCodelengthOnTree with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapBase_setActiveNetworkFromLeafs

`InfomapBase_setActiveNetworkFromLeafs` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_setActiveNetworkFromLeafs', self, PACKAGE='infomap');
  
}

attr(`InfomapBase_setActiveNetworkFromLeafs`, 'returnType') = 'void'
attr(`InfomapBase_setActiveNetworkFromLeafs`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_setActiveNetworkFromLeafs`) = c("SWIGFunction", class('InfomapBase_setActiveNetworkFromLeafs'))

# Start of InfomapBase_setActiveNetworkFromChildrenOfRoot

`InfomapBase_setActiveNetworkFromChildrenOfRoot` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_setActiveNetworkFromChildrenOfRoot', self, PACKAGE='infomap');
  
}

attr(`InfomapBase_setActiveNetworkFromChildrenOfRoot`, 'returnType') = 'void'
attr(`InfomapBase_setActiveNetworkFromChildrenOfRoot`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_setActiveNetworkFromChildrenOfRoot`) = c("SWIGFunction", class('InfomapBase_setActiveNetworkFromChildrenOfRoot'))

# Start of InfomapBase_initPartition

`InfomapBase_initPartition__SWIG_8` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_initPartition__SWIG_8', self, PACKAGE='infomap');
  
}

attr(`InfomapBase_initPartition__SWIG_8`, 'returnType') = 'void'
attr(`InfomapBase_initPartition__SWIG_8`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_initPartition__SWIG_8`) = c("SWIGFunction", class('InfomapBase_initPartition__SWIG_8'))

`InfomapBase_initPartition` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 9
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]]))) {
      f <- InfomapBase_initPartition__SWIG_8; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && ( is.list(argv[[2]]) && all(sapply(argv[[2]] , is.integer) || sapply(argv[[2]], is.numeric)) )) {
      f <- InfomapBase_initPartition__SWIG_5; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && ( is.integer(argv[[2]]) || is.numeric(argv[[2]]) )) {
      f <- InfomapBase_initPartition__SWIG_7; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && is.character(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- InfomapBase_initPartition__SWIG_1; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && extends(argtypes[2], '_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t') && length(argv[[2]]) == 1) {
      f <- InfomapBase_initPartition__SWIG_3; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && ( is.integer(argv[[2]]) || is.numeric(argv[[2]]) ) && ( is.logical(argv[[3]]) && length(argv[[3]]) == 1 )) {
      f <- InfomapBase_initPartition__SWIG_6; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && ( is.list(argv[[2]]) && all(sapply(argv[[2]] , is.integer) || sapply(argv[[2]], is.numeric)) ) && ( is.logical(argv[[3]]) && length(argv[[3]]) == 1 )) {
      f <- InfomapBase_initPartition__SWIG_4; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && is.character(argv[[2]]) && length(argv[[2]]) == 1 && ( is.logical(argv[[3]]) && length(argv[[3]]) == 1 )) {
      f <- InfomapBase_initPartition__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && extends(argtypes[2], '_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t') && length(argv[[2]]) == 1 && ( is.logical(argv[[3]]) && length(argv[[3]]) == 1 )) {
      f <- InfomapBase_initPartition__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for InfomapBase_initPartition with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapBase_findTopModulesRepeatedly

`InfomapBase_findTopModulesRepeatedly` = function(self, maxLevels)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  maxLevels = as.integer(maxLevels);
  
  if(length(maxLevels) > 1) {
    warning("using only the first element of maxLevels");
  };
  
  ;.Call('R_swig_InfomapBase_findTopModulesRepeatedly', self, maxLevels, PACKAGE='infomap');
  
}

attr(`InfomapBase_findTopModulesRepeatedly`, 'returnType') = 'void'
attr(`InfomapBase_findTopModulesRepeatedly`, "inputTypes") = c('_p_infomap__InfomapBase', 'integer')
class(`InfomapBase_findTopModulesRepeatedly`) = c("SWIGFunction", class('InfomapBase_findTopModulesRepeatedly'))

# Start of InfomapBase_fineTune

`InfomapBase_fineTune` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_fineTune', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_fineTune`, 'returnType') = 'integer'
attr(`InfomapBase_fineTune`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_fineTune`) = c("SWIGFunction", class('InfomapBase_fineTune'))

# Start of InfomapBase_coarseTune

`InfomapBase_coarseTune` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_coarseTune', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_coarseTune`, 'returnType') = 'integer'
attr(`InfomapBase_coarseTune`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_coarseTune`) = c("SWIGFunction", class('InfomapBase_coarseTune'))

# Start of InfomapBase_optimizeActiveNetwork

`InfomapBase_optimizeActiveNetwork` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_optimizeActiveNetwork', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_optimizeActiveNetwork`, 'returnType') = 'integer'
attr(`InfomapBase_optimizeActiveNetwork`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_optimizeActiveNetwork`) = c("SWIGFunction", class('InfomapBase_optimizeActiveNetwork'))

# Start of InfomapBase_moveActiveNodesToPredefinedModules

`InfomapBase_moveActiveNodesToPredefinedModules` = function(self, modules)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  modules = as.integer(modules);
  ;.Call('R_swig_InfomapBase_moveActiveNodesToPredefinedModules', self, modules, PACKAGE='infomap');
  
}

attr(`InfomapBase_moveActiveNodesToPredefinedModules`, 'returnType') = 'void'
attr(`InfomapBase_moveActiveNodesToPredefinedModules`, "inputTypes") = c('_p_infomap__InfomapBase', 'integer')
class(`InfomapBase_moveActiveNodesToPredefinedModules`) = c("SWIGFunction", class('InfomapBase_moveActiveNodesToPredefinedModules'))

# Start of InfomapBase_consolidateModules

`InfomapBase_consolidateModules__SWIG_0` = function(self, replaceExistingModules)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  replaceExistingModules = as.logical(replaceExistingModules);
  ;.Call('R_swig_InfomapBase_consolidateModules__SWIG_0', self, replaceExistingModules, PACKAGE='infomap');
  
}

attr(`InfomapBase_consolidateModules__SWIG_0`, 'returnType') = 'void'
attr(`InfomapBase_consolidateModules__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapBase', 'logical')
class(`InfomapBase_consolidateModules__SWIG_0`) = c("SWIGFunction", class('InfomapBase_consolidateModules__SWIG_0'))

# Start of InfomapBase_consolidateModules

`InfomapBase_consolidateModules__SWIG_1` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_consolidateModules__SWIG_1', self, PACKAGE='infomap');
  
}

attr(`InfomapBase_consolidateModules__SWIG_1`, 'returnType') = 'void'
attr(`InfomapBase_consolidateModules__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_consolidateModules__SWIG_1`) = c("SWIGFunction", class('InfomapBase_consolidateModules__SWIG_1'))

`InfomapBase_consolidateModules` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]]))) {
      f <- InfomapBase_consolidateModules__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && ( is.logical(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- InfomapBase_consolidateModules__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InfomapBase_consolidateModules with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapBase_calculateNumNonTrivialTopModules

`InfomapBase_calculateNumNonTrivialTopModules` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_calculateNumNonTrivialTopModules', self, PACKAGE='infomap');
  
}

attr(`InfomapBase_calculateNumNonTrivialTopModules`, 'returnType') = 'void'
attr(`InfomapBase_calculateNumNonTrivialTopModules`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_calculateNumNonTrivialTopModules`) = c("SWIGFunction", class('InfomapBase_calculateNumNonTrivialTopModules'))

# Start of InfomapBase_calculateMaxDepth

`InfomapBase_calculateMaxDepth` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_calculateMaxDepth', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_calculateMaxDepth`, 'returnType') = 'integer'
attr(`InfomapBase_calculateMaxDepth`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_calculateMaxDepth`) = c("SWIGFunction", class('InfomapBase_calculateMaxDepth'))

# Start of InfomapBase_restoreConsolidatedOptimizationPointIfNoImprovement

`InfomapBase_restoreConsolidatedOptimizationPointIfNoImprovement__SWIG_0` = function(self, forceRestore, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  forceRestore = as.logical(forceRestore);
  ;.Call('R_swig_InfomapBase_restoreConsolidatedOptimizationPointIfNoImprovement__SWIG_0', self, forceRestore, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_restoreConsolidatedOptimizationPointIfNoImprovement__SWIG_0`, 'returnType') = 'logical'
attr(`InfomapBase_restoreConsolidatedOptimizationPointIfNoImprovement__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapBase', 'logical')
class(`InfomapBase_restoreConsolidatedOptimizationPointIfNoImprovement__SWIG_0`) = c("SWIGFunction", class('InfomapBase_restoreConsolidatedOptimizationPointIfNoImprovement__SWIG_0'))

# Start of InfomapBase_restoreConsolidatedOptimizationPointIfNoImprovement

`InfomapBase_restoreConsolidatedOptimizationPointIfNoImprovement__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_restoreConsolidatedOptimizationPointIfNoImprovement__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_restoreConsolidatedOptimizationPointIfNoImprovement__SWIG_1`, 'returnType') = 'logical'
attr(`InfomapBase_restoreConsolidatedOptimizationPointIfNoImprovement__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_restoreConsolidatedOptimizationPointIfNoImprovement__SWIG_1`) = c("SWIGFunction", class('InfomapBase_restoreConsolidatedOptimizationPointIfNoImprovement__SWIG_1'))

`InfomapBase_restoreConsolidatedOptimizationPointIfNoImprovement` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]]))) {
      f <- InfomapBase_restoreConsolidatedOptimizationPointIfNoImprovement__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && ( is.logical(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- InfomapBase_restoreConsolidatedOptimizationPointIfNoImprovement__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InfomapBase_restoreConsolidatedOptimizationPointIfNoImprovement with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapBase_findHierarchicalSuperModules

`InfomapBase_findHierarchicalSuperModules__SWIG_0` = function(self, superLevelLimit, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  superLevelLimit = as.integer(superLevelLimit);
  
  if(length(superLevelLimit) > 1) {
    warning("using only the first element of superLevelLimit");
  };
  
  ;.Call('R_swig_InfomapBase_findHierarchicalSuperModules__SWIG_0', self, superLevelLimit, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_findHierarchicalSuperModules__SWIG_0`, 'returnType') = 'integer'
attr(`InfomapBase_findHierarchicalSuperModules__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapBase', 'integer')
class(`InfomapBase_findHierarchicalSuperModules__SWIG_0`) = c("SWIGFunction", class('InfomapBase_findHierarchicalSuperModules__SWIG_0'))

# Start of InfomapBase_findHierarchicalSuperModules

`InfomapBase_findHierarchicalSuperModules__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_findHierarchicalSuperModules__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_findHierarchicalSuperModules__SWIG_1`, 'returnType') = 'integer'
attr(`InfomapBase_findHierarchicalSuperModules__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_findHierarchicalSuperModules__SWIG_1`) = c("SWIGFunction", class('InfomapBase_findHierarchicalSuperModules__SWIG_1'))

`InfomapBase_findHierarchicalSuperModules` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]]))) {
      f <- InfomapBase_findHierarchicalSuperModules__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- InfomapBase_findHierarchicalSuperModules__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InfomapBase_findHierarchicalSuperModules with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapBase_findHierarchicalSuperModulesFast

`InfomapBase_findHierarchicalSuperModulesFast__SWIG_0` = function(self, superLevelLimit, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  superLevelLimit = as.integer(superLevelLimit);
  
  if(length(superLevelLimit) > 1) {
    warning("using only the first element of superLevelLimit");
  };
  
  ;.Call('R_swig_InfomapBase_findHierarchicalSuperModulesFast__SWIG_0', self, superLevelLimit, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_findHierarchicalSuperModulesFast__SWIG_0`, 'returnType') = 'integer'
attr(`InfomapBase_findHierarchicalSuperModulesFast__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapBase', 'integer')
class(`InfomapBase_findHierarchicalSuperModulesFast__SWIG_0`) = c("SWIGFunction", class('InfomapBase_findHierarchicalSuperModulesFast__SWIG_0'))

# Start of InfomapBase_findHierarchicalSuperModulesFast

`InfomapBase_findHierarchicalSuperModulesFast__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_findHierarchicalSuperModulesFast__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_findHierarchicalSuperModulesFast__SWIG_1`, 'returnType') = 'integer'
attr(`InfomapBase_findHierarchicalSuperModulesFast__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_findHierarchicalSuperModulesFast__SWIG_1`) = c("SWIGFunction", class('InfomapBase_findHierarchicalSuperModulesFast__SWIG_1'))

`InfomapBase_findHierarchicalSuperModulesFast` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]]))) {
      f <- InfomapBase_findHierarchicalSuperModulesFast__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- InfomapBase_findHierarchicalSuperModulesFast__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InfomapBase_findHierarchicalSuperModulesFast with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapBase_transformNodeFlowToEnterFlow

`InfomapBase_transformNodeFlowToEnterFlow` = function(self, parent)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(parent, "ExternalReference")) parent = slot(parent,"ref"); 
  ;.Call('R_swig_InfomapBase_transformNodeFlowToEnterFlow', self, parent, PACKAGE='infomap');
  
}

attr(`InfomapBase_transformNodeFlowToEnterFlow`, 'returnType') = 'void'
attr(`InfomapBase_transformNodeFlowToEnterFlow`, "inputTypes") = c('_p_infomap__InfomapBase', '_p_infomap__InfoNode')
class(`InfomapBase_transformNodeFlowToEnterFlow`) = c("SWIGFunction", class('InfomapBase_transformNodeFlowToEnterFlow'))

# Start of InfomapBase_resetFlowOnModules

`InfomapBase_resetFlowOnModules` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_resetFlowOnModules', self, PACKAGE='infomap');
  
}

attr(`InfomapBase_resetFlowOnModules`, 'returnType') = 'void'
attr(`InfomapBase_resetFlowOnModules`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_resetFlowOnModules`) = c("SWIGFunction", class('InfomapBase_resetFlowOnModules'))

# Start of InfomapBase_removeModules

`InfomapBase_removeModules` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_removeModules', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_removeModules`, 'returnType') = 'integer'
attr(`InfomapBase_removeModules`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_removeModules`) = c("SWIGFunction", class('InfomapBase_removeModules'))

# Start of InfomapBase_removeSubModules

`InfomapBase_removeSubModules` = function(self, recalculateCodelengthOnTree, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  recalculateCodelengthOnTree = as.logical(recalculateCodelengthOnTree);
  ;.Call('R_swig_InfomapBase_removeSubModules', self, recalculateCodelengthOnTree, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_removeSubModules`, 'returnType') = 'integer'
attr(`InfomapBase_removeSubModules`, "inputTypes") = c('_p_infomap__InfomapBase', 'logical')
class(`InfomapBase_removeSubModules`) = c("SWIGFunction", class('InfomapBase_removeSubModules'))

# Start of InfomapBase_recursivePartition

`InfomapBase_recursivePartition` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_recursivePartition', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_recursivePartition`, 'returnType') = 'integer'
attr(`InfomapBase_recursivePartition`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_recursivePartition`) = c("SWIGFunction", class('InfomapBase_recursivePartition'))

# Start of InfomapBase_queueTopModules

`InfomapBase_queueTopModules` = function(self, partitionQueue)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(partitionQueue, "ExternalReference")) partitionQueue = slot(partitionQueue,"ref"); 
  ;.Call('R_swig_InfomapBase_queueTopModules', self, partitionQueue, PACKAGE='infomap');
  
}

attr(`InfomapBase_queueTopModules`, 'returnType') = 'void'
attr(`InfomapBase_queueTopModules`, "inputTypes") = c('_p_infomap__InfomapBase', '_p_infomap__detail__PartitionQueue')
class(`InfomapBase_queueTopModules`) = c("SWIGFunction", class('InfomapBase_queueTopModules'))

# Start of InfomapBase_queueLeafModules

`InfomapBase_queueLeafModules` = function(self, partitionQueue)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(partitionQueue, "ExternalReference")) partitionQueue = slot(partitionQueue,"ref"); 
  ;.Call('R_swig_InfomapBase_queueLeafModules', self, partitionQueue, PACKAGE='infomap');
  
}

attr(`InfomapBase_queueLeafModules`, 'returnType') = 'void'
attr(`InfomapBase_queueLeafModules`, "inputTypes") = c('_p_infomap__InfomapBase', '_p_infomap__detail__PartitionQueue')
class(`InfomapBase_queueLeafModules`) = c("SWIGFunction", class('InfomapBase_queueLeafModules'))

# Start of InfomapBase_processPartitionQueue

`InfomapBase_processPartitionQueue` = function(self, queue, nextLevel, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(queue, "ExternalReference")) queue = slot(queue,"ref"); 
  if (inherits(nextLevel, "ExternalReference")) nextLevel = slot(nextLevel,"ref"); 
  ;.Call('R_swig_InfomapBase_processPartitionQueue', self, queue, nextLevel, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_processPartitionQueue`, 'returnType') = 'logical'
attr(`InfomapBase_processPartitionQueue`, "inputTypes") = c('_p_infomap__InfomapBase', '_p_infomap__detail__PartitionQueue', '_p_infomap__detail__PartitionQueue')
class(`InfomapBase_processPartitionQueue`) = c("SWIGFunction", class('InfomapBase_processPartitionQueue'))

# Start of InfomapBase_getOutputFileHeader

`InfomapBase_getOutputFileHeader` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_getOutputFileHeader', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_getOutputFileHeader`, 'returnType') = 'character'
attr(`InfomapBase_getOutputFileHeader`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_getOutputFileHeader`) = c("SWIGFunction", class('InfomapBase_getOutputFileHeader'))

# Start of InfomapBase_writeTree

`InfomapBase_writeTree__SWIG_0` = function(self, filename, states, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  filename = as(filename, "character"); 
  states = as.logical(states);
  ;.Call('R_swig_InfomapBase_writeTree__SWIG_0', self, filename, states, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_writeTree__SWIG_0`, 'returnType') = 'character'
attr(`InfomapBase_writeTree__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapBase', 'character', 'logical')
class(`InfomapBase_writeTree__SWIG_0`) = c("SWIGFunction", class('InfomapBase_writeTree__SWIG_0'))

# Start of InfomapBase_writeTree

`InfomapBase_writeTree__SWIG_1` = function(self, filename, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  filename = as(filename, "character"); 
  ;.Call('R_swig_InfomapBase_writeTree__SWIG_1', self, filename, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_writeTree__SWIG_1`, 'returnType') = 'character'
attr(`InfomapBase_writeTree__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapBase', 'character')
class(`InfomapBase_writeTree__SWIG_1`) = c("SWIGFunction", class('InfomapBase_writeTree__SWIG_1'))

# Start of InfomapBase_writeTree

`InfomapBase_writeTree__SWIG_2` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_writeTree__SWIG_2', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_writeTree__SWIG_2`, 'returnType') = 'character'
attr(`InfomapBase_writeTree__SWIG_2`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_writeTree__SWIG_2`) = c("SWIGFunction", class('InfomapBase_writeTree__SWIG_2'))

`InfomapBase_writeTree` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]]))) {
      f <- InfomapBase_writeTree__SWIG_2; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && is.character(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- InfomapBase_writeTree__SWIG_1; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && is.character(argv[[2]]) && length(argv[[2]]) == 1 && ( is.logical(argv[[3]]) && length(argv[[3]]) == 1 )) {
      f <- InfomapBase_writeTree__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InfomapBase_writeTree with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapBase_writeFlowTree

`InfomapBase_writeFlowTree__SWIG_0` = function(self, filename, states, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  filename = as(filename, "character"); 
  states = as.logical(states);
  ;.Call('R_swig_InfomapBase_writeFlowTree__SWIG_0', self, filename, states, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_writeFlowTree__SWIG_0`, 'returnType') = 'character'
attr(`InfomapBase_writeFlowTree__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapBase', 'character', 'logical')
class(`InfomapBase_writeFlowTree__SWIG_0`) = c("SWIGFunction", class('InfomapBase_writeFlowTree__SWIG_0'))

# Start of InfomapBase_writeFlowTree

`InfomapBase_writeFlowTree__SWIG_1` = function(self, filename, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  filename = as(filename, "character"); 
  ;.Call('R_swig_InfomapBase_writeFlowTree__SWIG_1', self, filename, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_writeFlowTree__SWIG_1`, 'returnType') = 'character'
attr(`InfomapBase_writeFlowTree__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapBase', 'character')
class(`InfomapBase_writeFlowTree__SWIG_1`) = c("SWIGFunction", class('InfomapBase_writeFlowTree__SWIG_1'))

# Start of InfomapBase_writeFlowTree

`InfomapBase_writeFlowTree__SWIG_2` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_writeFlowTree__SWIG_2', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_writeFlowTree__SWIG_2`, 'returnType') = 'character'
attr(`InfomapBase_writeFlowTree__SWIG_2`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_writeFlowTree__SWIG_2`) = c("SWIGFunction", class('InfomapBase_writeFlowTree__SWIG_2'))

`InfomapBase_writeFlowTree` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]]))) {
      f <- InfomapBase_writeFlowTree__SWIG_2; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && is.character(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- InfomapBase_writeFlowTree__SWIG_1; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && is.character(argv[[2]]) && length(argv[[2]]) == 1 && ( is.logical(argv[[3]]) && length(argv[[3]]) == 1 )) {
      f <- InfomapBase_writeFlowTree__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InfomapBase_writeFlowTree with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapBase_writeNewickTree

`InfomapBase_writeNewickTree__SWIG_0` = function(self, filename, states, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  filename = as(filename, "character"); 
  states = as.logical(states);
  ;.Call('R_swig_InfomapBase_writeNewickTree__SWIG_0', self, filename, states, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_writeNewickTree__SWIG_0`, 'returnType') = 'character'
attr(`InfomapBase_writeNewickTree__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapBase', 'character', 'logical')
class(`InfomapBase_writeNewickTree__SWIG_0`) = c("SWIGFunction", class('InfomapBase_writeNewickTree__SWIG_0'))

# Start of InfomapBase_writeNewickTree

`InfomapBase_writeNewickTree__SWIG_1` = function(self, filename, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  filename = as(filename, "character"); 
  ;.Call('R_swig_InfomapBase_writeNewickTree__SWIG_1', self, filename, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_writeNewickTree__SWIG_1`, 'returnType') = 'character'
attr(`InfomapBase_writeNewickTree__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapBase', 'character')
class(`InfomapBase_writeNewickTree__SWIG_1`) = c("SWIGFunction", class('InfomapBase_writeNewickTree__SWIG_1'))

# Start of InfomapBase_writeNewickTree

`InfomapBase_writeNewickTree__SWIG_2` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_writeNewickTree__SWIG_2', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_writeNewickTree__SWIG_2`, 'returnType') = 'character'
attr(`InfomapBase_writeNewickTree__SWIG_2`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_writeNewickTree__SWIG_2`) = c("SWIGFunction", class('InfomapBase_writeNewickTree__SWIG_2'))

`InfomapBase_writeNewickTree` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]]))) {
      f <- InfomapBase_writeNewickTree__SWIG_2; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && is.character(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- InfomapBase_writeNewickTree__SWIG_1; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && is.character(argv[[2]]) && length(argv[[2]]) == 1 && ( is.logical(argv[[3]]) && length(argv[[3]]) == 1 )) {
      f <- InfomapBase_writeNewickTree__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InfomapBase_writeNewickTree with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapBase_writeClu

`InfomapBase_writeClu__SWIG_0` = function(self, filename, states, moduleIndexLevel, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  filename = as(filename, "character"); 
  states = as.logical(states);
  moduleIndexLevel = as.integer(moduleIndexLevel);
  
  if(length(moduleIndexLevel) > 1) {
    warning("using only the first element of moduleIndexLevel");
  };
  
  ;.Call('R_swig_InfomapBase_writeClu__SWIG_0', self, filename, states, moduleIndexLevel, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_writeClu__SWIG_0`, 'returnType') = 'character'
attr(`InfomapBase_writeClu__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapBase', 'character', 'logical', 'integer')
class(`InfomapBase_writeClu__SWIG_0`) = c("SWIGFunction", class('InfomapBase_writeClu__SWIG_0'))

# Start of InfomapBase_writeClu

`InfomapBase_writeClu__SWIG_1` = function(self, filename, states, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  filename = as(filename, "character"); 
  states = as.logical(states);
  ;.Call('R_swig_InfomapBase_writeClu__SWIG_1', self, filename, states, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_writeClu__SWIG_1`, 'returnType') = 'character'
attr(`InfomapBase_writeClu__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapBase', 'character', 'logical')
class(`InfomapBase_writeClu__SWIG_1`) = c("SWIGFunction", class('InfomapBase_writeClu__SWIG_1'))

# Start of InfomapBase_writeClu

`InfomapBase_writeClu__SWIG_2` = function(self, filename, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  filename = as(filename, "character"); 
  ;.Call('R_swig_InfomapBase_writeClu__SWIG_2', self, filename, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_writeClu__SWIG_2`, 'returnType') = 'character'
attr(`InfomapBase_writeClu__SWIG_2`, "inputTypes") = c('_p_infomap__InfomapBase', 'character')
class(`InfomapBase_writeClu__SWIG_2`) = c("SWIGFunction", class('InfomapBase_writeClu__SWIG_2'))

# Start of InfomapBase_writeClu

`InfomapBase_writeClu__SWIG_3` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_writeClu__SWIG_3', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_writeClu__SWIG_3`, 'returnType') = 'character'
attr(`InfomapBase_writeClu__SWIG_3`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_writeClu__SWIG_3`) = c("SWIGFunction", class('InfomapBase_writeClu__SWIG_3'))

`InfomapBase_writeClu` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]]))) {
      f <- InfomapBase_writeClu__SWIG_3; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && is.character(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- InfomapBase_writeClu__SWIG_2; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && is.character(argv[[2]]) && length(argv[[2]]) == 1 && ( is.logical(argv[[3]]) && length(argv[[3]]) == 1 )) {
      f <- InfomapBase_writeClu__SWIG_1; 
    }
  } else if (argc == 4) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && is.character(argv[[2]]) && length(argv[[2]]) == 1 && ( is.logical(argv[[3]]) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 )) {
      f <- InfomapBase_writeClu__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InfomapBase_writeClu with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapBase_printPerLevelCodelength

`InfomapBase_printPerLevelCodelength` = function(self, out, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(out, "ExternalReference")) out = slot(out,"ref"); 
  ;.Call('R_swig_InfomapBase_printPerLevelCodelength', self, out, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapBase_printPerLevelCodelength`, 'returnType') = 'integer'
attr(`InfomapBase_printPerLevelCodelength`, "inputTypes") = c('_p_infomap__InfomapBase', '_p_std__ostream')
class(`InfomapBase_printPerLevelCodelength`) = c("SWIGFunction", class('InfomapBase_printPerLevelCodelength'))

# Start of InfomapBase_aggregatePerLevelCodelength

`InfomapBase_aggregatePerLevelCodelength__SWIG_0` = function(self, perLevelStat, level)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(perLevelStat, "ExternalReference")) perLevelStat = slot(perLevelStat,"ref"); 
  level = as.integer(level);
  
  if(length(level) > 1) {
    warning("using only the first element of level");
  };
  
  ;.Call('R_swig_InfomapBase_aggregatePerLevelCodelength__SWIG_0', self, perLevelStat, level, PACKAGE='infomap');
  
}

attr(`InfomapBase_aggregatePerLevelCodelength__SWIG_0`, 'returnType') = 'void'
attr(`InfomapBase_aggregatePerLevelCodelength__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapBase', '_p_std__vectorT_infomap__PerLevelStat_std__allocatorT_infomap__PerLevelStat_t_t', 'integer')
class(`InfomapBase_aggregatePerLevelCodelength__SWIG_0`) = c("SWIGFunction", class('InfomapBase_aggregatePerLevelCodelength__SWIG_0'))

# Start of InfomapBase_aggregatePerLevelCodelength

`InfomapBase_aggregatePerLevelCodelength__SWIG_1` = function(self, perLevelStat)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(perLevelStat, "ExternalReference")) perLevelStat = slot(perLevelStat,"ref"); 
  ;.Call('R_swig_InfomapBase_aggregatePerLevelCodelength__SWIG_1', self, perLevelStat, PACKAGE='infomap');
  
}

attr(`InfomapBase_aggregatePerLevelCodelength__SWIG_1`, 'returnType') = 'void'
attr(`InfomapBase_aggregatePerLevelCodelength__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapBase', '_p_std__vectorT_infomap__PerLevelStat_std__allocatorT_infomap__PerLevelStat_t_t')
class(`InfomapBase_aggregatePerLevelCodelength__SWIG_1`) = c("SWIGFunction", class('InfomapBase_aggregatePerLevelCodelength__SWIG_1'))

# Start of InfomapBase_aggregatePerLevelCodelength

`InfomapBase_aggregatePerLevelCodelength__SWIG_2` = function(self, parent, perLevelStat, level)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(parent, "ExternalReference")) parent = slot(parent,"ref"); 
  if (inherits(perLevelStat, "ExternalReference")) perLevelStat = slot(perLevelStat,"ref"); 
  level = as.integer(level);
  
  if(length(level) > 1) {
    warning("using only the first element of level");
  };
  
  ;.Call('R_swig_InfomapBase_aggregatePerLevelCodelength__SWIG_2', self, parent, perLevelStat, level, PACKAGE='infomap');
  
}

attr(`InfomapBase_aggregatePerLevelCodelength__SWIG_2`, 'returnType') = 'void'
attr(`InfomapBase_aggregatePerLevelCodelength__SWIG_2`, "inputTypes") = c('_p_infomap__InfomapBase', '_p_infomap__InfoNode', '_p_std__vectorT_infomap__PerLevelStat_std__allocatorT_infomap__PerLevelStat_t_t', 'integer')
class(`InfomapBase_aggregatePerLevelCodelength__SWIG_2`) = c("SWIGFunction", class('InfomapBase_aggregatePerLevelCodelength__SWIG_2'))

`InfomapBase_aggregatePerLevelCodelength` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && extends(argtypes[2], '_p_std__vectorT_infomap__PerLevelStat_std__allocatorT_infomap__PerLevelStat_t_t') && length(argv[[2]]) == 1) {
      f <- InfomapBase_aggregatePerLevelCodelength__SWIG_1; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && extends(argtypes[2], '_p_std__vectorT_infomap__PerLevelStat_std__allocatorT_infomap__PerLevelStat_t_t') && length(argv[[2]]) == 1 && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 )) {
      f <- InfomapBase_aggregatePerLevelCodelength__SWIG_0; 
    }
  } else if (argc == 4) {
    if ((extends(argtypes[1], '_p_infomap__InfomapBase') || is.null(argv[[1]])) && extends(argtypes[2], '_p_infomap__InfoNode') && length(argv[[2]]) == 1 && extends(argtypes[3], '_p_std__vectorT_infomap__PerLevelStat_std__allocatorT_infomap__PerLevelStat_t_t') && length(argv[[3]]) == 1 && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 )) {
      f <- InfomapBase_aggregatePerLevelCodelength__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for InfomapBase_aggregatePerLevelCodelength with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapBase_printDebug

`InfomapBase_printDebug` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapBase_printDebug', self, PACKAGE='infomap');
  
}

attr(`InfomapBase_printDebug`, 'returnType') = 'void'
attr(`InfomapBase_printDebug`, "inputTypes") = c('_p_infomap__InfomapBase')
class(`InfomapBase_printDebug`) = c("SWIGFunction", class('InfomapBase_printDebug'))

# Start of accessor method for infomap::InfomapBase
setMethod('$', '_p_infomap__InfomapBase', function(x, name)

{
  accessorFuns = list('network' = InfomapBase_network, 'root' = InfomapBase_root, 'iterTree' = InfomapBase_iterTree, 'iterTreePhysical' = InfomapBase_iterTreePhysical, 'iterModules' = InfomapBase_iterModules, 'iterLeafModules' = InfomapBase_iterLeafModules, 'iterLeafNodes' = InfomapBase_iterLeafNodes, 'iterLeafNodesPhysical' = InfomapBase_iterLeafNodesPhysical, 'begin' = InfomapBase_begin, 'end' = InfomapBase_end, 'numLeafNodes' = InfomapBase_numLeafNodes, 'leafNodes' = InfomapBase_leafNodes, 'numTopModules' = InfomapBase_numTopModules, 'numActiveModules' = InfomapBase_numActiveModules, 'numNonTrivialTopModules' = InfomapBase_numNonTrivialTopModules, 'haveModules' = InfomapBase_haveModules, 'haveNonTrivialModules' = InfomapBase_haveNonTrivialModules, 'numLevels' = InfomapBase_numLevels, 'maxTreeDepth' = InfomapBase_maxTreeDepth, 'getCodelength' = InfomapBase_getCodelength, 'getMetaCodelength' = InfomapBase_getMetaCodelength, 'codelength' = InfomapBase_codelength, 'codelengths' = InfomapBase_codelengths, 'getIndexCodelength' = InfomapBase_getIndexCodelength, 'getModuleCodelength' = InfomapBase_getModuleCodelength, 'getHierarchicalCodelength' = InfomapBase_getHierarchicalCodelength, 'getOneLevelCodelength' = InfomapBase_getOneLevelCodelength, 'getRelativeCodelengthSavings' = InfomapBase_getRelativeCodelengthSavings, 'isFullNetwork' = InfomapBase_isFullNetwork, 'isFirstLoop' = InfomapBase_isFirstLoop, 'getNewInfomapInstance' = InfomapBase_getNewInfomapInstance, 'getNewInfomapInstanceWithoutMemory' = InfomapBase_getNewInfomapInstanceWithoutMemory, 'getSubInfomap' = InfomapBase_getSubInfomap, 'getSuperInfomap' = InfomapBase_getSuperInfomap, 'setIsMain' = InfomapBase_setIsMain, 'setSubLevel' = InfomapBase_setSubLevel, 'isTopLevel' = InfomapBase_isTopLevel, 'isSuperLevelOnTopLevel' = InfomapBase_isSuperLevelOnTopLevel, 'isMainInfomap' = InfomapBase_isMainInfomap, 'haveHardPartition' = InfomapBase_haveHardPartition, 'activeNetwork' = InfomapBase_activeNetwork, 'toString' = InfomapBase_toString, 'getInitialPartition' = InfomapBase_getInitialPartition, 'calcEntropyRate' = InfomapBase_calcEntropyRate, 'setInitialPartition' = InfomapBase_setInitialPartition, 'run' = InfomapBase_run, 'initNetwork' = InfomapBase_initNetwork, 'generateSubNetwork' = InfomapBase_generateSubNetwork, 'initMetaData' = InfomapBase_initMetaData, 'initPartition' = InfomapBase_initPartition, 'initTree' = InfomapBase_initTree, 'init' = InfomapBase_init, 'runPartition' = InfomapBase_runPartition, 'restoreHardPartition' = InfomapBase_restoreHardPartition, 'sortTreeOnFlow' = InfomapBase_sortTreeOnFlow, 'writeResult' = InfomapBase_writeResult, 'hierarchicalPartition' = InfomapBase_hierarchicalPartition, 'partition' = InfomapBase_partition, 'initEnterExitFlow' = InfomapBase_initEnterExitFlow, 'aggregateFlowValuesFromLeafToRoot' = InfomapBase_aggregateFlowValuesFromLeafToRoot, 'initSuperNetwork' = InfomapBase_initSuperNetwork, 'calcCodelength' = InfomapBase_calcCodelength, 'calcCodelengthOnTree' = InfomapBase_calcCodelengthOnTree, 'setActiveNetworkFromLeafs' = InfomapBase_setActiveNetworkFromLeafs, 'setActiveNetworkFromChildrenOfRoot' = InfomapBase_setActiveNetworkFromChildrenOfRoot, 'findTopModulesRepeatedly' = InfomapBase_findTopModulesRepeatedly, 'fineTune' = InfomapBase_fineTune, 'coarseTune' = InfomapBase_coarseTune, 'optimizeActiveNetwork' = InfomapBase_optimizeActiveNetwork, 'moveActiveNodesToPredefinedModules' = InfomapBase_moveActiveNodesToPredefinedModules, 'consolidateModules' = InfomapBase_consolidateModules, 'calculateNumNonTrivialTopModules' = InfomapBase_calculateNumNonTrivialTopModules, 'calculateMaxDepth' = InfomapBase_calculateMaxDepth, 'restoreConsolidatedOptimizationPointIfNoImprovement' = InfomapBase_restoreConsolidatedOptimizationPointIfNoImprovement, 'findHierarchicalSuperModules' = InfomapBase_findHierarchicalSuperModules, 'findHierarchicalSuperModulesFast' = InfomapBase_findHierarchicalSuperModulesFast, 'transformNodeFlowToEnterFlow' = InfomapBase_transformNodeFlowToEnterFlow, 'resetFlowOnModules' = InfomapBase_resetFlowOnModules, 'removeModules' = InfomapBase_removeModules, 'removeSubModules' = InfomapBase_removeSubModules, 'recursivePartition' = InfomapBase_recursivePartition, 'queueTopModules' = InfomapBase_queueTopModules, 'queueLeafModules' = InfomapBase_queueLeafModules, 'processPartitionQueue' = InfomapBase_processPartitionQueue, 'getOutputFileHeader' = InfomapBase_getOutputFileHeader, 'writeTree' = InfomapBase_writeTree, 'writeFlowTree' = InfomapBase_writeFlowTree, 'writeNewickTree' = InfomapBase_writeNewickTree, 'writeClu' = InfomapBase_writeClu, 'printPerLevelCodelength' = InfomapBase_printPerLevelCodelength, 'aggregatePerLevelCodelength' = InfomapBase_aggregatePerLevelCodelength, 'printDebug' = InfomapBase_printDebug);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for infomap::InfomapBase
setMethod('delete', '_p_infomap__InfomapBase', function(obj) {delete_infomap__InfomapBase(obj)})
# Start of PerLevelStat_codelength

`PerLevelStat_codelength` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_PerLevelStat_codelength', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`PerLevelStat_codelength`, 'returnType') = 'numeric'
attr(`PerLevelStat_codelength`, "inputTypes") = c('_p_infomap__PerLevelStat')
class(`PerLevelStat_codelength`) = c("SWIGFunction", class('PerLevelStat_codelength'))

# Start of PerLevelStat_numNodes

`PerLevelStat_numNodes` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_PerLevelStat_numNodes', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`PerLevelStat_numNodes`, 'returnType') = 'integer'
attr(`PerLevelStat_numNodes`, "inputTypes") = c('_p_infomap__PerLevelStat')
class(`PerLevelStat_numNodes`) = c("SWIGFunction", class('PerLevelStat_numNodes'))

# Start of PerLevelStat_numModules_set

`PerLevelStat_numModules_set` = function(self, s_numModules)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_numModules = as.integer(s_numModules);
  
  if(length(s_numModules) > 1) {
    warning("using only the first element of s_numModules");
  };
  
  ;.Call('R_swig_PerLevelStat_numModules_set', self, s_numModules, PACKAGE='infomap');
  
}

attr(`PerLevelStat_numModules_set`, 'returnType') = 'void'
attr(`PerLevelStat_numModules_set`, "inputTypes") = c('_p_infomap__PerLevelStat', 'integer')
class(`PerLevelStat_numModules_set`) = c("SWIGFunction", class('PerLevelStat_numModules_set'))

# Start of PerLevelStat_numModules_get

`PerLevelStat_numModules_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_PerLevelStat_numModules_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`PerLevelStat_numModules_get`, 'returnType') = 'integer'
attr(`PerLevelStat_numModules_get`, "inputTypes") = c('_p_infomap__PerLevelStat')
class(`PerLevelStat_numModules_get`) = c("SWIGFunction", class('PerLevelStat_numModules_get'))

# Start of PerLevelStat_numLeafNodes_set

`PerLevelStat_numLeafNodes_set` = function(self, s_numLeafNodes)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_numLeafNodes = as.integer(s_numLeafNodes);
  
  if(length(s_numLeafNodes) > 1) {
    warning("using only the first element of s_numLeafNodes");
  };
  
  ;.Call('R_swig_PerLevelStat_numLeafNodes_set', self, s_numLeafNodes, PACKAGE='infomap');
  
}

attr(`PerLevelStat_numLeafNodes_set`, 'returnType') = 'void'
attr(`PerLevelStat_numLeafNodes_set`, "inputTypes") = c('_p_infomap__PerLevelStat', 'integer')
class(`PerLevelStat_numLeafNodes_set`) = c("SWIGFunction", class('PerLevelStat_numLeafNodes_set'))

# Start of PerLevelStat_numLeafNodes_get

`PerLevelStat_numLeafNodes_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_PerLevelStat_numLeafNodes_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`PerLevelStat_numLeafNodes_get`, 'returnType') = 'integer'
attr(`PerLevelStat_numLeafNodes_get`, "inputTypes") = c('_p_infomap__PerLevelStat')
class(`PerLevelStat_numLeafNodes_get`) = c("SWIGFunction", class('PerLevelStat_numLeafNodes_get'))

# Start of PerLevelStat_indexLength_set

`PerLevelStat_indexLength_set` = function(self, s_indexLength)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_PerLevelStat_indexLength_set', self, s_indexLength, PACKAGE='infomap');
  
}

attr(`PerLevelStat_indexLength_set`, 'returnType') = 'void'
attr(`PerLevelStat_indexLength_set`, "inputTypes") = c('_p_infomap__PerLevelStat', 'numeric')
class(`PerLevelStat_indexLength_set`) = c("SWIGFunction", class('PerLevelStat_indexLength_set'))

# Start of PerLevelStat_indexLength_get

`PerLevelStat_indexLength_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_PerLevelStat_indexLength_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`PerLevelStat_indexLength_get`, 'returnType') = 'numeric'
attr(`PerLevelStat_indexLength_get`, "inputTypes") = c('_p_infomap__PerLevelStat')
class(`PerLevelStat_indexLength_get`) = c("SWIGFunction", class('PerLevelStat_indexLength_get'))

# Start of PerLevelStat_leafLength_set

`PerLevelStat_leafLength_set` = function(self, s_leafLength)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_PerLevelStat_leafLength_set', self, s_leafLength, PACKAGE='infomap');
  
}

attr(`PerLevelStat_leafLength_set`, 'returnType') = 'void'
attr(`PerLevelStat_leafLength_set`, "inputTypes") = c('_p_infomap__PerLevelStat', 'numeric')
class(`PerLevelStat_leafLength_set`) = c("SWIGFunction", class('PerLevelStat_leafLength_set'))

# Start of PerLevelStat_leafLength_get

`PerLevelStat_leafLength_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_PerLevelStat_leafLength_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`PerLevelStat_leafLength_get`, 'returnType') = 'numeric'
attr(`PerLevelStat_leafLength_get`, "inputTypes") = c('_p_infomap__PerLevelStat')
class(`PerLevelStat_leafLength_get`) = c("SWIGFunction", class('PerLevelStat_leafLength_get'))

# Start of new_PerLevelStat

`PerLevelStat` = function()
{
  ;ans = .Call('R_swig_new_PerLevelStat', PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__PerLevelStat", ref=ans);
  
  reg.finalizer(ans@ref, delete_PerLevelStat);
  ans
  
}

attr(`PerLevelStat`, 'returnType') = '_p_infomap__PerLevelStat'
class(`PerLevelStat`) = c("SWIGFunction", class('PerLevelStat'))

# Start of delete_PerLevelStat

`delete_PerLevelStat` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_PerLevelStat', self, PACKAGE='infomap');
  
}

attr(`delete_PerLevelStat`, 'returnType') = 'void'
attr(`delete_PerLevelStat`, "inputTypes") = c('_p_infomap__PerLevelStat')
class(`delete_PerLevelStat`) = c("SWIGFunction", class('delete_PerLevelStat'))

# Start of accessor method for infomap::PerLevelStat
setMethod('$', '_p_infomap__PerLevelStat', function(x, name)

{
  accessorFuns = list('codelength' = PerLevelStat_codelength, 'numNodes' = PerLevelStat_numNodes, 'numModules' = PerLevelStat_numModules_get, 'numLeafNodes' = PerLevelStat_numLeafNodes_get, 'indexLength' = PerLevelStat_indexLength_get, 'leafLength' = PerLevelStat_leafLength_get);
  vaccessors = c('numModules', 'numLeafNodes', 'indexLength', 'leafLength');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for infomap::PerLevelStat
# Start of accessor method for infomap::PerLevelStat
setMethod('$<-', '_p_infomap__PerLevelStat', function(x, name, value)

{
  accessorFuns = list('numModules' = PerLevelStat_numModules_set, 'numLeafNodes' = PerLevelStat_numLeafNodes_set, 'indexLength' = PerLevelStat_indexLength_set, 'leafLength' = PerLevelStat_leafLength_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_infomap__PerLevelStat', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('numModules' = PerLevelStat_numModules_set, 'numLeafNodes' = PerLevelStat_numLeafNodes_set, 'indexLength' = PerLevelStat_indexLength_set, 'leafLength' = PerLevelStat_leafLength_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for infomap::PerLevelStat
setMethod('delete', '_p_infomap__PerLevelStat', function(obj) {delete_infomap__PerLevelStat(obj)})
# Start definition of copy functions & methods for infomap::PerLevelStat
CopyToR_infomap__PerLevelStat = function(value, obj = new("infomap::PerLevelStat"))
{
  obj@numModules = value$numModules;
  obj@numLeafNodes = value$numLeafNodes;
  obj@indexLength = value$indexLength;
  obj@leafLength = value$leafLength;
  obj;
}



CopyToC_infomap__PerLevelStat = function(value, obj)
{
  obj$numModules = value@numModules;
  obj$numLeafNodes = value@numLeafNodes;
  obj$indexLength = value@indexLength;
  obj$leafLength = value@leafLength;
  obj
}



# Start definition of copy methods for infomap::PerLevelStat
setMethod('copyToR', '_p_infomap::PerLevelStat', CopyToR_infomap__PerLevelStat);
setMethod('copyToC', 'infomap::PerLevelStat', CopyToC_infomap__PerLevelStat);

# End definition of copy methods for infomap::PerLevelStat
# End definition of copy functions & methods for infomap::PerLevelStat
# Start of PartitionQueue_swap

`PartitionQueue_swap` = function(self, other)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;.Call('R_swig_PartitionQueue_swap', self, other, PACKAGE='infomap');
  
}

attr(`PartitionQueue_swap`, 'returnType') = 'void'
attr(`PartitionQueue_swap`, "inputTypes") = c('_p_infomap__detail__PartitionQueue', '_p_infomap__detail__PartitionQueue')
class(`PartitionQueue_swap`) = c("SWIGFunction", class('PartitionQueue_swap'))

# Start of PartitionQueue_size

`PartitionQueue_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_PartitionQueue_size', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__dequeT_infomap__InfoNode_p_std__allocatorT_infomap__InfoNode_p_t_t__size_type", ref=ans);
  
  ans
  
}

attr(`PartitionQueue_size`, 'returnType') = '_p_std__dequeT_infomap__InfoNode_p_std__allocatorT_infomap__InfoNode_p_t_t__size_type'
attr(`PartitionQueue_size`, "inputTypes") = c('_p_infomap__detail__PartitionQueue')
class(`PartitionQueue_size`) = c("SWIGFunction", class('PartitionQueue_size'))

# Start of PartitionQueue_resize

`PartitionQueue_resize` = function(self, size)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(size, "ExternalReference")) size = slot(size,"ref"); 
  ;.Call('R_swig_PartitionQueue_resize', self, size, PACKAGE='infomap');
  
}

attr(`PartitionQueue_resize`, 'returnType') = 'void'
attr(`PartitionQueue_resize`, "inputTypes") = c('_p_infomap__detail__PartitionQueue', '_p_std__dequeT_infomap__InfoNode_p_std__allocatorT_infomap__InfoNode_p_t_t__size_type')
class(`PartitionQueue_resize`) = c("SWIGFunction", class('PartitionQueue_resize'))

# Start of PartitionQueue_level_set

`PartitionQueue_level_set` = function(self, s_level)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_level = as.integer(s_level);
  
  if(length(s_level) > 1) {
    warning("using only the first element of s_level");
  };
  
  ;.Call('R_swig_PartitionQueue_level_set', self, s_level, PACKAGE='infomap');
  
}

attr(`PartitionQueue_level_set`, 'returnType') = 'void'
attr(`PartitionQueue_level_set`, "inputTypes") = c('_p_infomap__detail__PartitionQueue', 'integer')
class(`PartitionQueue_level_set`) = c("SWIGFunction", class('PartitionQueue_level_set'))

# Start of PartitionQueue_level_get

`PartitionQueue_level_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_PartitionQueue_level_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`PartitionQueue_level_get`, 'returnType') = 'integer'
attr(`PartitionQueue_level_get`, "inputTypes") = c('_p_infomap__detail__PartitionQueue')
class(`PartitionQueue_level_get`) = c("SWIGFunction", class('PartitionQueue_level_get'))

# Start of PartitionQueue_numNonTrivialModules_set

`PartitionQueue_numNonTrivialModules_set` = function(self, s_numNonTrivialModules)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_numNonTrivialModules = as.integer(s_numNonTrivialModules);
  
  if(length(s_numNonTrivialModules) > 1) {
    warning("using only the first element of s_numNonTrivialModules");
  };
  
  ;.Call('R_swig_PartitionQueue_numNonTrivialModules_set', self, s_numNonTrivialModules, PACKAGE='infomap');
  
}

attr(`PartitionQueue_numNonTrivialModules_set`, 'returnType') = 'void'
attr(`PartitionQueue_numNonTrivialModules_set`, "inputTypes") = c('_p_infomap__detail__PartitionQueue', 'integer')
class(`PartitionQueue_numNonTrivialModules_set`) = c("SWIGFunction", class('PartitionQueue_numNonTrivialModules_set'))

# Start of PartitionQueue_numNonTrivialModules_get

`PartitionQueue_numNonTrivialModules_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_PartitionQueue_numNonTrivialModules_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`PartitionQueue_numNonTrivialModules_get`, 'returnType') = 'integer'
attr(`PartitionQueue_numNonTrivialModules_get`, "inputTypes") = c('_p_infomap__detail__PartitionQueue')
class(`PartitionQueue_numNonTrivialModules_get`) = c("SWIGFunction", class('PartitionQueue_numNonTrivialModules_get'))

# Start of PartitionQueue_flow_set

`PartitionQueue_flow_set` = function(self, s_flow)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_PartitionQueue_flow_set', self, s_flow, PACKAGE='infomap');
  
}

attr(`PartitionQueue_flow_set`, 'returnType') = 'void'
attr(`PartitionQueue_flow_set`, "inputTypes") = c('_p_infomap__detail__PartitionQueue', 'numeric')
class(`PartitionQueue_flow_set`) = c("SWIGFunction", class('PartitionQueue_flow_set'))

# Start of PartitionQueue_flow_get

`PartitionQueue_flow_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_PartitionQueue_flow_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`PartitionQueue_flow_get`, 'returnType') = 'numeric'
attr(`PartitionQueue_flow_get`, "inputTypes") = c('_p_infomap__detail__PartitionQueue')
class(`PartitionQueue_flow_get`) = c("SWIGFunction", class('PartitionQueue_flow_get'))

# Start of PartitionQueue_nonTrivialFlow_set

`PartitionQueue_nonTrivialFlow_set` = function(self, s_nonTrivialFlow)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_PartitionQueue_nonTrivialFlow_set', self, s_nonTrivialFlow, PACKAGE='infomap');
  
}

attr(`PartitionQueue_nonTrivialFlow_set`, 'returnType') = 'void'
attr(`PartitionQueue_nonTrivialFlow_set`, "inputTypes") = c('_p_infomap__detail__PartitionQueue', 'numeric')
class(`PartitionQueue_nonTrivialFlow_set`) = c("SWIGFunction", class('PartitionQueue_nonTrivialFlow_set'))

# Start of PartitionQueue_nonTrivialFlow_get

`PartitionQueue_nonTrivialFlow_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_PartitionQueue_nonTrivialFlow_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`PartitionQueue_nonTrivialFlow_get`, 'returnType') = 'numeric'
attr(`PartitionQueue_nonTrivialFlow_get`, "inputTypes") = c('_p_infomap__detail__PartitionQueue')
class(`PartitionQueue_nonTrivialFlow_get`) = c("SWIGFunction", class('PartitionQueue_nonTrivialFlow_get'))

# Start of PartitionQueue_skip_set

`PartitionQueue_skip_set` = function(self, s_skip)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_skip = as.logical(s_skip);
  ;.Call('R_swig_PartitionQueue_skip_set', self, s_skip, PACKAGE='infomap');
  
}

attr(`PartitionQueue_skip_set`, 'returnType') = 'void'
attr(`PartitionQueue_skip_set`, "inputTypes") = c('_p_infomap__detail__PartitionQueue', 'logical')
class(`PartitionQueue_skip_set`) = c("SWIGFunction", class('PartitionQueue_skip_set'))

# Start of PartitionQueue_skip_get

`PartitionQueue_skip_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_PartitionQueue_skip_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`PartitionQueue_skip_get`, 'returnType') = 'logical'
attr(`PartitionQueue_skip_get`, "inputTypes") = c('_p_infomap__detail__PartitionQueue')
class(`PartitionQueue_skip_get`) = c("SWIGFunction", class('PartitionQueue_skip_get'))

# Start of PartitionQueue_indexCodelength_set

`PartitionQueue_indexCodelength_set` = function(self, s_indexCodelength)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_PartitionQueue_indexCodelength_set', self, s_indexCodelength, PACKAGE='infomap');
  
}

attr(`PartitionQueue_indexCodelength_set`, 'returnType') = 'void'
attr(`PartitionQueue_indexCodelength_set`, "inputTypes") = c('_p_infomap__detail__PartitionQueue', 'numeric')
class(`PartitionQueue_indexCodelength_set`) = c("SWIGFunction", class('PartitionQueue_indexCodelength_set'))

# Start of PartitionQueue_indexCodelength_get

`PartitionQueue_indexCodelength_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_PartitionQueue_indexCodelength_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`PartitionQueue_indexCodelength_get`, 'returnType') = 'numeric'
attr(`PartitionQueue_indexCodelength_get`, "inputTypes") = c('_p_infomap__detail__PartitionQueue')
class(`PartitionQueue_indexCodelength_get`) = c("SWIGFunction", class('PartitionQueue_indexCodelength_get'))

# Start of PartitionQueue_leafCodelength_set

`PartitionQueue_leafCodelength_set` = function(self, s_leafCodelength)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_PartitionQueue_leafCodelength_set', self, s_leafCodelength, PACKAGE='infomap');
  
}

attr(`PartitionQueue_leafCodelength_set`, 'returnType') = 'void'
attr(`PartitionQueue_leafCodelength_set`, "inputTypes") = c('_p_infomap__detail__PartitionQueue', 'numeric')
class(`PartitionQueue_leafCodelength_set`) = c("SWIGFunction", class('PartitionQueue_leafCodelength_set'))

# Start of PartitionQueue_leafCodelength_get

`PartitionQueue_leafCodelength_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_PartitionQueue_leafCodelength_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`PartitionQueue_leafCodelength_get`, 'returnType') = 'numeric'
attr(`PartitionQueue_leafCodelength_get`, "inputTypes") = c('_p_infomap__detail__PartitionQueue')
class(`PartitionQueue_leafCodelength_get`) = c("SWIGFunction", class('PartitionQueue_leafCodelength_get'))

# Start of PartitionQueue_moduleCodelength_set

`PartitionQueue_moduleCodelength_set` = function(self, s_moduleCodelength)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_PartitionQueue_moduleCodelength_set', self, s_moduleCodelength, PACKAGE='infomap');
  
}

attr(`PartitionQueue_moduleCodelength_set`, 'returnType') = 'void'
attr(`PartitionQueue_moduleCodelength_set`, "inputTypes") = c('_p_infomap__detail__PartitionQueue', 'numeric')
class(`PartitionQueue_moduleCodelength_set`) = c("SWIGFunction", class('PartitionQueue_moduleCodelength_set'))

# Start of PartitionQueue_moduleCodelength_get

`PartitionQueue_moduleCodelength_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_PartitionQueue_moduleCodelength_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`PartitionQueue_moduleCodelength_get`, 'returnType') = 'numeric'
attr(`PartitionQueue_moduleCodelength_get`, "inputTypes") = c('_p_infomap__detail__PartitionQueue')
class(`PartitionQueue_moduleCodelength_get`) = c("SWIGFunction", class('PartitionQueue_moduleCodelength_get'))

# Start of new_PartitionQueue

`PartitionQueue` = function()
{
  ;ans = .Call('R_swig_new_PartitionQueue', PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__detail__PartitionQueue", ref=ans);
  
  reg.finalizer(ans@ref, delete_PartitionQueue);
  ans
  
}

attr(`PartitionQueue`, 'returnType') = '_p_infomap__detail__PartitionQueue'
class(`PartitionQueue`) = c("SWIGFunction", class('PartitionQueue'))

# Start of delete_PartitionQueue

`delete_PartitionQueue` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_PartitionQueue', self, PACKAGE='infomap');
  
}

attr(`delete_PartitionQueue`, 'returnType') = 'void'
attr(`delete_PartitionQueue`, "inputTypes") = c('_p_infomap__detail__PartitionQueue')
class(`delete_PartitionQueue`) = c("SWIGFunction", class('delete_PartitionQueue'))

# Start of accessor method for infomap::detail::PartitionQueue
setMethod('$', '_p_infomap__detail__PartitionQueue', function(x, name)

{
  accessorFuns = list('swap' = PartitionQueue_swap, 'size' = PartitionQueue_size, 'resize' = PartitionQueue_resize, 'level' = PartitionQueue_level_get, 'numNonTrivialModules' = PartitionQueue_numNonTrivialModules_get, 'flow' = PartitionQueue_flow_get, 'nonTrivialFlow' = PartitionQueue_nonTrivialFlow_get, 'skip' = PartitionQueue_skip_get, 'indexCodelength' = PartitionQueue_indexCodelength_get, 'leafCodelength' = PartitionQueue_leafCodelength_get, 'moduleCodelength' = PartitionQueue_moduleCodelength_get);
  vaccessors = c('level', 'numNonTrivialModules', 'flow', 'nonTrivialFlow', 'skip', 'indexCodelength', 'leafCodelength', 'moduleCodelength');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for infomap::detail::PartitionQueue
# Start of accessor method for infomap::detail::PartitionQueue
setMethod('$<-', '_p_infomap__detail__PartitionQueue', function(x, name, value)

{
  accessorFuns = list('level' = PartitionQueue_level_set, 'numNonTrivialModules' = PartitionQueue_numNonTrivialModules_set, 'flow' = PartitionQueue_flow_set, 'nonTrivialFlow' = PartitionQueue_nonTrivialFlow_set, 'skip' = PartitionQueue_skip_set, 'indexCodelength' = PartitionQueue_indexCodelength_set, 'leafCodelength' = PartitionQueue_leafCodelength_set, 'moduleCodelength' = PartitionQueue_moduleCodelength_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_infomap__detail__PartitionQueue', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('level' = PartitionQueue_level_set, 'numNonTrivialModules' = PartitionQueue_numNonTrivialModules_set, 'flow' = PartitionQueue_flow_set, 'nonTrivialFlow' = PartitionQueue_nonTrivialFlow_set, 'skip' = PartitionQueue_skip_set, 'indexCodelength' = PartitionQueue_indexCodelength_set, 'leafCodelength' = PartitionQueue_leafCodelength_set, 'moduleCodelength' = PartitionQueue_moduleCodelength_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for infomap::detail::PartitionQueue
setMethod('delete', '_p_infomap__detail__PartitionQueue', function(obj) {delete_infomap__detail__PartitionQueue(obj)})
# Start of new_MapEquation

`MapEquation__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_MapEquation__SWIG_0', PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__MapEquation", ref=ans);
  
  reg.finalizer(ans@ref, delete_MapEquation);
  ans
  
}

attr(`MapEquation__SWIG_0`, 'returnType') = '_p_infomap__MapEquation'
class(`MapEquation__SWIG_0`) = c("SWIGFunction", class('MapEquation__SWIG_0'))

# Start of new_MapEquation

`MapEquation__SWIG_1` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_new_MapEquation__SWIG_1', other, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__MapEquation", ref=ans);
  
  reg.finalizer(ans@ref, delete_MapEquation);
  ans
  
}

attr(`MapEquation__SWIG_1`, 'returnType') = '_p_infomap__MapEquation'
attr(`MapEquation__SWIG_1`, "inputTypes") = c('_p_infomap__MapEquation')
class(`MapEquation__SWIG_1`) = c("SWIGFunction", class('MapEquation__SWIG_1'))

`MapEquation` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- MapEquation__SWIG_0; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_infomap__MapEquation') && length(argv[[1]]) == 1) {
      f <- MapEquation__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for MapEquation with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of MapEquation_Equal

`MapEquation_Equal` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_MapEquation_Equal', self, other, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__MapEquation", ref=ans);
  
  ans
  
}

attr(`MapEquation_Equal`, 'returnType') = '_p_infomap__MapEquation'
attr(`MapEquation_Equal`, "inputTypes") = c('_p_infomap__MapEquation', '_p_infomap__MapEquation')
class(`MapEquation_Equal`) = c("SWIGFunction", class('MapEquation_Equal'))

# Start of delete_MapEquation

`delete_MapEquation` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_MapEquation', self, PACKAGE='infomap');
  
}

attr(`delete_MapEquation`, 'returnType') = 'void'
attr(`delete_MapEquation`, "inputTypes") = c('_p_infomap__MapEquation')
class(`delete_MapEquation`) = c("SWIGFunction", class('delete_MapEquation'))

# Start of MapEquation_getIndexCodelength

`MapEquation_getIndexCodelength` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MapEquation_getIndexCodelength', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MapEquation_getIndexCodelength`, 'returnType') = 'numeric'
attr(`MapEquation_getIndexCodelength`, "inputTypes") = c('_p_infomap__MapEquation')
class(`MapEquation_getIndexCodelength`) = c("SWIGFunction", class('MapEquation_getIndexCodelength'))

# Start of MapEquation_getModuleCodelength

`MapEquation_getModuleCodelength` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MapEquation_getModuleCodelength', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MapEquation_getModuleCodelength`, 'returnType') = 'numeric'
attr(`MapEquation_getModuleCodelength`, "inputTypes") = c('_p_infomap__MapEquation')
class(`MapEquation_getModuleCodelength`) = c("SWIGFunction", class('MapEquation_getModuleCodelength'))

# Start of MapEquation_getCodelength

`MapEquation_getCodelength` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MapEquation_getCodelength', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MapEquation_getCodelength`, 'returnType') = 'numeric'
attr(`MapEquation_getCodelength`, "inputTypes") = c('_p_infomap__MapEquation')
class(`MapEquation_getCodelength`) = c("SWIGFunction", class('MapEquation_getCodelength'))

# Start of MapEquation_print

`MapEquation_print` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(s_arg2, "ExternalReference")) s_arg2 = slot(s_arg2,"ref"); 
  ;ans = .Call('R_swig_MapEquation_print', self, s_arg2, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__ostream", ref=ans);
  
  ans
  
}

attr(`MapEquation_print`, 'returnType') = '_p_std__ostream'
attr(`MapEquation_print`, "inputTypes") = c('_p_infomap__MapEquation', '_p_std__ostream')
class(`MapEquation_print`) = c("SWIGFunction", class('MapEquation_print'))

# Start of MapEquation_init

`MapEquation_init` = function(self, config)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(config, "ExternalReference")) config = slot(config,"ref"); 
  ;.Call('R_swig_MapEquation_init', self, config, PACKAGE='infomap');
  
}

attr(`MapEquation_init`, 'returnType') = 'void'
attr(`MapEquation_init`, "inputTypes") = c('_p_infomap__MapEquation', '_p_infomap__Config')
class(`MapEquation_init`) = c("SWIGFunction", class('MapEquation_init'))

# Start of MapEquation_initNetwork

`MapEquation_initNetwork` = function(self, root)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(root, "ExternalReference")) root = slot(root,"ref"); 
  ;.Call('R_swig_MapEquation_initNetwork', self, root, PACKAGE='infomap');
  
}

attr(`MapEquation_initNetwork`, 'returnType') = 'void'
attr(`MapEquation_initNetwork`, "inputTypes") = c('_p_infomap__MapEquation', '_p_infomap__InfoNode')
class(`MapEquation_initNetwork`) = c("SWIGFunction", class('MapEquation_initNetwork'))

# Start of MapEquation_initSuperNetwork

`MapEquation_initSuperNetwork` = function(self, root)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(root, "ExternalReference")) root = slot(root,"ref"); 
  ;.Call('R_swig_MapEquation_initSuperNetwork', self, root, PACKAGE='infomap');
  
}

attr(`MapEquation_initSuperNetwork`, 'returnType') = 'void'
attr(`MapEquation_initSuperNetwork`, "inputTypes") = c('_p_infomap__MapEquation', '_p_infomap__InfoNode')
class(`MapEquation_initSuperNetwork`) = c("SWIGFunction", class('MapEquation_initSuperNetwork'))

# Start of MapEquation_initSubNetwork

`MapEquation_initSubNetwork` = function(self, root)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(root, "ExternalReference")) root = slot(root,"ref"); 
  ;.Call('R_swig_MapEquation_initSubNetwork', self, root, PACKAGE='infomap');
  
}

attr(`MapEquation_initSubNetwork`, 'returnType') = 'void'
attr(`MapEquation_initSubNetwork`, "inputTypes") = c('_p_infomap__MapEquation', '_p_infomap__InfoNode')
class(`MapEquation_initSubNetwork`) = c("SWIGFunction", class('MapEquation_initSubNetwork'))

# Start of MapEquation_initPartition

`MapEquation_initPartition` = function(self, nodes)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(nodes, "ExternalReference")) nodes = slot(nodes,"ref"); 
  ;.Call('R_swig_MapEquation_initPartition', self, nodes, PACKAGE='infomap');
  
}

attr(`MapEquation_initPartition`, 'returnType') = 'void'
attr(`MapEquation_initPartition`, "inputTypes") = c('_p_infomap__MapEquation', '_p_std__vectorT_infomap__InfoNode_p_std__allocatorT_infomap__InfoNode_p_t_t')
class(`MapEquation_initPartition`) = c("SWIGFunction", class('MapEquation_initPartition'))

# Start of MapEquation_calcCodelength

`MapEquation_calcCodelength` = function(self, parent, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(parent, "ExternalReference")) parent = slot(parent,"ref"); 
  ;.Call('R_swig_MapEquation_calcCodelength', self, parent, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MapEquation_calcCodelength`, 'returnType') = 'numeric'
attr(`MapEquation_calcCodelength`, "inputTypes") = c('_p_infomap__MapEquation', '_p_infomap__InfoNode')
class(`MapEquation_calcCodelength`) = c("SWIGFunction", class('MapEquation_calcCodelength'))

# Start of MapEquation_addMemoryContributions

`MapEquation_addMemoryContributions__SWIG_0` = function(self, current, oldModuleDelta, newModuleDelta)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(current, "ExternalReference")) current = slot(current,"ref"); 
  if (inherits(oldModuleDelta, "ExternalReference")) oldModuleDelta = slot(oldModuleDelta,"ref"); 
  if (inherits(newModuleDelta, "ExternalReference")) newModuleDelta = slot(newModuleDelta,"ref"); 
  ;.Call('R_swig_MapEquation_addMemoryContributions__SWIG_0', self, current, oldModuleDelta, newModuleDelta, PACKAGE='infomap');
  
}

attr(`MapEquation_addMemoryContributions__SWIG_0`, 'returnType') = 'void'
attr(`MapEquation_addMemoryContributions__SWIG_0`, "inputTypes") = c('_p_infomap__MapEquation', '_p_infomap__InfoNode', '_p_infomap__DeltaFlow', '_p_infomap__DeltaFlow')
class(`MapEquation_addMemoryContributions__SWIG_0`) = c("SWIGFunction", class('MapEquation_addMemoryContributions__SWIG_0'))

# Start of MapEquation_addMemoryContributions

`MapEquation_addMemoryContributions__SWIG_1` = function(self, current, oldModuleDelta, moduleDeltaFlow)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(current, "ExternalReference")) current = slot(current,"ref"); 
  if (inherits(oldModuleDelta, "ExternalReference")) oldModuleDelta = slot(oldModuleDelta,"ref"); 
  if (inherits(moduleDeltaFlow, "ExternalReference")) moduleDeltaFlow = slot(moduleDeltaFlow,"ref"); 
  ;.Call('R_swig_MapEquation_addMemoryContributions__SWIG_1', self, current, oldModuleDelta, moduleDeltaFlow, PACKAGE='infomap');
  
}

attr(`MapEquation_addMemoryContributions__SWIG_1`, 'returnType') = 'void'
attr(`MapEquation_addMemoryContributions__SWIG_1`, "inputTypes") = c('_p_infomap__MapEquation', '_p_infomap__InfoNode', '_p_infomap__DeltaFlow', '_p_VectorMapT_infomap__DeltaFlow_t')
class(`MapEquation_addMemoryContributions__SWIG_1`) = c("SWIGFunction", class('MapEquation_addMemoryContributions__SWIG_1'))

`MapEquation_addMemoryContributions` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 4) {
    if ((extends(argtypes[1], '_p_infomap__MapEquation') || is.null(argv[[1]])) && extends(argtypes[2], '_p_infomap__InfoNode') && length(argv[[2]]) == 1 && extends(argtypes[3], '_p_infomap__DeltaFlow') && length(argv[[3]]) == 1 && extends(argtypes[4], '_p_infomap__DeltaFlow') && length(argv[[4]]) == 1) {
      f <- MapEquation_addMemoryContributions__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_infomap__MapEquation') || is.null(argv[[1]])) && extends(argtypes[2], '_p_infomap__InfoNode') && length(argv[[2]]) == 1 && extends(argtypes[3], '_p_infomap__DeltaFlow') && length(argv[[3]]) == 1 && extends(argtypes[4], '_p_VectorMapT_infomap__DeltaFlow_t') && length(argv[[4]]) == 1) {
      f <- MapEquation_addMemoryContributions__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for MapEquation_addMemoryContributions with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of MapEquation_getDeltaCodelengthOnMovingNode

`MapEquation_getDeltaCodelengthOnMovingNode` = function(self, current, oldModuleDelta, newModuleDelta, moduleFlowData, moduleMembers, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(current, "ExternalReference")) current = slot(current,"ref"); 
  if (inherits(oldModuleDelta, "ExternalReference")) oldModuleDelta = slot(oldModuleDelta,"ref"); 
  if (inherits(newModuleDelta, "ExternalReference")) newModuleDelta = slot(newModuleDelta,"ref"); 
  if (inherits(moduleFlowData, "ExternalReference")) moduleFlowData = slot(moduleFlowData,"ref"); 
  moduleMembers = as.integer(moduleMembers);
  ;.Call('R_swig_MapEquation_getDeltaCodelengthOnMovingNode', self, current, oldModuleDelta, newModuleDelta, moduleFlowData, moduleMembers, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MapEquation_getDeltaCodelengthOnMovingNode`, 'returnType') = 'numeric'
attr(`MapEquation_getDeltaCodelengthOnMovingNode`, "inputTypes") = c('_p_infomap__MapEquation', '_p_infomap__InfoNode', '_p_infomap__DeltaFlow', '_p_infomap__DeltaFlow', '_p_std__vectorT_infomap__FlowData_std__allocatorT_infomap__FlowData_t_t', 'integer')
class(`MapEquation_getDeltaCodelengthOnMovingNode`) = c("SWIGFunction", class('MapEquation_getDeltaCodelengthOnMovingNode'))

# Start of MapEquation_updateCodelengthOnMovingNode

`MapEquation_updateCodelengthOnMovingNode` = function(self, current, oldModuleDelta, newModuleDelta, moduleFlowData, moduleMembers)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(current, "ExternalReference")) current = slot(current,"ref"); 
  if (inherits(oldModuleDelta, "ExternalReference")) oldModuleDelta = slot(oldModuleDelta,"ref"); 
  if (inherits(newModuleDelta, "ExternalReference")) newModuleDelta = slot(newModuleDelta,"ref"); 
  if (inherits(moduleFlowData, "ExternalReference")) moduleFlowData = slot(moduleFlowData,"ref"); 
  moduleMembers = as.integer(moduleMembers);
  ;.Call('R_swig_MapEquation_updateCodelengthOnMovingNode', self, current, oldModuleDelta, newModuleDelta, moduleFlowData, moduleMembers, PACKAGE='infomap');
  
}

attr(`MapEquation_updateCodelengthOnMovingNode`, 'returnType') = 'void'
attr(`MapEquation_updateCodelengthOnMovingNode`, "inputTypes") = c('_p_infomap__MapEquation', '_p_infomap__InfoNode', '_p_infomap__DeltaFlow', '_p_infomap__DeltaFlow', '_p_std__vectorT_infomap__FlowData_std__allocatorT_infomap__FlowData_t_t', 'integer')
class(`MapEquation_updateCodelengthOnMovingNode`) = c("SWIGFunction", class('MapEquation_updateCodelengthOnMovingNode'))

# Start of MapEquation_consolidateModules

`MapEquation_consolidateModules` = function(self, modules)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(modules, "ExternalReference")) modules = slot(modules,"ref"); 
  ;.Call('R_swig_MapEquation_consolidateModules', self, modules, PACKAGE='infomap');
  
}

attr(`MapEquation_consolidateModules`, 'returnType') = 'void'
attr(`MapEquation_consolidateModules`, "inputTypes") = c('_p_infomap__MapEquation', '_p_std__vectorT_infomap__InfoNode_p_std__allocatorT_infomap__InfoNode_p_t_t')
class(`MapEquation_consolidateModules`) = c("SWIGFunction", class('MapEquation_consolidateModules'))

# Start of MapEquation_printDebug

`MapEquation_printDebug` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MapEquation_printDebug', self, PACKAGE='infomap');
  
}

attr(`MapEquation_printDebug`, 'returnType') = 'void'
attr(`MapEquation_printDebug`, "inputTypes") = c('_p_infomap__MapEquation')
class(`MapEquation_printDebug`) = c("SWIGFunction", class('MapEquation_printDebug'))

# Start of MapEquation_codelength_set

`MapEquation_codelength_set` = function(self, s_codelength)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_MapEquation_codelength_set', self, s_codelength, PACKAGE='infomap');
  
}

attr(`MapEquation_codelength_set`, 'returnType') = 'void'
attr(`MapEquation_codelength_set`, "inputTypes") = c('_p_infomap__MapEquation', 'numeric')
class(`MapEquation_codelength_set`) = c("SWIGFunction", class('MapEquation_codelength_set'))

# Start of MapEquation_codelength_get

`MapEquation_codelength_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MapEquation_codelength_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MapEquation_codelength_get`, 'returnType') = 'numeric'
attr(`MapEquation_codelength_get`, "inputTypes") = c('_p_infomap__MapEquation')
class(`MapEquation_codelength_get`) = c("SWIGFunction", class('MapEquation_codelength_get'))

# Start of MapEquation_indexCodelength_set

`MapEquation_indexCodelength_set` = function(self, s_indexCodelength)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_MapEquation_indexCodelength_set', self, s_indexCodelength, PACKAGE='infomap');
  
}

attr(`MapEquation_indexCodelength_set`, 'returnType') = 'void'
attr(`MapEquation_indexCodelength_set`, "inputTypes") = c('_p_infomap__MapEquation', 'numeric')
class(`MapEquation_indexCodelength_set`) = c("SWIGFunction", class('MapEquation_indexCodelength_set'))

# Start of MapEquation_indexCodelength_get

`MapEquation_indexCodelength_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MapEquation_indexCodelength_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MapEquation_indexCodelength_get`, 'returnType') = 'numeric'
attr(`MapEquation_indexCodelength_get`, "inputTypes") = c('_p_infomap__MapEquation')
class(`MapEquation_indexCodelength_get`) = c("SWIGFunction", class('MapEquation_indexCodelength_get'))

# Start of MapEquation_moduleCodelength_set

`MapEquation_moduleCodelength_set` = function(self, s_moduleCodelength)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_MapEquation_moduleCodelength_set', self, s_moduleCodelength, PACKAGE='infomap');
  
}

attr(`MapEquation_moduleCodelength_set`, 'returnType') = 'void'
attr(`MapEquation_moduleCodelength_set`, "inputTypes") = c('_p_infomap__MapEquation', 'numeric')
class(`MapEquation_moduleCodelength_set`) = c("SWIGFunction", class('MapEquation_moduleCodelength_set'))

# Start of MapEquation_moduleCodelength_get

`MapEquation_moduleCodelength_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MapEquation_moduleCodelength_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MapEquation_moduleCodelength_get`, 'returnType') = 'numeric'
attr(`MapEquation_moduleCodelength_get`, "inputTypes") = c('_p_infomap__MapEquation')
class(`MapEquation_moduleCodelength_get`) = c("SWIGFunction", class('MapEquation_moduleCodelength_get'))

# Start of accessor method for infomap::MapEquation
setMethod('$', '_p_infomap__MapEquation', function(x, name)

{
  accessorFuns = list('Equal' = MapEquation_Equal, 'getIndexCodelength' = MapEquation_getIndexCodelength, 'getModuleCodelength' = MapEquation_getModuleCodelength, 'getCodelength' = MapEquation_getCodelength, 'print' = MapEquation_print, 'init' = MapEquation_init, 'initNetwork' = MapEquation_initNetwork, 'initSuperNetwork' = MapEquation_initSuperNetwork, 'initSubNetwork' = MapEquation_initSubNetwork, 'initPartition' = MapEquation_initPartition, 'calcCodelength' = MapEquation_calcCodelength, 'addMemoryContributions' = MapEquation_addMemoryContributions, 'getDeltaCodelengthOnMovingNode' = MapEquation_getDeltaCodelengthOnMovingNode, 'updateCodelengthOnMovingNode' = MapEquation_updateCodelengthOnMovingNode, 'consolidateModules' = MapEquation_consolidateModules, 'printDebug' = MapEquation_printDebug, 'codelength' = MapEquation_codelength_get, 'indexCodelength' = MapEquation_indexCodelength_get, 'moduleCodelength' = MapEquation_moduleCodelength_get);
  vaccessors = c('codelength', 'indexCodelength', 'moduleCodelength');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for infomap::MapEquation
# Start of accessor method for infomap::MapEquation
setMethod('$<-', '_p_infomap__MapEquation', function(x, name, value)

{
  accessorFuns = list('codelength' = MapEquation_codelength_set, 'indexCodelength' = MapEquation_indexCodelength_set, 'moduleCodelength' = MapEquation_moduleCodelength_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_infomap__MapEquation', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('codelength' = MapEquation_codelength_set, 'indexCodelength' = MapEquation_indexCodelength_set, 'moduleCodelength' = MapEquation_moduleCodelength_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for infomap::MapEquation
setMethod('delete', '_p_infomap__MapEquation', function(obj) {delete_infomap__MapEquation(obj)})
# Start of new_MemMapEquation

`MemMapEquation__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_MemMapEquation__SWIG_0', PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__MemMapEquation", ref=ans);
  
  reg.finalizer(ans@ref, delete_MemMapEquation);
  ans
  
}

attr(`MemMapEquation__SWIG_0`, 'returnType') = '_p_infomap__MemMapEquation'
class(`MemMapEquation__SWIG_0`) = c("SWIGFunction", class('MemMapEquation__SWIG_0'))

# Start of new_MemMapEquation

`MemMapEquation__SWIG_1` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_new_MemMapEquation__SWIG_1', other, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__MemMapEquation", ref=ans);
  
  reg.finalizer(ans@ref, delete_MemMapEquation);
  ans
  
}

attr(`MemMapEquation__SWIG_1`, 'returnType') = '_p_infomap__MemMapEquation'
attr(`MemMapEquation__SWIG_1`, "inputTypes") = c('_p_infomap__MemMapEquation')
class(`MemMapEquation__SWIG_1`) = c("SWIGFunction", class('MemMapEquation__SWIG_1'))

`MemMapEquation` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- MemMapEquation__SWIG_0; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_infomap__MemMapEquation') && length(argv[[1]]) == 1) {
      f <- MemMapEquation__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for MemMapEquation with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of MemMapEquation_Equal

`MemMapEquation_Equal` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_MemMapEquation_Equal', self, other, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__MemMapEquation", ref=ans);
  
  ans
  
}

attr(`MemMapEquation_Equal`, 'returnType') = '_p_infomap__MemMapEquation'
attr(`MemMapEquation_Equal`, "inputTypes") = c('_p_infomap__MemMapEquation', '_p_infomap__MemMapEquation')
class(`MemMapEquation_Equal`) = c("SWIGFunction", class('MemMapEquation_Equal'))

# Start of delete_MemMapEquation

`delete_MemMapEquation` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_MemMapEquation', self, PACKAGE='infomap');
  
}

attr(`delete_MemMapEquation`, 'returnType') = 'void'
attr(`delete_MemMapEquation`, "inputTypes") = c('_p_infomap__MemMapEquation')
class(`delete_MemMapEquation`) = c("SWIGFunction", class('delete_MemMapEquation'))

# Start of MemMapEquation_getIndexCodelength

`MemMapEquation_getIndexCodelength` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MemMapEquation_getIndexCodelength', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MemMapEquation_getIndexCodelength`, 'returnType') = 'numeric'
attr(`MemMapEquation_getIndexCodelength`, "inputTypes") = c('_p_infomap__MemMapEquation')
class(`MemMapEquation_getIndexCodelength`) = c("SWIGFunction", class('MemMapEquation_getIndexCodelength'))

# Start of MemMapEquation_getModuleCodelength

`MemMapEquation_getModuleCodelength` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MemMapEquation_getModuleCodelength', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MemMapEquation_getModuleCodelength`, 'returnType') = 'numeric'
attr(`MemMapEquation_getModuleCodelength`, "inputTypes") = c('_p_infomap__MemMapEquation')
class(`MemMapEquation_getModuleCodelength`) = c("SWIGFunction", class('MemMapEquation_getModuleCodelength'))

# Start of MemMapEquation_getCodelength

`MemMapEquation_getCodelength` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MemMapEquation_getCodelength', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MemMapEquation_getCodelength`, 'returnType') = 'numeric'
attr(`MemMapEquation_getCodelength`, "inputTypes") = c('_p_infomap__MemMapEquation')
class(`MemMapEquation_getCodelength`) = c("SWIGFunction", class('MemMapEquation_getCodelength'))

# Start of MemMapEquation_print

`MemMapEquation_print` = function(self, out, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(out, "ExternalReference")) out = slot(out,"ref"); 
  ;ans = .Call('R_swig_MemMapEquation_print', self, out, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__ostream", ref=ans);
  
  ans
  
}

attr(`MemMapEquation_print`, 'returnType') = '_p_std__ostream'
attr(`MemMapEquation_print`, "inputTypes") = c('_p_infomap__MemMapEquation', '_p_std__ostream')
class(`MemMapEquation_print`) = c("SWIGFunction", class('MemMapEquation_print'))

# Start of MemMapEquation_init

`MemMapEquation_init` = function(self, config)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(config, "ExternalReference")) config = slot(config,"ref"); 
  ;.Call('R_swig_MemMapEquation_init', self, config, PACKAGE='infomap');
  
}

attr(`MemMapEquation_init`, 'returnType') = 'void'
attr(`MemMapEquation_init`, "inputTypes") = c('_p_infomap__MemMapEquation', '_p_infomap__Config')
class(`MemMapEquation_init`) = c("SWIGFunction", class('MemMapEquation_init'))

# Start of MemMapEquation_initNetwork

`MemMapEquation_initNetwork` = function(self, root)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(root, "ExternalReference")) root = slot(root,"ref"); 
  ;.Call('R_swig_MemMapEquation_initNetwork', self, root, PACKAGE='infomap');
  
}

attr(`MemMapEquation_initNetwork`, 'returnType') = 'void'
attr(`MemMapEquation_initNetwork`, "inputTypes") = c('_p_infomap__MemMapEquation', '_p_infomap__InfoNode')
class(`MemMapEquation_initNetwork`) = c("SWIGFunction", class('MemMapEquation_initNetwork'))

# Start of MemMapEquation_initSuperNetwork

`MemMapEquation_initSuperNetwork` = function(self, root)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(root, "ExternalReference")) root = slot(root,"ref"); 
  ;.Call('R_swig_MemMapEquation_initSuperNetwork', self, root, PACKAGE='infomap');
  
}

attr(`MemMapEquation_initSuperNetwork`, 'returnType') = 'void'
attr(`MemMapEquation_initSuperNetwork`, "inputTypes") = c('_p_infomap__MemMapEquation', '_p_infomap__InfoNode')
class(`MemMapEquation_initSuperNetwork`) = c("SWIGFunction", class('MemMapEquation_initSuperNetwork'))

# Start of MemMapEquation_initSubNetwork

`MemMapEquation_initSubNetwork` = function(self, root)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(root, "ExternalReference")) root = slot(root,"ref"); 
  ;.Call('R_swig_MemMapEquation_initSubNetwork', self, root, PACKAGE='infomap');
  
}

attr(`MemMapEquation_initSubNetwork`, 'returnType') = 'void'
attr(`MemMapEquation_initSubNetwork`, "inputTypes") = c('_p_infomap__MemMapEquation', '_p_infomap__InfoNode')
class(`MemMapEquation_initSubNetwork`) = c("SWIGFunction", class('MemMapEquation_initSubNetwork'))

# Start of MemMapEquation_initPartition

`MemMapEquation_initPartition` = function(self, nodes)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(nodes, "ExternalReference")) nodes = slot(nodes,"ref"); 
  ;.Call('R_swig_MemMapEquation_initPartition', self, nodes, PACKAGE='infomap');
  
}

attr(`MemMapEquation_initPartition`, 'returnType') = 'void'
attr(`MemMapEquation_initPartition`, "inputTypes") = c('_p_infomap__MemMapEquation', '_p_std__vectorT_infomap__InfoNode_p_std__allocatorT_infomap__InfoNode_p_t_t')
class(`MemMapEquation_initPartition`) = c("SWIGFunction", class('MemMapEquation_initPartition'))

# Start of MemMapEquation_calcCodelength

`MemMapEquation_calcCodelength` = function(self, parent, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(parent, "ExternalReference")) parent = slot(parent,"ref"); 
  ;.Call('R_swig_MemMapEquation_calcCodelength', self, parent, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MemMapEquation_calcCodelength`, 'returnType') = 'numeric'
attr(`MemMapEquation_calcCodelength`, "inputTypes") = c('_p_infomap__MemMapEquation', '_p_infomap__InfoNode')
class(`MemMapEquation_calcCodelength`) = c("SWIGFunction", class('MemMapEquation_calcCodelength'))

# Start of MemMapEquation_addMemoryContributions

`MemMapEquation_addMemoryContributions` = function(self, current, oldModuleDelta, moduleDeltaFlow)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(current, "ExternalReference")) current = slot(current,"ref"); 
  if (inherits(oldModuleDelta, "ExternalReference")) oldModuleDelta = slot(oldModuleDelta,"ref"); 
  if (inherits(moduleDeltaFlow, "ExternalReference")) moduleDeltaFlow = slot(moduleDeltaFlow,"ref"); 
  ;.Call('R_swig_MemMapEquation_addMemoryContributions', self, current, oldModuleDelta, moduleDeltaFlow, PACKAGE='infomap');
  
}

attr(`MemMapEquation_addMemoryContributions`, 'returnType') = 'void'
attr(`MemMapEquation_addMemoryContributions`, "inputTypes") = c('_p_infomap__MemMapEquation', '_p_infomap__InfoNode', '_p_infomap__MemDeltaFlow', '_p_VectorMapT_infomap__MemDeltaFlow_t')
class(`MemMapEquation_addMemoryContributions`) = c("SWIGFunction", class('MemMapEquation_addMemoryContributions'))

# Start of MemMapEquation_getDeltaCodelengthOnMovingNode

`MemMapEquation_getDeltaCodelengthOnMovingNode` = function(self, current, oldModuleDelta, newModuleDelta, moduleFlowData, moduleMembers, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(current, "ExternalReference")) current = slot(current,"ref"); 
  if (inherits(oldModuleDelta, "ExternalReference")) oldModuleDelta = slot(oldModuleDelta,"ref"); 
  if (inherits(newModuleDelta, "ExternalReference")) newModuleDelta = slot(newModuleDelta,"ref"); 
  if (inherits(moduleFlowData, "ExternalReference")) moduleFlowData = slot(moduleFlowData,"ref"); 
  moduleMembers = as.integer(moduleMembers);
  ;.Call('R_swig_MemMapEquation_getDeltaCodelengthOnMovingNode', self, current, oldModuleDelta, newModuleDelta, moduleFlowData, moduleMembers, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MemMapEquation_getDeltaCodelengthOnMovingNode`, 'returnType') = 'numeric'
attr(`MemMapEquation_getDeltaCodelengthOnMovingNode`, "inputTypes") = c('_p_infomap__MemMapEquation', '_p_infomap__InfoNode', '_p_infomap__MemDeltaFlow', '_p_infomap__MemDeltaFlow', '_p_std__vectorT_infomap__FlowData_std__allocatorT_infomap__FlowData_t_t', 'integer')
class(`MemMapEquation_getDeltaCodelengthOnMovingNode`) = c("SWIGFunction", class('MemMapEquation_getDeltaCodelengthOnMovingNode'))

# Start of MemMapEquation_updateCodelengthOnMovingNode

`MemMapEquation_updateCodelengthOnMovingNode` = function(self, current, oldModuleDelta, newModuleDelta, moduleFlowData, moduleMembers)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(current, "ExternalReference")) current = slot(current,"ref"); 
  if (inherits(oldModuleDelta, "ExternalReference")) oldModuleDelta = slot(oldModuleDelta,"ref"); 
  if (inherits(newModuleDelta, "ExternalReference")) newModuleDelta = slot(newModuleDelta,"ref"); 
  if (inherits(moduleFlowData, "ExternalReference")) moduleFlowData = slot(moduleFlowData,"ref"); 
  moduleMembers = as.integer(moduleMembers);
  ;.Call('R_swig_MemMapEquation_updateCodelengthOnMovingNode', self, current, oldModuleDelta, newModuleDelta, moduleFlowData, moduleMembers, PACKAGE='infomap');
  
}

attr(`MemMapEquation_updateCodelengthOnMovingNode`, 'returnType') = 'void'
attr(`MemMapEquation_updateCodelengthOnMovingNode`, "inputTypes") = c('_p_infomap__MemMapEquation', '_p_infomap__InfoNode', '_p_infomap__MemDeltaFlow', '_p_infomap__MemDeltaFlow', '_p_std__vectorT_infomap__FlowData_std__allocatorT_infomap__FlowData_t_t', 'integer')
class(`MemMapEquation_updateCodelengthOnMovingNode`) = c("SWIGFunction", class('MemMapEquation_updateCodelengthOnMovingNode'))

# Start of MemMapEquation_consolidateModules

`MemMapEquation_consolidateModules` = function(self, modules)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(modules, "ExternalReference")) modules = slot(modules,"ref"); 
  ;.Call('R_swig_MemMapEquation_consolidateModules', self, modules, PACKAGE='infomap');
  
}

attr(`MemMapEquation_consolidateModules`, 'returnType') = 'void'
attr(`MemMapEquation_consolidateModules`, "inputTypes") = c('_p_infomap__MemMapEquation', '_p_std__vectorT_infomap__InfoNode_p_std__allocatorT_infomap__InfoNode_p_t_t')
class(`MemMapEquation_consolidateModules`) = c("SWIGFunction", class('MemMapEquation_consolidateModules'))

# Start of MemMapEquation_printDebug

`MemMapEquation_printDebug` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MemMapEquation_printDebug', self, PACKAGE='infomap');
  
}

attr(`MemMapEquation_printDebug`, 'returnType') = 'void'
attr(`MemMapEquation_printDebug`, "inputTypes") = c('_p_infomap__MemMapEquation')
class(`MemMapEquation_printDebug`) = c("SWIGFunction", class('MemMapEquation_printDebug'))

# Start of MemMapEquation_codelength_set

`MemMapEquation_codelength_set` = function(self, s_codelength)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_MemMapEquation_codelength_set', self, s_codelength, PACKAGE='infomap');
  
}

attr(`MemMapEquation_codelength_set`, 'returnType') = 'void'
attr(`MemMapEquation_codelength_set`, "inputTypes") = c('_p_infomap__MemMapEquation', 'numeric')
class(`MemMapEquation_codelength_set`) = c("SWIGFunction", class('MemMapEquation_codelength_set'))

# Start of MemMapEquation_codelength_get

`MemMapEquation_codelength_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MemMapEquation_codelength_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MemMapEquation_codelength_get`, 'returnType') = 'numeric'
attr(`MemMapEquation_codelength_get`, "inputTypes") = c('_p_infomap__MemMapEquation')
class(`MemMapEquation_codelength_get`) = c("SWIGFunction", class('MemMapEquation_codelength_get'))

# Start of MemMapEquation_indexCodelength_set

`MemMapEquation_indexCodelength_set` = function(self, s_indexCodelength)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_MemMapEquation_indexCodelength_set', self, s_indexCodelength, PACKAGE='infomap');
  
}

attr(`MemMapEquation_indexCodelength_set`, 'returnType') = 'void'
attr(`MemMapEquation_indexCodelength_set`, "inputTypes") = c('_p_infomap__MemMapEquation', 'numeric')
class(`MemMapEquation_indexCodelength_set`) = c("SWIGFunction", class('MemMapEquation_indexCodelength_set'))

# Start of MemMapEquation_indexCodelength_get

`MemMapEquation_indexCodelength_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MemMapEquation_indexCodelength_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MemMapEquation_indexCodelength_get`, 'returnType') = 'numeric'
attr(`MemMapEquation_indexCodelength_get`, "inputTypes") = c('_p_infomap__MemMapEquation')
class(`MemMapEquation_indexCodelength_get`) = c("SWIGFunction", class('MemMapEquation_indexCodelength_get'))

# Start of MemMapEquation_moduleCodelength_set

`MemMapEquation_moduleCodelength_set` = function(self, s_moduleCodelength)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_MemMapEquation_moduleCodelength_set', self, s_moduleCodelength, PACKAGE='infomap');
  
}

attr(`MemMapEquation_moduleCodelength_set`, 'returnType') = 'void'
attr(`MemMapEquation_moduleCodelength_set`, "inputTypes") = c('_p_infomap__MemMapEquation', 'numeric')
class(`MemMapEquation_moduleCodelength_set`) = c("SWIGFunction", class('MemMapEquation_moduleCodelength_set'))

# Start of MemMapEquation_moduleCodelength_get

`MemMapEquation_moduleCodelength_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MemMapEquation_moduleCodelength_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MemMapEquation_moduleCodelength_get`, 'returnType') = 'numeric'
attr(`MemMapEquation_moduleCodelength_get`, "inputTypes") = c('_p_infomap__MemMapEquation')
class(`MemMapEquation_moduleCodelength_get`) = c("SWIGFunction", class('MemMapEquation_moduleCodelength_get'))

# Start of accessor method for infomap::MemMapEquation
setMethod('$', '_p_infomap__MemMapEquation', function(x, name)

{
  accessorFuns = list('Equal' = MemMapEquation_Equal, 'getIndexCodelength' = MemMapEquation_getIndexCodelength, 'getModuleCodelength' = MemMapEquation_getModuleCodelength, 'getCodelength' = MemMapEquation_getCodelength, 'print' = MemMapEquation_print, 'init' = MemMapEquation_init, 'initNetwork' = MemMapEquation_initNetwork, 'initSuperNetwork' = MemMapEquation_initSuperNetwork, 'initSubNetwork' = MemMapEquation_initSubNetwork, 'initPartition' = MemMapEquation_initPartition, 'calcCodelength' = MemMapEquation_calcCodelength, 'addMemoryContributions' = MemMapEquation_addMemoryContributions, 'getDeltaCodelengthOnMovingNode' = MemMapEquation_getDeltaCodelengthOnMovingNode, 'updateCodelengthOnMovingNode' = MemMapEquation_updateCodelengthOnMovingNode, 'consolidateModules' = MemMapEquation_consolidateModules, 'printDebug' = MemMapEquation_printDebug, 'codelength' = MemMapEquation_codelength_get, 'indexCodelength' = MemMapEquation_indexCodelength_get, 'moduleCodelength' = MemMapEquation_moduleCodelength_get);
  vaccessors = c('codelength', 'indexCodelength', 'moduleCodelength');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for infomap::MemMapEquation
# Start of accessor method for infomap::MemMapEquation
setMethod('$<-', '_p_infomap__MemMapEquation', function(x, name, value)

{
  accessorFuns = list('codelength' = MemMapEquation_codelength_set, 'indexCodelength' = MemMapEquation_indexCodelength_set, 'moduleCodelength' = MemMapEquation_moduleCodelength_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_infomap__MemMapEquation', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('codelength' = MemMapEquation_codelength_set, 'indexCodelength' = MemMapEquation_indexCodelength_set, 'moduleCodelength' = MemMapEquation_moduleCodelength_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for infomap::MemMapEquation
setMethod('delete', '_p_infomap__MemMapEquation', function(obj) {delete_infomap__MemMapEquation(obj)})
# Start of new_MemNodeSet

`MemNodeSet__SWIG_0` = function(numMemNodes, sumFlow)
{
  numMemNodes = as.integer(numMemNodes);
  
  if(length(numMemNodes) > 1) {
    warning("using only the first element of numMemNodes");
  };
  
  
  ;ans = .Call('R_swig_new_MemNodeSet__SWIG_0', numMemNodes, sumFlow, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__MemNodeSet", ref=ans);
  
  reg.finalizer(ans@ref, delete_MemNodeSet);
  ans
  
}

attr(`MemNodeSet__SWIG_0`, 'returnType') = '_p_infomap__MemNodeSet'
attr(`MemNodeSet__SWIG_0`, "inputTypes") = c('integer', 'numeric')
class(`MemNodeSet__SWIG_0`) = c("SWIGFunction", class('MemNodeSet__SWIG_0'))

# Start of new_MemNodeSet

`MemNodeSet__SWIG_1` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_new_MemNodeSet__SWIG_1', other, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__MemNodeSet", ref=ans);
  
  reg.finalizer(ans@ref, delete_MemNodeSet);
  ans
  
}

attr(`MemNodeSet__SWIG_1`, 'returnType') = '_p_infomap__MemNodeSet'
attr(`MemNodeSet__SWIG_1`, "inputTypes") = c('_p_infomap__MemNodeSet')
class(`MemNodeSet__SWIG_1`) = c("SWIGFunction", class('MemNodeSet__SWIG_1'))

`MemNodeSet` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_infomap__MemNodeSet') && length(argv[[1]]) == 1) {
      f <- MemNodeSet__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- MemNodeSet__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for MemNodeSet with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of MemNodeSet_Equal

`MemNodeSet_Equal` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_MemNodeSet_Equal', self, other, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__MemNodeSet", ref=ans);
  
  ans
  
}

attr(`MemNodeSet_Equal`, 'returnType') = '_p_infomap__MemNodeSet'
attr(`MemNodeSet_Equal`, "inputTypes") = c('_p_infomap__MemNodeSet', '_p_infomap__MemNodeSet')
class(`MemNodeSet_Equal`) = c("SWIGFunction", class('MemNodeSet_Equal'))

# Start of MemNodeSet_numMemNodes_set

`MemNodeSet_numMemNodes_set` = function(self, s_numMemNodes)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  s_numMemNodes = as.integer(s_numMemNodes);
  
  if(length(s_numMemNodes) > 1) {
    warning("using only the first element of s_numMemNodes");
  };
  
  ;.Call('R_swig_MemNodeSet_numMemNodes_set', self, s_numMemNodes, PACKAGE='infomap');
  
}

attr(`MemNodeSet_numMemNodes_set`, 'returnType') = 'void'
attr(`MemNodeSet_numMemNodes_set`, "inputTypes") = c('_p_infomap__MemNodeSet', 'integer')
class(`MemNodeSet_numMemNodes_set`) = c("SWIGFunction", class('MemNodeSet_numMemNodes_set'))

# Start of MemNodeSet_numMemNodes_get

`MemNodeSet_numMemNodes_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MemNodeSet_numMemNodes_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MemNodeSet_numMemNodes_get`, 'returnType') = 'integer'
attr(`MemNodeSet_numMemNodes_get`, "inputTypes") = c('_p_infomap__MemNodeSet')
class(`MemNodeSet_numMemNodes_get`) = c("SWIGFunction", class('MemNodeSet_numMemNodes_get'))

# Start of MemNodeSet_sumFlow_set

`MemNodeSet_sumFlow_set` = function(self, s_sumFlow)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_MemNodeSet_sumFlow_set', self, s_sumFlow, PACKAGE='infomap');
  
}

attr(`MemNodeSet_sumFlow_set`, 'returnType') = 'void'
attr(`MemNodeSet_sumFlow_set`, "inputTypes") = c('_p_infomap__MemNodeSet', 'numeric')
class(`MemNodeSet_sumFlow_set`) = c("SWIGFunction", class('MemNodeSet_sumFlow_set'))

# Start of MemNodeSet_sumFlow_get

`MemNodeSet_sumFlow_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MemNodeSet_sumFlow_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MemNodeSet_sumFlow_get`, 'returnType') = 'numeric'
attr(`MemNodeSet_sumFlow_get`, "inputTypes") = c('_p_infomap__MemNodeSet')
class(`MemNodeSet_sumFlow_get`) = c("SWIGFunction", class('MemNodeSet_sumFlow_get'))

# Start of delete_MemNodeSet

`delete_MemNodeSet` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_MemNodeSet', self, PACKAGE='infomap');
  
}

attr(`delete_MemNodeSet`, 'returnType') = 'void'
attr(`delete_MemNodeSet`, "inputTypes") = c('_p_infomap__MemNodeSet')
class(`delete_MemNodeSet`) = c("SWIGFunction", class('delete_MemNodeSet'))

# Start of accessor method for infomap::MemNodeSet
setMethod('$', '_p_infomap__MemNodeSet', function(x, name)

{
  accessorFuns = list('Equal' = MemNodeSet_Equal, 'numMemNodes' = MemNodeSet_numMemNodes_get, 'sumFlow' = MemNodeSet_sumFlow_get);
  vaccessors = c('numMemNodes', 'sumFlow');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for infomap::MemNodeSet
# Start of accessor method for infomap::MemNodeSet
setMethod('$<-', '_p_infomap__MemNodeSet', function(x, name, value)

{
  accessorFuns = list('numMemNodes' = MemNodeSet_numMemNodes_set, 'sumFlow' = MemNodeSet_sumFlow_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_infomap__MemNodeSet', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('numMemNodes' = MemNodeSet_numMemNodes_set, 'sumFlow' = MemNodeSet_sumFlow_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for infomap::MemNodeSet
setMethod('delete', '_p_infomap__MemNodeSet', function(obj) {delete_infomap__MemNodeSet(obj)})
# Start definition of copy functions & methods for infomap::MemNodeSet
CopyToR_infomap__MemNodeSet = function(value, obj = new("infomap::MemNodeSet"))
{
  obj@numMemNodes = value$numMemNodes;
  obj@sumFlow = value$sumFlow;
  obj;
}



CopyToC_infomap__MemNodeSet = function(value, obj)
{
  obj$numMemNodes = value@numMemNodes;
  obj$sumFlow = value@sumFlow;
  obj
}



# Start definition of copy methods for infomap::MemNodeSet
setMethod('copyToR', '_p_infomap::MemNodeSet', CopyToR_infomap__MemNodeSet);
setMethod('copyToC', 'infomap::MemNodeSet', CopyToC_infomap__MemNodeSet);

# End definition of copy methods for infomap::MemNodeSet
# End definition of copy functions & methods for infomap::MemNodeSet
# Start of new_MetaMapEquation

`MetaMapEquation__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_MetaMapEquation__SWIG_0', PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__MetaMapEquation", ref=ans);
  
  reg.finalizer(ans@ref, delete_MetaMapEquation);
  ans
  
}

attr(`MetaMapEquation__SWIG_0`, 'returnType') = '_p_infomap__MetaMapEquation'
class(`MetaMapEquation__SWIG_0`) = c("SWIGFunction", class('MetaMapEquation__SWIG_0'))

# Start of new_MetaMapEquation

`MetaMapEquation__SWIG_1` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_new_MetaMapEquation__SWIG_1', other, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__MetaMapEquation", ref=ans);
  
  reg.finalizer(ans@ref, delete_MetaMapEquation);
  ans
  
}

attr(`MetaMapEquation__SWIG_1`, 'returnType') = '_p_infomap__MetaMapEquation'
attr(`MetaMapEquation__SWIG_1`, "inputTypes") = c('_p_infomap__MetaMapEquation')
class(`MetaMapEquation__SWIG_1`) = c("SWIGFunction", class('MetaMapEquation__SWIG_1'))

`MetaMapEquation` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- MetaMapEquation__SWIG_0; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_infomap__MetaMapEquation') && length(argv[[1]]) == 1) {
      f <- MetaMapEquation__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for MetaMapEquation with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of MetaMapEquation_Equal

`MetaMapEquation_Equal` = function(self, other, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_MetaMapEquation_Equal', self, other, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__MetaMapEquation", ref=ans);
  
  ans
  
}

attr(`MetaMapEquation_Equal`, 'returnType') = '_p_infomap__MetaMapEquation'
attr(`MetaMapEquation_Equal`, "inputTypes") = c('_p_infomap__MetaMapEquation', '_p_infomap__MetaMapEquation')
class(`MetaMapEquation_Equal`) = c("SWIGFunction", class('MetaMapEquation_Equal'))

# Start of delete_MetaMapEquation

`delete_MetaMapEquation` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_MetaMapEquation', self, PACKAGE='infomap');
  
}

attr(`delete_MetaMapEquation`, 'returnType') = 'void'
attr(`delete_MetaMapEquation`, "inputTypes") = c('_p_infomap__MetaMapEquation')
class(`delete_MetaMapEquation`) = c("SWIGFunction", class('delete_MetaMapEquation'))

# Start of MetaMapEquation_getIndexCodelength

`MetaMapEquation_getIndexCodelength` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MetaMapEquation_getIndexCodelength', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MetaMapEquation_getIndexCodelength`, 'returnType') = 'numeric'
attr(`MetaMapEquation_getIndexCodelength`, "inputTypes") = c('_p_infomap__MetaMapEquation')
class(`MetaMapEquation_getIndexCodelength`) = c("SWIGFunction", class('MetaMapEquation_getIndexCodelength'))

# Start of MetaMapEquation_getModuleCodelength

`MetaMapEquation_getModuleCodelength` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MetaMapEquation_getModuleCodelength', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MetaMapEquation_getModuleCodelength`, 'returnType') = 'numeric'
attr(`MetaMapEquation_getModuleCodelength`, "inputTypes") = c('_p_infomap__MetaMapEquation')
class(`MetaMapEquation_getModuleCodelength`) = c("SWIGFunction", class('MetaMapEquation_getModuleCodelength'))

# Start of MetaMapEquation_getCodelength

`MetaMapEquation_getCodelength` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MetaMapEquation_getCodelength', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MetaMapEquation_getCodelength`, 'returnType') = 'numeric'
attr(`MetaMapEquation_getCodelength`, "inputTypes") = c('_p_infomap__MetaMapEquation')
class(`MetaMapEquation_getCodelength`) = c("SWIGFunction", class('MetaMapEquation_getCodelength'))

# Start of MetaMapEquation_getMetaCodelength

`MetaMapEquation_getMetaCodelength__SWIG_0` = function(self, unweighted, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  unweighted = as.logical(unweighted);
  ;.Call('R_swig_MetaMapEquation_getMetaCodelength__SWIG_0', self, unweighted, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MetaMapEquation_getMetaCodelength__SWIG_0`, 'returnType') = 'numeric'
attr(`MetaMapEquation_getMetaCodelength__SWIG_0`, "inputTypes") = c('_p_infomap__MetaMapEquation', 'logical')
class(`MetaMapEquation_getMetaCodelength__SWIG_0`) = c("SWIGFunction", class('MetaMapEquation_getMetaCodelength__SWIG_0'))

# Start of MetaMapEquation_getMetaCodelength

`MetaMapEquation_getMetaCodelength__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MetaMapEquation_getMetaCodelength__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MetaMapEquation_getMetaCodelength__SWIG_1`, 'returnType') = 'numeric'
attr(`MetaMapEquation_getMetaCodelength__SWIG_1`, "inputTypes") = c('_p_infomap__MetaMapEquation')
class(`MetaMapEquation_getMetaCodelength__SWIG_1`) = c("SWIGFunction", class('MetaMapEquation_getMetaCodelength__SWIG_1'))

`MetaMapEquation_getMetaCodelength` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__MetaMapEquation') || is.null(argv[[1]]))) {
      f <- MetaMapEquation_getMetaCodelength__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__MetaMapEquation') || is.null(argv[[1]])) && ( is.logical(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- MetaMapEquation_getMetaCodelength__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for MetaMapEquation_getMetaCodelength with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of MetaMapEquation_print

`MetaMapEquation_print` = function(self, out, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(out, "ExternalReference")) out = slot(out,"ref"); 
  ;ans = .Call('R_swig_MetaMapEquation_print', self, out, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__ostream", ref=ans);
  
  ans
  
}

attr(`MetaMapEquation_print`, 'returnType') = '_p_std__ostream'
attr(`MetaMapEquation_print`, "inputTypes") = c('_p_infomap__MetaMapEquation', '_p_std__ostream')
class(`MetaMapEquation_print`) = c("SWIGFunction", class('MetaMapEquation_print'))

# Start of MetaMapEquation_init

`MetaMapEquation_init` = function(self, config)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(config, "ExternalReference")) config = slot(config,"ref"); 
  ;.Call('R_swig_MetaMapEquation_init', self, config, PACKAGE='infomap');
  
}

attr(`MetaMapEquation_init`, 'returnType') = 'void'
attr(`MetaMapEquation_init`, "inputTypes") = c('_p_infomap__MetaMapEquation', '_p_infomap__Config')
class(`MetaMapEquation_init`) = c("SWIGFunction", class('MetaMapEquation_init'))

# Start of MetaMapEquation_initNetwork

`MetaMapEquation_initNetwork` = function(self, root)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(root, "ExternalReference")) root = slot(root,"ref"); 
  ;.Call('R_swig_MetaMapEquation_initNetwork', self, root, PACKAGE='infomap');
  
}

attr(`MetaMapEquation_initNetwork`, 'returnType') = 'void'
attr(`MetaMapEquation_initNetwork`, "inputTypes") = c('_p_infomap__MetaMapEquation', '_p_infomap__InfoNode')
class(`MetaMapEquation_initNetwork`) = c("SWIGFunction", class('MetaMapEquation_initNetwork'))

# Start of MetaMapEquation_initSuperNetwork

`MetaMapEquation_initSuperNetwork` = function(self, root)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(root, "ExternalReference")) root = slot(root,"ref"); 
  ;.Call('R_swig_MetaMapEquation_initSuperNetwork', self, root, PACKAGE='infomap');
  
}

attr(`MetaMapEquation_initSuperNetwork`, 'returnType') = 'void'
attr(`MetaMapEquation_initSuperNetwork`, "inputTypes") = c('_p_infomap__MetaMapEquation', '_p_infomap__InfoNode')
class(`MetaMapEquation_initSuperNetwork`) = c("SWIGFunction", class('MetaMapEquation_initSuperNetwork'))

# Start of MetaMapEquation_initSubNetwork

`MetaMapEquation_initSubNetwork` = function(self, root)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(root, "ExternalReference")) root = slot(root,"ref"); 
  ;.Call('R_swig_MetaMapEquation_initSubNetwork', self, root, PACKAGE='infomap');
  
}

attr(`MetaMapEquation_initSubNetwork`, 'returnType') = 'void'
attr(`MetaMapEquation_initSubNetwork`, "inputTypes") = c('_p_infomap__MetaMapEquation', '_p_infomap__InfoNode')
class(`MetaMapEquation_initSubNetwork`) = c("SWIGFunction", class('MetaMapEquation_initSubNetwork'))

# Start of MetaMapEquation_initPartition

`MetaMapEquation_initPartition` = function(self, nodes)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(nodes, "ExternalReference")) nodes = slot(nodes,"ref"); 
  ;.Call('R_swig_MetaMapEquation_initPartition', self, nodes, PACKAGE='infomap');
  
}

attr(`MetaMapEquation_initPartition`, 'returnType') = 'void'
attr(`MetaMapEquation_initPartition`, "inputTypes") = c('_p_infomap__MetaMapEquation', '_p_std__vectorT_infomap__InfoNode_p_std__allocatorT_infomap__InfoNode_p_t_t')
class(`MetaMapEquation_initPartition`) = c("SWIGFunction", class('MetaMapEquation_initPartition'))

# Start of MetaMapEquation_calcCodelength

`MetaMapEquation_calcCodelength` = function(self, parent, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(parent, "ExternalReference")) parent = slot(parent,"ref"); 
  ;.Call('R_swig_MetaMapEquation_calcCodelength', self, parent, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MetaMapEquation_calcCodelength`, 'returnType') = 'numeric'
attr(`MetaMapEquation_calcCodelength`, "inputTypes") = c('_p_infomap__MetaMapEquation', '_p_infomap__InfoNode')
class(`MetaMapEquation_calcCodelength`) = c("SWIGFunction", class('MetaMapEquation_calcCodelength'))

# Start of MetaMapEquation_addMemoryContributions

`MetaMapEquation_addMemoryContributions` = function(self, current, oldModuleDelta, moduleDeltaFlow)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(current, "ExternalReference")) current = slot(current,"ref"); 
  if (inherits(oldModuleDelta, "ExternalReference")) oldModuleDelta = slot(oldModuleDelta,"ref"); 
  if (inherits(moduleDeltaFlow, "ExternalReference")) moduleDeltaFlow = slot(moduleDeltaFlow,"ref"); 
  ;.Call('R_swig_MetaMapEquation_addMemoryContributions', self, current, oldModuleDelta, moduleDeltaFlow, PACKAGE='infomap');
  
}

attr(`MetaMapEquation_addMemoryContributions`, 'returnType') = 'void'
attr(`MetaMapEquation_addMemoryContributions`, "inputTypes") = c('_p_infomap__MetaMapEquation', '_p_infomap__InfoNode', '_p_infomap__DeltaFlow', '_p_VectorMapT_infomap__DeltaFlow_t')
class(`MetaMapEquation_addMemoryContributions`) = c("SWIGFunction", class('MetaMapEquation_addMemoryContributions'))

# Start of MetaMapEquation_getDeltaCodelengthOnMovingNode

`MetaMapEquation_getDeltaCodelengthOnMovingNode` = function(self, current, oldModuleDelta, newModuleDelta, moduleFlowData, moduleMembers, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(current, "ExternalReference")) current = slot(current,"ref"); 
  if (inherits(oldModuleDelta, "ExternalReference")) oldModuleDelta = slot(oldModuleDelta,"ref"); 
  if (inherits(newModuleDelta, "ExternalReference")) newModuleDelta = slot(newModuleDelta,"ref"); 
  if (inherits(moduleFlowData, "ExternalReference")) moduleFlowData = slot(moduleFlowData,"ref"); 
  moduleMembers = as.integer(moduleMembers);
  ;.Call('R_swig_MetaMapEquation_getDeltaCodelengthOnMovingNode', self, current, oldModuleDelta, newModuleDelta, moduleFlowData, moduleMembers, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MetaMapEquation_getDeltaCodelengthOnMovingNode`, 'returnType') = 'numeric'
attr(`MetaMapEquation_getDeltaCodelengthOnMovingNode`, "inputTypes") = c('_p_infomap__MetaMapEquation', '_p_infomap__InfoNode', '_p_infomap__DeltaFlow', '_p_infomap__DeltaFlow', '_p_std__vectorT_infomap__FlowData_std__allocatorT_infomap__FlowData_t_t', 'integer')
class(`MetaMapEquation_getDeltaCodelengthOnMovingNode`) = c("SWIGFunction", class('MetaMapEquation_getDeltaCodelengthOnMovingNode'))

# Start of MetaMapEquation_updateCodelengthOnMovingNode

`MetaMapEquation_updateCodelengthOnMovingNode` = function(self, current, oldModuleDelta, newModuleDelta, moduleFlowData, moduleMembers)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(current, "ExternalReference")) current = slot(current,"ref"); 
  if (inherits(oldModuleDelta, "ExternalReference")) oldModuleDelta = slot(oldModuleDelta,"ref"); 
  if (inherits(newModuleDelta, "ExternalReference")) newModuleDelta = slot(newModuleDelta,"ref"); 
  if (inherits(moduleFlowData, "ExternalReference")) moduleFlowData = slot(moduleFlowData,"ref"); 
  moduleMembers = as.integer(moduleMembers);
  ;.Call('R_swig_MetaMapEquation_updateCodelengthOnMovingNode', self, current, oldModuleDelta, newModuleDelta, moduleFlowData, moduleMembers, PACKAGE='infomap');
  
}

attr(`MetaMapEquation_updateCodelengthOnMovingNode`, 'returnType') = 'void'
attr(`MetaMapEquation_updateCodelengthOnMovingNode`, "inputTypes") = c('_p_infomap__MetaMapEquation', '_p_infomap__InfoNode', '_p_infomap__DeltaFlow', '_p_infomap__DeltaFlow', '_p_std__vectorT_infomap__FlowData_std__allocatorT_infomap__FlowData_t_t', 'integer')
class(`MetaMapEquation_updateCodelengthOnMovingNode`) = c("SWIGFunction", class('MetaMapEquation_updateCodelengthOnMovingNode'))

# Start of MetaMapEquation_consolidateModules

`MetaMapEquation_consolidateModules` = function(self, modules)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(modules, "ExternalReference")) modules = slot(modules,"ref"); 
  ;.Call('R_swig_MetaMapEquation_consolidateModules', self, modules, PACKAGE='infomap');
  
}

attr(`MetaMapEquation_consolidateModules`, 'returnType') = 'void'
attr(`MetaMapEquation_consolidateModules`, "inputTypes") = c('_p_infomap__MetaMapEquation', '_p_std__vectorT_infomap__InfoNode_p_std__allocatorT_infomap__InfoNode_p_t_t')
class(`MetaMapEquation_consolidateModules`) = c("SWIGFunction", class('MetaMapEquation_consolidateModules'))

# Start of MetaMapEquation_printDebug

`MetaMapEquation_printDebug` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MetaMapEquation_printDebug', self, PACKAGE='infomap');
  
}

attr(`MetaMapEquation_printDebug`, 'returnType') = 'void'
attr(`MetaMapEquation_printDebug`, "inputTypes") = c('_p_infomap__MetaMapEquation')
class(`MetaMapEquation_printDebug`) = c("SWIGFunction", class('MetaMapEquation_printDebug'))

# Start of MetaMapEquation_codelength_set

`MetaMapEquation_codelength_set` = function(self, s_codelength)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_MetaMapEquation_codelength_set', self, s_codelength, PACKAGE='infomap');
  
}

attr(`MetaMapEquation_codelength_set`, 'returnType') = 'void'
attr(`MetaMapEquation_codelength_set`, "inputTypes") = c('_p_infomap__MetaMapEquation', 'numeric')
class(`MetaMapEquation_codelength_set`) = c("SWIGFunction", class('MetaMapEquation_codelength_set'))

# Start of MetaMapEquation_codelength_get

`MetaMapEquation_codelength_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MetaMapEquation_codelength_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MetaMapEquation_codelength_get`, 'returnType') = 'numeric'
attr(`MetaMapEquation_codelength_get`, "inputTypes") = c('_p_infomap__MetaMapEquation')
class(`MetaMapEquation_codelength_get`) = c("SWIGFunction", class('MetaMapEquation_codelength_get'))

# Start of MetaMapEquation_indexCodelength_set

`MetaMapEquation_indexCodelength_set` = function(self, s_indexCodelength)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_MetaMapEquation_indexCodelength_set', self, s_indexCodelength, PACKAGE='infomap');
  
}

attr(`MetaMapEquation_indexCodelength_set`, 'returnType') = 'void'
attr(`MetaMapEquation_indexCodelength_set`, "inputTypes") = c('_p_infomap__MetaMapEquation', 'numeric')
class(`MetaMapEquation_indexCodelength_set`) = c("SWIGFunction", class('MetaMapEquation_indexCodelength_set'))

# Start of MetaMapEquation_indexCodelength_get

`MetaMapEquation_indexCodelength_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MetaMapEquation_indexCodelength_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MetaMapEquation_indexCodelength_get`, 'returnType') = 'numeric'
attr(`MetaMapEquation_indexCodelength_get`, "inputTypes") = c('_p_infomap__MetaMapEquation')
class(`MetaMapEquation_indexCodelength_get`) = c("SWIGFunction", class('MetaMapEquation_indexCodelength_get'))

# Start of MetaMapEquation_moduleCodelength_set

`MetaMapEquation_moduleCodelength_set` = function(self, s_moduleCodelength)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  
  ;.Call('R_swig_MetaMapEquation_moduleCodelength_set', self, s_moduleCodelength, PACKAGE='infomap');
  
}

attr(`MetaMapEquation_moduleCodelength_set`, 'returnType') = 'void'
attr(`MetaMapEquation_moduleCodelength_set`, "inputTypes") = c('_p_infomap__MetaMapEquation', 'numeric')
class(`MetaMapEquation_moduleCodelength_set`) = c("SWIGFunction", class('MetaMapEquation_moduleCodelength_set'))

# Start of MetaMapEquation_moduleCodelength_get

`MetaMapEquation_moduleCodelength_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_MetaMapEquation_moduleCodelength_get', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`MetaMapEquation_moduleCodelength_get`, 'returnType') = 'numeric'
attr(`MetaMapEquation_moduleCodelength_get`, "inputTypes") = c('_p_infomap__MetaMapEquation')
class(`MetaMapEquation_moduleCodelength_get`) = c("SWIGFunction", class('MetaMapEquation_moduleCodelength_get'))

# Start of accessor method for infomap::MetaMapEquation
setMethod('$', '_p_infomap__MetaMapEquation', function(x, name)

{
  accessorFuns = list('Equal' = MetaMapEquation_Equal, 'getIndexCodelength' = MetaMapEquation_getIndexCodelength, 'getModuleCodelength' = MetaMapEquation_getModuleCodelength, 'getCodelength' = MetaMapEquation_getCodelength, 'getMetaCodelength' = MetaMapEquation_getMetaCodelength, 'print' = MetaMapEquation_print, 'init' = MetaMapEquation_init, 'initNetwork' = MetaMapEquation_initNetwork, 'initSuperNetwork' = MetaMapEquation_initSuperNetwork, 'initSubNetwork' = MetaMapEquation_initSubNetwork, 'initPartition' = MetaMapEquation_initPartition, 'calcCodelength' = MetaMapEquation_calcCodelength, 'addMemoryContributions' = MetaMapEquation_addMemoryContributions, 'getDeltaCodelengthOnMovingNode' = MetaMapEquation_getDeltaCodelengthOnMovingNode, 'updateCodelengthOnMovingNode' = MetaMapEquation_updateCodelengthOnMovingNode, 'consolidateModules' = MetaMapEquation_consolidateModules, 'printDebug' = MetaMapEquation_printDebug, 'codelength' = MetaMapEquation_codelength_get, 'indexCodelength' = MetaMapEquation_indexCodelength_get, 'moduleCodelength' = MetaMapEquation_moduleCodelength_get);
  vaccessors = c('codelength', 'indexCodelength', 'moduleCodelength');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for infomap::MetaMapEquation
# Start of accessor method for infomap::MetaMapEquation
setMethod('$<-', '_p_infomap__MetaMapEquation', function(x, name, value)

{
  accessorFuns = list('codelength' = MetaMapEquation_codelength_set, 'indexCodelength' = MetaMapEquation_indexCodelength_set, 'moduleCodelength' = MetaMapEquation_moduleCodelength_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_infomap__MetaMapEquation', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('codelength' = MetaMapEquation_codelength_set, 'indexCodelength' = MetaMapEquation_indexCodelength_set, 'moduleCodelength' = MetaMapEquation_moduleCodelength_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for infomap::MetaMapEquation
setMethod('delete', '_p_infomap__MetaMapEquation', function(obj) {delete_infomap__MetaMapEquation(obj)})
# Start of new_InfomapCore

`InfomapCore__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_InfomapCore__SWIG_0', PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapCore", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfomapCore);
  ans
  
}

attr(`InfomapCore__SWIG_0`, 'returnType') = '_p_infomap__InfomapCore'
class(`InfomapCore__SWIG_0`) = c("SWIGFunction", class('InfomapCore__SWIG_0'))

# Start of new_InfomapCore

`InfomapCore__SWIG_1` = function(flags)
{
  flags = as(flags, "character"); 
  ;ans = .Call('R_swig_new_InfomapCore__SWIG_1', flags, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapCore", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfomapCore);
  ans
  
}

attr(`InfomapCore__SWIG_1`, 'returnType') = '_p_infomap__InfomapCore'
attr(`InfomapCore__SWIG_1`, "inputTypes") = c('character')
class(`InfomapCore__SWIG_1`) = c("SWIGFunction", class('InfomapCore__SWIG_1'))

# Start of new_InfomapCore

`InfomapCore__SWIG_2` = function(conf)
{
  if (inherits(conf, "ExternalReference")) conf = slot(conf,"ref"); 
  ;ans = .Call('R_swig_new_InfomapCore__SWIG_2', conf, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapCore", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfomapCore);
  ans
  
}

attr(`InfomapCore__SWIG_2`, 'returnType') = '_p_infomap__InfomapCore'
attr(`InfomapCore__SWIG_2`, "inputTypes") = c('_p_infomap__Config')
class(`InfomapCore__SWIG_2`) = c("SWIGFunction", class('InfomapCore__SWIG_2'))

`InfomapCore` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 0) {
    f <- InfomapCore__SWIG_0; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_infomap__Config') && length(argv[[1]]) == 1) {
      f <- InfomapCore__SWIG_2; 
    }
    else if (is.character(argv[[1]]) && length(argv[[1]]) == 1) {
      f <- InfomapCore__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapCore with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_InfomapCore

`delete_InfomapCore` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_InfomapCore', self, PACKAGE='infomap');
  
}

attr(`delete_InfomapCore`, 'returnType') = 'void'
attr(`delete_InfomapCore`, "inputTypes") = c('_p_infomap__InfomapCore')
class(`delete_InfomapCore`) = c("SWIGFunction", class('delete_InfomapCore'))

# Start of InfomapCore_toString

`InfomapCore_toString` = function(self, out, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(out, "ExternalReference")) out = slot(out,"ref"); 
  ;ans = .Call('R_swig_InfomapCore_toString', self, out, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__ostream", ref=ans);
  
  ans
  
}

attr(`InfomapCore_toString`, 'returnType') = '_p_std__ostream'
attr(`InfomapCore_toString`, "inputTypes") = c('_p_infomap__InfomapCore', '_p_std__ostream')
class(`InfomapCore_toString`) = c("SWIGFunction", class('InfomapCore_toString'))

# Start of InfomapCore_getCodelength

`InfomapCore_getCodelength` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapCore_getCodelength', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapCore_getCodelength`, 'returnType') = 'numeric'
attr(`InfomapCore_getCodelength`, "inputTypes") = c('_p_infomap__InfomapCore')
class(`InfomapCore_getCodelength`) = c("SWIGFunction", class('InfomapCore_getCodelength'))

# Start of InfomapCore_getIndexCodelength

`InfomapCore_getIndexCodelength` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapCore_getIndexCodelength', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapCore_getIndexCodelength`, 'returnType') = 'numeric'
attr(`InfomapCore_getIndexCodelength`, "inputTypes") = c('_p_infomap__InfomapCore')
class(`InfomapCore_getIndexCodelength`) = c("SWIGFunction", class('InfomapCore_getIndexCodelength'))

# Start of InfomapCore_getModuleCodelength

`InfomapCore_getModuleCodelength` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapCore_getModuleCodelength', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapCore_getModuleCodelength`, 'returnType') = 'numeric'
attr(`InfomapCore_getModuleCodelength`, "inputTypes") = c('_p_infomap__InfomapCore')
class(`InfomapCore_getModuleCodelength`) = c("SWIGFunction", class('InfomapCore_getModuleCodelength'))

# Start of InfomapCore_getMetaCodelength

`InfomapCore_getMetaCodelength__SWIG_0` = function(self, unweighted, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  unweighted = as.logical(unweighted);
  ;.Call('R_swig_InfomapCore_getMetaCodelength__SWIG_0', self, unweighted, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapCore_getMetaCodelength__SWIG_0`, 'returnType') = 'numeric'
attr(`InfomapCore_getMetaCodelength__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapCore', 'logical')
class(`InfomapCore_getMetaCodelength__SWIG_0`) = c("SWIGFunction", class('InfomapCore_getMetaCodelength__SWIG_0'))

# Start of InfomapCore_getMetaCodelength

`InfomapCore_getMetaCodelength__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapCore_getMetaCodelength__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapCore_getMetaCodelength__SWIG_1`, 'returnType') = 'numeric'
attr(`InfomapCore_getMetaCodelength__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapCore')
class(`InfomapCore_getMetaCodelength__SWIG_1`) = c("SWIGFunction", class('InfomapCore_getMetaCodelength__SWIG_1'))

`InfomapCore_getMetaCodelength` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapCore') || is.null(argv[[1]]))) {
      f <- InfomapCore_getMetaCodelength__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapCore') || is.null(argv[[1]])) && ( is.logical(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- InfomapCore_getMetaCodelength__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InfomapCore_getMetaCodelength with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of accessor method for infomap::InfomapCore
setMethod('$', '_p_infomap__InfomapCore', function(x, name)

{
  accessorFuns = list('toString' = InfomapCore_toString, 'getCodelength' = InfomapCore_getCodelength, 'getIndexCodelength' = InfomapCore_getIndexCodelength, 'getModuleCodelength' = InfomapCore_getModuleCodelength, 'getMetaCodelength' = InfomapCore_getMetaCodelength);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for infomap::InfomapCore
setMethod('delete', '_p_infomap__InfomapCore', function(obj) {delete_infomap__InfomapCore(obj)})
# Start of new_map_uint_vector_uint

`map_uint_vector_uint__SWIG_0` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_new_map_uint_vector_uint__SWIG_0', other, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_map_uint_vector_uint);
  ans
  
}

attr(`map_uint_vector_uint__SWIG_0`, 'returnType') = '_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t'
attr(`map_uint_vector_uint__SWIG_0`, "inputTypes") = c('_p_std__lessT_unsigned_int_t')
class(`map_uint_vector_uint__SWIG_0`) = c("SWIGFunction", class('map_uint_vector_uint__SWIG_0'))

# Start of new_map_uint_vector_uint

`map_uint_vector_uint__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_map_uint_vector_uint__SWIG_1', PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_map_uint_vector_uint);
  ans
  
}

attr(`map_uint_vector_uint__SWIG_1`, 'returnType') = '_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t'
class(`map_uint_vector_uint__SWIG_1`) = c("SWIGFunction", class('map_uint_vector_uint__SWIG_1'))

# Start of new_map_uint_vector_uint

`map_uint_vector_uint__SWIG_2` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_new_map_uint_vector_uint__SWIG_2', other, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_map_uint_vector_uint);
  ans
  
}

attr(`map_uint_vector_uint__SWIG_2`, 'returnType') = '_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t'
attr(`map_uint_vector_uint__SWIG_2`, "inputTypes") = c('_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t')
class(`map_uint_vector_uint__SWIG_2`) = c("SWIGFunction", class('map_uint_vector_uint__SWIG_2'))

`map_uint_vector_uint` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 0) {
    f <- map_uint_vector_uint__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_std__lessT_unsigned_int_t') && length(argv[[1]]) == 1) {
      f <- map_uint_vector_uint__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t') && length(argv[[1]]) == 1) {
      f <- map_uint_vector_uint__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for map_uint_vector_uint with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of map_uint_vector_uint_empty

`map_uint_vector_uint_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_map_uint_vector_uint_empty', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`map_uint_vector_uint_empty`, 'returnType') = 'logical'
attr(`map_uint_vector_uint_empty`, "inputTypes") = c('_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t')
class(`map_uint_vector_uint_empty`) = c("SWIGFunction", class('map_uint_vector_uint_empty'))

# Start of map_uint_vector_uint_size

`map_uint_vector_uint_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_map_uint_vector_uint_size', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`map_uint_vector_uint_size`, 'returnType') = 'integer'
attr(`map_uint_vector_uint_size`, "inputTypes") = c('_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t')
class(`map_uint_vector_uint_size`) = c("SWIGFunction", class('map_uint_vector_uint_size'))

# Start of map_uint_vector_uint_swap

`map_uint_vector_uint_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref"); 
  ;.Call('R_swig_map_uint_vector_uint_swap', self, v, PACKAGE='infomap');
  
}

attr(`map_uint_vector_uint_swap`, 'returnType') = 'void'
attr(`map_uint_vector_uint_swap`, "inputTypes") = c('_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t', '_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t')
class(`map_uint_vector_uint_swap`) = c("SWIGFunction", class('map_uint_vector_uint_swap'))

# Start of map_uint_vector_uint_clear

`map_uint_vector_uint_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_map_uint_vector_uint_clear', self, PACKAGE='infomap');
  
}

attr(`map_uint_vector_uint_clear`, 'returnType') = 'void'
attr(`map_uint_vector_uint_clear`, "inputTypes") = c('_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t')
class(`map_uint_vector_uint_clear`) = c("SWIGFunction", class('map_uint_vector_uint_clear'))

# Start of map_uint_vector_uint_get_allocator

`map_uint_vector_uint_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_map_uint_vector_uint_get_allocator', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t", ref=ans);
  
  ans
  
}

attr(`map_uint_vector_uint_get_allocator`, 'returnType') = '_p_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t'
attr(`map_uint_vector_uint_get_allocator`, "inputTypes") = c('_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t')
class(`map_uint_vector_uint_get_allocator`) = c("SWIGFunction", class('map_uint_vector_uint_get_allocator'))

# Start of map_uint_vector_uint_erase

`map_uint_vector_uint_erase` = function(self, x, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_map_uint_vector_uint_erase', self, x, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`map_uint_vector_uint_erase`, 'returnType') = 'integer'
attr(`map_uint_vector_uint_erase`, "inputTypes") = c('_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t', '_p_unsigned_int')
class(`map_uint_vector_uint_erase`) = c("SWIGFunction", class('map_uint_vector_uint_erase'))

# Start of map_uint_vector_uint_count

`map_uint_vector_uint_count` = function(self, x, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_map_uint_vector_uint_count', self, x, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`map_uint_vector_uint_count`, 'returnType') = 'integer'
attr(`map_uint_vector_uint_count`, "inputTypes") = c('_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t', '_p_unsigned_int')
class(`map_uint_vector_uint_count`) = c("SWIGFunction", class('map_uint_vector_uint_count'))

# Start of delete_map_uint_vector_uint

`delete_map_uint_vector_uint` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_map_uint_vector_uint', self, PACKAGE='infomap');
  
}

attr(`delete_map_uint_vector_uint`, 'returnType') = 'void'
attr(`delete_map_uint_vector_uint`, "inputTypes") = c('_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t')
class(`delete_map_uint_vector_uint`) = c("SWIGFunction", class('delete_map_uint_vector_uint'))

# Start of accessor method for std::map< unsigned int,std::vector< unsigned int > >
setMethod('$', '_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t', function(x, name)

{
  accessorFuns = list('empty' = map_uint_vector_uint_empty, 'size' = map_uint_vector_uint_size, 'swap' = map_uint_vector_uint_swap, 'clear' = map_uint_vector_uint_clear, 'get_allocator' = map_uint_vector_uint_get_allocator, 'erase' = map_uint_vector_uint_erase, 'count' = map_uint_vector_uint_count);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::map< unsigned int,std::vector< unsigned int > >
setMethod('delete', '_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t', function(obj) {delete_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t(obj)})
# Start of new_map_uint_string

`map_uint_string__SWIG_0` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_new_map_uint_string__SWIG_0', other, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_map_uint_string);
  ans
  
}

attr(`map_uint_string__SWIG_0`, 'returnType') = '_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t'
attr(`map_uint_string__SWIG_0`, "inputTypes") = c('_p_std__lessT_unsigned_int_t')
class(`map_uint_string__SWIG_0`) = c("SWIGFunction", class('map_uint_string__SWIG_0'))

# Start of new_map_uint_string

`map_uint_string__SWIG_1` = function()
{
  ;ans = .Call('R_swig_new_map_uint_string__SWIG_1', PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_map_uint_string);
  ans
  
}

attr(`map_uint_string__SWIG_1`, 'returnType') = '_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t'
class(`map_uint_string__SWIG_1`) = c("SWIGFunction", class('map_uint_string__SWIG_1'))

# Start of new_map_uint_string

`map_uint_string__SWIG_2` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref"); 
  ;ans = .Call('R_swig_new_map_uint_string__SWIG_2', other, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_map_uint_string);
  ans
  
}

attr(`map_uint_string__SWIG_2`, 'returnType') = '_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t'
attr(`map_uint_string__SWIG_2`, "inputTypes") = c('_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t')
class(`map_uint_string__SWIG_2`) = c("SWIGFunction", class('map_uint_string__SWIG_2'))

`map_uint_string` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 0) {
    f <- map_uint_string__SWIG_1; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_std__lessT_unsigned_int_t') && length(argv[[1]]) == 1) {
      f <- map_uint_string__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t') && length(argv[[1]]) == 1) {
      f <- map_uint_string__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for map_uint_string with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of map_uint_string_empty

`map_uint_string_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_map_uint_string_empty', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`map_uint_string_empty`, 'returnType') = 'logical'
attr(`map_uint_string_empty`, "inputTypes") = c('_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t')
class(`map_uint_string_empty`) = c("SWIGFunction", class('map_uint_string_empty'))

# Start of map_uint_string_size

`map_uint_string_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_map_uint_string_size', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`map_uint_string_size`, 'returnType') = 'integer'
attr(`map_uint_string_size`, "inputTypes") = c('_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t')
class(`map_uint_string_size`) = c("SWIGFunction", class('map_uint_string_size'))

# Start of map_uint_string_swap

`map_uint_string_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref"); 
  ;.Call('R_swig_map_uint_string_swap', self, v, PACKAGE='infomap');
  
}

attr(`map_uint_string_swap`, 'returnType') = 'void'
attr(`map_uint_string_swap`, "inputTypes") = c('_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t', '_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t')
class(`map_uint_string_swap`) = c("SWIGFunction", class('map_uint_string_swap'))

# Start of map_uint_string_clear

`map_uint_string_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_map_uint_string_clear', self, PACKAGE='infomap');
  
}

attr(`map_uint_string_clear`, 'returnType') = 'void'
attr(`map_uint_string_clear`, "inputTypes") = c('_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t')
class(`map_uint_string_clear`) = c("SWIGFunction", class('map_uint_string_clear'))

# Start of map_uint_string_get_allocator

`map_uint_string_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_map_uint_string_get_allocator', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t", ref=ans);
  
  ans
  
}

attr(`map_uint_string_get_allocator`, 'returnType') = '_p_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t'
attr(`map_uint_string_get_allocator`, "inputTypes") = c('_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t')
class(`map_uint_string_get_allocator`) = c("SWIGFunction", class('map_uint_string_get_allocator'))

# Start of map_uint_string_erase

`map_uint_string_erase` = function(self, x, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_map_uint_string_erase', self, x, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`map_uint_string_erase`, 'returnType') = 'integer'
attr(`map_uint_string_erase`, "inputTypes") = c('_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t', '_p_unsigned_int')
class(`map_uint_string_erase`) = c("SWIGFunction", class('map_uint_string_erase'))

# Start of map_uint_string_count

`map_uint_string_count` = function(self, x, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref"); 
  ;.Call('R_swig_map_uint_string_count', self, x, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`map_uint_string_count`, 'returnType') = 'integer'
attr(`map_uint_string_count`, "inputTypes") = c('_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t', '_p_unsigned_int')
class(`map_uint_string_count`) = c("SWIGFunction", class('map_uint_string_count'))

# Start of delete_map_uint_string

`delete_map_uint_string` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_map_uint_string', self, PACKAGE='infomap');
  
}

attr(`delete_map_uint_string`, 'returnType') = 'void'
attr(`delete_map_uint_string`, "inputTypes") = c('_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t')
class(`delete_map_uint_string`) = c("SWIGFunction", class('delete_map_uint_string'))

# Start of accessor method for std::map< unsigned int,std::string >
setMethod('$', '_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t', function(x, name)

{
  accessorFuns = list('empty' = map_uint_string_empty, 'size' = map_uint_string_size, 'swap' = map_uint_string_swap, 'clear' = map_uint_string_clear, 'get_allocator' = map_uint_string_get_allocator, 'erase' = map_uint_string_erase, 'count' = map_uint_string_count);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::map< unsigned int,std::string >
setMethod('delete', '_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t', function(obj) {delete_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t(obj)})
# Start of new_InfomapWrapper

`InfomapWrapper__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_InfomapWrapper__SWIG_0', PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapWrapper", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfomapWrapper);
  ans
  
}

attr(`InfomapWrapper__SWIG_0`, 'returnType') = '_p_infomap__InfomapWrapper'
class(`InfomapWrapper__SWIG_0`) = c("SWIGFunction", class('InfomapWrapper__SWIG_0'))

# Start of new_InfomapWrapper

`InfomapWrapper__SWIG_1` = function(flags)
{
  flags = as(flags, "character"); 
  ;ans = .Call('R_swig_new_InfomapWrapper__SWIG_1', flags, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapWrapper", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfomapWrapper);
  ans
  
}

attr(`InfomapWrapper__SWIG_1`, 'returnType') = '_p_infomap__InfomapWrapper'
attr(`InfomapWrapper__SWIG_1`, "inputTypes") = c('character')
class(`InfomapWrapper__SWIG_1`) = c("SWIGFunction", class('InfomapWrapper__SWIG_1'))

# Start of new_InfomapWrapper

`InfomapWrapper__SWIG_2` = function(conf)
{
  if (inherits(conf, "ExternalReference")) conf = slot(conf,"ref"); 
  ;ans = .Call('R_swig_new_InfomapWrapper__SWIG_2', conf, PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapWrapper", ref=ans);
  
  reg.finalizer(ans@ref, delete_InfomapWrapper);
  ans
  
}

attr(`InfomapWrapper__SWIG_2`, 'returnType') = '_p_infomap__InfomapWrapper'
attr(`InfomapWrapper__SWIG_2`, "inputTypes") = c('_p_infomap__Config')
class(`InfomapWrapper__SWIG_2`) = c("SWIGFunction", class('InfomapWrapper__SWIG_2'))

`InfomapWrapper` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 0) {
    f <- InfomapWrapper__SWIG_0; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_infomap__Config') && length(argv[[1]]) == 1) {
      f <- InfomapWrapper__SWIG_2; 
    }
    else if (is.character(argv[[1]]) && length(argv[[1]]) == 1) {
      f <- InfomapWrapper__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for InfomapWrapper with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_InfomapWrapper

`delete_InfomapWrapper` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_delete_InfomapWrapper', self, PACKAGE='infomap');
  
}

attr(`delete_InfomapWrapper`, 'returnType') = 'void'
attr(`delete_InfomapWrapper`, "inputTypes") = c('_p_infomap__InfomapWrapper')
class(`delete_InfomapWrapper`) = c("SWIGFunction", class('delete_InfomapWrapper'))

# Start of InfomapWrapper_readInputData

`InfomapWrapper_readInputData__SWIG_0` = function(self, filename, accumulate)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  filename = as(filename, "character"); 
  accumulate = as.logical(accumulate);
  ;.Call('R_swig_InfomapWrapper_readInputData__SWIG_0', self, filename, accumulate, PACKAGE='infomap');
  
}

attr(`InfomapWrapper_readInputData__SWIG_0`, 'returnType') = 'void'
attr(`InfomapWrapper_readInputData__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapWrapper', 'character', 'logical')
class(`InfomapWrapper_readInputData__SWIG_0`) = c("SWIGFunction", class('InfomapWrapper_readInputData__SWIG_0'))

# Start of InfomapWrapper_readInputData

`InfomapWrapper_readInputData__SWIG_1` = function(self, filename)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  filename = as(filename, "character"); 
  ;.Call('R_swig_InfomapWrapper_readInputData__SWIG_1', self, filename, PACKAGE='infomap');
  
}

attr(`InfomapWrapper_readInputData__SWIG_1`, 'returnType') = 'void'
attr(`InfomapWrapper_readInputData__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapWrapper', 'character')
class(`InfomapWrapper_readInputData__SWIG_1`) = c("SWIGFunction", class('InfomapWrapper_readInputData__SWIG_1'))

# Start of InfomapWrapper_readInputData

`InfomapWrapper_readInputData__SWIG_2` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapWrapper_readInputData__SWIG_2', self, PACKAGE='infomap');
  
}

attr(`InfomapWrapper_readInputData__SWIG_2`, 'returnType') = 'void'
attr(`InfomapWrapper_readInputData__SWIG_2`, "inputTypes") = c('_p_infomap__InfomapWrapper')
class(`InfomapWrapper_readInputData__SWIG_2`) = c("SWIGFunction", class('InfomapWrapper_readInputData__SWIG_2'))

`InfomapWrapper_readInputData` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapWrapper') || is.null(argv[[1]]))) {
      f <- InfomapWrapper_readInputData__SWIG_2; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapWrapper') || is.null(argv[[1]])) && is.character(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- InfomapWrapper_readInputData__SWIG_1; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_infomap__InfomapWrapper') || is.null(argv[[1]])) && is.character(argv[[2]]) && length(argv[[2]]) == 1 && ( is.logical(argv[[3]]) && length(argv[[3]]) == 1 )) {
      f <- InfomapWrapper_readInputData__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InfomapWrapper_readInputData with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapWrapper_addNode

`InfomapWrapper_addNode__SWIG_0` = function(self, id)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  id = as.integer(id);
  
  if(length(id) > 1) {
    warning("using only the first element of id");
  };
  
  ;.Call('R_swig_InfomapWrapper_addNode__SWIG_0', self, id, PACKAGE='infomap');
  
}

attr(`InfomapWrapper_addNode__SWIG_0`, 'returnType') = 'void'
attr(`InfomapWrapper_addNode__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapWrapper', 'integer')
class(`InfomapWrapper_addNode__SWIG_0`) = c("SWIGFunction", class('InfomapWrapper_addNode__SWIG_0'))

# Start of InfomapWrapper_addNode

`InfomapWrapper_addNode__SWIG_1` = function(self, id, name)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  id = as.integer(id);
  
  if(length(id) > 1) {
    warning("using only the first element of id");
  };
  
  name = as(name, "character"); 
  ;.Call('R_swig_InfomapWrapper_addNode__SWIG_1', self, id, name, PACKAGE='infomap');
  
}

attr(`InfomapWrapper_addNode__SWIG_1`, 'returnType') = 'void'
attr(`InfomapWrapper_addNode__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapWrapper', 'integer', 'character')
class(`InfomapWrapper_addNode__SWIG_1`) = c("SWIGFunction", class('InfomapWrapper_addNode__SWIG_1'))

# Start of InfomapWrapper_addNode

`InfomapWrapper_addNode__SWIG_2` = function(self, id, weight)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  id = as.integer(id);
  
  if(length(id) > 1) {
    warning("using only the first element of id");
  };
  
  
  ;.Call('R_swig_InfomapWrapper_addNode__SWIG_2', self, id, weight, PACKAGE='infomap');
  
}

attr(`InfomapWrapper_addNode__SWIG_2`, 'returnType') = 'void'
attr(`InfomapWrapper_addNode__SWIG_2`, "inputTypes") = c('_p_infomap__InfomapWrapper', 'integer', 'numeric')
class(`InfomapWrapper_addNode__SWIG_2`) = c("SWIGFunction", class('InfomapWrapper_addNode__SWIG_2'))

# Start of InfomapWrapper_addNode

`InfomapWrapper_addNode__SWIG_3` = function(self, id, name, weight)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  id = as.integer(id);
  
  if(length(id) > 1) {
    warning("using only the first element of id");
  };
  
  name = as(name, "character"); 
  
  ;.Call('R_swig_InfomapWrapper_addNode__SWIG_3', self, id, name, weight, PACKAGE='infomap');
  
}

attr(`InfomapWrapper_addNode__SWIG_3`, 'returnType') = 'void'
attr(`InfomapWrapper_addNode__SWIG_3`, "inputTypes") = c('_p_infomap__InfomapWrapper', 'integer', 'character', 'numeric')
class(`InfomapWrapper_addNode__SWIG_3`) = c("SWIGFunction", class('InfomapWrapper_addNode__SWIG_3'))

`InfomapWrapper_addNode` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapWrapper') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- InfomapWrapper_addNode__SWIG_0; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_infomap__InfomapWrapper') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.numeric(argv[[3]]) && length(argv[[3]]) == 1 )) {
      f <- InfomapWrapper_addNode__SWIG_2; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapWrapper') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && is.character(argv[[3]]) && length(argv[[3]]) == 1) {
      f <- InfomapWrapper_addNode__SWIG_1; 
    }
  } else if (argc == 4) {
    if ((extends(argtypes[1], '_p_infomap__InfomapWrapper') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && is.character(argv[[3]]) && length(argv[[3]]) == 1 && ( is.numeric(argv[[4]]) && length(argv[[4]]) == 1 )) {
      f <- InfomapWrapper_addNode__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for InfomapWrapper_addNode with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapWrapper_addName

`InfomapWrapper_addName` = function(self, id, name)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  id = as.integer(id);
  
  if(length(id) > 1) {
    warning("using only the first element of id");
  };
  
  name = as(name, "character"); 
  ;.Call('R_swig_InfomapWrapper_addName', self, id, name, PACKAGE='infomap');
  
}

attr(`InfomapWrapper_addName`, 'returnType') = 'void'
attr(`InfomapWrapper_addName`, "inputTypes") = c('_p_infomap__InfomapWrapper', 'integer', 'character')
class(`InfomapWrapper_addName`) = c("SWIGFunction", class('InfomapWrapper_addName'))

# Start of InfomapWrapper_getName

`InfomapWrapper_getName` = function(self, id, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  id = as.integer(id);
  
  if(length(id) > 1) {
    warning("using only the first element of id");
  };
  
  ;.Call('R_swig_InfomapWrapper_getName', self, id, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapWrapper_getName`, 'returnType') = 'character'
attr(`InfomapWrapper_getName`, "inputTypes") = c('_p_infomap__InfomapWrapper', 'integer')
class(`InfomapWrapper_getName`) = c("SWIGFunction", class('InfomapWrapper_getName'))

# Start of InfomapWrapper_getNames

`InfomapWrapper_getNames` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapWrapper_getNames', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t", ref=ans);
  
  ans
  
}

attr(`InfomapWrapper_getNames`, 'returnType') = '_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t'
attr(`InfomapWrapper_getNames`, "inputTypes") = c('_p_infomap__InfomapWrapper')
class(`InfomapWrapper_getNames`) = c("SWIGFunction", class('InfomapWrapper_getNames'))

# Start of InfomapWrapper_addPhysicalNode

`InfomapWrapper_addPhysicalNode__SWIG_0` = function(self, id, name)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  id = as.integer(id);
  
  if(length(id) > 1) {
    warning("using only the first element of id");
  };
  
  name = as(name, "character"); 
  ;.Call('R_swig_InfomapWrapper_addPhysicalNode__SWIG_0', self, id, name, PACKAGE='infomap');
  
}

attr(`InfomapWrapper_addPhysicalNode__SWIG_0`, 'returnType') = 'void'
attr(`InfomapWrapper_addPhysicalNode__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapWrapper', 'integer', 'character')
class(`InfomapWrapper_addPhysicalNode__SWIG_0`) = c("SWIGFunction", class('InfomapWrapper_addPhysicalNode__SWIG_0'))

# Start of InfomapWrapper_addPhysicalNode

`InfomapWrapper_addPhysicalNode__SWIG_1` = function(self, id)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  id = as.integer(id);
  
  if(length(id) > 1) {
    warning("using only the first element of id");
  };
  
  ;.Call('R_swig_InfomapWrapper_addPhysicalNode__SWIG_1', self, id, PACKAGE='infomap');
  
}

attr(`InfomapWrapper_addPhysicalNode__SWIG_1`, 'returnType') = 'void'
attr(`InfomapWrapper_addPhysicalNode__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapWrapper', 'integer')
class(`InfomapWrapper_addPhysicalNode__SWIG_1`) = c("SWIGFunction", class('InfomapWrapper_addPhysicalNode__SWIG_1'))

`InfomapWrapper_addPhysicalNode` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapWrapper') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- InfomapWrapper_addPhysicalNode__SWIG_1; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_infomap__InfomapWrapper') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && is.character(argv[[3]]) && length(argv[[3]]) == 1) {
      f <- InfomapWrapper_addPhysicalNode__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InfomapWrapper_addPhysicalNode with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapWrapper_addStateNode

`InfomapWrapper_addStateNode` = function(self, id, physId)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  id = as.integer(id);
  
  if(length(id) > 1) {
    warning("using only the first element of id");
  };
  
  physId = as.integer(physId);
  
  if(length(physId) > 1) {
    warning("using only the first element of physId");
  };
  
  ;.Call('R_swig_InfomapWrapper_addStateNode', self, id, physId, PACKAGE='infomap');
  
}

attr(`InfomapWrapper_addStateNode`, 'returnType') = 'void'
attr(`InfomapWrapper_addStateNode`, "inputTypes") = c('_p_infomap__InfomapWrapper', 'integer', 'integer')
class(`InfomapWrapper_addStateNode`) = c("SWIGFunction", class('InfomapWrapper_addStateNode'))

# Start of InfomapWrapper_addLink

`InfomapWrapper_addLink__SWIG_0` = function(self, sourceId, targetId, weight)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  sourceId = as.integer(sourceId);
  
  if(length(sourceId) > 1) {
    warning("using only the first element of sourceId");
  };
  
  targetId = as.integer(targetId);
  
  if(length(targetId) > 1) {
    warning("using only the first element of targetId");
  };
  
  
  ;.Call('R_swig_InfomapWrapper_addLink__SWIG_0', self, sourceId, targetId, weight, PACKAGE='infomap');
  
}

attr(`InfomapWrapper_addLink__SWIG_0`, 'returnType') = 'void'
attr(`InfomapWrapper_addLink__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapWrapper', 'integer', 'integer', 'numeric')
class(`InfomapWrapper_addLink__SWIG_0`) = c("SWIGFunction", class('InfomapWrapper_addLink__SWIG_0'))

# Start of InfomapWrapper_addLink

`InfomapWrapper_addLink__SWIG_1` = function(self, sourceId, targetId)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  sourceId = as.integer(sourceId);
  
  if(length(sourceId) > 1) {
    warning("using only the first element of sourceId");
  };
  
  targetId = as.integer(targetId);
  
  if(length(targetId) > 1) {
    warning("using only the first element of targetId");
  };
  
  ;.Call('R_swig_InfomapWrapper_addLink__SWIG_1', self, sourceId, targetId, PACKAGE='infomap');
  
}

attr(`InfomapWrapper_addLink__SWIG_1`, 'returnType') = 'void'
attr(`InfomapWrapper_addLink__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapWrapper', 'integer', 'integer')
class(`InfomapWrapper_addLink__SWIG_1`) = c("SWIGFunction", class('InfomapWrapper_addLink__SWIG_1'))

# Start of InfomapWrapper_addLink

`InfomapWrapper_addLink__SWIG_2` = function(self, sourceId, targetId, weight)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  sourceId = as.integer(sourceId);
  
  if(length(sourceId) > 1) {
    warning("using only the first element of sourceId");
  };
  
  targetId = as.integer(targetId);
  
  if(length(targetId) > 1) {
    warning("using only the first element of targetId");
  };
  
  weight = as.integer(weight);
  
  if(length(weight) > 1) {
    warning("using only the first element of weight");
  };
  
  ;.Call('R_swig_InfomapWrapper_addLink__SWIG_2', self, sourceId, targetId, weight, PACKAGE='infomap');
  
}

attr(`InfomapWrapper_addLink__SWIG_2`, 'returnType') = 'void'
attr(`InfomapWrapper_addLink__SWIG_2`, "inputTypes") = c('_p_infomap__InfomapWrapper', 'integer', 'integer', 'integer')
class(`InfomapWrapper_addLink__SWIG_2`) = c("SWIGFunction", class('InfomapWrapper_addLink__SWIG_2'))

`InfomapWrapper_addLink` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 3) {
    if ((extends(argtypes[1], '_p_infomap__InfomapWrapper') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 )) {
      f <- InfomapWrapper_addLink__SWIG_1; 
    }
  } else if (argc == 4) {
    if ((extends(argtypes[1], '_p_infomap__InfomapWrapper') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 )) {
      f <- InfomapWrapper_addLink__SWIG_2; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapWrapper') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( is.numeric(argv[[4]]) && length(argv[[4]]) == 1 )) {
      f <- InfomapWrapper_addLink__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InfomapWrapper_addLink with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapWrapper_addMultilayerLink

`InfomapWrapper_addMultilayerLink__SWIG_0` = function(self, layer1, n1, layer2, n2, weight)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  layer1 = as.integer(layer1);
  
  if(length(layer1) > 1) {
    warning("using only the first element of layer1");
  };
  
  n1 = as.integer(n1);
  
  if(length(n1) > 1) {
    warning("using only the first element of n1");
  };
  
  layer2 = as.integer(layer2);
  
  if(length(layer2) > 1) {
    warning("using only the first element of layer2");
  };
  
  n2 = as.integer(n2);
  
  if(length(n2) > 1) {
    warning("using only the first element of n2");
  };
  
  
  ;.Call('R_swig_InfomapWrapper_addMultilayerLink__SWIG_0', self, layer1, n1, layer2, n2, weight, PACKAGE='infomap');
  
}

attr(`InfomapWrapper_addMultilayerLink__SWIG_0`, 'returnType') = 'void'
attr(`InfomapWrapper_addMultilayerLink__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapWrapper', 'integer', 'integer', 'integer', 'integer', 'numeric')
class(`InfomapWrapper_addMultilayerLink__SWIG_0`) = c("SWIGFunction", class('InfomapWrapper_addMultilayerLink__SWIG_0'))

# Start of InfomapWrapper_addMultilayerLink

`InfomapWrapper_addMultilayerLink__SWIG_1` = function(self, layer1, n1, layer2, n2)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  layer1 = as.integer(layer1);
  
  if(length(layer1) > 1) {
    warning("using only the first element of layer1");
  };
  
  n1 = as.integer(n1);
  
  if(length(n1) > 1) {
    warning("using only the first element of n1");
  };
  
  layer2 = as.integer(layer2);
  
  if(length(layer2) > 1) {
    warning("using only the first element of layer2");
  };
  
  n2 = as.integer(n2);
  
  if(length(n2) > 1) {
    warning("using only the first element of n2");
  };
  
  ;.Call('R_swig_InfomapWrapper_addMultilayerLink__SWIG_1', self, layer1, n1, layer2, n2, PACKAGE='infomap');
  
}

attr(`InfomapWrapper_addMultilayerLink__SWIG_1`, 'returnType') = 'void'
attr(`InfomapWrapper_addMultilayerLink__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapWrapper', 'integer', 'integer', 'integer', 'integer')
class(`InfomapWrapper_addMultilayerLink__SWIG_1`) = c("SWIGFunction", class('InfomapWrapper_addMultilayerLink__SWIG_1'))

`InfomapWrapper_addMultilayerLink` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 5) {
    if ((extends(argtypes[1], '_p_infomap__InfomapWrapper') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 )) {
      f <- InfomapWrapper_addMultilayerLink__SWIG_1; 
    }
  } else if (argc == 6) {
    if ((extends(argtypes[1], '_p_infomap__InfomapWrapper') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( (is.integer(argv[[5]]) || is.numeric(argv[[5]])) && length(argv[[5]]) == 1 ) && ( is.numeric(argv[[6]]) && length(argv[[6]]) == 1 )) {
      f <- InfomapWrapper_addMultilayerLink__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InfomapWrapper_addMultilayerLink with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapWrapper_setBipartiteStartId

`InfomapWrapper_setBipartiteStartId` = function(self, startId)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  startId = as.integer(startId);
  
  if(length(startId) > 1) {
    warning("using only the first element of startId");
  };
  
  ;.Call('R_swig_InfomapWrapper_setBipartiteStartId', self, startId, PACKAGE='infomap');
  
}

attr(`InfomapWrapper_setBipartiteStartId`, 'returnType') = 'void'
attr(`InfomapWrapper_setBipartiteStartId`, "inputTypes") = c('_p_infomap__InfomapWrapper', 'integer')
class(`InfomapWrapper_setBipartiteStartId`) = c("SWIGFunction", class('InfomapWrapper_setBipartiteStartId'))

# Start of InfomapWrapper_getModules

`InfomapWrapper_getModules__SWIG_0` = function(self, level, states, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  level = as.integer(level);
  
  if(length(level) > 1) {
    warning("using only the first element of level");
  };
  
  states = as.logical(states);
  ;ans = .Call('R_swig_InfomapWrapper_getModules__SWIG_0', self, level, states, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t", ref=ans);
  
  ans
  
}

attr(`InfomapWrapper_getModules__SWIG_0`, 'returnType') = '_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t'
attr(`InfomapWrapper_getModules__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapWrapper', 'integer', 'logical')
class(`InfomapWrapper_getModules__SWIG_0`) = c("SWIGFunction", class('InfomapWrapper_getModules__SWIG_0'))

# Start of InfomapWrapper_getModules

`InfomapWrapper_getModules__SWIG_1` = function(self, level, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  level = as.integer(level);
  
  if(length(level) > 1) {
    warning("using only the first element of level");
  };
  
  ;ans = .Call('R_swig_InfomapWrapper_getModules__SWIG_1', self, level, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t", ref=ans);
  
  ans
  
}

attr(`InfomapWrapper_getModules__SWIG_1`, 'returnType') = '_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t'
attr(`InfomapWrapper_getModules__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapWrapper', 'integer')
class(`InfomapWrapper_getModules__SWIG_1`) = c("SWIGFunction", class('InfomapWrapper_getModules__SWIG_1'))

# Start of InfomapWrapper_getModules

`InfomapWrapper_getModules__SWIG_2` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapWrapper_getModules__SWIG_2', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t", ref=ans);
  
  ans
  
}

attr(`InfomapWrapper_getModules__SWIG_2`, 'returnType') = '_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t'
attr(`InfomapWrapper_getModules__SWIG_2`, "inputTypes") = c('_p_infomap__InfomapWrapper')
class(`InfomapWrapper_getModules__SWIG_2`) = c("SWIGFunction", class('InfomapWrapper_getModules__SWIG_2'))

`InfomapWrapper_getModules` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapWrapper') || is.null(argv[[1]]))) {
      f <- InfomapWrapper_getModules__SWIG_2; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapWrapper') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- InfomapWrapper_getModules__SWIG_1; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_infomap__InfomapWrapper') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.logical(argv[[3]]) && length(argv[[3]]) == 1 )) {
      f <- InfomapWrapper_getModules__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InfomapWrapper_getModules with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapWrapper_getMultilevelModules

`InfomapWrapper_getMultilevelModules__SWIG_0` = function(self, states, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  states = as.logical(states);
  ;ans = .Call('R_swig_InfomapWrapper_getMultilevelModules__SWIG_0', self, states, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t", ref=ans);
  
  ans
  
}

attr(`InfomapWrapper_getMultilevelModules__SWIG_0`, 'returnType') = '_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t'
attr(`InfomapWrapper_getMultilevelModules__SWIG_0`, "inputTypes") = c('_p_infomap__InfomapWrapper', 'logical')
class(`InfomapWrapper_getMultilevelModules__SWIG_0`) = c("SWIGFunction", class('InfomapWrapper_getMultilevelModules__SWIG_0'))

# Start of InfomapWrapper_getMultilevelModules

`InfomapWrapper_getMultilevelModules__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapWrapper_getMultilevelModules__SWIG_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t", ref=ans);
  
  ans
  
}

attr(`InfomapWrapper_getMultilevelModules__SWIG_1`, 'returnType') = '_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t'
attr(`InfomapWrapper_getMultilevelModules__SWIG_1`, "inputTypes") = c('_p_infomap__InfomapWrapper')
class(`InfomapWrapper_getMultilevelModules__SWIG_1`) = c("SWIGFunction", class('InfomapWrapper_getMultilevelModules__SWIG_1'))

`InfomapWrapper_getMultilevelModules` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapWrapper') || is.null(argv[[1]]))) {
      f <- InfomapWrapper_getMultilevelModules__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapWrapper') || is.null(argv[[1]])) && ( is.logical(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- InfomapWrapper_getMultilevelModules__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for InfomapWrapper_getMultilevelModules with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapWrapper_run

`InfomapWrapper_run_SWIG_0_0` = function(self, parameters)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  parameters = as(parameters, "character"); 
  ;.Call('R_swig_InfomapWrapper_run_SWIG_0_0', self, parameters, PACKAGE='infomap');
  
}

attr(`InfomapWrapper_run_SWIG_0_0`, 'returnType') = 'void'
attr(`InfomapWrapper_run_SWIG_0_0`, "inputTypes") = c('_p_infomap__InfomapWrapper', 'character')
class(`InfomapWrapper_run_SWIG_0_0`) = c("SWIGFunction", class('InfomapWrapper_run_SWIG_0_0'))

# Start of InfomapWrapper_run

`InfomapWrapper_run_SWIG_0_1` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapWrapper_run_SWIG_0_1', self, PACKAGE='infomap');
  
}

attr(`InfomapWrapper_run_SWIG_0_1`, 'returnType') = 'void'
attr(`InfomapWrapper_run_SWIG_0_1`, "inputTypes") = c('_p_infomap__InfomapWrapper')
class(`InfomapWrapper_run_SWIG_0_1`) = c("SWIGFunction", class('InfomapWrapper_run_SWIG_0_1'))

# Start of InfomapWrapper_run

`InfomapWrapper_run_SWIG_0_2` = function(self, network)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  if (inherits(network, "ExternalReference")) network = slot(network,"ref"); 
  ;.Call('R_swig_InfomapWrapper_run_SWIG_0_2', self, network, PACKAGE='infomap');
  
}

attr(`InfomapWrapper_run_SWIG_0_2`, 'returnType') = 'void'
attr(`InfomapWrapper_run_SWIG_0_2`, "inputTypes") = c('_p_infomap__InfomapWrapper', '_p_infomap__Network')
class(`InfomapWrapper_run_SWIG_0_2`) = c("SWIGFunction", class('InfomapWrapper_run_SWIG_0_2'))

`InfomapWrapper_run` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapWrapper') || is.null(argv[[1]]))) {
      f <- InfomapWrapper_run_SWIG_0_1; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapWrapper') || is.null(argv[[1]])) && extends(argtypes[2], '_p_infomap__Network') && length(argv[[2]]) == 1) {
      f <- InfomapWrapper_run_SWIG_0_2; 
    }
    else if ((extends(argtypes[1], '_p_infomap__InfomapWrapper') || is.null(argv[[1]])) && is.character(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- InfomapWrapper_run_SWIG_0_0; 
    }
  } else {
    stop("cannot find overloaded function for InfomapWrapper_run with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapWrapper_codelength

`InfomapWrapper_codelength` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;.Call('R_swig_InfomapWrapper_codelength', self, as.logical(.copy), PACKAGE='infomap');
  
}

attr(`InfomapWrapper_codelength`, 'returnType') = 'numeric'
attr(`InfomapWrapper_codelength`, "inputTypes") = c('_p_infomap__InfomapWrapper')
class(`InfomapWrapper_codelength`) = c("SWIGFunction", class('InfomapWrapper_codelength'))

# Start of InfomapWrapper_iterTree

`InfomapWrapper_iterTree_SWIG_0_0` = function(self, maxClusterLevel, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  maxClusterLevel = as.integer(maxClusterLevel);
  
  if(length(maxClusterLevel) > 1) {
    warning("using only the first element of maxClusterLevel");
  };
  
  ;ans = .Call('R_swig_InfomapWrapper_iterTree_SWIG_0_0', self, maxClusterLevel, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapIterator", ref=ans);
  
  ans
  
}

attr(`InfomapWrapper_iterTree_SWIG_0_0`, 'returnType') = '_p_infomap__InfomapIterator'
attr(`InfomapWrapper_iterTree_SWIG_0_0`, "inputTypes") = c('_p_infomap__InfomapWrapper', 'integer')
class(`InfomapWrapper_iterTree_SWIG_0_0`) = c("SWIGFunction", class('InfomapWrapper_iterTree_SWIG_0_0'))

# Start of InfomapWrapper_iterTree

`InfomapWrapper_iterTree_SWIG_0_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapWrapper_iterTree_SWIG_0_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapIterator", ref=ans);
  
  ans
  
}

attr(`InfomapWrapper_iterTree_SWIG_0_1`, 'returnType') = '_p_infomap__InfomapIterator'
attr(`InfomapWrapper_iterTree_SWIG_0_1`, "inputTypes") = c('_p_infomap__InfomapWrapper')
class(`InfomapWrapper_iterTree_SWIG_0_1`) = c("SWIGFunction", class('InfomapWrapper_iterTree_SWIG_0_1'))

`InfomapWrapper_iterTree` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapWrapper') || is.null(argv[[1]]))) {
      f <- InfomapWrapper_iterTree_SWIG_0_1; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapWrapper') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- InfomapWrapper_iterTree_SWIG_0_0; 
    }
  } else {
    stop("cannot find overloaded function for InfomapWrapper_iterTree with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of InfomapWrapper_iterLeafNodes

`InfomapWrapper_iterLeafNodes_SWIG_0_0` = function(self, maxClusterLevel, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  maxClusterLevel = as.integer(maxClusterLevel);
  
  if(length(maxClusterLevel) > 1) {
    warning("using only the first element of maxClusterLevel");
  };
  
  ;ans = .Call('R_swig_InfomapWrapper_iterLeafNodes_SWIG_0_0', self, maxClusterLevel, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapLeafIterator", ref=ans);
  
  ans
  
}

attr(`InfomapWrapper_iterLeafNodes_SWIG_0_0`, 'returnType') = '_p_infomap__InfomapLeafIterator'
attr(`InfomapWrapper_iterLeafNodes_SWIG_0_0`, "inputTypes") = c('_p_infomap__InfomapWrapper', 'integer')
class(`InfomapWrapper_iterLeafNodes_SWIG_0_0`) = c("SWIGFunction", class('InfomapWrapper_iterLeafNodes_SWIG_0_0'))

# Start of InfomapWrapper_iterLeafNodes

`InfomapWrapper_iterLeafNodes_SWIG_0_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref"); 
  ;ans = .Call('R_swig_InfomapWrapper_iterLeafNodes_SWIG_0_1', self, as.logical(.copy), PACKAGE='infomap');
  ans <- if (is.null(ans)) ans
  else new("_p_infomap__InfomapLeafIterator", ref=ans);
  
  ans
  
}

attr(`InfomapWrapper_iterLeafNodes_SWIG_0_1`, 'returnType') = '_p_infomap__InfomapLeafIterator'
attr(`InfomapWrapper_iterLeafNodes_SWIG_0_1`, "inputTypes") = c('_p_infomap__InfomapWrapper')
class(`InfomapWrapper_iterLeafNodes_SWIG_0_1`) = c("SWIGFunction", class('InfomapWrapper_iterLeafNodes_SWIG_0_1'))

`InfomapWrapper_iterLeafNodes` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_infomap__InfomapWrapper') || is.null(argv[[1]]))) {
      f <- InfomapWrapper_iterLeafNodes_SWIG_0_1; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_infomap__InfomapWrapper') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- InfomapWrapper_iterLeafNodes_SWIG_0_0; 
    }
  } else {
    stop("cannot find overloaded function for InfomapWrapper_iterLeafNodes with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of accessor method for infomap::InfomapWrapper
setMethod('$', '_p_infomap__InfomapWrapper', function(x, name)

{
  accessorFuns = list('readInputData' = InfomapWrapper_readInputData, 'addNode' = InfomapWrapper_addNode, 'addName' = InfomapWrapper_addName, 'getName' = InfomapWrapper_getName, 'getNames' = InfomapWrapper_getNames, 'addPhysicalNode' = InfomapWrapper_addPhysicalNode, 'addStateNode' = InfomapWrapper_addStateNode, 'addLink' = InfomapWrapper_addLink, 'addMultilayerLink' = InfomapWrapper_addMultilayerLink, 'setBipartiteStartId' = InfomapWrapper_setBipartiteStartId, 'getModules' = InfomapWrapper_getModules, 'getMultilevelModules' = InfomapWrapper_getMultilevelModules, 'run' = InfomapWrapper_run, 'codelength' = InfomapWrapper_codelength, 'iterTree' = InfomapWrapper_iterTree, 'iterLeafNodes' = InfomapWrapper_iterLeafNodes);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for infomap::InfomapWrapper
setMethod('delete', '_p_infomap__InfomapWrapper', function(obj) {delete_infomap__InfomapWrapper(obj)})
# Start definition of copy functions & methods for infomap::InfomapWrapper
CopyToR_infomap__InfomapWrapper = function(value, obj = new("infomap::InfomapWrapper"))
{
  obj;
}



CopyToC_infomap__InfomapWrapper = function(value, obj)
{
  obj
}



# Start definition of copy methods for infomap::InfomapWrapper
setMethod('copyToR', '_p_infomap::InfomapWrapper', CopyToR_infomap__InfomapWrapper);
setMethod('copyToC', 'infomap::InfomapWrapper', CopyToC_infomap__InfomapWrapper);

# End definition of copy methods for infomap::InfomapWrapper
# End definition of copy functions & methods for infomap::InfomapWrapper



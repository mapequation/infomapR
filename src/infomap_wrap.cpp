/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.2
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

#define SWIG_PYTHON_CAST_MODE



#ifndef SWIGR
#define SWIGR
#endif


#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if defined(__GNUC__)
#  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    ifndef GCC_HASCLASSVISIBILITY
#      define GCC_HASCLASSVISIBILITY
#    endif
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif

/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic C API SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "4"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the SWIG runtime code.
  In 99.9% of the cases, SWIG just needs to declare them as 'static'.

  But only do this if strictly necessary, ie, if you have problems
  with your compiler or suchlike.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1
#define SWIG_CAST_NEW_MEMORY       0x2
#define SWIG_POINTER_NO_NULL       0x4

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/*
   Flags/methods for returning states.

   The SWIG conversion methods, as ConvertPtr, return an integer
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).

   Use the following macros/flags to set or process the returning
   states.

   In old versions of SWIG, code such as the following was usually written:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   which is the same really, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }

   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   also requires SWIG_ConvertPtr to return new result values, such as

      int SWIG_ConvertPtr(obj, ptr,...) {
        if (<obj is ok>) {
          if (<need new object>) {
            *ptr = <ptr to new allocated object>;
            return SWIG_NEWOBJ;
          } else {
            *ptr = <ptr to old object>;
            return SWIG_OLDOBJ;
          }
        } else {
          return SWIG_BADOBJ;
        }
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   SWIG errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows to return the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call

      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()
*/

#define SWIG_OK                    (0)
#define SWIG_ERROR                 (-1)
#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporal objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))

/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) {
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) {
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0;
}
#else /* no cast-rank mode */
#  define SWIG_AddCast(r) (r)
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif


#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *, int *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store information on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/*
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (int)((l1 - f1) - (l2 - f2));
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCmp(const char *nb, const char *tb) {
  int equiv = 1;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (equiv != 0 && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = SWIG_TypeNameComp(nb, ne, tb, te);
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  return SWIG_TypeCmp(nb, tb) == 0 ? 1 : 0;
}

/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (strcmp(iter->type->name, c) == 0) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (iter->type == from) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
}

/*
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/*
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;

  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}

/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start,
                            swig_module_info *end,
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      size_t l = 0;
      size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	size_t i = (l + r) >> 1;
	const char *iname = iter->types[i]->name;
	if (iname) {
	  int compare = strcmp(name, iname);
	  if (compare == 0) {
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start,
                     swig_module_info *end,
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }

  /* neither found a match */
  return 0;
}

/*
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  const unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/*
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    char d = *(c++);
    unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = (unsigned char)((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = (unsigned char)((d - ('a'-10)) << 4);
    else
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (unsigned char)(d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (unsigned char)(d - ('a'-10));
    else
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/*
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1
#define  SWIG_IOError        	   -2
#define  SWIG_RuntimeError   	   -3
#define  SWIG_IndexError     	   -4
#define  SWIG_TypeError      	   -5
#define  SWIG_DivisionByZero 	   -6
#define  SWIG_OverflowError  	   -7
#define  SWIG_SyntaxError    	   -8
#define  SWIG_ValueError     	   -9
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12
#define  SWIG_NullReferenceError   -13



/* Remove global namespace pollution */
#if !defined(SWIG_NO_R_NO_REMAP)
# define R_NO_REMAP
#endif
#if !defined(SWIG_NO_STRICT_R_HEADERS)
# define STRICT_R_HEADERS
#endif

#include <Rdefines.h>
#include <Rversion.h>

#ifdef __cplusplus
#include <exception>
extern "C" {
#endif

/* for raw pointer */
#define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_R_ConvertPtr(obj, pptr, type, flags)
#define SWIG_ConvertPtrAndOwn(obj,pptr,type,flags,own)  SWIG_R_ConvertPtr(obj, pptr, type, flags)
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_R_NewPointerObj(ptr, type, flags)

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <stdarg.h>

#if R_VERSION >= R_Version(2,6,0)
#define VMAXTYPE void *
#else
#define VMAXTYPE char *
#endif

/* Last error */
static int SWIG_lasterror_code = 0;
static char SWIG_lasterror_msg[1024];
SWIGRUNTIME void SWIG_Error(int code, const char *format, ...) {
  va_list arg;
  SWIG_lasterror_code = code;
  va_start(arg, format);
  vsnprintf(SWIG_lasterror_msg, sizeof(SWIG_lasterror_msg), format, arg);
  va_end(arg);
}

SWIGRUNTIME const char *SWIG_ErrorType(int code) {
  switch (code) {
  case SWIG_MemoryError:
    return "SWIG:MemoryError";
  case SWIG_IOError:
    return "SWIG:IOError";
  case SWIG_RuntimeError:
    return "SWIG:RuntimeError";
  case SWIG_IndexError:
    return "SWIG:IndexError";
  case SWIG_TypeError:
    return "SWIG:TypeError";
  case SWIG_DivisionByZero:
    return "SWIG:DivisionByZero";
  case SWIG_OverflowError:
    return "SWIG:OverflowError";
  case SWIG_SyntaxError:
    return "SWIG:SyntaxError";
  case SWIG_ValueError:
    return "SWIG:ValueError";
  case SWIG_SystemError:
    return "SWIG:SystemError";
  case SWIG_AttributeError:
    return "SWIG:AttributeError";
  }
  return "SWIG:UnknownError";
}

#define SWIG_fail goto fail

/*
  This is mainly a way to avoid having lots of local variables that may 
  conflict with those in the routine.

   Change name to R_SWIG_Callb....
*/
typedef struct RCallbackFunctionData {

  SEXP fun;
  SEXP userData;


  SEXP expr;
  SEXP retValue;
  int errorOccurred;

  SEXP el;  /* Temporary pointer used in the construction of the expression to call the R function. */

  struct RCallbackFunctionData *previous;   /* Stack */

} RCallbackFunctionData;

static RCallbackFunctionData  *callbackFunctionDataStack;


SWIGRUNTIME SEXP
R_SWIG_debug_getCallbackFunctionData()
{
  int n, i;
  SEXP ans;
  RCallbackFunctionData  *p = callbackFunctionDataStack;

  n = 0;
  while(p) { 
    n++;
    p = p->previous;
  }

  Rf_protect(ans = Rf_allocVector(VECSXP, n));
  for(p = callbackFunctionDataStack, i = 0; i < n; p = p->previous, i++) 
      SET_VECTOR_ELT(ans, i, p->fun);

  Rf_unprotect(1);

  return(ans);
}



SWIGRUNTIME RCallbackFunctionData *
R_SWIG_pushCallbackFunctionData(SEXP fun, SEXP userData)
{
   RCallbackFunctionData *el;
   el = (RCallbackFunctionData *) calloc(1, sizeof(RCallbackFunctionData));
   el->fun = fun;
   el->userData = userData;
   el->previous = callbackFunctionDataStack;

   callbackFunctionDataStack = el;

   return(el);
}


SWIGRUNTIME SEXP
R_SWIG_R_pushCallbackFunctionData(SEXP fun, SEXP userData)
{
    R_SWIG_pushCallbackFunctionData(fun, userData);
    return R_NilValue;
}

SWIGRUNTIME RCallbackFunctionData *
R_SWIG_getCallbackFunctionData()
{
  if(!callbackFunctionDataStack) {
    Rf_error("Supposedly impossible error occurred in the SWIG callback mechanism."
            "  No callback function data set.");
  }
  
  return callbackFunctionDataStack;
}

SWIGRUNTIME void
R_SWIG_popCallbackFunctionData(int doFree)
{
  RCallbackFunctionData  *el = NULL;
  if(!callbackFunctionDataStack)
    return ; /* Error !!! */

  el = callbackFunctionDataStack ;
  callbackFunctionDataStack = callbackFunctionDataStack->previous;

  if(doFree)
     free(el);
}


/*
  Interface to S function
      is(obj, type)
  which is to be used to determine if an 
  external pointer inherits from the right class.

  Ideally, we would like to be able to do this without an explicit call to the is() function.
  When the S4 class system uses its own SEXP types, then we will hopefully be able to do this
  in the C code.

  Should we make the expression static and preserve it to avoid the overhead of 
  allocating each time.
*/
SWIGRUNTIME int
R_SWIG_checkInherits(SEXP obj, SEXP tag, const char *type)
{
  SEXP e, val;
  int check_err = 0;

  Rf_protect(e = Rf_allocVector(LANGSXP, 3));
  SETCAR(e, Rf_install("extends"));

  SETCAR(CDR(e), Rf_mkString(CHAR(PRINTNAME(tag))));
  SETCAR(CDR(CDR(e)), Rf_mkString(type));

  val = R_tryEval(e, R_GlobalEnv, &check_err);
  Rf_unprotect(1);
  if(check_err) 
    return(0);


  return(LOGICAL(val)[0]);
}


SWIGRUNTIME void *
R_SWIG_resolveExternalRef(SEXP arg, const char * const type, const char * const argName, Rboolean nullOk)
{
  void *ptr;
  SEXP orig = arg;

  if(TYPEOF(arg) != EXTPTRSXP) 
    arg = GET_SLOT(arg, Rf_mkString("ref"));

  
  if(TYPEOF(arg) != EXTPTRSXP) {
    Rf_error("argument %s must be an external pointer (from an ExternalReference)", argName);
  }


  ptr = R_ExternalPtrAddr(arg);

  if(ptr == NULL && nullOk == (Rboolean) FALSE) {
    Rf_error("the external pointer (of type %s) for argument %s has value NULL", argName, type);
  }

  if(type[0] && R_ExternalPtrTag(arg) != Rf_install(type) && strcmp(type, "voidRef")
      && !R_SWIG_checkInherits(orig,  R_ExternalPtrTag(arg), type)) {
    Rf_error("the external pointer for argument %s has tag %s, not the expected value %s",
             argName, CHAR(PRINTNAME(R_ExternalPtrTag(arg))), type);
  }


  return(ptr);
}

SWIGRUNTIME void
R_SWIG_ReferenceFinalizer(SEXP el)
{
  void *ptr = R_SWIG_resolveExternalRef(el, "", "<finalizer>",  (Rboolean) 1);
  fprintf(stderr, "In R_SWIG_ReferenceFinalizer for %p\n", ptr);
  Rf_PrintValue(el);

  if(ptr) {
     if(TYPEOF(el) != EXTPTRSXP)
        el = GET_SLOT(el, Rf_mkString("ref"));

     if(TYPEOF(el) == EXTPTRSXP)
        R_ClearExternalPtr(el);

     free(ptr);
  }

  return;
}

SWIGRUNTIME SEXP
SWIG_MakePtr(void *ptr, const char *typeName, int flags)
{
  SEXP external, r_obj;

  Rf_protect(external = R_MakeExternalPtr(ptr, Rf_install(typeName), R_NilValue));
  Rf_protect(r_obj = NEW_OBJECT(MAKE_CLASS((char *) typeName)));

  if (flags & SWIG_POINTER_OWN)
    R_RegisterCFinalizer(external, R_SWIG_ReferenceFinalizer);

  r_obj = SET_SLOT(r_obj, Rf_mkString((char *) "ref"), external);
  SET_S4_OBJECT(r_obj);
  Rf_unprotect(2);

  return(r_obj);
}


SWIGRUNTIME SEXP
R_SWIG_create_SWIG_R_Array(const char *typeName, SEXP ref, int len)
{
   SEXP arr;

/*XXX remove the char * cast when we can. MAKE_CLASS should be declared appropriately. */
   Rf_protect(arr = NEW_OBJECT(MAKE_CLASS((char *) typeName)));
   Rf_protect(arr = R_do_slot_assign(arr, Rf_mkString("ref"), ref));
   Rf_protect(arr = R_do_slot_assign(arr, Rf_mkString("dims"), Rf_ScalarInteger(len)));

   Rf_unprotect(3); 			   
   SET_S4_OBJECT(arr);	
   return arr;
}

#define ADD_OUTPUT_ARG(result, pos, value, name)  r_ans = AddOutputArgToReturn(pos, value, name, OutputValues);

SWIGRUNTIME SEXP
AddOutputArgToReturn(int pos, SEXP value, const char *name, SEXP output)
{
  SET_VECTOR_ELT(output, pos, value);

  return(output);
}

/* Create a new pointer object */
SWIGRUNTIMEINLINE SEXP
SWIG_R_NewPointerObj(void *ptr, swig_type_info *type, int flags) {
  SEXP rptr;
  if (!ptr) {
     return R_NilValue;
  }
  rptr = R_MakeExternalPtr(ptr, 
  R_MakeExternalPtr(type, R_NilValue, R_NilValue), R_NilValue); 
  SET_S4_OBJECT(rptr);
  return rptr;
}


/* Convert a pointer value */
SWIGRUNTIMEINLINE int
SWIG_R_ConvertPtr(SEXP obj, void **ptr, swig_type_info *ty, int flags) {
  void *vptr;
  if (!obj) return SWIG_ERROR;
  if (obj == R_NilValue) {
    if (ptr) *ptr = NULL;
    return (flags & SWIG_POINTER_NO_NULL) ? SWIG_NullReferenceError : SWIG_OK;
  }

  vptr = R_ExternalPtrAddr(obj);
  if (ty) {
    swig_type_info *to = (swig_type_info*) 
      R_ExternalPtrAddr(R_ExternalPtrTag(obj));
    if (to == ty) {
      if (ptr) *ptr = vptr;
    } else {
      swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
      int newmemory = 0;
      if (ptr) *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
      assert(!newmemory); /* newmemory handling not yet implemented */
    }
  } else {
      if (ptr) *ptr = vptr;
 }
  return SWIG_OK;
}

SWIGRUNTIME swig_module_info *
SWIG_GetModule(void *SWIGUNUSEDPARM(clientdata)) {
  static void *type_pointer = (void *)0;
  return (swig_module_info *) type_pointer;
}

SWIGRUNTIME void
SWIG_SetModule(void *v, swig_module_info *swig_module) {
}

typedef struct {
  void *pack;
  swig_type_info *ty;
  size_t size;
} RSwigPacked;

/* Create a new packed object */

SWIGRUNTIMEINLINE SEXP RSwigPacked_New(void *ptr, size_t sz,
		  swig_type_info *ty) {
  SEXP rptr;
  RSwigPacked *sobj = 
  (RSwigPacked*) malloc(sizeof(RSwigPacked));
  if (sobj) {
    void *pack = malloc(sz);
    if (pack) {
      memcpy(pack, ptr, sz);
      sobj->pack = pack;
      sobj->ty   = ty;
      sobj->size = sz;
    } else {
      sobj = 0;
    }
  }
  rptr = R_MakeExternalPtr(sobj, R_NilValue, R_NilValue); 
  return rptr;
}

SWIGRUNTIME swig_type_info *
RSwigPacked_UnpackData(SEXP obj, void *ptr, size_t size)
{
    RSwigPacked *sobj = 
        (RSwigPacked *)R_ExternalPtrAddr(obj);
    if (sobj->size != size) return 0;
    memcpy(ptr, sobj->pack, size);
    return sobj->ty;
}

SWIGRUNTIMEINLINE SEXP
SWIG_R_NewPackedObj(void *ptr, size_t sz, swig_type_info *type) {
  return ptr ? RSwigPacked_New((void *) ptr, sz, type) : R_NilValue;
}

/* Convert a packed pointer value */

SWIGRUNTIME int
SWIG_R_ConvertPacked(SEXP obj, void *ptr, size_t sz, swig_type_info *ty) {
  swig_type_info *to = RSwigPacked_UnpackData(obj, ptr, sz);
  if (!to) return SWIG_ERROR;
  if (ty) {
    if (to != ty) {
      /* check type cast? */
      swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
      if (!tc) return SWIG_ERROR;
    }
  }
  return SWIG_OK;
}  

#ifdef __cplusplus
#define SWIG_exception_noreturn(code, msg) do { throw std::runtime_error(msg); } while(0)
#else
#define SWIG_exception_noreturn(code, msg) do { return result; } while(0)
#endif

#ifdef __cplusplus
}
#endif



#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 

#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 



  #define SWIG_exception(code, msg) do { switch (code) {case SWIG_IndexError: return Rf_ScalarLogical(NA_LOGICAL); default: SWIG_Error(code, msg); SWIG_fail;}; } while(0) 



/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_p_ChildIteratorT_infomap__InfoNode_const_p_t swig_types[0]
#define SWIGTYPE_p_ChildIteratorT_infomap__InfoNode_p_t swig_types[1]
#define SWIGTYPE_p_Date swig_types[2]
#define SWIGTYPE_p_DeltaFlowDataType swig_types[3]
#define SWIGTYPE_p_DepthFirstIteratorT_infomap__InfoNode_p_false_t swig_types[4]
#define SWIGTYPE_p_EdgeT_infomap__InfoNode_t swig_types[5]
#define SWIGTYPE_p_EdgeType swig_types[6]
#define SWIGTYPE_p_FlowDataType swig_types[7]
#define SWIGTYPE_p_IterWrapperT_ChildIteratorT_infomap__InfoNode_const_p_t_t swig_types[8]
#define SWIGTYPE_p_IterWrapperT_ChildIteratorT_infomap__InfoNode_p_t_t swig_types[9]
#define SWIGTYPE_p_IterWrapperT_InfomapChildIteratorT_infomap__InfoNode_const_p_t_t swig_types[10]
#define SWIGTYPE_p_IterWrapperT_InfomapChildIteratorT_infomap__InfoNode_p_t_t swig_types[11]
#define SWIGTYPE_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_const_p_t_t swig_types[12]
#define SWIGTYPE_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_p_t_t swig_types[13]
#define SWIGTYPE_p_IterWrapperT_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator_t swig_types[14]
#define SWIGTYPE_p_LeafModuleIteratorT_infomap__InfoNode_p_t swig_types[15]
#define SWIGTYPE_p_LeafNodeIteratorT_infomap__InfoNode_p_t swig_types[16]
#define SWIGTYPE_p_MetaCollection swig_types[17]
#define SWIGTYPE_p_NodeLinkMap swig_types[18]
#define SWIGTYPE_p_NodeMap swig_types[19]
#define SWIGTYPE_p_NodePaths swig_types[20]
#define SWIGTYPE_p_OutLinkMap swig_types[21]
#define SWIGTYPE_p_PartitionQueue swig_types[22]
#define SWIGTYPE_p_TreeIteratorT_infomap__InfoNode_const_p_t swig_types[23]
#define SWIGTYPE_p_TreeIteratorT_infomap__InfoNode_p_t swig_types[24]
#define SWIGTYPE_p_VectorMapT_infomap__DeltaFlow_t swig_types[25]
#define SWIGTYPE_p_VectorMapT_infomap__MemDeltaFlow_t swig_types[26]
#define SWIGTYPE_p_allocator_type swig_types[27]
#define SWIGTYPE_p_char swig_types[28]
#define SWIGTYPE_p_child_iterator swig_types[29]
#define SWIGTYPE_p_child_iterator_wrapper swig_types[30]
#define SWIGTYPE_p_const_child_iterator swig_types[31]
#define SWIGTYPE_p_const_child_iterator_wrapper swig_types[32]
#define SWIGTYPE_p_const_edge_iterator swig_types[33]
#define SWIGTYPE_p_const_edge_iterator_wrapper swig_types[34]
#define SWIGTYPE_p_const_infomap_child_iterator swig_types[35]
#define SWIGTYPE_p_const_infomap_child_iterator_wrapper swig_types[36]
#define SWIGTYPE_p_const_infomap_iterator_wrapper swig_types[37]
#define SWIGTYPE_p_const_leaf_module_iterator swig_types[38]
#define SWIGTYPE_p_const_leaf_node_iterator swig_types[39]
#define SWIGTYPE_p_const_post_depth_first_iterator swig_types[40]
#define SWIGTYPE_p_const_tree_iterator swig_types[41]
#define SWIGTYPE_p_difference_type swig_types[42]
#define SWIGTYPE_p_edge_iterator swig_types[43]
#define SWIGTYPE_p_edge_iterator_wrapper swig_types[44]
#define SWIGTYPE_p_infomap__Bigram swig_types[45]
#define SWIGTYPE_p_infomap__BipartiteLink swig_types[46]
#define SWIGTYPE_p_infomap__Config swig_types[47]
#define SWIGTYPE_p_infomap__DeltaFlow swig_types[48]
#define SWIGTYPE_p_infomap__FlowData swig_types[49]
#define SWIGTYPE_p_infomap__FlowModel swig_types[50]
#define SWIGTYPE_p_infomap__InfoNode swig_types[51]
#define SWIGTYPE_p_infomap__InfomapBase swig_types[52]
#define SWIGTYPE_p_infomap__InfomapConfigT_infomap__InfomapBase_t swig_types[53]
#define SWIGTYPE_p_infomap__InfomapCore swig_types[54]
#define SWIGTYPE_p_infomap__InfomapIterator swig_types[55]
#define SWIGTYPE_p_infomap__InfomapIteratorPhysical swig_types[56]
#define SWIGTYPE_p_infomap__InfomapLeafIterator swig_types[57]
#define SWIGTYPE_p_infomap__InfomapLeafIteratorPhysical swig_types[58]
#define SWIGTYPE_p_infomap__InfomapLeafModuleIterator swig_types[59]
#define SWIGTYPE_p_infomap__InfomapModuleIterator swig_types[60]
#define SWIGTYPE_p_infomap__InfomapParentIterator swig_types[61]
#define SWIGTYPE_p_infomap__InfomapWrapper swig_types[62]
#define SWIGTYPE_p_infomap__LayerNode swig_types[63]
#define SWIGTYPE_p_infomap__MapEquation swig_types[64]
#define SWIGTYPE_p_infomap__MapMapT_unsigned_int_unsigned_int_double_t swig_types[65]
#define SWIGTYPE_p_infomap__MemDeltaFlow swig_types[66]
#define SWIGTYPE_p_infomap__MemMapEquation swig_types[67]
#define SWIGTYPE_p_infomap__MemNodeSet swig_types[68]
#define SWIGTYPE_p_infomap__MetaMapEquation swig_types[69]
#define SWIGTYPE_p_infomap__Network swig_types[70]
#define SWIGTYPE_p_infomap__OptimizationLevel swig_types[71]
#define SWIGTYPE_p_infomap__PerLevelStat swig_types[72]
#define SWIGTYPE_p_infomap__PhysData swig_types[73]
#define SWIGTYPE_p_infomap__StateNetwork swig_types[74]
#define SWIGTYPE_p_infomap__StateNetwork__PhysNode swig_types[75]
#define SWIGTYPE_p_infomap__StateNetwork__StateNode swig_types[76]
#define SWIGTYPE_p_infomap__Triple swig_types[77]
#define SWIGTYPE_p_infomap__Weight swig_types[78]
#define SWIGTYPE_p_infomap__detail__PartitionQueue swig_types[79]
#define SWIGTYPE_p_infomap_child_iterator swig_types[80]
#define SWIGTYPE_p_infomap_child_iterator_wrapper swig_types[81]
#define SWIGTYPE_p_infomap_iterator_wrapper swig_types[82]
#define SWIGTYPE_p_key_type swig_types[83]
#define SWIGTYPE_p_leaf_module_iterator swig_types[84]
#define SWIGTYPE_p_leaf_node_iterator swig_types[85]
#define SWIGTYPE_p_mapped_type swig_types[86]
#define SWIGTYPE_p_post_depth_first_iterator swig_types[87]
#define SWIGTYPE_p_size_t swig_types[88]
#define SWIGTYPE_p_size_type swig_types[89]
#define SWIGTYPE_p_std__allocatorT_double_t swig_types[90]
#define SWIGTYPE_p_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t swig_types[91]
#define SWIGTYPE_p_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t swig_types[92]
#define SWIGTYPE_p_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t swig_types[93]
#define SWIGTYPE_p_std__allocatorT_unsigned_int_t swig_types[94]
#define SWIGTYPE_p_std__dequeT_infomap__InfoNode_p_std__allocatorT_infomap__InfoNode_p_t_t__size_type swig_types[95]
#define SWIGTYPE_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t swig_types[96]
#define SWIGTYPE_p_std__lessT_unsigned_int_t swig_types[97]
#define SWIGTYPE_p_std__mapT_infomap__StateNetwork__StateNode_std__mapT_infomap__StateNetwork__StateNode_infomap__StateNetwork__LinkData_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_infomap__StateNetwork__LinkData_t_t_t_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_std__mapT_infomap__StateNetwork__StateNode_infomap__StateNetwork__LinkData_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_infomap__StateNetwork__LinkData_t_t_t_t_t_t swig_types[98]
#define SWIGTYPE_p_std__mapT_unsigned_int_double_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_double_t_t_t swig_types[99]
#define SWIGTYPE_p_std__mapT_unsigned_int_infomap__StateNetwork__StateNode_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_infomap__StateNetwork__StateNode_t_t_t swig_types[100]
#define SWIGTYPE_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t swig_types[101]
#define SWIGTYPE_p_std__mapT_unsigned_int_std__vectorT_int_std__allocatorT_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_int_std__allocatorT_int_t_t_t_t_t swig_types[102]
#define SWIGTYPE_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t swig_types[103]
#define SWIGTYPE_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t swig_types[104]
#define SWIGTYPE_p_std__ostream swig_types[105]
#define SWIGTYPE_p_std__pairT_std__mapT_unsigned_int_infomap__StateNetwork__StateNode_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_infomap__StateNetwork__StateNode_t_t_t__iterator_bool_t swig_types[106]
#define SWIGTYPE_p_std__pairT_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t__iterator_bool_t swig_types[107]
#define SWIGTYPE_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator swig_types[108]
#define SWIGTYPE_p_std__vectorT_ParsedOption_std__allocatorT_ParsedOption_t_t swig_types[109]
#define SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t swig_types[110]
#define SWIGTYPE_p_std__vectorT_infomap__FlowData_std__allocatorT_infomap__FlowData_t_t swig_types[111]
#define SWIGTYPE_p_std__vectorT_infomap__InfoNode_p_std__allocatorT_infomap__InfoNode_p_t_t swig_types[112]
#define SWIGTYPE_p_std__vectorT_infomap__PerLevelStat_std__allocatorT_infomap__PerLevelStat_t_t swig_types[113]
#define SWIGTYPE_p_std__vectorT_infomap__PhysData_std__allocatorT_infomap__PhysData_t_t swig_types[114]
#define SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t swig_types[115]
#define SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t swig_types[116]
#define SWIGTYPE_p_std__vectorT_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__allocatorT_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t swig_types[117]
#define SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t swig_types[118]
#define SWIGTYPE_p_tree_iterator swig_types[119]
#define SWIGTYPE_p_value_type swig_types[120]
static swig_type_info *swig_types[122];
static swig_module_info swig_module = {swig_types, 121, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */


/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if defined(__GNUC__)
#  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    ifndef GCC_HASCLASSVISIBILITY
#      define GCC_HASCLASSVISIBILITY
#    endif
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif


#define SWIGVERSION 0x040002 
#define SWIG_VERSION SWIGVERSION


#define SWIG_as_voidptr(a) const_cast< void * >(static_cast< const void * >(a)) 
#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),reinterpret_cast< void** >(a)) 


#include <stdexcept>


/* Includes the header in the wrapper code */
#include "src/Infomap.h"
// SWIG strips namespaces, so include infomap in global namespace in wrapper code
using namespace infomap;


#include <string>


/* Includes the header in the wrapper code */
#include "src/io/Config.h"


SWIGINTERN int
SWIG_AsCharPtrAndSize(SEXP obj, char** cptr, size_t* psize, int *alloc)
{
  if (cptr && Rf_isString(obj)) {
    char *cstr = const_cast< char * >(CHAR(STRING_ELT(obj, 0)));
    int len = strlen(cstr);

    if (alloc) {
      if (*alloc == SWIG_NEWOBJ) {
        *cptr = reinterpret_cast< char* >(memcpy(new char[len + 1], cstr, sizeof(char)*(len + 1)));
        *alloc = SWIG_NEWOBJ;
      } else {
        *cptr = cstr;
      }
    } else {
      *cptr = reinterpret_cast< char * >(malloc(len + 1));
      *cptr = strcpy(*cptr, cstr);
    }
    if (psize) *psize = len + 1;
    return SWIG_OK;
  }
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsPtr_std_string (SEXP obj, std::string **val) 
{
  char* buf = 0 ; size_t size = 0; int alloc = SWIG_OLDOBJ;
  if (SWIG_IsOK((SWIG_AsCharPtrAndSize(obj, &buf, &size, &alloc)))) {
    if (buf) {
      if (val) *val = new std::string(buf, size - 1);
      if (alloc == SWIG_NEWOBJ) delete[] buf;
      return SWIG_NEWOBJ;
    } else {
      if (val) *val = 0;
      return SWIG_OLDOBJ;
    }
  } else {
    static int init = 0;
    static swig_type_info* descriptor = 0;
    if (!init) {
      descriptor = SWIG_TypeQuery("std::string" " *");
      init = 1;
    }
    if (descriptor) {
      std::string *vptr;
      int res = SWIG_R_ConvertPtr(obj, (void**)&vptr, descriptor, 0);
      if (SWIG_IsOK(res) && val) *val = vptr;
      return res;
    }
  }
  return SWIG_ERROR;
}


SWIGINTERN SEXP
SWIG_FromCharPtrAndSize(const char* carray, size_t size) 
{
  SEXP t, c;
  if (!carray) return R_NilValue;
/* See R internals document 1.10.  
   MkCharLen was introduced in 2.7.0.  Use that instead of hand
   creating vector.

   Starting in 2.8.0 creating strings via vectors was deprecated in
   order to allow for use of CHARSXP caches. */

  Rf_protect(t = Rf_allocVector(STRSXP, 1));
#if R_VERSION >=  R_Version(2,7,0)
  c = Rf_mkCharLen(carray, size);
#else
  c = Rf_allocVector(CHARSXP, size);
  strncpy((char *)CHAR(c), carray, size);
#endif
  SET_STRING_ELT(t, 0, c);
  Rf_unprotect(1);
  return t;
}


SWIGINTERNINLINE SEXP
SWIG_From_std_string  (const std::string& s)
{
  return SWIG_FromCharPtrAndSize(s.data(), s.size());
}


SWIGINTERNINLINE SEXP
SWIG_From_double  (double value)
{
	return Rf_ScalarReal(value);
}


#include <limits.h>
#if !defined(SWIG_NO_LLONG_MAX)
# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
#   define LLONG_MAX __LONG_LONG_MAX__
#   define LLONG_MIN (-LLONG_MAX - 1LL)
#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
# endif
#endif


SWIGINTERNINLINE  int
SWIG_AsVal_long (SEXP obj, long *val)
{
   if (val) *val = Rf_asInteger(obj);
   return SWIG_OK;
}


SWIGINTERN int
SWIG_AsVal_int (SEXP obj, int *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < INT_MIN || v > INT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< int >(v);
    }
  }  
  return res;
}


SWIGINTERNINLINE SEXP
SWIG_From_long  (long value)
{
	return Rf_ScalarInteger((int)value);
}


SWIGINTERNINLINE SEXP
SWIG_From_int  (int value)
{    
  return SWIG_From_long  (value);
}


/* Includes the header in the wrapper code */
#include "src/core/InfomapCore.h"
// SWIG strips namespaces, so include infomap in global namespace in wrapper code
using namespace infomap;


/* Includes the header in the wrapper code */
#include "src/core/InfomapBase.h"


/* Includes the header in the wrapper code */
#include "src/core/InfomapConfig.h"


/* Includes the header in the wrapper code */
#include "src/core/InfoNode.h"


/* Includes the header in the wrapper code */
#include "src/core/FlowData.h"


#include <typeinfo>
#include <stdexcept>


#if defined(__GNUC__)
#  if __GNUC__ == 2 && __GNUC_MINOR <= 96
#     define SWIG_STD_NOMODERN_STL
#  endif
#endif


#include <stddef.h>


#include <algorithm>


#include <vector>


namespace swig {
  template <class Type>
  struct noconst_traits {
    typedef Type noconst_type;
  };

  template <class Type>
  struct noconst_traits<const Type> {
    typedef Type noconst_type;
  };

  /*
    type categories
  */
  struct pointer_category { };
  struct value_category { };

  /*
    General traits that provides type_name and type_info
  */
  template <class Type> struct traits { };

  template <class Type>
  inline const char* type_name() {
    return traits<typename noconst_traits<Type >::noconst_type >::type_name();
  }

  template <class Type> struct traits_info {
    static swig_type_info *type_query(std::string name) {
      name += " *";
      return SWIG_TypeQuery(name.c_str());
    }
    static swig_type_info *type_info() {
      static swig_type_info *info = type_query(type_name<Type>());
      return info;
    }
  };

  /*
    Partial specialization for pointers (traits_info)
  */
  template <class Type> struct traits_info<Type *> {
    static swig_type_info *type_query(std::string name) {
      name += " *";
      return SWIG_TypeQuery(name.c_str());
    }
    static swig_type_info *type_info() {
      static swig_type_info *info = type_query(type_name<Type>());
      return info;
    }
  };

  template <class Type>
  inline swig_type_info *type_info() {
    return traits_info<Type>::type_info();
  }

  /*
    Partial specialization for pointers (traits)
  */
  template <class Type> struct traits <Type *> {
    typedef pointer_category category;
    static std::string make_ptr_name(const char* name) {
      std::string ptrname = name;
      ptrname += " *";
      return ptrname;
    }
    static const char* type_name() {
      static std::string name = make_ptr_name(swig::type_name<Type>());
      return name.c_str();
    }
  };

  template <class Type, class Category>
  struct traits_as { };

  template <class Type, class Category>
  struct traits_check { };

}


namespace swig {  
  /*
    Traits that provides the from method
  */

  template <class Type> struct traits_from_ptr {
    static SEXP from(Type *val, int owner = 0) {
      return SWIG_R_NewPointerObj(val, type_info<Type>(), owner);
    }
  };

  template <class Type> struct traits_from {
    static SEXP from(const Type& val) {
      return traits_from_ptr<Type>::from(new Type(val), 1);
    }
  };

  template <class Type> struct traits_from<Type *> {
    static SEXP from(Type* val) {
      return traits_from_ptr<Type>::from(val, 0);
    }
  };

  template <class Type>
  inline SEXP from(const Type& val) {
    return traits_from<Type>::from(val);
  }

  template <class Type>
  inline SEXP from_ptr(Type* val, int owner) {
    return traits_from_ptr<Type>::from(val, owner);
  }

  /*
    Traits that provides the asval/as/check method
  */
  template <class Type>
  struct traits_asptr {   
    static int asptr(SEXP obj, Type **val) {
      Type *p = 0;
      swig_type_info *descriptor = type_info<Type>();
      int res = descriptor ? SWIG_R_ConvertPtr(obj, (void **)&p, descriptor, 0) : SWIG_ERROR;
      if (SWIG_IsOK(res)) {
	if (val) *val = p;
      }
      return res;
    }
  }; 

  template <class Type>
  inline int asptr(SEXP obj, Type **vptr) {
    return traits_asptr<Type>::asptr(obj, vptr);
  }

  template <class Type> 
  struct traits_asval {
    static int asval(SEXP obj, Type *val) {
      if (val) {
	Type *p = 0;
	int res = traits_asptr<Type>::asptr(obj, &p);
	if (!SWIG_IsOK(res)) return res;	
	if (p) {
	  typedef typename noconst_traits<Type>::noconst_type noconst_type;
	  *(const_cast<noconst_type*>(val)) = *p;
	  if (SWIG_IsNewObj(res)){
	    delete p;
	    res = SWIG_DelNewMask(res);
	  }
	  return res;
	} else {
	  return SWIG_ERROR;
	}
      } else {
	return traits_asptr<Type>::asptr(obj, (Type **)(0));
      }
    }
  };

  template <class Type> struct traits_asval<Type*> {
    static int asval(SEXP obj, Type **val) {
      if (val) {
        typedef typename noconst_traits<Type>::noconst_type noconst_type;
        noconst_type *p = 0;
        int res = traits_asptr<noconst_type>::asptr(obj,  &p);
        if (SWIG_IsOK(res)) {
          *(const_cast<noconst_type**>(val)) = p;
	}
	return res;
      } else {
	return traits_asptr<Type>::asptr(obj, (Type **)(0));
      }
    }
  };
  
  template <class Type>
  inline int asval(SEXP obj, Type *val) {
    return traits_asval<Type>::asval(obj, val);
  }

  template <class Type> 
  struct traits_as<Type, value_category> {
    static Type as(SEXP obj) {
      Type v;
      int res = asval(obj, &v);
      if (!obj || !SWIG_IsOK(res)) {
        throw std::invalid_argument("bad type");
      }
      return v;
    }
  };

  template <class Type> 
  struct traits_as<Type, pointer_category> {
    static Type as(SEXP obj) {
      Type *v = 0;      
      int res = (obj ? traits_asptr<Type>::asptr(obj, &v) : SWIG_ERROR);
      if (SWIG_IsOK(res) && v) {
	if (SWIG_IsNewObj(res)) {
	  Type r(*v);
	  delete v;
	  return r;
	} else {
	  return *v;
	}
      } else {
          throw std::invalid_argument("bad type");
      }
    }
  };

  template <class Type> 
  struct traits_as<Type*, pointer_category> {
    static Type* as(SEXP obj, bool throw_error) {
      Type *v = 0;      
      int res = (obj ? traits_asptr<Type>::asptr(obj, &v) : SWIG_ERROR);
      if (SWIG_IsOK(res)) {
	return v;
      } else {
	if (throw_error)
          throw std::invalid_argument("bad type");
	return 0;
      }
    }
  };
    
  template <class Type>
  inline Type as(SEXP obj) {
    return traits_as<Type, typename traits<Type>::category>::as(obj);
  }

  template <class Type> 
  struct traits_check<Type, value_category> {
    static bool check(SEXP obj) {
      int res = obj ? asval(obj, (Type *)(0)) : SWIG_ERROR;
      return SWIG_IsOK(res) ? true : false;
    }
  };

  template <class Type> 
  struct traits_check<Type, pointer_category> {
    static bool check(SEXP obj) {
      int res = obj ? asptr(obj, (Type **)(0)) : SWIG_ERROR;
      return SWIG_IsOK(res) ? true : false;
    }
  };

  template <class Type>
  inline bool check(SEXP obj) {
    return traits_check<Type, typename traits<Type>::category>::check(obj);
  }
}


#include <functional>
namespace swig {
  inline size_t
  check_index(ptrdiff_t i, size_t size, bool insert = false) {
    if ( i < 0 ) {
      if ((size_t) (-i) <= size)
	return (size_t) (i + size);
    } else if ( (size_t) i < size ) {
      return (size_t) i;
    } else if (insert && ((size_t) i == size)) {
      return size;
    }
    
    throw std::out_of_range("index out of range");
  }

  inline size_t
  slice_index(ptrdiff_t i, size_t size) {
    if ( i < 0 ) {
      if ((size_t) (-i) <= size) {
	return (size_t) (i + size);
      } else {
	throw std::out_of_range("index out of range");
      }
    } else {
      return ( (size_t) i < size ) ? ((size_t) i) : size;
    }
  }

  template <class Sequence, class Difference>
  inline typename Sequence::iterator
  getpos(Sequence* self, Difference i)  {
    typename Sequence::iterator pos = self->begin();
    std::advance(pos, check_index(i,self->size()));
    return pos;
  }

  template <class Sequence, class Difference>
  inline typename Sequence::const_iterator
  cgetpos(const Sequence* self, Difference i)  {
    typename Sequence::const_iterator pos = self->begin();
    std::advance(pos, check_index(i,self->size()));
    return pos;
  }

  template <class Sequence, class Difference>
  inline Sequence*
  getslice(const Sequence* self, Difference i, Difference j) {
    typename Sequence::size_type size = self->size();
    typename Sequence::size_type ii = swig::check_index(i, size);
    typename Sequence::size_type jj = swig::slice_index(j, size);

    if (jj > ii) {
      typename Sequence::const_iterator vb = self->begin();
      typename Sequence::const_iterator ve = self->begin();
      std::advance(vb,ii);
      std::advance(ve,jj);
      return new Sequence(vb, ve);
    } else {
      return new Sequence();
    }
  }

  template <class Sequence, class Difference, class InputSeq>
  inline void
  setslice(Sequence* self, Difference i, Difference j, const InputSeq& v) {
    typename Sequence::size_type size = self->size();
    typename Sequence::size_type ii = swig::check_index(i, size, true);
    typename Sequence::size_type jj = swig::slice_index(j, size);
    if (jj < ii) jj = ii;
    size_t ssize = jj - ii;
    if (ssize <= v.size()) {
      typename Sequence::iterator sb = self->begin();
      typename InputSeq::const_iterator vmid = v.begin();
      std::advance(sb,ii);
      std::advance(vmid, jj - ii);
      self->insert(std::copy(v.begin(), vmid, sb), vmid, v.end());
    } else {
      typename Sequence::iterator sb = self->begin();
      typename Sequence::iterator se = self->begin();
      std::advance(sb,ii);
      std::advance(se,jj);
      self->erase(sb,se);
      self->insert(sb, v.begin(), v.end());
    }
  }

  template <class Sequence, class Difference>
  inline void
  delslice(Sequence* self, Difference i, Difference j) {
    typename Sequence::size_type size = self->size();
    typename Sequence::size_type ii = swig::check_index(i, size, true);
    typename Sequence::size_type jj = swig::slice_index(j, size);
    if (jj > ii) {
      typename Sequence::iterator sb = self->begin();
      typename Sequence::iterator se = self->begin();
      std::advance(sb,ii);
      std::advance(se,jj);
      self->erase(sb,se);
    }
  }
}


  namespace swig {
    // vectors of doubles
    template <>
      struct traits_from_ptr<std::vector<double> > {
      static SEXP from (std::vector<double > *val, int owner = 0) {
        SEXP result;
        PROTECT(result = Rf_allocVector(REALSXP, val->size()));
        for (unsigned pos = 0; pos < val->size(); pos++)
          {
            NUMERIC_POINTER(result)[pos] = ((*val)[pos]);
          }
        UNPROTECT(1);
        return(result);
      }
    };
    // vectors of floats
    template <>
      struct traits_from_ptr<std::vector<float> > {
      static SEXP from (std::vector<float > *val, int owner = 0) {
        SEXP result;
        PROTECT(result = Rf_allocVector(REALSXP, val->size()));
        for (unsigned pos = 0; pos < val->size(); pos++)
          {
            NUMERIC_POINTER(result)[pos] = ((*val)[pos]);
          }
        UNPROTECT(1);
        return(result);
      }
    };
    // vectors of unsigned 8bit int
    template <>
      struct traits_from_ptr<std::vector<unsigned char> > {
      static SEXP from (std::vector<unsigned char > *val, int owner = 0) {
        SEXP result;
        PROTECT(result = Rf_allocVector(INTSXP, val->size()));
        for (unsigned pos = 0; pos < val->size(); pos++)
          {
            INTEGER_POINTER(result)[pos] = ((*val)[pos]);
          }
        UNPROTECT(1);
        return(result);
      }
    };
    // vectors of 8bit int
    template <>
      struct traits_from_ptr<std::vector<signed char> > {
      static SEXP from (std::vector<signed char > *val, int owner = 0) {
        SEXP result;
        PROTECT(result = Rf_allocVector(INTSXP, val->size()));
        for (unsigned pos = 0; pos < val->size(); pos++)
          {
            INTEGER_POINTER(result)[pos] = ((*val)[pos]);
          }
        UNPROTECT(1);
        return(result);
      }
    };

    // vectors of unsigned 16bit int
    template <>
      struct traits_from_ptr<std::vector<unsigned short int> > {
      static SEXP from (std::vector<unsigned short int > *val, int owner = 0) {
        SEXP result;
        PROTECT(result = Rf_allocVector(INTSXP, val->size()));
        for (unsigned pos = 0; pos < val->size(); pos++)
          {
            INTEGER_POINTER(result)[pos] = ((*val)[pos]);
          }
        UNPROTECT(1);
        return(result);
      }
    };
    // vectors of 16bit int
    template <>
      struct traits_from_ptr<std::vector<short int> > {
      static SEXP from (std::vector<short int > *val, int owner = 0) {
        SEXP result;
        PROTECT(result = Rf_allocVector(INTSXP, val->size()));
        for (unsigned pos = 0; pos < val->size(); pos++)
          {
            INTEGER_POINTER(result)[pos] = ((*val)[pos]);
          }
        UNPROTECT(1);
        return(result);
      }
    };

   // vectors of 32 bit unsigned int
    template <>
      struct traits_from_ptr<std::vector<unsigned int> > {
      static SEXP from (std::vector<unsigned int> *val, int owner = 0) {
        SEXP result;
        PROTECT(result = Rf_allocVector(INTSXP, val->size()));
        for (unsigned pos = 0; pos < val->size(); pos++)
          {
            INTEGER_POINTER(result)[pos] = ((*val)[pos]);
          }
        UNPROTECT(1);
        return(result);
      }
    };

    // vectors of 32bit int
    template <>
      struct traits_from_ptr<std::vector<int> > {
      static SEXP from (std::vector<int > *val, int owner = 0) {
        SEXP result;
        PROTECT(result = Rf_allocVector(INTSXP, val->size()));
        for (unsigned pos = 0; pos < val->size(); pos++)
          {
            INTEGER_POINTER(result)[pos] = ((*val)[pos]);
          }
        UNPROTECT(1);
        return(result);
      }
    };

   // vectors of 64 bit unsigned int
#if defined(SWIGWORDSIZE64)
    template <>
      struct traits_from_ptr<std::vector<unsigned long int> > {
      static SEXP from (std::vector<unsigned long int> *val, int owner = 0) {
        SEXP result;
        PROTECT(result = Rf_allocVector(INTSXP, val->size()));
        for (unsigned pos = 0; pos < val->size(); pos++)
          {
            INTEGER_POINTER(result)[pos] = ((*val)[pos]);
          }
        UNPROTECT(1);
        return(result);
      }
    };
     // vectors of 64 bit int
    template <>
      struct traits_from_ptr<std::vector<long int> > {
      static SEXP from (std::vector<long int> *val, int owner = 0) {
        SEXP result;
        PROTECT(result = Rf_allocVector(INTSXP, val->size()));
        for (unsigned pos = 0; pos < val->size(); pos++)
          {
            INTEGER_POINTER(result)[pos] = ((*val)[pos]);
          }
        UNPROTECT(1);
        return(result);
      }
    };
#else
    template <>
      struct traits_from_ptr<std::vector<unsigned long long int> > {
      static SEXP from (std::vector<unsigned long long int> *val, int owner = 0) {
        SEXP result;
        PROTECT(result = Rf_allocVector(INTSXP, val->size()));
        for (unsigned pos = 0; pos < val->size(); pos++)
          {
            INTEGER_POINTER(result)[pos] = ((*val)[pos]);
          }
        UNPROTECT(1);
        return(result);
      }
    };
     // vectors of 64 bit int
    template <>
      struct traits_from_ptr<std::vector<long long int> > {
      static SEXP from (std::vector<long long int> *val, int owner = 0) {
        SEXP result;
        PROTECT(result = Rf_allocVector(INTSXP, val->size()));
        for (unsigned pos = 0; pos < val->size(); pos++)
          {
            INTEGER_POINTER(result)[pos] = ((*val)[pos]);
          }
        UNPROTECT(1);
        return(result);
      }
    };
#endif
    // vectors of bool
    template <>
      struct traits_from_ptr<std::vector<bool> > {
      static SEXP from (std::vector<bool> *val, int owner = 0) {
        SEXP result;
        PROTECT(result = Rf_allocVector(LGLSXP, val->size()));
        for (unsigned pos = 0; pos < val->size(); pos++)
          {
            LOGICAL_POINTER(result)[pos] = ((*val)[pos]);
          }
        UNPROTECT(1);
        return(result);
      }
    };
    
    // vectors of strings
    template <>
      struct traits_from_ptr<std::vector<std::basic_string<char> > > {
      static SEXP from (std::vector<std::basic_string<char> > *val, int owner = 0) {
        SEXP result;
         PROTECT(result = Rf_allocVector(STRSXP, val->size()));
         for (unsigned pos = 0; pos < val->size(); pos++)
           {
             CHARACTER_POINTER(result)[pos] = Rf_mkChar(((*val)[pos]).c_str());
           }
        UNPROTECT(1);
        return(result);
      }
    };

    // catch all that does everything with vectors
    template <typename T>
      struct traits_from_ptr< std::vector< T > > {
      static SEXP from (std::vector< T > *val, int owner = 0) {
        return SWIG_R_NewPointerObj(val, type_info< std::vector< T >  >(), owner);
      }
    };
    /////////////////////////////////////////////////
    template <>
  struct traits_asptr < std::vector<double> > {
    static int asptr(SEXP obj, std::vector<double> **val) {
      std::vector<double> *p;
      // not sure how to check the size of the SEXP obj is correct
      unsigned int sexpsz = Rf_length(obj);
      p = new std::vector<double>(sexpsz);
      double *S = NUMERIC_POINTER(obj);
      for (unsigned pos = 0; pos < p->size(); pos++)
        {
          (*p)[pos] = static_cast<double>(S[pos]);
        }
      int res = SWIG_OK;
      if (SWIG_IsOK(res)) {
        if (val) *val = p;
      }
      return res;
    }
  };

    template <>
  struct traits_asptr < std::vector<float> > {
    static int asptr(SEXP obj, std::vector<float> **val) {
      std::vector<float> *p;
      // not sure how to check the size of the SEXP obj is correct
      unsigned int sexpsz = Rf_length(obj);
      p = new std::vector<float>(sexpsz);
      double *S = NUMERIC_POINTER(obj);
      for (unsigned pos = 0; pos < p->size(); pos++)
        {
          (*p)[pos] = static_cast<double>(S[pos]);
        }
      int res = SWIG_OK;
      if (SWIG_IsOK(res)) {
        if (val) *val = p;
      }
      return res;
    }
  };

    // 8 bit integer types
    template <>
  struct traits_asptr < std::vector<unsigned char> > {
    static int asptr(SEXP obj, std::vector<unsigned char> **val) {
      std::vector<unsigned char> *p;
      unsigned int sexpsz = Rf_length(obj);
      p = new std::vector<unsigned char>(sexpsz);
      SEXP coerced;
      PROTECT(coerced = Rf_coerceVector(obj, INTSXP));
      int *S = INTEGER_POINTER(coerced);
      for (unsigned pos = 0; pos < p->size(); pos++)
        {
          (*p)[pos] = static_cast<unsigned char>(S[pos]);
        }
      int res = SWIG_OK;
      if (SWIG_IsOK(res)) {
        if (val) *val = p;
      }
      UNPROTECT(1);
      return res;
    }
  };

    template <>
  struct traits_asptr < std::vector<signed char> > {
    static int asptr(SEXP obj, std::vector<signed char> **val) {
      std::vector<signed char> *p;
      // not sure how to check the size of the SEXP obj is correct
      int sexpsz = Rf_length(obj);
      p = new std::vector<signed char>(sexpsz);
      SEXP coerced;
      PROTECT(coerced = Rf_coerceVector(obj, INTSXP));
      int *S = INTEGER_POINTER(coerced);
      for (unsigned pos = 0; pos < p->size(); pos++)
        {
          (*p)[pos] = static_cast<signed char>(S[pos]);
        }
      int res = SWIG_OK;
      if (SWIG_IsOK(res)) {
        if (val) *val = p;
      }
      UNPROTECT(1);
      return res;
    }
  };

   // 16 bit integer types
    template <>
  struct traits_asptr < std::vector<unsigned short int> > {
    static int asptr(SEXP obj, std::vector<unsigned short int> **val) {
      std::vector<unsigned short int> *p;
      unsigned int sexpsz = Rf_length(obj);
      p = new std::vector<unsigned short int>(sexpsz);
      SEXP coerced;
      PROTECT(coerced = Rf_coerceVector(obj, INTSXP));
      int *S = INTEGER_POINTER(coerced);
      for (unsigned pos = 0; pos < p->size(); pos++)
        {
          (*p)[pos] = static_cast<unsigned short int>(S[pos]);
        }
      int res = SWIG_OK;
      if (SWIG_IsOK(res)) {
        if (val) *val = p;
      }
      UNPROTECT(1);
      return res;
    }
  };

    template <>
  struct traits_asptr < std::vector<short int> > {
    static int asptr(SEXP obj, std::vector<short int> **val) {
      std::vector<short int> *p;
      // not sure how to check the size of the SEXP obj is correct
      int sexpsz = Rf_length(obj);
      p = new std::vector<short int>(sexpsz);
      SEXP coerced;
      PROTECT(coerced = Rf_coerceVector(obj, INTSXP));
      int *S = INTEGER_POINTER(coerced);
      for (unsigned pos = 0; pos < p->size(); pos++)
        {
          (*p)[pos] = static_cast<short int>(S[pos]);
        }
      int res = SWIG_OK;
      if (SWIG_IsOK(res)) {
        if (val) *val = p;
      }
      UNPROTECT(1);
      return res;
    }
  };
    // 32 bit integer types
    template <>
  struct traits_asptr < std::vector<unsigned int> > {
    static int asptr(SEXP obj, std::vector<unsigned int> **val) {
      std::vector<unsigned int> *p;
      unsigned int sexpsz = Rf_length(obj);
      p = new std::vector<unsigned int>(sexpsz);
      SEXP coerced;
      PROTECT(coerced = Rf_coerceVector(obj, INTSXP));
      int *S = INTEGER_POINTER(coerced);
      for (unsigned pos = 0; pos < p->size(); pos++)
        {
          (*p)[pos] = static_cast<unsigned int>(S[pos]);
        }
      int res = SWIG_OK;
      if (SWIG_IsOK(res)) {
        if (val) *val = p;
      }
      UNPROTECT(1);
      return res;
    }
  };

    template <>
  struct traits_asptr < std::vector<int> > {
    static int asptr(SEXP obj, std::vector<int> **val) {
      std::vector<int> *p;
      // not sure how to check the size of the SEXP obj is correct
      int sexpsz = Rf_length(obj);
      p = new std::vector<int>(sexpsz);
      SEXP coerced;
      PROTECT(coerced = Rf_coerceVector(obj, INTSXP));
      int *S = INTEGER_POINTER(coerced);
      for (unsigned pos = 0; pos < p->size(); pos++)
        {
          (*p)[pos] = static_cast<int>(S[pos]);
        }
      int res = SWIG_OK;
      if (SWIG_IsOK(res)) {
        if (val) *val = p;
      }
      UNPROTECT(1);
      return res;
    }
  };

#if defined(SWIGWORDSIZE64)
    // 64 bit integer types
    template <>
  struct traits_asptr < std::vector<unsigned long int> > {
    static int asptr(SEXP obj, std::vector<unsigned long int> **val) {
      std::vector<unsigned long int> *p;
      unsigned int sexpsz = Rf_length(obj);
      p = new std::vector<unsigned long int>(sexpsz);
      SEXP coerced;
      PROTECT(coerced = Rf_coerceVector(obj, INTSXP));
      int *S = INTEGER_POINTER(coerced);
      for (unsigned pos = 0; pos < p->size(); pos++)
        {
          (*p)[pos] = static_cast<unsigned long int>(S[pos]);
        }
      int res = SWIG_OK;
      if (SWIG_IsOK(res)) {
        if (val) *val = p;
      }
      UNPROTECT(1);
      return res;
    }
  };

    template <>
  struct traits_asptr < std::vector<long int> > {
    static int asptr(SEXP obj, std::vector<long int> **val) {
      std::vector<long int> *p;
      // not sure how to check the size of the SEXP obj is correct
      int sexpsz = Rf_length(obj);
      p = new std::vector<long int>(sexpsz);
      SEXP coerced;
      PROTECT(coerced = Rf_coerceVector(obj, INTSXP));
      int *S = INTEGER_POINTER(coerced);
      for (unsigned pos = 0; pos < p->size(); pos++)
        {
          (*p)[pos] = static_cast<long int>(S[pos]);
        }
      int res = SWIG_OK;
      if (SWIG_IsOK(res)) {
        if (val) *val = p;
      }
      UNPROTECT(1);
      return res;
    }
  };

#else
    // 64 bit integer types
    template <>
  struct traits_asptr < std::vector<unsigned long long int> > {
    static int asptr(SEXP obj, std::vector<unsigned long long int> **val) {
      std::vector<unsigned long long int> *p;
      unsigned int sexpsz = Rf_length(obj);
      p = new std::vector<unsigned long long int>(sexpsz);
      SEXP coerced;
      PROTECT(coerced = Rf_coerceVector(obj, INTSXP));
      int *S = INTEGER_POINTER(coerced);
      for (unsigned pos = 0; pos < p->size(); pos++)
        {
          (*p)[pos] = static_cast<unsigned long long int>(S[pos]);
        }
      int res = SWIG_OK;
      if (SWIG_IsOK(res)) {
        if (val) *val = p;
      }
      UNPROTECT(1);
      return res;
    }
  };

    template <>
  struct traits_asptr < std::vector<long long int> > {
    static int asptr(SEXP obj, std::vector<long long int> **val) {
      std::vector<long long int> *p;
      // not sure how to check the size of the SEXP obj is correct
      int sexpsz = Rf_length(obj);
      p = new std::vector<long long int>(sexpsz);
      SEXP coerced;
      PROTECT(coerced = Rf_coerceVector(obj, INTSXP));
      int *S = INTEGER_POINTER(coerced);
      for (unsigned pos = 0; pos < p->size(); pos++)
        {
          (*p)[pos] = static_cast<long long int>(S[pos]);
        }
      int res = SWIG_OK;
      if (SWIG_IsOK(res)) {
        if (val) *val = p;
      }
      UNPROTECT(1);
      return res;
    }
  };

#endif

    template <>
  struct traits_asptr < std::vector<bool> > {
    static int asptr(SEXP obj, std::vector<bool> **val) {
      std::vector<bool> *p;
      // not sure how to check the size of the SEXP obj is correct
      int sexpsz = Rf_length(obj);
      p = new std::vector<bool>(sexpsz);
      SEXP coerced;
      PROTECT(coerced = Rf_coerceVector(obj, LGLSXP));
      int *S = LOGICAL_POINTER(coerced);
      for (unsigned pos = 0; pos < p->size(); pos++)
        {
          (*p)[pos] = static_cast<bool>(S[pos]);
        }
      int res = SWIG_OK;
      if (SWIG_IsOK(res)) {
        if (val) *val = p;
      }
      UNPROTECT(1);
      return res;
    }
  };

    template <>
      struct traits_asptr < std::vector<std::basic_string<char> > > {
      static int asptr(SEXP obj, std::vector<std::basic_string<char> > **val) {
	std::vector<std::basic_string<char> > *p;
      // R character vectors are STRSXP containing CHARSXP
      // access a CHARSXP using STRING_ELT
      int sexpsz = Rf_length(obj);
      p = new std::vector<std::basic_string<char> >(sexpsz);
      SEXP coerced;
      PROTECT(coerced = Rf_coerceVector(obj, STRSXP));
      //SEXP *S = CHARACTER_POINTER(coerced);
      for (unsigned pos = 0; pos < p->size(); pos++)
        {
	  const char * thecstring = CHAR(STRING_ELT(coerced, pos));
          (*p)[pos] = std::basic_string<char>(thecstring);
        }
      int res = SWIG_OK;
      if (SWIG_IsOK(res)) {
        if (val) *val = p;
      }
      UNPROTECT(1);
      return res;
    }
  };

    // catchall for R to vector conversion
  template <typename T>
  struct traits_asptr < std::vector<T> > {
    static int asptr(SEXP obj, std::vector<T> **val) {
      std::vector<T> *p;
      int res = SWIG_R_ConvertPtr(obj, (void**)&p, type_info< std::vector<T> >(), 0);
      if (SWIG_IsOK(res)) {
        if (val) *val = p;
      }
      return res;
    }
  };

  // now for vectors of vectors. These will be represented as lists of vectors on the
  // catch all that does everything with vectors
  template <>
    struct traits_from_ptr<std::vector<std::vector<unsigned int> > > {
      static SEXP from (std::vector< std::vector<unsigned int> > *val, int owner = 0) {
        SEXP result;
        // allocate the R list
        PROTECT(result = Rf_allocVector(VECSXP, val->size()));
        for (unsigned pos = 0; pos < val->size(); pos++)
          {
            // allocate the R vector
            SET_VECTOR_ELT(result, pos, Rf_allocVector(INTSXP, val->at(pos).size()));
            // Fill the R vector
            for (unsigned vpos = 0; vpos < val->at(pos).size(); ++vpos)
              {
                INTEGER_POINTER(VECTOR_ELT(result, pos))[vpos] = static_cast<int>(val->at(pos).at(vpos));
              }
          }
        UNPROTECT(1);
        return(result);
      }
    };


  template <>
    struct traits_from_ptr<std::vector<std::vector<int> > > {
      static SEXP from (std::vector< std::vector<int > > *val, int owner = 0) {
        SEXP result;
        // allocate the R list
        PROTECT(result = Rf_allocVector(VECSXP, val->size()));
        for (unsigned pos = 0; pos < val->size(); pos++)
          {
            // allocate the R vector
            SET_VECTOR_ELT(result, pos, Rf_allocVector(INTSXP, val->at(pos).size()));
            // Fill the R vector
            for (unsigned vpos = 0; vpos < val->at(pos).size(); ++vpos)
              {
                INTEGER_POINTER(VECTOR_ELT(result, pos))[vpos] = static_cast<int>(val->at(pos).at(vpos));
              }
          }
        UNPROTECT(1);
        return(result);
      }
    };

  template <>
    struct traits_from_ptr<std::vector<std::vector<float> > > {
      static SEXP from (std::vector< std::vector<float > > *val, int owner = 0) {
        SEXP result;
        // allocate the R list
        PROTECT(result = Rf_allocVector(VECSXP, val->size()));
        for (unsigned pos = 0; pos < val->size(); pos++)
          {
            // allocate the R vector
            SET_VECTOR_ELT(result, pos, Rf_allocVector(REALSXP, val->at(pos).size()));
            // Fill the R vector
            for (unsigned vpos = 0; vpos < val->at(pos).size(); ++vpos)
              {
                NUMERIC_POINTER(VECTOR_ELT(result, pos))[vpos] = static_cast<double>(val->at(pos).at(vpos));
              }
          }
        UNPROTECT(1);
        return(result);
      }
    };

  template <>
    struct traits_from_ptr<std::vector<std::vector<double> > > {
      static SEXP from (std::vector< std::vector<double > > *val, int owner = 0) {
        SEXP result;
        // allocate the R list
        PROTECT(result = Rf_allocVector(VECSXP, val->size()));
        for (unsigned pos = 0; pos < val->size(); pos++)
          {
            // allocate the R vector
            SET_VECTOR_ELT(result, pos, Rf_allocVector(REALSXP, val->at(pos).size()));
            // Fill the R vector
            for (unsigned vpos = 0; vpos < val->at(pos).size(); ++vpos)
              {
                NUMERIC_POINTER(VECTOR_ELT(result, pos))[vpos] = static_cast<double>(val->at(pos).at(vpos));
              }
          }
        UNPROTECT(1);
        return(result);
      }
    };

  template <>
    struct traits_from_ptr<std::vector<std::vector<bool> > > {
      static SEXP from (std::vector< std::vector<bool> > *val, int owner = 0) {
        SEXP result;
        // allocate the R list
        PROTECT(result = Rf_allocVector(VECSXP, val->size()));
        for (unsigned pos = 0; pos < val->size(); pos++)
          {
            // allocate the R vector
            SET_VECTOR_ELT(result, pos, Rf_allocVector(LGLSXP, val->at(pos).size()));
            // Fill the R vector
            for (unsigned vpos = 0; vpos < val->at(pos).size(); ++vpos)
              {
                LOGICAL_POINTER(VECTOR_ELT(result, pos))[vpos] = (val->at(pos).at(vpos));
              }
          }
        UNPROTECT(1);
        return(result);
      }
    };

  template <typename T>
    struct traits_from_ptr< std::vector < std::vector< T > > > {
    static SEXP from (std::vector < std::vector< T > > *val, int owner = 0) {
      return SWIG_R_NewPointerObj(val, type_info< std::vector < std::vector< T > > >(), owner);
    }
  };

  /////////////////////////////////////////////////////////////////

  // R side
  template <>
    struct traits_asptr < std::vector< std::vector<unsigned int> > > {
    static int asptr(SEXP obj, std::vector< std::vector<unsigned int> > **val) {
      std::vector <std::vector<unsigned int> > *p;
      // this is the length of the list
      unsigned int sexpsz = Rf_length(obj);
      p = new std::vector< std::vector<unsigned int> > (sexpsz);

      for (unsigned listpos = 0; listpos < sexpsz; ++listpos)
        {
          unsigned vecsize = Rf_length(VECTOR_ELT(obj, listpos));
          for (unsigned vpos = 0; vpos < vecsize; ++vpos)
            {
              (*p)[listpos].push_back(static_cast<int>(INTEGER_POINTER(VECTOR_ELT(obj, listpos))[vpos]));
            }
        }

      int res = SWIG_OK;

      if (SWIG_IsOK(res)) {
        if (val) *val = p;
      }
      return res;
    }
  };

  template <>
    struct traits_asptr < std::vector< std::vector< int> > > {
    static int asptr(SEXP obj, std::vector< std::vector< int> > **val) {
      std::vector <std::vector< int> > *p;
      // this is the length of the list
      unsigned int sexpsz = Rf_length(obj);
      p = new std::vector< std::vector< int> > (sexpsz);

      for (unsigned listpos = 0; listpos < sexpsz; ++listpos)
        {
          unsigned vecsize = Rf_length(VECTOR_ELT(obj, listpos));
          for (unsigned vpos = 0; vpos < vecsize; ++vpos)
            {
              (*p)[listpos].push_back(static_cast<int>(INTEGER_POINTER(VECTOR_ELT(obj, listpos))[vpos]));
            }
        }

      int res = SWIG_OK;

      if (SWIG_IsOK(res)) {
        if (val) *val = p;
      }
      return res;
    }
  };

  template <>
    struct traits_asptr < std::vector< std::vector< float> > > {
    static int asptr(SEXP obj, std::vector< std::vector< float> > **val) {
      std::vector <std::vector< float> > *p;
      // this is the length of the list
      unsigned int sexpsz = Rf_length(obj);
      p = new std::vector< std::vector< float> > (sexpsz);

      for (unsigned listpos = 0; listpos < sexpsz; ++listpos)
        {
          unsigned vecsize = Rf_length(VECTOR_ELT(obj, listpos));
          for (unsigned vpos = 0; vpos < vecsize; ++vpos)
            {
              (*p)[listpos].push_back(static_cast<float>(NUMERIC_POINTER(VECTOR_ELT(obj, listpos))[vpos]));
            }
        }

      int res = SWIG_OK;

      if (SWIG_IsOK(res)) {
        if (val) *val = p;
      }
      return res;
    }
  };

  template <>
    struct traits_asptr < std::vector< std::vector< double> > > {
    static int asptr(SEXP obj, std::vector< std::vector< double> > **val) {
      std::vector <std::vector< double> > *p;
      // this is the length of the list
      unsigned int sexpsz = Rf_length(obj);
      p = new std::vector< std::vector< double> > (sexpsz);

      for (unsigned listpos = 0; listpos < sexpsz; ++listpos)
        {
          unsigned vecsize = Rf_length(VECTOR_ELT(obj, listpos));
          for (unsigned vpos = 0; vpos < vecsize; ++vpos)
            {
              (*p)[listpos].push_back(static_cast<double>(NUMERIC_POINTER(VECTOR_ELT(obj, listpos))[vpos]));
            }
        }

      int res = SWIG_OK;

      if (SWIG_IsOK(res)) {
        if (val) *val = p;
      }
      return res;
    }
  };

  template <>
    struct traits_asptr < std::vector< std::vector< bool > > > {
    static int asptr(SEXP obj, std::vector< std::vector< bool> > **val) {
      std::vector <std::vector< bool > > *p;
      // this is the length of the list
      unsigned int sexpsz = Rf_length(obj);
      p = new std::vector< std::vector< bool > > (sexpsz);

      for (unsigned listpos = 0; listpos < sexpsz; ++listpos)
        {
          unsigned vecsize = Rf_length(VECTOR_ELT(obj, listpos));
          for (unsigned vpos = 0; vpos < vecsize; ++vpos)
            {
              (*p)[listpos].push_back(static_cast<bool>(LOGICAL_POINTER(VECTOR_ELT(obj, listpos))[vpos]));
            }
        }

      int res = SWIG_OK;

      if (SWIG_IsOK(res)) {
        if (val) *val = p;
      }
      return res;
    }
  };

  //  catchall
  template <typename T>
    struct traits_asptr < std::vector< std::vector<T> > > {
    static int asptr(SEXP obj, std::vector< std::vector<T> > **val) {
      std::vector< std::vector<T> > *p;
      Rprintf("vector of vectors - unsupported content\n");
      int res = SWIG_R_ConvertPtr(obj, (void**)&p, type_info< std::vector< std::vector<T> > > (), 0);
      if (SWIG_IsOK(res)) {
        if (val) *val = p;
      }
      return res;
    }
  };

  }


  namespace swig {
    template <>  struct traits< std::vector<unsigned int> > {
      typedef pointer_category category;
      static const char* type_name() {
        return"std::vector<unsigned int>";
      }
    };
  }
 
SWIGINTERN bool std_vector_Sl_unsigned_SS_int_Sg____nonzero__(std::vector< unsigned int > const *self){
      return !(self->empty());
    }
SWIGINTERN std::vector< unsigned int >::size_type std_vector_Sl_unsigned_SS_int_Sg____len__(std::vector< unsigned int > const *self){
      return self->size();
    }
SWIGINTERN std::vector< unsigned int >::value_type std_vector_Sl_unsigned_SS_int_Sg__pop(std::vector< unsigned int > *self){
      if (self->size() == 0)
	throw std::out_of_range("pop from empty container");
      std::vector< unsigned int,std::allocator< unsigned int > >::value_type x = self->back();
      self->pop_back();
      return x;
    }
SWIGINTERN std::vector< unsigned int,std::allocator< unsigned int > > *std_vector_Sl_unsigned_SS_int_Sg____getslice__(std::vector< unsigned int > *self,std::vector< unsigned int >::difference_type i,std::vector< unsigned int >::difference_type j){
      return swig::getslice(self, i, j);
    }
SWIGINTERN void std_vector_Sl_unsigned_SS_int_Sg____setslice__(std::vector< unsigned int > *self,std::vector< unsigned int >::difference_type i,std::vector< unsigned int >::difference_type j,std::vector< unsigned int,std::allocator< unsigned int > > const &v){
      swig::setslice(self, i, j, v);
    }
SWIGINTERN void std_vector_Sl_unsigned_SS_int_Sg____delslice__(std::vector< unsigned int > *self,std::vector< unsigned int >::difference_type i,std::vector< unsigned int >::difference_type j){
      swig::delslice(self, i, j);
    }
SWIGINTERN void std_vector_Sl_unsigned_SS_int_Sg____delitem__(std::vector< unsigned int > *self,std::vector< unsigned int >::difference_type i){
      self->erase(swig::getpos(self,i));
    }
SWIGINTERN std::vector< unsigned int >::value_type const &std_vector_Sl_unsigned_SS_int_Sg____getitem__(std::vector< unsigned int > const *self,std::vector< unsigned int >::difference_type i){
      return *(swig::cgetpos(self, i));
    }

SWIGINTERNINLINE SEXP
SWIG_From_unsigned_SS_long  (unsigned long value)
{
	return Rf_ScalarInteger((int)value);
}


SWIGINTERNINLINE SEXP
SWIG_From_unsigned_SS_int  (unsigned int value)
{    
  return SWIG_From_unsigned_SS_long  (value);
}


SWIGINTERNINLINE  int
SWIG_AsVal_unsigned_SS_long (SEXP obj, unsigned long *val)
{
   if (val) *val = Rf_asInteger(obj);
   return SWIG_OK;
}


SWIGINTERN int
SWIG_AsVal_unsigned_SS_int (SEXP obj, unsigned int *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > UINT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< unsigned int >(v);
    }
  }  
  return res;
}

SWIGINTERN void std_vector_Sl_unsigned_SS_int_Sg____setitem__(std::vector< unsigned int > *self,std::vector< unsigned int >::difference_type i,std::vector< unsigned int >::value_type const &x){
      *(swig::getpos(self,i)) = x;
    }
SWIGINTERN void std_vector_Sl_unsigned_SS_int_Sg__append(std::vector< unsigned int > *self,std::vector< unsigned int >::value_type const &x){
      self->push_back(x);
    }

  namespace swig {
    template <>  struct traits< std::vector<int> > {
      typedef pointer_category category;
      static const char* type_name() {
        return"std::vector<int>";
      }
    };
  }
 

/* Includes the header in the wrapper code */
#include "src/core/InfomapIterator.h"


#include <deque>


namespace swig {
  template <> struct traits< unsigned int > {
    typedef value_category category;
    static const char* type_name() { return"unsigned int"; }
  };
  template <>  struct traits_asval< unsigned int > {
    typedef unsigned int value_type;
    static int asval(SEXP obj, value_type *val) {
      return SWIG_AsVal_unsigned_SS_int (obj, val);
    }
  };
  template <>  struct traits_from< unsigned int > {
    typedef unsigned int value_type;
    static SEXP from(const value_type& val) {
      return SWIG_From_unsigned_SS_int  (val);
    }
  };
}


      namespace swig {
	template <>  struct traits<std::deque< unsigned int, std::allocator< unsigned int > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::deque<" "unsigned int" " >";
	  }
	};
      }
    

/* Includes the header in the wrapper code */
#include "src/io/Network.h"


/* Includes the header in the wrapper code */
#include "src/core/StateNetwork.h"


#include <utility>


#include <map>


#include <algorithm>




      namespace swig {
	template <>  struct traits<std::pair< unsigned int, unsigned int > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::pair<" "unsigned int" "," "unsigned int" " >";
	  }
	};
      }
    



      namespace swig {
	template <>  struct traits<std::map< unsigned int, unsigned int, std::less< unsigned int >, std::allocator< std::pair< unsigned int const,unsigned int > > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::map<" "unsigned int" "," "unsigned int" "," "std::less< unsigned int >" "," "std::allocator< std::pair< unsigned int const,unsigned int > >" " >";
	  }
	};
      }
    

  namespace swig {
    template <>  struct traits< std::vector<double> > {
      typedef pointer_category category;
      static const char* type_name() {
        return"std::vector<double>";
      }
    };
  }
 
SWIGINTERN bool std_vector_Sl_double_Sg____nonzero__(std::vector< double > const *self){
      return !(self->empty());
    }
SWIGINTERN std::vector< double >::size_type std_vector_Sl_double_Sg____len__(std::vector< double > const *self){
      return self->size();
    }
SWIGINTERN std::vector< double >::value_type std_vector_Sl_double_Sg__pop(std::vector< double > *self){
      if (self->size() == 0)
	throw std::out_of_range("pop from empty container");
      std::vector< double,std::allocator< double > >::value_type x = self->back();
      self->pop_back();
      return x;
    }
SWIGINTERN std::vector< double,std::allocator< double > > *std_vector_Sl_double_Sg____getslice__(std::vector< double > *self,std::vector< double >::difference_type i,std::vector< double >::difference_type j){
      return swig::getslice(self, i, j);
    }
SWIGINTERN void std_vector_Sl_double_Sg____setslice__(std::vector< double > *self,std::vector< double >::difference_type i,std::vector< double >::difference_type j,std::vector< double,std::allocator< double > > const &v){
      swig::setslice(self, i, j, v);
    }
SWIGINTERN void std_vector_Sl_double_Sg____delslice__(std::vector< double > *self,std::vector< double >::difference_type i,std::vector< double >::difference_type j){
      swig::delslice(self, i, j);
    }
SWIGINTERN void std_vector_Sl_double_Sg____delitem__(std::vector< double > *self,std::vector< double >::difference_type i){
      self->erase(swig::getpos(self,i));
    }
SWIGINTERN std::vector< double >::value_type const &std_vector_Sl_double_Sg____getitem__(std::vector< double > const *self,std::vector< double >::difference_type i){
      return *(swig::cgetpos(self, i));
    }

SWIGINTERNINLINE  int
SWIG_AsVal_double (SEXP obj, double *val)
{
   if (val) *val = Rf_asReal(obj);
   return SWIG_OK;
}

SWIGINTERN void std_vector_Sl_double_Sg____setitem__(std::vector< double > *self,std::vector< double >::difference_type i,std::vector< double >::value_type const &x){
      *(swig::getpos(self,i)) = x;
    }
SWIGINTERN void std_vector_Sl_double_Sg__append(std::vector< double > *self,std::vector< double >::value_type const &x){
      self->push_back(x);
    }

/* Includes the header in the wrapper code */
#include "src/core/MapEquation.h"


/* Includes the header in the wrapper code */
#include "src/core/MemMapEquation.h"


/* Includes the header in the wrapper code */
#include "src/core/MetaMapEquation.h"


      namespace swig {
	template <>  struct traits<std::pair< unsigned int, std::vector< unsigned int,std::allocator< unsigned int > > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::pair<" "unsigned int" "," "std::vector< unsigned int,std::allocator< unsigned int > >" " >";
	  }
	};
      }
    

      namespace swig {
	template <>  struct traits<std::map< unsigned int, std::vector< unsigned int,std::allocator< unsigned int > >, std::less< unsigned int >, std::allocator< std::pair< unsigned int const,std::vector< unsigned int,std::allocator< unsigned int > > > > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::map<" "unsigned int" "," "std::vector< unsigned int,std::allocator< unsigned int > >" "," "std::less< unsigned int >" "," "std::allocator< std::pair< unsigned int const,std::vector< unsigned int,std::allocator< unsigned int > > > >" " >";
	  }
	};
      }
    

SWIGINTERN int
SWIG_AsVal_std_string (SEXP obj, std::string *val)
{
  std::string* v = (std::string *) 0;
  int res = SWIG_AsPtr_std_string (obj, &v);
  if (!SWIG_IsOK(res)) return res;
  if (v) {
    if (val) *val = *v;
    if (SWIG_IsNewObj(res)) {
      delete v;
      res = SWIG_DelNewMask(res);
    }
    return res;
  }
  return SWIG_ERROR;
}


namespace swig {
  template <> struct traits< std::string > {
    typedef value_category category;
    static const char* type_name() { return"std::string"; }
  };
  template <>  struct traits_asval< std::string > {
    typedef std::string value_type;
    static int asval(SEXP obj, value_type *val) {
      return SWIG_AsVal_std_string (obj, val);
    }
  };
  template <>  struct traits_from< std::string > {
    typedef std::string value_type;
    static SEXP from(const value_type& val) {
      return SWIG_From_std_string  (val);
    }
  };
}


      namespace swig {
	template <>  struct traits<std::pair< unsigned int, std::string > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::pair<" "unsigned int" "," "std::string" " >";
	  }
	};
      }
    

      namespace swig {
	template <>  struct traits<std::map< unsigned int, std::string, std::less< unsigned int >, std::allocator< std::pair< unsigned int const,std::string > > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::map<" "unsigned int" "," "std::string" "," "std::less< unsigned int >" "," "std::allocator< std::pair< unsigned int const,std::string > >" " >";
	  }
	};
      }
    

#ifdef __cplusplus
extern "C" {
#endif

SWIGEXPORT SEXP
R_swig_FlowModel_value_set ( SEXP self, SEXP s_value)
{
  infomap::FlowModel *arg1 = (infomap::FlowModel *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__FlowModel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FlowModel_value_set" "', argument " "1"" of type '" "infomap::FlowModel *""'"); 
  }
  arg1 = reinterpret_cast< infomap::FlowModel * >(argp1);
  arg2 = static_cast< int >(INTEGER(s_value)[0]);
  if (arg1) (arg1)->value = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_FlowModel_value_get ( SEXP self, SEXP s_swig_copy)
{
  int result;
  infomap::FlowModel *arg1 = (infomap::FlowModel *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__FlowModel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FlowModel_value_get" "', argument " "1"" of type '" "infomap::FlowModel *""'"); 
  }
  arg1 = reinterpret_cast< infomap::FlowModel * >(argp1);
  result = (int) ((arg1)->value);
  r_ans = Rf_ScalarInteger(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_FlowModel ( SEXP val)
{
  infomap::FlowModel *result = 0 ;
  int arg1 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  arg1 = static_cast< int >(INTEGER(val)[0]);
  {
    try {
      result = (infomap::FlowModel *)new infomap::FlowModel(arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__FlowModel, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_FlowModel_Equal ( SEXP self, SEXP val, SEXP s_swig_copy)
{
  infomap::FlowModel *result = 0 ;
  infomap::FlowModel *arg1 = (infomap::FlowModel *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__FlowModel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FlowModel_Equal" "', argument " "1"" of type '" "infomap::FlowModel *""'"); 
  }
  arg1 = reinterpret_cast< infomap::FlowModel * >(argp1);
  arg2 = static_cast< int >(INTEGER(val)[0]);
  {
    try {
      result = (infomap::FlowModel *) &(arg1)->operator =(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__FlowModel, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_FlowModel ( SEXP self)
{
  infomap::FlowModel *arg1 = (infomap::FlowModel *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__FlowModel, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_FlowModel" "', argument " "1"" of type '" "infomap::FlowModel *""'"); 
  }
  arg1 = reinterpret_cast< infomap::FlowModel * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_OptimizationLevel_value_set ( SEXP self, SEXP s_value)
{
  infomap::OptimizationLevel *arg1 = (infomap::OptimizationLevel *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__OptimizationLevel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptimizationLevel_value_set" "', argument " "1"" of type '" "infomap::OptimizationLevel *""'"); 
  }
  arg1 = reinterpret_cast< infomap::OptimizationLevel * >(argp1);
  arg2 = static_cast< int >(INTEGER(s_value)[0]);
  if (arg1) (arg1)->value = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_OptimizationLevel_value_get ( SEXP self, SEXP s_swig_copy)
{
  int result;
  infomap::OptimizationLevel *arg1 = (infomap::OptimizationLevel *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__OptimizationLevel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptimizationLevel_value_get" "', argument " "1"" of type '" "infomap::OptimizationLevel *""'"); 
  }
  arg1 = reinterpret_cast< infomap::OptimizationLevel * >(argp1);
  result = (int) ((arg1)->value);
  r_ans = Rf_ScalarInteger(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_OptimizationLevel ( )
{
  infomap::OptimizationLevel *result = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    try {
      result = (infomap::OptimizationLevel *)new infomap::OptimizationLevel();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__OptimizationLevel, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_OptimizationLevel ( SEXP self)
{
  infomap::OptimizationLevel *arg1 = (infomap::OptimizationLevel *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__OptimizationLevel, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_OptimizationLevel" "', argument " "1"" of type '" "infomap::OptimizationLevel *""'"); 
  }
  arg1 = reinterpret_cast< infomap::OptimizationLevel * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_isCLI_set ( SEXP self, SEXP s_isCLI)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_isCLI_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_isCLI)[0] ? true : false;
  if (arg1) (arg1)->isCLI = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_isCLI_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_isCLI_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->isCLI);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_networkFile_set ( SEXP self, SEXP s_networkFile)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_networkFile_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(s_networkFile, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Config_networkFile_set" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Config_networkFile_set" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  if (arg1) (arg1)->networkFile = *arg2;
  r_ans = R_NilValue;
  if (SWIG_IsNewObj(res2)) delete arg2;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  if (SWIG_IsNewObj(res2)) delete arg2;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_networkFile_get ( SEXP self, SEXP s_swig_copy)
{
  std::string *result = 0 ;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_networkFile_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (std::string *) & ((arg1)->networkFile);
  r_ans = SWIG_From_std_string(static_cast< std::string >(*result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_additionalInput_set ( SEXP self, SEXP s_additionalInput)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg2 = (std::vector< std::string,std::allocator< std::string > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_additionalInput_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_additionalInput, &argp2, SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Config_additionalInput_set" "', argument " "2"" of type '" "std::vector< std::string,std::allocator< std::string > > *""'"); 
  }
  arg2 = reinterpret_cast< std::vector< std::string,std::allocator< std::string > > * >(argp2);
  if (arg1) (arg1)->additionalInput = *arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_additionalInput_get ( SEXP self)
{
  std::vector< std::string,std::allocator< std::string > > *result = 0 ;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_additionalInput_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (std::vector< std::string,std::allocator< std::string > > *)& ((arg1)->additionalInput);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_inputFormat_set ( SEXP self, SEXP s_inputFormat)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_inputFormat_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(s_inputFormat, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Config_inputFormat_set" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Config_inputFormat_set" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  if (arg1) (arg1)->inputFormat = *arg2;
  r_ans = R_NilValue;
  if (SWIG_IsNewObj(res2)) delete arg2;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  if (SWIG_IsNewObj(res2)) delete arg2;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_inputFormat_get ( SEXP self, SEXP s_swig_copy)
{
  std::string *result = 0 ;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_inputFormat_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (std::string *) & ((arg1)->inputFormat);
  r_ans = SWIG_From_std_string(static_cast< std::string >(*result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_memoryInput_set ( SEXP self, SEXP s_memoryInput)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_memoryInput_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_memoryInput)[0] ? true : false;
  if (arg1) (arg1)->memoryInput = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_memoryInput_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_memoryInput_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->memoryInput);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_multilayerInput_set ( SEXP self, SEXP s_multilayerInput)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_multilayerInput_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_multilayerInput)[0] ? true : false;
  if (arg1) (arg1)->multilayerInput = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_multilayerInput_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_multilayerInput_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->multilayerInput);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_weightThreshold_set ( SEXP self, SEXP s_weightThreshold)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_weightThreshold_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = static_cast< double >(REAL(s_weightThreshold)[0]);
  if (arg1) (arg1)->weightThreshold = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_weightThreshold_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_weightThreshold_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (double) ((arg1)->weightThreshold);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_unweightedPaths_set ( SEXP self, SEXP s_unweightedPaths)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_unweightedPaths_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_unweightedPaths)[0] ? true : false;
  if (arg1) (arg1)->unweightedPaths = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_unweightedPaths_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_unweightedPaths_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->unweightedPaths);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_pathMarkovOrder_set ( SEXP self, SEXP s_pathMarkovOrder)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_pathMarkovOrder_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  ecode2 = SWIG_AsVal_int(s_pathMarkovOrder, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Config_pathMarkovOrder_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->pathMarkovOrder = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_pathMarkovOrder_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_pathMarkovOrder_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (unsigned int) ((arg1)->pathMarkovOrder);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_bipartite_set ( SEXP self, SEXP s_bipartite)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_bipartite_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_bipartite)[0] ? true : false;
  if (arg1) (arg1)->bipartite = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_bipartite_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_bipartite_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->bipartite);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_skipAdjustBipartiteFlow_set ( SEXP self, SEXP s_skipAdjustBipartiteFlow)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_skipAdjustBipartiteFlow_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_skipAdjustBipartiteFlow)[0] ? true : false;
  if (arg1) (arg1)->skipAdjustBipartiteFlow = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_skipAdjustBipartiteFlow_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_skipAdjustBipartiteFlow_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->skipAdjustBipartiteFlow);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_bipartiteTeleportation_set ( SEXP self, SEXP s_bipartiteTeleportation)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_bipartiteTeleportation_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_bipartiteTeleportation)[0] ? true : false;
  if (arg1) (arg1)->bipartiteTeleportation = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_bipartiteTeleportation_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_bipartiteTeleportation_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->bipartiteTeleportation);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_hardPartitions_set ( SEXP self, SEXP s_hardPartitions)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_hardPartitions_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_hardPartitions)[0] ? true : false;
  if (arg1) (arg1)->hardPartitions = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_hardPartitions_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_hardPartitions_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->hardPartitions);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_parseWithoutIOStreams_set ( SEXP self, SEXP s_parseWithoutIOStreams)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_parseWithoutIOStreams_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_parseWithoutIOStreams)[0] ? true : false;
  if (arg1) (arg1)->parseWithoutIOStreams = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_parseWithoutIOStreams_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_parseWithoutIOStreams_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->parseWithoutIOStreams);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_zeroBasedNodeNumbers_set ( SEXP self, SEXP s_zeroBasedNodeNumbers)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_zeroBasedNodeNumbers_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_zeroBasedNodeNumbers)[0] ? true : false;
  if (arg1) (arg1)->zeroBasedNodeNumbers = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_zeroBasedNodeNumbers_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_zeroBasedNodeNumbers_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->zeroBasedNodeNumbers);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_includeSelfLinks_set ( SEXP self, SEXP s_includeSelfLinks)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_includeSelfLinks_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_includeSelfLinks)[0] ? true : false;
  if (arg1) (arg1)->includeSelfLinks = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_includeSelfLinks_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_includeSelfLinks_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->includeSelfLinks);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_ignoreEdgeWeights_set ( SEXP self, SEXP s_ignoreEdgeWeights)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_ignoreEdgeWeights_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_ignoreEdgeWeights)[0] ? true : false;
  if (arg1) (arg1)->ignoreEdgeWeights = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_ignoreEdgeWeights_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_ignoreEdgeWeights_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->ignoreEdgeWeights);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_nodeLimit_set ( SEXP self, SEXP s_nodeLimit)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_nodeLimit_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  ecode2 = SWIG_AsVal_int(s_nodeLimit, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Config_nodeLimit_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->nodeLimit = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_nodeLimit_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_nodeLimit_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (unsigned int) ((arg1)->nodeLimit);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_preClusterMultilayer_set ( SEXP self, SEXP s_preClusterMultilayer)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_preClusterMultilayer_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_preClusterMultilayer)[0] ? true : false;
  if (arg1) (arg1)->preClusterMultilayer = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_preClusterMultilayer_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_preClusterMultilayer_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->preClusterMultilayer);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_clusterDataFile_set ( SEXP self, SEXP s_clusterDataFile)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_clusterDataFile_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(s_clusterDataFile, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Config_clusterDataFile_set" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Config_clusterDataFile_set" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  if (arg1) (arg1)->clusterDataFile = *arg2;
  r_ans = R_NilValue;
  if (SWIG_IsNewObj(res2)) delete arg2;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  if (SWIG_IsNewObj(res2)) delete arg2;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_clusterDataFile_get ( SEXP self, SEXP s_swig_copy)
{
  std::string *result = 0 ;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_clusterDataFile_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (std::string *) & ((arg1)->clusterDataFile);
  r_ans = SWIG_From_std_string(static_cast< std::string >(*result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_metaDataFile_set ( SEXP self, SEXP s_metaDataFile)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_metaDataFile_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(s_metaDataFile, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Config_metaDataFile_set" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Config_metaDataFile_set" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  if (arg1) (arg1)->metaDataFile = *arg2;
  r_ans = R_NilValue;
  if (SWIG_IsNewObj(res2)) delete arg2;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  if (SWIG_IsNewObj(res2)) delete arg2;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_metaDataFile_get ( SEXP self, SEXP s_swig_copy)
{
  std::string *result = 0 ;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_metaDataFile_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (std::string *) & ((arg1)->metaDataFile);
  r_ans = SWIG_From_std_string(static_cast< std::string >(*result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_metaDataRate_set ( SEXP self, SEXP s_metaDataRate)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_metaDataRate_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = static_cast< double >(REAL(s_metaDataRate)[0]);
  if (arg1) (arg1)->metaDataRate = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_metaDataRate_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_metaDataRate_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (double) ((arg1)->metaDataRate);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_unweightedMetaData_set ( SEXP self, SEXP s_unweightedMetaData)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_unweightedMetaData_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_unweightedMetaData)[0] ? true : false;
  if (arg1) (arg1)->unweightedMetaData = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_unweightedMetaData_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_unweightedMetaData_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->unweightedMetaData);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_numMetaDataDimensions_set ( SEXP self, SEXP s_numMetaDataDimensions)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_numMetaDataDimensions_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  ecode2 = SWIG_AsVal_int(s_numMetaDataDimensions, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Config_numMetaDataDimensions_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->numMetaDataDimensions = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_numMetaDataDimensions_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_numMetaDataDimensions_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (unsigned int) ((arg1)->numMetaDataDimensions);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_clusterDataIsHard_set ( SEXP self, SEXP s_clusterDataIsHard)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_clusterDataIsHard_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_clusterDataIsHard)[0] ? true : false;
  if (arg1) (arg1)->clusterDataIsHard = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_clusterDataIsHard_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_clusterDataIsHard_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->clusterDataIsHard);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_assignToNeighbouringModule_set ( SEXP self, SEXP s_assignToNeighbouringModule)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_assignToNeighbouringModule_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_assignToNeighbouringModule)[0] ? true : false;
  if (arg1) (arg1)->assignToNeighbouringModule = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_assignToNeighbouringModule_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_assignToNeighbouringModule_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->assignToNeighbouringModule);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_noInfomap_set ( SEXP self, SEXP s_noInfomap)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_noInfomap_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_noInfomap)[0] ? true : false;
  if (arg1) (arg1)->noInfomap = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_noInfomap_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_noInfomap_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->noInfomap);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_flowModel_set ( SEXP self, SEXP s_flowModel)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  infomap::FlowModel *arg2 = (infomap::FlowModel *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_flowModel_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_flowModel, &argp2, SWIGTYPE_p_infomap__FlowModel, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Config_flowModel_set" "', argument " "2"" of type '" "infomap::FlowModel *""'"); 
  }
  arg2 = reinterpret_cast< infomap::FlowModel * >(argp2);
  if (arg1) (arg1)->flowModel = *arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_flowModel_get ( SEXP self)
{
  infomap::FlowModel *result = 0 ;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_flowModel_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (infomap::FlowModel *)& ((arg1)->flowModel);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__FlowModel, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_directed_set ( SEXP self, SEXP s_directed)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_directed_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_directed)[0] ? true : false;
  if (arg1) (arg1)->directed = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_directed_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_directed_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->directed);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_undirdir_set ( SEXP self, SEXP s_undirdir)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_undirdir_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_undirdir)[0] ? true : false;
  if (arg1) (arg1)->undirdir = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_undirdir_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_undirdir_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->undirdir);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_outdirdir_set ( SEXP self, SEXP s_outdirdir)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_outdirdir_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_outdirdir)[0] ? true : false;
  if (arg1) (arg1)->outdirdir = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_outdirdir_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_outdirdir_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->outdirdir);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_rawdir_set ( SEXP self, SEXP s_rawdir)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_rawdir_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_rawdir)[0] ? true : false;
  if (arg1) (arg1)->rawdir = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_rawdir_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_rawdir_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->rawdir);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_useNodeWeightsAsFlow_set ( SEXP self, SEXP s_useNodeWeightsAsFlow)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_useNodeWeightsAsFlow_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_useNodeWeightsAsFlow)[0] ? true : false;
  if (arg1) (arg1)->useNodeWeightsAsFlow = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_useNodeWeightsAsFlow_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_useNodeWeightsAsFlow_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->useNodeWeightsAsFlow);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_teleportToNodes_set ( SEXP self, SEXP s_teleportToNodes)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_teleportToNodes_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_teleportToNodes)[0] ? true : false;
  if (arg1) (arg1)->teleportToNodes = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_teleportToNodes_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_teleportToNodes_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->teleportToNodes);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_selfTeleportationProbability_set ( SEXP self, SEXP s_selfTeleportationProbability)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_selfTeleportationProbability_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = static_cast< double >(REAL(s_selfTeleportationProbability)[0]);
  if (arg1) (arg1)->selfTeleportationProbability = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_selfTeleportationProbability_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_selfTeleportationProbability_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (double) ((arg1)->selfTeleportationProbability);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_markovTime_set ( SEXP self, SEXP s_markovTime)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_markovTime_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = static_cast< double >(REAL(s_markovTime)[0]);
  if (arg1) (arg1)->markovTime = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_markovTime_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_markovTime_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (double) ((arg1)->markovTime);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_multilayerRelaxRate_set ( SEXP self, SEXP s_multilayerRelaxRate)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_multilayerRelaxRate_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = static_cast< double >(REAL(s_multilayerRelaxRate)[0]);
  if (arg1) (arg1)->multilayerRelaxRate = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_multilayerRelaxRate_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_multilayerRelaxRate_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (double) ((arg1)->multilayerRelaxRate);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_multilayerRelaxLimit_set ( SEXP self, SEXP s_multilayerRelaxLimit)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_multilayerRelaxLimit_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = static_cast< int >(INTEGER(s_multilayerRelaxLimit)[0]);
  if (arg1) (arg1)->multilayerRelaxLimit = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_multilayerRelaxLimit_get ( SEXP self, SEXP s_swig_copy)
{
  int result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_multilayerRelaxLimit_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (int) ((arg1)->multilayerRelaxLimit);
  r_ans = Rf_ScalarInteger(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_multilayerRelaxLimitUp_set ( SEXP self, SEXP s_multilayerRelaxLimitUp)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_multilayerRelaxLimitUp_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = static_cast< int >(INTEGER(s_multilayerRelaxLimitUp)[0]);
  if (arg1) (arg1)->multilayerRelaxLimitUp = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_multilayerRelaxLimitUp_get ( SEXP self, SEXP s_swig_copy)
{
  int result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_multilayerRelaxLimitUp_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (int) ((arg1)->multilayerRelaxLimitUp);
  r_ans = Rf_ScalarInteger(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_multilayerRelaxLimitDown_set ( SEXP self, SEXP s_multilayerRelaxLimitDown)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_multilayerRelaxLimitDown_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = static_cast< int >(INTEGER(s_multilayerRelaxLimitDown)[0]);
  if (arg1) (arg1)->multilayerRelaxLimitDown = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_multilayerRelaxLimitDown_get ( SEXP self, SEXP s_swig_copy)
{
  int result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_multilayerRelaxLimitDown_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (int) ((arg1)->multilayerRelaxLimitDown);
  r_ans = Rf_ScalarInteger(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_multilayerJSRelaxRate_set ( SEXP self, SEXP s_multilayerJSRelaxRate)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_multilayerJSRelaxRate_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = static_cast< double >(REAL(s_multilayerJSRelaxRate)[0]);
  if (arg1) (arg1)->multilayerJSRelaxRate = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_multilayerJSRelaxRate_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_multilayerJSRelaxRate_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (double) ((arg1)->multilayerJSRelaxRate);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_multilayerRelaxByJensenShannonDivergence_set ( SEXP self, SEXP s_multilayerRelaxByJensenShannonDivergence)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_multilayerRelaxByJensenShannonDivergence_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_multilayerRelaxByJensenShannonDivergence)[0] ? true : false;
  if (arg1) (arg1)->multilayerRelaxByJensenShannonDivergence = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_multilayerRelaxByJensenShannonDivergence_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_multilayerRelaxByJensenShannonDivergence_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->multilayerRelaxByJensenShannonDivergence);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_multilayerJSRelaxLimit_set ( SEXP self, SEXP s_multilayerJSRelaxLimit)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_multilayerJSRelaxLimit_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = static_cast< int >(INTEGER(s_multilayerJSRelaxLimit)[0]);
  if (arg1) (arg1)->multilayerJSRelaxLimit = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_multilayerJSRelaxLimit_get ( SEXP self, SEXP s_swig_copy)
{
  int result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_multilayerJSRelaxLimit_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (int) ((arg1)->multilayerJSRelaxLimit);
  r_ans = Rf_ScalarInteger(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_twoLevel_set ( SEXP self, SEXP s_twoLevel)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_twoLevel_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_twoLevel)[0] ? true : false;
  if (arg1) (arg1)->twoLevel = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_twoLevel_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_twoLevel_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->twoLevel);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_noCoarseTune_set ( SEXP self, SEXP s_noCoarseTune)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_noCoarseTune_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_noCoarseTune)[0] ? true : false;
  if (arg1) (arg1)->noCoarseTune = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_noCoarseTune_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_noCoarseTune_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->noCoarseTune);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_directedEdges_set ( SEXP self, SEXP s_directedEdges)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_directedEdges_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_directedEdges)[0] ? true : false;
  if (arg1) (arg1)->directedEdges = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_directedEdges_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_directedEdges_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->directedEdges);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_recordedTeleportation_set ( SEXP self, SEXP s_recordedTeleportation)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_recordedTeleportation_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_recordedTeleportation)[0] ? true : false;
  if (arg1) (arg1)->recordedTeleportation = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_recordedTeleportation_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_recordedTeleportation_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->recordedTeleportation);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_teleportationProbability_set ( SEXP self, SEXP s_teleportationProbability)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_teleportationProbability_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = static_cast< double >(REAL(s_teleportationProbability)[0]);
  if (arg1) (arg1)->teleportationProbability = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_teleportationProbability_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_teleportationProbability_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (double) ((arg1)->teleportationProbability);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_preferredNumberOfModules_set ( SEXP self, SEXP s_preferredNumberOfModules)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_preferredNumberOfModules_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  ecode2 = SWIG_AsVal_int(s_preferredNumberOfModules, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Config_preferredNumberOfModules_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->preferredNumberOfModules = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_preferredNumberOfModules_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_preferredNumberOfModules_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (unsigned int) ((arg1)->preferredNumberOfModules);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_seedToRandomNumberGenerator_set ( SEXP self, SEXP s_seedToRandomNumberGenerator)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  unsigned long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_seedToRandomNumberGenerator_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  ecode2 = SWIG_AsVal_long(s_seedToRandomNumberGenerator, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Config_seedToRandomNumberGenerator_set" "', argument " "2"" of type '" "unsigned long""'");
  } 
  arg2 = static_cast< unsigned long >(val2);
  if (arg1) (arg1)->seedToRandomNumberGenerator = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_seedToRandomNumberGenerator_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned long result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_seedToRandomNumberGenerator_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (unsigned long) ((arg1)->seedToRandomNumberGenerator);
  r_ans = SWIG_From_long(static_cast< long >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_numTrials_set ( SEXP self, SEXP s_numTrials)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_numTrials_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  ecode2 = SWIG_AsVal_int(s_numTrials, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Config_numTrials_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->numTrials = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_numTrials_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_numTrials_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (unsigned int) ((arg1)->numTrials);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_minimumCodelengthImprovement_set ( SEXP self, SEXP s_minimumCodelengthImprovement)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_minimumCodelengthImprovement_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = static_cast< double >(REAL(s_minimumCodelengthImprovement)[0]);
  if (arg1) (arg1)->minimumCodelengthImprovement = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_minimumCodelengthImprovement_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_minimumCodelengthImprovement_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (double) ((arg1)->minimumCodelengthImprovement);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_minimumSingleNodeCodelengthImprovement_set ( SEXP self, SEXP s_minimumSingleNodeCodelengthImprovement)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_minimumSingleNodeCodelengthImprovement_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = static_cast< double >(REAL(s_minimumSingleNodeCodelengthImprovement)[0]);
  if (arg1) (arg1)->minimumSingleNodeCodelengthImprovement = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_minimumSingleNodeCodelengthImprovement_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_minimumSingleNodeCodelengthImprovement_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (double) ((arg1)->minimumSingleNodeCodelengthImprovement);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_randomizeCoreLoopLimit_set ( SEXP self, SEXP s_randomizeCoreLoopLimit)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_randomizeCoreLoopLimit_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_randomizeCoreLoopLimit)[0] ? true : false;
  if (arg1) (arg1)->randomizeCoreLoopLimit = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_randomizeCoreLoopLimit_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_randomizeCoreLoopLimit_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->randomizeCoreLoopLimit);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_coreLoopLimit_set ( SEXP self, SEXP s_coreLoopLimit)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_coreLoopLimit_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  ecode2 = SWIG_AsVal_int(s_coreLoopLimit, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Config_coreLoopLimit_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->coreLoopLimit = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_coreLoopLimit_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_coreLoopLimit_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (unsigned int) ((arg1)->coreLoopLimit);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_levelAggregationLimit_set ( SEXP self, SEXP s_levelAggregationLimit)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_levelAggregationLimit_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  ecode2 = SWIG_AsVal_int(s_levelAggregationLimit, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Config_levelAggregationLimit_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->levelAggregationLimit = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_levelAggregationLimit_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_levelAggregationLimit_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (unsigned int) ((arg1)->levelAggregationLimit);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_tuneIterationLimit_set ( SEXP self, SEXP s_tuneIterationLimit)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_tuneIterationLimit_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  ecode2 = SWIG_AsVal_int(s_tuneIterationLimit, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Config_tuneIterationLimit_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->tuneIterationLimit = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_tuneIterationLimit_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_tuneIterationLimit_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (unsigned int) ((arg1)->tuneIterationLimit);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_minimumRelativeTuneIterationImprovement_set ( SEXP self, SEXP s_minimumRelativeTuneIterationImprovement)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_minimumRelativeTuneIterationImprovement_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = static_cast< double >(REAL(s_minimumRelativeTuneIterationImprovement)[0]);
  if (arg1) (arg1)->minimumRelativeTuneIterationImprovement = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_minimumRelativeTuneIterationImprovement_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_minimumRelativeTuneIterationImprovement_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (double) ((arg1)->minimumRelativeTuneIterationImprovement);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_fastCoarseTunePartition_set ( SEXP self, SEXP s_fastCoarseTunePartition)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_fastCoarseTunePartition_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_fastCoarseTunePartition)[0] ? true : false;
  if (arg1) (arg1)->fastCoarseTunePartition = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_fastCoarseTunePartition_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_fastCoarseTunePartition_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->fastCoarseTunePartition);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_alternateCoarseTuneLevel_set ( SEXP self, SEXP s_alternateCoarseTuneLevel)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_alternateCoarseTuneLevel_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_alternateCoarseTuneLevel)[0] ? true : false;
  if (arg1) (arg1)->alternateCoarseTuneLevel = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_alternateCoarseTuneLevel_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_alternateCoarseTuneLevel_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->alternateCoarseTuneLevel);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_coarseTuneLevel_set ( SEXP self, SEXP s_coarseTuneLevel)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_coarseTuneLevel_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  ecode2 = SWIG_AsVal_int(s_coarseTuneLevel, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Config_coarseTuneLevel_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->coarseTuneLevel = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_coarseTuneLevel_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_coarseTuneLevel_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (unsigned int) ((arg1)->coarseTuneLevel);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_superLevelLimit_set ( SEXP self, SEXP s_superLevelLimit)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_superLevelLimit_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  ecode2 = SWIG_AsVal_int(s_superLevelLimit, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Config_superLevelLimit_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->superLevelLimit = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_superLevelLimit_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_superLevelLimit_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (unsigned int) ((arg1)->superLevelLimit);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_onlySuperModules_set ( SEXP self, SEXP s_onlySuperModules)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_onlySuperModules_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_onlySuperModules)[0] ? true : false;
  if (arg1) (arg1)->onlySuperModules = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_onlySuperModules_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_onlySuperModules_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->onlySuperModules);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_fastHierarchicalSolution_set ( SEXP self, SEXP s_fastHierarchicalSolution)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_fastHierarchicalSolution_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  ecode2 = SWIG_AsVal_int(s_fastHierarchicalSolution, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Config_fastHierarchicalSolution_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->fastHierarchicalSolution = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_fastHierarchicalSolution_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_fastHierarchicalSolution_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (unsigned int) ((arg1)->fastHierarchicalSolution);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_fastFirstIteration_set ( SEXP self, SEXP s_fastFirstIteration)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_fastFirstIteration_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_fastFirstIteration)[0] ? true : false;
  if (arg1) (arg1)->fastFirstIteration = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_fastFirstIteration_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_fastFirstIteration_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->fastFirstIteration);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_preferModularSolution_set ( SEXP self, SEXP s_preferModularSolution)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_preferModularSolution_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_preferModularSolution)[0] ? true : false;
  if (arg1) (arg1)->preferModularSolution = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_preferModularSolution_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_preferModularSolution_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->preferModularSolution);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_innerParallelization_set ( SEXP self, SEXP s_innerParallelization)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_innerParallelization_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_innerParallelization)[0] ? true : false;
  if (arg1) (arg1)->innerParallelization = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_innerParallelization_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_innerParallelization_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->innerParallelization);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_outDirectory_set ( SEXP self, SEXP s_outDirectory)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_outDirectory_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(s_outDirectory, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Config_outDirectory_set" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Config_outDirectory_set" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  if (arg1) (arg1)->outDirectory = *arg2;
  r_ans = R_NilValue;
  if (SWIG_IsNewObj(res2)) delete arg2;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  if (SWIG_IsNewObj(res2)) delete arg2;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_outDirectory_get ( SEXP self, SEXP s_swig_copy)
{
  std::string *result = 0 ;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_outDirectory_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (std::string *) & ((arg1)->outDirectory);
  r_ans = SWIG_From_std_string(static_cast< std::string >(*result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_outName_set ( SEXP self, SEXP s_outName)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_outName_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(s_outName, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Config_outName_set" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Config_outName_set" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  if (arg1) (arg1)->outName = *arg2;
  r_ans = R_NilValue;
  if (SWIG_IsNewObj(res2)) delete arg2;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  if (SWIG_IsNewObj(res2)) delete arg2;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_outName_get ( SEXP self, SEXP s_swig_copy)
{
  std::string *result = 0 ;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_outName_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (std::string *) & ((arg1)->outName);
  r_ans = SWIG_From_std_string(static_cast< std::string >(*result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_outputFormats_set ( SEXP self, SEXP s_outputFormats)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_outputFormats_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(s_outputFormats, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Config_outputFormats_set" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Config_outputFormats_set" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  if (arg1) (arg1)->outputFormats = *arg2;
  r_ans = R_NilValue;
  if (SWIG_IsNewObj(res2)) delete arg2;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  if (SWIG_IsNewObj(res2)) delete arg2;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_outputFormats_get ( SEXP self, SEXP s_swig_copy)
{
  std::string *result = 0 ;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_outputFormats_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (std::string *) & ((arg1)->outputFormats);
  r_ans = SWIG_From_std_string(static_cast< std::string >(*result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_originallyUndirected_set ( SEXP self, SEXP s_originallyUndirected)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_originallyUndirected_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_originallyUndirected)[0] ? true : false;
  if (arg1) (arg1)->originallyUndirected = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_originallyUndirected_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_originallyUndirected_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->originallyUndirected);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_printTree_set ( SEXP self, SEXP s_printTree)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_printTree_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_printTree)[0] ? true : false;
  if (arg1) (arg1)->printTree = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_printTree_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_printTree_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->printTree);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_printFlowTree_set ( SEXP self, SEXP s_printFlowTree)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_printFlowTree_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_printFlowTree)[0] ? true : false;
  if (arg1) (arg1)->printFlowTree = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_printFlowTree_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_printFlowTree_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->printFlowTree);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_printNewick_set ( SEXP self, SEXP s_printNewick)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_printNewick_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_printNewick)[0] ? true : false;
  if (arg1) (arg1)->printNewick = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_printNewick_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_printNewick_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->printNewick);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_printJson_set ( SEXP self, SEXP s_printJson)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_printJson_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_printJson)[0] ? true : false;
  if (arg1) (arg1)->printJson = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_printJson_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_printJson_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->printJson);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_printMap_set ( SEXP self, SEXP s_printMap)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_printMap_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_printMap)[0] ? true : false;
  if (arg1) (arg1)->printMap = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_printMap_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_printMap_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->printMap);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_printClu_set ( SEXP self, SEXP s_printClu)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_printClu_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_printClu)[0] ? true : false;
  if (arg1) (arg1)->printClu = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_printClu_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_printClu_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->printClu);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_cluLevel_set ( SEXP self, SEXP s_cluLevel)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_cluLevel_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = static_cast< int >(INTEGER(s_cluLevel)[0]);
  if (arg1) (arg1)->cluLevel = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_cluLevel_get ( SEXP self, SEXP s_swig_copy)
{
  int result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_cluLevel_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (int) ((arg1)->cluLevel);
  r_ans = Rf_ScalarInteger(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_printNodeRanks_set ( SEXP self, SEXP s_printNodeRanks)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_printNodeRanks_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_printNodeRanks)[0] ? true : false;
  if (arg1) (arg1)->printNodeRanks = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_printNodeRanks_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_printNodeRanks_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->printNodeRanks);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_printFlowNetwork_set ( SEXP self, SEXP s_printFlowNetwork)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_printFlowNetwork_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_printFlowNetwork)[0] ? true : false;
  if (arg1) (arg1)->printFlowNetwork = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_printFlowNetwork_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_printFlowNetwork_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->printFlowNetwork);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_printPajekNetwork_set ( SEXP self, SEXP s_printPajekNetwork)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_printPajekNetwork_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_printPajekNetwork)[0] ? true : false;
  if (arg1) (arg1)->printPajekNetwork = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_printPajekNetwork_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_printPajekNetwork_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->printPajekNetwork);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_printStateNetwork_set ( SEXP self, SEXP s_printStateNetwork)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_printStateNetwork_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_printStateNetwork)[0] ? true : false;
  if (arg1) (arg1)->printStateNetwork = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_printStateNetwork_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_printStateNetwork_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->printStateNetwork);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_printBinaryTree_set ( SEXP self, SEXP s_printBinaryTree)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_printBinaryTree_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_printBinaryTree)[0] ? true : false;
  if (arg1) (arg1)->printBinaryTree = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_printBinaryTree_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_printBinaryTree_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->printBinaryTree);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_printBinaryFlowTree_set ( SEXP self, SEXP s_printBinaryFlowTree)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_printBinaryFlowTree_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_printBinaryFlowTree)[0] ? true : false;
  if (arg1) (arg1)->printBinaryFlowTree = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_printBinaryFlowTree_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_printBinaryFlowTree_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->printBinaryFlowTree);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_noFileOutput_set ( SEXP self, SEXP s_noFileOutput)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_noFileOutput_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_noFileOutput)[0] ? true : false;
  if (arg1) (arg1)->noFileOutput = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_noFileOutput_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_noFileOutput_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->noFileOutput);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_verbosity_set ( SEXP self, SEXP s_verbosity)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_verbosity_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  ecode2 = SWIG_AsVal_int(s_verbosity, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Config_verbosity_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->verbosity = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_verbosity_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_verbosity_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (unsigned int) ((arg1)->verbosity);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_verboseNumberPrecision_set ( SEXP self, SEXP s_verboseNumberPrecision)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_verboseNumberPrecision_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  ecode2 = SWIG_AsVal_int(s_verboseNumberPrecision, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Config_verboseNumberPrecision_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->verboseNumberPrecision = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_verboseNumberPrecision_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_verboseNumberPrecision_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (unsigned int) ((arg1)->verboseNumberPrecision);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_silent_set ( SEXP self, SEXP s_silent)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_silent_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_silent)[0] ? true : false;
  if (arg1) (arg1)->silent = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_silent_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_silent_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->silent);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_benchmark_set ( SEXP self, SEXP s_benchmark)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_benchmark_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_benchmark)[0] ? true : false;
  if (arg1) (arg1)->benchmark = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_benchmark_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_benchmark_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->benchmark);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_hideBipartiteNodes_set ( SEXP self, SEXP s_hideBipartiteNodes)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_hideBipartiteNodes_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  arg2 = LOGICAL(s_hideBipartiteNodes)[0] ? true : false;
  if (arg1) (arg1)->hideBipartiteNodes = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_hideBipartiteNodes_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_hideBipartiteNodes_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (bool) ((arg1)->hideBipartiteNodes);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_maxNodeIndexVisible_set ( SEXP self, SEXP s_maxNodeIndexVisible)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_maxNodeIndexVisible_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  ecode2 = SWIG_AsVal_int(s_maxNodeIndexVisible, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Config_maxNodeIndexVisible_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->maxNodeIndexVisible = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_maxNodeIndexVisible_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_maxNodeIndexVisible_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (unsigned int) ((arg1)->maxNodeIndexVisible);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_minBipartiteNodeIndex_set ( SEXP self, SEXP s_minBipartiteNodeIndex)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_minBipartiteNodeIndex_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  ecode2 = SWIG_AsVal_int(s_minBipartiteNodeIndex, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Config_minBipartiteNodeIndex_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->minBipartiteNodeIndex = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_minBipartiteNodeIndex_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_minBipartiteNodeIndex_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (unsigned int) ((arg1)->minBipartiteNodeIndex);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_startDate_set ( SEXP self, SEXP s_startDate)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  Date arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_startDate_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  {
    res2 = SWIG_R_ConvertPtr(s_startDate, &argp2, SWIGTYPE_p_Date,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Config_startDate_set" "', argument " "2"" of type '" "Date""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Config_startDate_set" "', argument " "2"" of type '" "Date""'");
    } else {
      arg2 = *(reinterpret_cast< Date * >(argp2));
    }
  }
  if (arg1) (arg1)->startDate = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_startDate_get ( SEXP self, SEXP s_swig_copy)
{
  Date result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_startDate_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result =  ((arg1)->startDate);
  r_ans = SWIG_R_NewPointerObj((new Date(static_cast< const Date& >(result))), SWIGTYPE_p_Date, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_version_set ( SEXP self, SEXP s_version)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_version_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(s_version, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Config_version_set" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Config_version_set" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  if (arg1) (arg1)->version = *arg2;
  r_ans = R_NilValue;
  if (SWIG_IsNewObj(res2)) delete arg2;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  if (SWIG_IsNewObj(res2)) delete arg2;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_version_get ( SEXP self, SEXP s_swig_copy)
{
  std::string *result = 0 ;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_version_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (std::string *) & ((arg1)->version);
  r_ans = SWIG_From_std_string(static_cast< std::string >(*result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_parsedString_set ( SEXP self, SEXP s_parsedString)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_parsedString_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(s_parsedString, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Config_parsedString_set" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Config_parsedString_set" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  if (arg1) (arg1)->parsedString = *arg2;
  r_ans = R_NilValue;
  if (SWIG_IsNewObj(res2)) delete arg2;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  if (SWIG_IsNewObj(res2)) delete arg2;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_parsedString_get ( SEXP self, SEXP s_swig_copy)
{
  std::string *result = 0 ;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_parsedString_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (std::string *) & ((arg1)->parsedString);
  r_ans = SWIG_From_std_string(static_cast< std::string >(*result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_parsedOptions_set ( SEXP self, SEXP s_parsedOptions)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  std::vector< ParsedOption,std::allocator< ParsedOption > > *arg2 = (std::vector< ParsedOption,std::allocator< ParsedOption > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_parsedOptions_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_parsedOptions, &argp2, SWIGTYPE_p_std__vectorT_ParsedOption_std__allocatorT_ParsedOption_t_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Config_parsedOptions_set" "', argument " "2"" of type '" "std::vector< ParsedOption,std::allocator< ParsedOption > > *""'"); 
  }
  arg2 = reinterpret_cast< std::vector< ParsedOption,std::allocator< ParsedOption > > * >(argp2);
  if (arg1) (arg1)->parsedOptions = *arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_parsedOptions_get ( SEXP self)
{
  std::vector< ParsedOption,std::allocator< ParsedOption > > *result = 0 ;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_parsedOptions_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (std::vector< ParsedOption,std::allocator< ParsedOption > > *)& ((arg1)->parsedOptions);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_ParsedOption_std__allocatorT_ParsedOption_t_t, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_error_set ( SEXP self, SEXP s_error)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_error_set" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(s_error, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Config_error_set" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Config_error_set" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  if (arg1) (arg1)->error = *arg2;
  r_ans = R_NilValue;
  if (SWIG_IsNewObj(res2)) delete arg2;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  if (SWIG_IsNewObj(res2)) delete arg2;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_error_get ( SEXP self, SEXP s_swig_copy)
{
  std::string *result = 0 ;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_error_get" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  result = (std::string *) & ((arg1)->error);
  r_ans = SWIG_From_std_string(static_cast< std::string >(*result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_Config__SWIG_0 ( )
{
  infomap::Config *result = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    try {
      result = (infomap::Config *)new infomap::Config();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__Config, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_Config__SWIG_1 ( SEXP flags, SEXP isCLI)
{
  infomap::Config *result = 0 ;
  std::string arg1 ;
  bool arg2 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(flags, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "new_Config" "', argument " "1"" of type '" "std::string""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  arg2 = LOGICAL(isCLI)[0] ? true : false;
  {
    try {
      result = (infomap::Config *)new infomap::Config(arg1,arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__Config, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_Config__SWIG_2 ( SEXP flags)
{
  infomap::Config *result = 0 ;
  std::string arg1 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(flags, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "new_Config" "', argument " "1"" of type '" "std::string""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      result = (infomap::Config *)new infomap::Config(arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__Config, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_cloneAsNonMain ( SEXP self, SEXP other, SEXP s_swig_copy)
{
  infomap::Config *result = 0 ;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  infomap::Config *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_cloneAsNonMain" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  res2 = SWIG_R_ConvertPtr(other, &argp2, SWIGTYPE_p_infomap__Config,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Config_cloneAsNonMain" "', argument " "2"" of type '" "infomap::Config const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Config_cloneAsNonMain" "', argument " "2"" of type '" "infomap::Config const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::Config * >(argp2);
  {
    try {
      result = (infomap::Config *) &(arg1)->cloneAsNonMain((infomap::Config const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__Config, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_setOptimizationLevel ( SEXP self, SEXP level)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  infomap::OptimizationLevel arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_setOptimizationLevel" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  {
    res2 = SWIG_R_ConvertPtr(level, &argp2, SWIGTYPE_p_infomap__OptimizationLevel,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Config_setOptimizationLevel" "', argument " "2"" of type '" "infomap::OptimizationLevel""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Config_setOptimizationLevel" "', argument " "2"" of type '" "infomap::OptimizationLevel""'");
    } else {
      arg2 = *(reinterpret_cast< infomap::OptimizationLevel * >(argp2));
    }
  }
  {
    try {
      (arg1)->setOptimizationLevel(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_adaptDefaults ( SEXP self)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_adaptDefaults" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  {
    try {
      (arg1)->adaptDefaults();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_setMemoryInput ( SEXP self)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_setMemoryInput" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  {
    try {
      (arg1)->setMemoryInput();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_setMultilayerInput ( SEXP self)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_setMultilayerInput" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  {
    try {
      (arg1)->setMultilayerInput();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_isUndirectedClustering ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_isUndirectedClustering" "', argument " "1"" of type '" "infomap::Config const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  {
    try {
      result = (bool)((infomap::Config const *)arg1)->isUndirectedClustering();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_isUndirectedFlow ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_isUndirectedFlow" "', argument " "1"" of type '" "infomap::Config const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  {
    try {
      result = (bool)((infomap::Config const *)arg1)->isUndirectedFlow();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_printAsUndirected ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_printAsUndirected" "', argument " "1"" of type '" "infomap::Config const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  {
    try {
      result = (bool)((infomap::Config const *)arg1)->printAsUndirected();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_is3gram ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_is3gram" "', argument " "1"" of type '" "infomap::Config const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  {
    try {
      result = (bool)((infomap::Config const *)arg1)->is3gram();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_isPath ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_isPath" "', argument " "1"" of type '" "infomap::Config const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  {
    try {
      result = (bool)((infomap::Config const *)arg1)->isPath();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_isMultilayerNetwork ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_isMultilayerNetwork" "', argument " "1"" of type '" "infomap::Config const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  {
    try {
      result = (bool)((infomap::Config const *)arg1)->isMultilayerNetwork();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_isStateNetwork ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_isStateNetwork" "', argument " "1"" of type '" "infomap::Config const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  {
    try {
      result = (bool)((infomap::Config const *)arg1)->isStateNetwork();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_isBipartite ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_isBipartite" "', argument " "1"" of type '" "infomap::Config const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  {
    try {
      result = (bool)((infomap::Config const *)arg1)->isBipartite();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_haveMemory ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_haveMemory" "', argument " "1"" of type '" "infomap::Config const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  {
    try {
      result = (bool)((infomap::Config const *)arg1)->haveMemory();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_haveMetaData ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_haveMetaData" "', argument " "1"" of type '" "infomap::Config const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  {
    try {
      result = (bool)((infomap::Config const *)arg1)->haveMetaData();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_haveOutput ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_haveOutput" "', argument " "1"" of type '" "infomap::Config const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  {
    try {
      result = (bool)((infomap::Config const *)arg1)->haveOutput();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Config_haveModularResultOutput ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Config_haveModularResultOutput" "', argument " "1"" of type '" "infomap::Config const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  {
    try {
      result = (bool)((infomap::Config const *)arg1)->haveModularResultOutput();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_Config ( SEXP self)
{
  infomap::Config *arg1 = (infomap::Config *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Config, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Config" "', argument " "1"" of type '" "infomap::Config *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_FlowData__SWIG_0 ( SEXP flow)
{
  infomap::FlowData *result = 0 ;
  double arg1 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  arg1 = static_cast< double >(REAL(flow)[0]);
  {
    try {
      result = (infomap::FlowData *)new infomap::FlowData(arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__FlowData, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_FlowData__SWIG_1 ( )
{
  infomap::FlowData *result = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    try {
      result = (infomap::FlowData *)new infomap::FlowData();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__FlowData, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_FlowData__SWIG_2 ( SEXP other)
{
  infomap::FlowData *result = 0 ;
  infomap::FlowData *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(other, &argp1, SWIGTYPE_p_infomap__FlowData,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_FlowData" "', argument " "1"" of type '" "infomap::FlowData const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_FlowData" "', argument " "1"" of type '" "infomap::FlowData const &""'"); 
  }
  arg1 = reinterpret_cast< infomap::FlowData * >(argp1);
  {
    try {
      result = (infomap::FlowData *)new infomap::FlowData((infomap::FlowData const &)*arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__FlowData, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_FlowData_Equal ( SEXP self, SEXP other, SEXP s_swig_copy)
{
  infomap::FlowData *result = 0 ;
  infomap::FlowData *arg1 = (infomap::FlowData *) 0 ;
  infomap::FlowData *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__FlowData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FlowData_Equal" "', argument " "1"" of type '" "infomap::FlowData *""'"); 
  }
  arg1 = reinterpret_cast< infomap::FlowData * >(argp1);
  res2 = SWIG_R_ConvertPtr(other, &argp2, SWIGTYPE_p_infomap__FlowData,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FlowData_Equal" "', argument " "2"" of type '" "infomap::FlowData const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FlowData_Equal" "', argument " "2"" of type '" "infomap::FlowData const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::FlowData * >(argp2);
  {
    try {
      result = (infomap::FlowData *) &(arg1)->operator =((infomap::FlowData const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__FlowData, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_FlowData_flow_set ( SEXP self, SEXP s_flow)
{
  infomap::FlowData *arg1 = (infomap::FlowData *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__FlowData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FlowData_flow_set" "', argument " "1"" of type '" "infomap::FlowData *""'"); 
  }
  arg1 = reinterpret_cast< infomap::FlowData * >(argp1);
  arg2 = static_cast< double >(REAL(s_flow)[0]);
  if (arg1) (arg1)->flow = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_FlowData_flow_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::FlowData *arg1 = (infomap::FlowData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__FlowData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FlowData_flow_get" "', argument " "1"" of type '" "infomap::FlowData *""'"); 
  }
  arg1 = reinterpret_cast< infomap::FlowData * >(argp1);
  result = (double) ((arg1)->flow);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_FlowData_enterFlow_set ( SEXP self, SEXP s_enterFlow)
{
  infomap::FlowData *arg1 = (infomap::FlowData *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__FlowData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FlowData_enterFlow_set" "', argument " "1"" of type '" "infomap::FlowData *""'"); 
  }
  arg1 = reinterpret_cast< infomap::FlowData * >(argp1);
  arg2 = static_cast< double >(REAL(s_enterFlow)[0]);
  if (arg1) (arg1)->enterFlow = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_FlowData_enterFlow_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::FlowData *arg1 = (infomap::FlowData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__FlowData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FlowData_enterFlow_get" "', argument " "1"" of type '" "infomap::FlowData *""'"); 
  }
  arg1 = reinterpret_cast< infomap::FlowData * >(argp1);
  result = (double) ((arg1)->enterFlow);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_FlowData_exitFlow_set ( SEXP self, SEXP s_exitFlow)
{
  infomap::FlowData *arg1 = (infomap::FlowData *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__FlowData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FlowData_exitFlow_set" "', argument " "1"" of type '" "infomap::FlowData *""'"); 
  }
  arg1 = reinterpret_cast< infomap::FlowData * >(argp1);
  arg2 = static_cast< double >(REAL(s_exitFlow)[0]);
  if (arg1) (arg1)->exitFlow = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_FlowData_exitFlow_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::FlowData *arg1 = (infomap::FlowData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__FlowData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FlowData_exitFlow_get" "', argument " "1"" of type '" "infomap::FlowData *""'"); 
  }
  arg1 = reinterpret_cast< infomap::FlowData * >(argp1);
  result = (double) ((arg1)->exitFlow);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_FlowData_PlusEqual ( SEXP self, SEXP other, SEXP s_swig_copy)
{
  infomap::FlowData *result = 0 ;
  infomap::FlowData *arg1 = (infomap::FlowData *) 0 ;
  infomap::FlowData *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__FlowData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FlowData_PlusEqual" "', argument " "1"" of type '" "infomap::FlowData *""'"); 
  }
  arg1 = reinterpret_cast< infomap::FlowData * >(argp1);
  res2 = SWIG_R_ConvertPtr(other, &argp2, SWIGTYPE_p_infomap__FlowData,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FlowData_PlusEqual" "', argument " "2"" of type '" "infomap::FlowData const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FlowData_PlusEqual" "', argument " "2"" of type '" "infomap::FlowData const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::FlowData * >(argp2);
  {
    try {
      result = (infomap::FlowData *) &(arg1)->operator +=((infomap::FlowData const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__FlowData, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_FlowData_MinusEqual ( SEXP self, SEXP other, SEXP s_swig_copy)
{
  infomap::FlowData *result = 0 ;
  infomap::FlowData *arg1 = (infomap::FlowData *) 0 ;
  infomap::FlowData *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__FlowData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FlowData_MinusEqual" "', argument " "1"" of type '" "infomap::FlowData *""'"); 
  }
  arg1 = reinterpret_cast< infomap::FlowData * >(argp1);
  res2 = SWIG_R_ConvertPtr(other, &argp2, SWIGTYPE_p_infomap__FlowData,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FlowData_MinusEqual" "', argument " "2"" of type '" "infomap::FlowData const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FlowData_MinusEqual" "', argument " "2"" of type '" "infomap::FlowData const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::FlowData * >(argp2);
  {
    try {
      result = (infomap::FlowData *) &(arg1)->operator -=((infomap::FlowData const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__FlowData, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_FlowData ( SEXP self)
{
  infomap::FlowData *arg1 = (infomap::FlowData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__FlowData, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_FlowData" "', argument " "1"" of type '" "infomap::FlowData *""'"); 
  }
  arg1 = reinterpret_cast< infomap::FlowData * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_DeltaFlow_module_set ( SEXP self, SEXP s_module)
{
  infomap::DeltaFlow *arg1 = (infomap::DeltaFlow *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__DeltaFlow, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeltaFlow_module_set" "', argument " "1"" of type '" "infomap::DeltaFlow *""'"); 
  }
  arg1 = reinterpret_cast< infomap::DeltaFlow * >(argp1);
  ecode2 = SWIG_AsVal_int(s_module, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DeltaFlow_module_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->module = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_DeltaFlow_module_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::DeltaFlow *arg1 = (infomap::DeltaFlow *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__DeltaFlow, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeltaFlow_module_get" "', argument " "1"" of type '" "infomap::DeltaFlow *""'"); 
  }
  arg1 = reinterpret_cast< infomap::DeltaFlow * >(argp1);
  result = (unsigned int) ((arg1)->module);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_DeltaFlow_deltaExit_set ( SEXP self, SEXP s_deltaExit)
{
  infomap::DeltaFlow *arg1 = (infomap::DeltaFlow *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__DeltaFlow, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeltaFlow_deltaExit_set" "', argument " "1"" of type '" "infomap::DeltaFlow *""'"); 
  }
  arg1 = reinterpret_cast< infomap::DeltaFlow * >(argp1);
  arg2 = static_cast< double >(REAL(s_deltaExit)[0]);
  if (arg1) (arg1)->deltaExit = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_DeltaFlow_deltaExit_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::DeltaFlow *arg1 = (infomap::DeltaFlow *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__DeltaFlow, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeltaFlow_deltaExit_get" "', argument " "1"" of type '" "infomap::DeltaFlow *""'"); 
  }
  arg1 = reinterpret_cast< infomap::DeltaFlow * >(argp1);
  result = (double) ((arg1)->deltaExit);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_DeltaFlow_deltaEnter_set ( SEXP self, SEXP s_deltaEnter)
{
  infomap::DeltaFlow *arg1 = (infomap::DeltaFlow *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__DeltaFlow, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeltaFlow_deltaEnter_set" "', argument " "1"" of type '" "infomap::DeltaFlow *""'"); 
  }
  arg1 = reinterpret_cast< infomap::DeltaFlow * >(argp1);
  arg2 = static_cast< double >(REAL(s_deltaEnter)[0]);
  if (arg1) (arg1)->deltaEnter = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_DeltaFlow_deltaEnter_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::DeltaFlow *arg1 = (infomap::DeltaFlow *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__DeltaFlow, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeltaFlow_deltaEnter_get" "', argument " "1"" of type '" "infomap::DeltaFlow *""'"); 
  }
  arg1 = reinterpret_cast< infomap::DeltaFlow * >(argp1);
  result = (double) ((arg1)->deltaEnter);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_DeltaFlow_count_set ( SEXP self, SEXP s_count)
{
  infomap::DeltaFlow *arg1 = (infomap::DeltaFlow *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__DeltaFlow, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeltaFlow_count_set" "', argument " "1"" of type '" "infomap::DeltaFlow *""'"); 
  }
  arg1 = reinterpret_cast< infomap::DeltaFlow * >(argp1);
  ecode2 = SWIG_AsVal_int(s_count, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DeltaFlow_count_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->count = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_DeltaFlow_count_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::DeltaFlow *arg1 = (infomap::DeltaFlow *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__DeltaFlow, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeltaFlow_count_get" "', argument " "1"" of type '" "infomap::DeltaFlow *""'"); 
  }
  arg1 = reinterpret_cast< infomap::DeltaFlow * >(argp1);
  result = (unsigned int) ((arg1)->count);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_DeltaFlow ( SEXP self)
{
  infomap::DeltaFlow *arg1 = (infomap::DeltaFlow *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__DeltaFlow, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_DeltaFlow" "', argument " "1"" of type '" "infomap::DeltaFlow *""'"); 
  }
  arg1 = reinterpret_cast< infomap::DeltaFlow * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_DeltaFlow__SWIG_0 ( )
{
  infomap::DeltaFlow *result = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    try {
      result = (infomap::DeltaFlow *)new infomap::DeltaFlow();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__DeltaFlow, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_DeltaFlow__SWIG_1 ( SEXP module, SEXP deltaExit, SEXP deltaEnter)
{
  infomap::DeltaFlow *result = 0 ;
  unsigned int arg1 ;
  double arg2 ;
  double arg3 ;
  int val1 ;
  int ecode1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  ecode1 = SWIG_AsVal_int(module, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_DeltaFlow" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  arg2 = static_cast< double >(REAL(deltaExit)[0]);
  arg3 = static_cast< double >(REAL(deltaEnter)[0]);
  {
    try {
      result = (infomap::DeltaFlow *)new infomap::DeltaFlow(arg1,arg2,arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__DeltaFlow, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_DeltaFlow__SWIG_2 ( SEXP s_arg1)
{
  infomap::DeltaFlow *result = 0 ;
  infomap::DeltaFlow *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(s_arg1, &argp1, SWIGTYPE_p_infomap__DeltaFlow,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DeltaFlow" "', argument " "1"" of type '" "infomap::DeltaFlow const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DeltaFlow" "', argument " "1"" of type '" "infomap::DeltaFlow const &""'"); 
  }
  arg1 = reinterpret_cast< infomap::DeltaFlow * >(argp1);
  {
    try {
      result = (infomap::DeltaFlow *)new infomap::DeltaFlow((infomap::DeltaFlow const &)*arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__DeltaFlow, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_DeltaFlow_Equal__SWIG_0 ( SEXP self, SEXP s_arg2, SEXP s_swig_copy)
{
  infomap::DeltaFlow *result = 0 ;
  infomap::DeltaFlow *arg1 = (infomap::DeltaFlow *) 0 ;
  infomap::DeltaFlow *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__DeltaFlow, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeltaFlow_Equal" "', argument " "1"" of type '" "infomap::DeltaFlow *""'"); 
  }
  arg1 = reinterpret_cast< infomap::DeltaFlow * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_arg2, &argp2, SWIGTYPE_p_infomap__DeltaFlow,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeltaFlow_Equal" "', argument " "2"" of type '" "infomap::DeltaFlow const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DeltaFlow_Equal" "', argument " "2"" of type '" "infomap::DeltaFlow const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::DeltaFlow * >(argp2);
  {
    try {
      result = (infomap::DeltaFlow *) &(arg1)->operator =((infomap::DeltaFlow const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__DeltaFlow, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_DeltaFlow__SWIG_3 ( SEXP s_arg1)
{
  infomap::DeltaFlow *result = 0 ;
  infomap::DeltaFlow *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(s_arg1, &argp1, SWIGTYPE_p_infomap__DeltaFlow,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DeltaFlow" "', argument " "1"" of type '" "infomap::DeltaFlow &&""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DeltaFlow" "', argument " "1"" of type '" "infomap::DeltaFlow &&""'"); 
  }
  arg1 = reinterpret_cast< infomap::DeltaFlow * >(argp1);
  {
    try {
      result = (infomap::DeltaFlow *)new infomap::DeltaFlow((infomap::DeltaFlow &&)*arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__DeltaFlow, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_DeltaFlow_Equal__SWIG_1 ( SEXP self, SEXP s_arg2, SEXP s_swig_copy)
{
  infomap::DeltaFlow *result = 0 ;
  infomap::DeltaFlow *arg1 = (infomap::DeltaFlow *) 0 ;
  infomap::DeltaFlow *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__DeltaFlow, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeltaFlow_Equal" "', argument " "1"" of type '" "infomap::DeltaFlow *""'"); 
  }
  arg1 = reinterpret_cast< infomap::DeltaFlow * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_arg2, &argp2, SWIGTYPE_p_infomap__DeltaFlow,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeltaFlow_Equal" "', argument " "2"" of type '" "infomap::DeltaFlow &&""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DeltaFlow_Equal" "', argument " "2"" of type '" "infomap::DeltaFlow &&""'"); 
  }
  arg2 = reinterpret_cast< infomap::DeltaFlow * >(argp2);
  {
    try {
      result = (infomap::DeltaFlow *) &(arg1)->operator =((infomap::DeltaFlow &&)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__DeltaFlow, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_DeltaFlow_PlusEqual ( SEXP self, SEXP other, SEXP s_swig_copy)
{
  infomap::DeltaFlow *result = 0 ;
  infomap::DeltaFlow *arg1 = (infomap::DeltaFlow *) 0 ;
  infomap::DeltaFlow *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__DeltaFlow, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeltaFlow_PlusEqual" "', argument " "1"" of type '" "infomap::DeltaFlow *""'"); 
  }
  arg1 = reinterpret_cast< infomap::DeltaFlow * >(argp1);
  res2 = SWIG_R_ConvertPtr(other, &argp2, SWIGTYPE_p_infomap__DeltaFlow,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeltaFlow_PlusEqual" "', argument " "2"" of type '" "infomap::DeltaFlow const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DeltaFlow_PlusEqual" "', argument " "2"" of type '" "infomap::DeltaFlow const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::DeltaFlow * >(argp2);
  {
    try {
      result = (infomap::DeltaFlow *) &(arg1)->operator +=((infomap::DeltaFlow const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__DeltaFlow, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_DeltaFlow_reset ( SEXP self)
{
  infomap::DeltaFlow *arg1 = (infomap::DeltaFlow *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__DeltaFlow, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeltaFlow_reset" "', argument " "1"" of type '" "infomap::DeltaFlow *""'"); 
  }
  arg1 = reinterpret_cast< infomap::DeltaFlow * >(argp1);
  {
    try {
      (arg1)->reset();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MemDeltaFlow_sumDeltaPlogpPhysFlow_set ( SEXP self, SEXP s_sumDeltaPlogpPhysFlow)
{
  infomap::MemDeltaFlow *arg1 = (infomap::MemDeltaFlow *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MemDeltaFlow, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemDeltaFlow_sumDeltaPlogpPhysFlow_set" "', argument " "1"" of type '" "infomap::MemDeltaFlow *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemDeltaFlow * >(argp1);
  arg2 = static_cast< double >(REAL(s_sumDeltaPlogpPhysFlow)[0]);
  if (arg1) (arg1)->sumDeltaPlogpPhysFlow = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MemDeltaFlow_sumDeltaPlogpPhysFlow_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::MemDeltaFlow *arg1 = (infomap::MemDeltaFlow *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MemDeltaFlow, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemDeltaFlow_sumDeltaPlogpPhysFlow_get" "', argument " "1"" of type '" "infomap::MemDeltaFlow *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemDeltaFlow * >(argp1);
  result = (double) ((arg1)->sumDeltaPlogpPhysFlow);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MemDeltaFlow_sumPlogpPhysFlow_set ( SEXP self, SEXP s_sumPlogpPhysFlow)
{
  infomap::MemDeltaFlow *arg1 = (infomap::MemDeltaFlow *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MemDeltaFlow, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemDeltaFlow_sumPlogpPhysFlow_set" "', argument " "1"" of type '" "infomap::MemDeltaFlow *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemDeltaFlow * >(argp1);
  arg2 = static_cast< double >(REAL(s_sumPlogpPhysFlow)[0]);
  if (arg1) (arg1)->sumPlogpPhysFlow = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MemDeltaFlow_sumPlogpPhysFlow_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::MemDeltaFlow *arg1 = (infomap::MemDeltaFlow *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MemDeltaFlow, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemDeltaFlow_sumPlogpPhysFlow_get" "', argument " "1"" of type '" "infomap::MemDeltaFlow *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemDeltaFlow * >(argp1);
  result = (double) ((arg1)->sumPlogpPhysFlow);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_MemDeltaFlow__SWIG_0 ( )
{
  infomap::MemDeltaFlow *result = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    try {
      result = (infomap::MemDeltaFlow *)new infomap::MemDeltaFlow();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__MemDeltaFlow, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_MemDeltaFlow__SWIG_1 ( SEXP module, SEXP deltaExit, SEXP deltaEnter, SEXP sumDeltaPlogpPhysFlow, SEXP sumPlogpPhysFlow)
{
  infomap::MemDeltaFlow *result = 0 ;
  unsigned int arg1 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  int val1 ;
  int ecode1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  ecode1 = SWIG_AsVal_int(module, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_MemDeltaFlow" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  arg2 = static_cast< double >(REAL(deltaExit)[0]);
  arg3 = static_cast< double >(REAL(deltaEnter)[0]);
  arg4 = static_cast< double >(REAL(sumDeltaPlogpPhysFlow)[0]);
  arg5 = static_cast< double >(REAL(sumPlogpPhysFlow)[0]);
  {
    try {
      result = (infomap::MemDeltaFlow *)new infomap::MemDeltaFlow(arg1,arg2,arg3,arg4,arg5);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__MemDeltaFlow, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_MemDeltaFlow__SWIG_2 ( SEXP module, SEXP deltaExit, SEXP deltaEnter, SEXP sumDeltaPlogpPhysFlow)
{
  infomap::MemDeltaFlow *result = 0 ;
  unsigned int arg1 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  int val1 ;
  int ecode1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  ecode1 = SWIG_AsVal_int(module, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_MemDeltaFlow" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  arg2 = static_cast< double >(REAL(deltaExit)[0]);
  arg3 = static_cast< double >(REAL(deltaEnter)[0]);
  arg4 = static_cast< double >(REAL(sumDeltaPlogpPhysFlow)[0]);
  {
    try {
      result = (infomap::MemDeltaFlow *)new infomap::MemDeltaFlow(arg1,arg2,arg3,arg4);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__MemDeltaFlow, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_MemDeltaFlow__SWIG_3 ( SEXP module, SEXP deltaExit, SEXP deltaEnter)
{
  infomap::MemDeltaFlow *result = 0 ;
  unsigned int arg1 ;
  double arg2 ;
  double arg3 ;
  int val1 ;
  int ecode1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  ecode1 = SWIG_AsVal_int(module, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_MemDeltaFlow" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  arg2 = static_cast< double >(REAL(deltaExit)[0]);
  arg3 = static_cast< double >(REAL(deltaEnter)[0]);
  {
    try {
      result = (infomap::MemDeltaFlow *)new infomap::MemDeltaFlow(arg1,arg2,arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__MemDeltaFlow, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MemDeltaFlow_PlusEqual ( SEXP self, SEXP other, SEXP s_swig_copy)
{
  infomap::MemDeltaFlow *result = 0 ;
  infomap::MemDeltaFlow *arg1 = (infomap::MemDeltaFlow *) 0 ;
  infomap::MemDeltaFlow *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MemDeltaFlow, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemDeltaFlow_PlusEqual" "', argument " "1"" of type '" "infomap::MemDeltaFlow *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemDeltaFlow * >(argp1);
  res2 = SWIG_R_ConvertPtr(other, &argp2, SWIGTYPE_p_infomap__MemDeltaFlow,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MemDeltaFlow_PlusEqual" "', argument " "2"" of type '" "infomap::MemDeltaFlow const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MemDeltaFlow_PlusEqual" "', argument " "2"" of type '" "infomap::MemDeltaFlow const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::MemDeltaFlow * >(argp2);
  {
    try {
      result = (infomap::MemDeltaFlow *) &(arg1)->operator +=((infomap::MemDeltaFlow const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__MemDeltaFlow, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MemDeltaFlow_reset ( SEXP self)
{
  infomap::MemDeltaFlow *arg1 = (infomap::MemDeltaFlow *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MemDeltaFlow, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemDeltaFlow_reset" "', argument " "1"" of type '" "infomap::MemDeltaFlow *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemDeltaFlow * >(argp1);
  {
    try {
      (arg1)->reset();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_MemDeltaFlow ( SEXP self)
{
  infomap::MemDeltaFlow *arg1 = (infomap::MemDeltaFlow *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MemDeltaFlow, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_MemDeltaFlow" "', argument " "1"" of type '" "infomap::MemDeltaFlow *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemDeltaFlow * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_PhysData__SWIG_0 ( SEXP physNodeIndex, SEXP sumFlowFromM2Node)
{
  infomap::PhysData *result = 0 ;
  unsigned int arg1 ;
  double arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  ecode1 = SWIG_AsVal_int(physNodeIndex, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_PhysData" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  arg2 = static_cast< double >(REAL(sumFlowFromM2Node)[0]);
  {
    try {
      result = (infomap::PhysData *)new infomap::PhysData(arg1,arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__PhysData, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_PhysData__SWIG_1 ( SEXP physNodeIndex)
{
  infomap::PhysData *result = 0 ;
  unsigned int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  ecode1 = SWIG_AsVal_int(physNodeIndex, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_PhysData" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  {
    try {
      result = (infomap::PhysData *)new infomap::PhysData(arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__PhysData, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_PhysData__SWIG_2 ( SEXP other)
{
  infomap::PhysData *result = 0 ;
  infomap::PhysData *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(other, &argp1, SWIGTYPE_p_infomap__PhysData,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PhysData" "', argument " "1"" of type '" "infomap::PhysData const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PhysData" "', argument " "1"" of type '" "infomap::PhysData const &""'"); 
  }
  arg1 = reinterpret_cast< infomap::PhysData * >(argp1);
  {
    try {
      result = (infomap::PhysData *)new infomap::PhysData((infomap::PhysData const &)*arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__PhysData, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_PhysData_physNodeIndex_set ( SEXP self, SEXP s_physNodeIndex)
{
  infomap::PhysData *arg1 = (infomap::PhysData *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__PhysData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PhysData_physNodeIndex_set" "', argument " "1"" of type '" "infomap::PhysData *""'"); 
  }
  arg1 = reinterpret_cast< infomap::PhysData * >(argp1);
  ecode2 = SWIG_AsVal_int(s_physNodeIndex, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PhysData_physNodeIndex_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->physNodeIndex = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_PhysData_physNodeIndex_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::PhysData *arg1 = (infomap::PhysData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__PhysData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PhysData_physNodeIndex_get" "', argument " "1"" of type '" "infomap::PhysData *""'"); 
  }
  arg1 = reinterpret_cast< infomap::PhysData * >(argp1);
  result = (unsigned int) ((arg1)->physNodeIndex);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_PhysData_sumFlowFromM2Node_set ( SEXP self, SEXP s_sumFlowFromM2Node)
{
  infomap::PhysData *arg1 = (infomap::PhysData *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__PhysData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PhysData_sumFlowFromM2Node_set" "', argument " "1"" of type '" "infomap::PhysData *""'"); 
  }
  arg1 = reinterpret_cast< infomap::PhysData * >(argp1);
  arg2 = static_cast< double >(REAL(s_sumFlowFromM2Node)[0]);
  if (arg1) (arg1)->sumFlowFromM2Node = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_PhysData_sumFlowFromM2Node_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::PhysData *arg1 = (infomap::PhysData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__PhysData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PhysData_sumFlowFromM2Node_get" "', argument " "1"" of type '" "infomap::PhysData *""'"); 
  }
  arg1 = reinterpret_cast< infomap::PhysData * >(argp1);
  result = (double) ((arg1)->sumFlowFromM2Node);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_PhysData ( SEXP self)
{
  infomap::PhysData *arg1 = (infomap::PhysData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__PhysData, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_PhysData" "', argument " "1"" of type '" "infomap::PhysData *""'"); 
  }
  arg1 = reinterpret_cast< infomap::PhysData * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_uint___nonzero__ ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_uint___nonzero__" "', argument " "1"" of type '" "std::vector< unsigned int > const *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  {
    try {
      result = (bool)std_vector_Sl_unsigned_SS_int_Sg____nonzero__((std::vector< unsigned int > const *)arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_uint___len__ ( SEXP self, SEXP s_swig_copy)
{
  std::vector< unsigned int >::size_type result;
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_uint___len__" "', argument " "1"" of type '" "std::vector< unsigned int > const *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  {
    try {
      result = std_vector_Sl_unsigned_SS_int_Sg____len__((std::vector< unsigned int > const *)arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_uint_pop ( SEXP self, SEXP s_swig_copy)
{
  std::vector< unsigned int >::value_type result;
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_uint_pop" "', argument " "1"" of type '" "std::vector< unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  {
    try {
      try {
        result = (std::vector< unsigned int >::value_type)std_vector_Sl_unsigned_SS_int_Sg__pop(arg1);
      } catch(std::out_of_range &_e) {
        /*@SWIG:/usr/local/Cellar/swig/4.0.2/share/swig/4.0.2/r/r.swg,29,%raise@*/ 
        return R_NilValue;
        /*@SWIG@*/;
      }
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_uint___getslice__ ( SEXP self, SEXP i, SEXP j)
{
  std::vector< unsigned int,std::allocator< unsigned int > > *result = 0 ;
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ;
  std::vector< unsigned int >::difference_type arg2 ;
  std::vector< unsigned int >::difference_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_uint___getslice__" "', argument " "1"" of type '" "std::vector< unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  ecode2 = SWIG_AsVal_int(i, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "vector_uint___getslice__" "', argument " "2"" of type '" "std::vector< unsigned int >::difference_type""'");
  } 
  arg2 = static_cast< std::vector< unsigned int >::difference_type >(val2);
  ecode3 = SWIG_AsVal_int(j, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "vector_uint___getslice__" "', argument " "3"" of type '" "std::vector< unsigned int >::difference_type""'");
  } 
  arg3 = static_cast< std::vector< unsigned int >::difference_type >(val3);
  {
    try {
      try {
        result = (std::vector< unsigned int,std::allocator< unsigned int > > *)std_vector_Sl_unsigned_SS_int_Sg____getslice__(arg1,arg2,arg3);
      } catch(std::out_of_range &_e) {
        /*@SWIG:/usr/local/Cellar/swig/4.0.2/share/swig/4.0.2/r/r.swg,29,%raise@*/ 
        return R_NilValue;
        /*@SWIG@*/;
      }
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_uint___setslice__ ( SEXP self, SEXP i, SEXP j, SEXP v)
{
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ;
  std::vector< unsigned int >::difference_type arg2 ;
  std::vector< unsigned int >::difference_type arg3 ;
  std::vector< unsigned int,std::allocator< unsigned int > > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_uint___setslice__" "', argument " "1"" of type '" "std::vector< unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  ecode2 = SWIG_AsVal_int(i, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "vector_uint___setslice__" "', argument " "2"" of type '" "std::vector< unsigned int >::difference_type""'");
  } 
  arg2 = static_cast< std::vector< unsigned int >::difference_type >(val2);
  ecode3 = SWIG_AsVal_int(j, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "vector_uint___setslice__" "', argument " "3"" of type '" "std::vector< unsigned int >::difference_type""'");
  } 
  arg3 = static_cast< std::vector< unsigned int >::difference_type >(val3);
  {
    std::vector< unsigned int,std::allocator< unsigned int > > *ptr = (std::vector< unsigned int,std::allocator< unsigned int > > *)0;
    res4 = swig::asptr(v, &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "vector_uint___setslice__" "', argument " "4"" of type '" "std::vector< unsigned int,std::allocator< unsigned int > > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "vector_uint___setslice__" "', argument " "4"" of type '" "std::vector< unsigned int,std::allocator< unsigned int > > const &""'"); 
    }
    arg4 = ptr;
  }
  {
    try {
      try {
        std_vector_Sl_unsigned_SS_int_Sg____setslice__(arg1,arg2,arg3,(std::vector< unsigned int,std::allocator< unsigned int > > const &)*arg4);
      } catch(std::out_of_range &_e) {
        /*@SWIG:/usr/local/Cellar/swig/4.0.2/share/swig/4.0.2/r/r.swg,29,%raise@*/ 
        return R_NilValue;
        /*@SWIG@*/;
      } catch(std::invalid_argument &_e) {
        /*@SWIG:/usr/local/Cellar/swig/4.0.2/share/swig/4.0.2/r/r.swg,29,%raise@*/ 
        return R_NilValue;
        /*@SWIG@*/;
      }
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  if (SWIG_IsNewObj(res4)) delete arg4;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  if (SWIG_IsNewObj(res4)) delete arg4;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_uint___delslice__ ( SEXP self, SEXP i, SEXP j)
{
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ;
  std::vector< unsigned int >::difference_type arg2 ;
  std::vector< unsigned int >::difference_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_uint___delslice__" "', argument " "1"" of type '" "std::vector< unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  ecode2 = SWIG_AsVal_int(i, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "vector_uint___delslice__" "', argument " "2"" of type '" "std::vector< unsigned int >::difference_type""'");
  } 
  arg2 = static_cast< std::vector< unsigned int >::difference_type >(val2);
  ecode3 = SWIG_AsVal_int(j, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "vector_uint___delslice__" "', argument " "3"" of type '" "std::vector< unsigned int >::difference_type""'");
  } 
  arg3 = static_cast< std::vector< unsigned int >::difference_type >(val3);
  {
    try {
      try {
        std_vector_Sl_unsigned_SS_int_Sg____delslice__(arg1,arg2,arg3);
      } catch(std::out_of_range &_e) {
        /*@SWIG:/usr/local/Cellar/swig/4.0.2/share/swig/4.0.2/r/r.swg,29,%raise@*/ 
        return R_NilValue;
        /*@SWIG@*/;
      }
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_uint___delitem__ ( SEXP self, SEXP i)
{
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ;
  std::vector< unsigned int >::difference_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_uint___delitem__" "', argument " "1"" of type '" "std::vector< unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  ecode2 = SWIG_AsVal_int(i, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "vector_uint___delitem__" "', argument " "2"" of type '" "std::vector< unsigned int >::difference_type""'");
  } 
  arg2 = static_cast< std::vector< unsigned int >::difference_type >(val2);
  {
    try {
      try {
        std_vector_Sl_unsigned_SS_int_Sg____delitem__(arg1,arg2);
      } catch(std::out_of_range &_e) {
        /*@SWIG:/usr/local/Cellar/swig/4.0.2/share/swig/4.0.2/r/r.swg,29,%raise@*/ 
        return R_NilValue;
        /*@SWIG@*/;
      }
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_uint___getitem__ ( SEXP self, SEXP i, SEXP s_swig_copy)
{
  std::vector< unsigned int >::value_type *result = 0 ;
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ;
  std::vector< unsigned int >::difference_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_uint___getitem__" "', argument " "1"" of type '" "std::vector< unsigned int > const *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  ecode2 = SWIG_AsVal_int(i, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "vector_uint___getitem__" "', argument " "2"" of type '" "std::vector< unsigned int >::difference_type""'");
  } 
  arg2 = static_cast< std::vector< unsigned int >::difference_type >(val2);
  {
    try {
      try {
        result = (std::vector< unsigned int >::value_type *) &std_vector_Sl_unsigned_SS_int_Sg____getitem__((std::vector< unsigned int > const *)arg1,arg2);
      } catch(std::out_of_range &_e) {
        /*@SWIG:/usr/local/Cellar/swig/4.0.2/share/swig/4.0.2/r/r.swg,29,%raise@*/ 
        return R_NilValue;
        /*@SWIG@*/;
      }
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(*result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_uint___setitem__ ( SEXP self, SEXP i, SEXP x)
{
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ;
  std::vector< unsigned int >::difference_type arg2 ;
  std::vector< unsigned int >::value_type *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  std::vector< unsigned int >::value_type temp3 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_uint___setitem__" "', argument " "1"" of type '" "std::vector< unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  ecode2 = SWIG_AsVal_int(i, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "vector_uint___setitem__" "', argument " "2"" of type '" "std::vector< unsigned int >::difference_type""'");
  } 
  arg2 = static_cast< std::vector< unsigned int >::difference_type >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(x, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "vector_uint___setitem__" "', argument " "3"" of type '" "std::vector< unsigned int >::value_type""'");
  } 
  temp3 = static_cast< std::vector< unsigned int >::value_type >(val3);
  arg3 = &temp3;
  {
    try {
      try {
        std_vector_Sl_unsigned_SS_int_Sg____setitem__(arg1,arg2,(unsigned int const &)*arg3);
      } catch(std::out_of_range &_e) {
        /*@SWIG:/usr/local/Cellar/swig/4.0.2/share/swig/4.0.2/r/r.swg,29,%raise@*/ 
        return R_NilValue;
        /*@SWIG@*/;
      }
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_uint_append ( SEXP self, SEXP x)
{
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ;
  std::vector< unsigned int >::value_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< unsigned int >::value_type temp2 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_uint_append" "', argument " "1"" of type '" "std::vector< unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(x, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "vector_uint_append" "', argument " "2"" of type '" "std::vector< unsigned int >::value_type""'");
  } 
  temp2 = static_cast< std::vector< unsigned int >::value_type >(val2);
  arg2 = &temp2;
  {
    try {
      std_vector_Sl_unsigned_SS_int_Sg__append(arg1,(unsigned int const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_vector_uint__SWIG_0 ( )
{
  std::vector< unsigned int > *result = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    try {
      result = (std::vector< unsigned int > *)new std::vector< unsigned int >();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_vector_uint__SWIG_1 ( SEXP other)
{
  std::vector< unsigned int > *result = 0 ;
  std::vector< unsigned int > *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    std::vector< unsigned int,std::allocator< unsigned int > > *ptr = (std::vector< unsigned int,std::allocator< unsigned int > > *)0;
    res1 = swig::asptr(other, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_vector_uint" "', argument " "1"" of type '" "std::vector< unsigned int > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_vector_uint" "', argument " "1"" of type '" "std::vector< unsigned int > const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (std::vector< unsigned int > *)new std::vector< unsigned int >((std::vector< unsigned int > const &)*arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  if (SWIG_IsNewObj(res1)) delete arg1;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_uint_empty ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_uint_empty" "', argument " "1"" of type '" "std::vector< unsigned int > const *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  {
    try {
      result = (bool)((std::vector< unsigned int > const *)arg1)->empty();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_uint_size ( SEXP self, SEXP s_swig_copy)
{
  std::vector< unsigned int >::size_type result;
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_uint_size" "', argument " "1"" of type '" "std::vector< unsigned int > const *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  {
    try {
      result = ((std::vector< unsigned int > const *)arg1)->size();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_uint_swap ( SEXP self, SEXP v)
{
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ;
  std::vector< unsigned int > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_uint_swap" "', argument " "1"" of type '" "std::vector< unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  res2 = SWIG_R_ConvertPtr(v, &argp2, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "vector_uint_swap" "', argument " "2"" of type '" "std::vector< unsigned int > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "vector_uint_swap" "', argument " "2"" of type '" "std::vector< unsigned int > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector< unsigned int > * >(argp2);
  {
    try {
      (arg1)->swap(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_uint_clear ( SEXP self)
{
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_uint_clear" "', argument " "1"" of type '" "std::vector< unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  {
    try {
      (arg1)->clear();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_uint_get_allocator ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< std::allocator< unsigned int > > result;
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_uint_get_allocator" "', argument " "1"" of type '" "std::vector< unsigned int > const *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  {
    try {
      result = ((std::vector< unsigned int > const *)arg1)->get_allocator();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new std::vector< unsigned int >::allocator_type(static_cast< const std::vector< unsigned int >::allocator_type& >(result))), SWIGTYPE_p_std__allocatorT_unsigned_int_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_vector_uint__SWIG_2 ( SEXP size)
{
  std::vector< unsigned int > *result = 0 ;
  std::vector< unsigned int >::size_type arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  ecode1 = SWIG_AsVal_int(size, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_vector_uint" "', argument " "1"" of type '" "std::vector< unsigned int >::size_type""'");
  } 
  arg1 = static_cast< std::vector< unsigned int >::size_type >(val1);
  {
    try {
      result = (std::vector< unsigned int > *)new std::vector< unsigned int >(arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_uint_pop_back ( SEXP self)
{
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_uint_pop_back" "', argument " "1"" of type '" "std::vector< unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  {
    try {
      (arg1)->pop_back();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_uint_resize__SWIG_0 ( SEXP self, SEXP new_size)
{
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ;
  std::vector< unsigned int >::size_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_uint_resize" "', argument " "1"" of type '" "std::vector< unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  ecode2 = SWIG_AsVal_int(new_size, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "vector_uint_resize" "', argument " "2"" of type '" "std::vector< unsigned int >::size_type""'");
  } 
  arg2 = static_cast< std::vector< unsigned int >::size_type >(val2);
  {
    try {
      (arg1)->resize(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_vector_uint__SWIG_3 ( SEXP size, SEXP value)
{
  std::vector< unsigned int > *result = 0 ;
  std::vector< unsigned int >::size_type arg1 ;
  std::vector< unsigned int >::value_type *arg2 = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  std::vector< unsigned int >::value_type temp2 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  ecode1 = SWIG_AsVal_int(size, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_vector_uint" "', argument " "1"" of type '" "std::vector< unsigned int >::size_type""'");
  } 
  arg1 = static_cast< std::vector< unsigned int >::size_type >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(value, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_vector_uint" "', argument " "2"" of type '" "std::vector< unsigned int >::value_type""'");
  } 
  temp2 = static_cast< std::vector< unsigned int >::value_type >(val2);
  arg2 = &temp2;
  {
    try {
      result = (std::vector< unsigned int > *)new std::vector< unsigned int >(arg1,(std::vector< unsigned int >::value_type const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_uint_push_back ( SEXP self, SEXP x)
{
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ;
  std::vector< unsigned int >::value_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< unsigned int >::value_type temp2 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_uint_push_back" "', argument " "1"" of type '" "std::vector< unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(x, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "vector_uint_push_back" "', argument " "2"" of type '" "std::vector< unsigned int >::value_type""'");
  } 
  temp2 = static_cast< std::vector< unsigned int >::value_type >(val2);
  arg2 = &temp2;
  {
    try {
      (arg1)->push_back((std::vector< unsigned int >::value_type const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_uint_front ( SEXP self, SEXP s_swig_copy)
{
  std::vector< unsigned int >::value_type *result = 0 ;
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_uint_front" "', argument " "1"" of type '" "std::vector< unsigned int > const *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  {
    try {
      result = (std::vector< unsigned int >::value_type *) &((std::vector< unsigned int > const *)arg1)->front();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(*result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_uint_back ( SEXP self, SEXP s_swig_copy)
{
  std::vector< unsigned int >::value_type *result = 0 ;
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_uint_back" "', argument " "1"" of type '" "std::vector< unsigned int > const *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  {
    try {
      result = (std::vector< unsigned int >::value_type *) &((std::vector< unsigned int > const *)arg1)->back();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(*result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_uint_assign ( SEXP self, SEXP n, SEXP x)
{
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ;
  std::vector< unsigned int >::size_type arg2 ;
  std::vector< unsigned int >::value_type *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  std::vector< unsigned int >::value_type temp3 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_uint_assign" "', argument " "1"" of type '" "std::vector< unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  ecode2 = SWIG_AsVal_int(n, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "vector_uint_assign" "', argument " "2"" of type '" "std::vector< unsigned int >::size_type""'");
  } 
  arg2 = static_cast< std::vector< unsigned int >::size_type >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(x, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "vector_uint_assign" "', argument " "3"" of type '" "std::vector< unsigned int >::value_type""'");
  } 
  temp3 = static_cast< std::vector< unsigned int >::value_type >(val3);
  arg3 = &temp3;
  {
    try {
      (arg1)->assign(arg2,(std::vector< unsigned int >::value_type const &)*arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_uint_resize__SWIG_1 ( SEXP self, SEXP new_size, SEXP x)
{
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ;
  std::vector< unsigned int >::size_type arg2 ;
  std::vector< unsigned int >::value_type *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  std::vector< unsigned int >::value_type temp3 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_uint_resize" "', argument " "1"" of type '" "std::vector< unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  ecode2 = SWIG_AsVal_int(new_size, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "vector_uint_resize" "', argument " "2"" of type '" "std::vector< unsigned int >::size_type""'");
  } 
  arg2 = static_cast< std::vector< unsigned int >::size_type >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(x, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "vector_uint_resize" "', argument " "3"" of type '" "std::vector< unsigned int >::value_type""'");
  } 
  temp3 = static_cast< std::vector< unsigned int >::value_type >(val3);
  arg3 = &temp3;
  {
    try {
      (arg1)->resize(arg2,(std::vector< unsigned int >::value_type const &)*arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_uint_reserve ( SEXP self, SEXP n)
{
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ;
  std::vector< unsigned int >::size_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_uint_reserve" "', argument " "1"" of type '" "std::vector< unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  ecode2 = SWIG_AsVal_int(n, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "vector_uint_reserve" "', argument " "2"" of type '" "std::vector< unsigned int >::size_type""'");
  } 
  arg2 = static_cast< std::vector< unsigned int >::size_type >(val2);
  {
    try {
      (arg1)->reserve(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_uint_capacity ( SEXP self, SEXP s_swig_copy)
{
  std::vector< unsigned int >::size_type result;
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_uint_capacity" "', argument " "1"" of type '" "std::vector< unsigned int > const *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  {
    try {
      result = ((std::vector< unsigned int > const *)arg1)->capacity();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_vector_uint ( SEXP self)
{
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_vector_uint" "', argument " "1"" of type '" "std::vector< unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_data_set ( SEXP self, SEXP s_data)
{
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  infomap::FlowData *arg2 = (infomap::FlowData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_data_set" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_data, &argp2, SWIGTYPE_p_infomap__FlowData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfoNode_data_set" "', argument " "2"" of type '" "infomap::FlowData *""'"); 
  }
  arg2 = reinterpret_cast< infomap::FlowData * >(argp2);
  if (arg1) (arg1)->data = *arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_data_get ( SEXP self)
{
  infomap::FlowData *result = 0 ;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_data_get" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  result = (infomap::FlowData *)& ((arg1)->data);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__FlowData, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_index_set ( SEXP self, SEXP s_index)
{
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_index_set" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  ecode2 = SWIG_AsVal_int(s_index, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfoNode_index_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->index = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_index_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_index_get" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  result = (unsigned int) ((arg1)->index);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_stateId_set ( SEXP self, SEXP s_stateId)
{
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_stateId_set" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  ecode2 = SWIG_AsVal_int(s_stateId, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfoNode_stateId_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->stateId = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_stateId_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_stateId_get" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  result = (unsigned int) ((arg1)->stateId);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_physicalId_set ( SEXP self, SEXP s_physicalId)
{
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_physicalId_set" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  ecode2 = SWIG_AsVal_int(s_physicalId, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfoNode_physicalId_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->physicalId = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_physicalId_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_physicalId_get" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  result = (unsigned int) ((arg1)->physicalId);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_layerId_set ( SEXP self, SEXP s_layerId)
{
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_layerId_set" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  ecode2 = SWIG_AsVal_int(s_layerId, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfoNode_layerId_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->layerId = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_layerId_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_layerId_get" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  result = (unsigned int) ((arg1)->layerId);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_metaData_set ( SEXP self, SEXP s_metaData)
{
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  std::vector< int,std::allocator< int > > *arg2 = (std::vector< int,std::allocator< int > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_metaData_set" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_metaData, &argp2, SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfoNode_metaData_set" "', argument " "2"" of type '" "std::vector< int,std::allocator< int > > *""'"); 
  }
  arg2 = reinterpret_cast< std::vector< int,std::allocator< int > > * >(argp2);
  if (arg1) (arg1)->metaData = *arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_metaData_get ( SEXP self)
{
  std::vector< int,std::allocator< int > > *result = 0 ;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_metaData_get" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  result = (std::vector< int,std::allocator< int > > *)& ((arg1)->metaData);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_owner_set ( SEXP self, SEXP s_owner)
{
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  infomap::InfoNode *arg2 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_owner_set" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_owner, &argp2, SWIGTYPE_p_infomap__InfoNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfoNode_owner_set" "', argument " "2"" of type '" "infomap::InfoNode *""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  if (arg1) (arg1)->owner = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_owner_get ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_owner_get" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  result = (infomap::InfoNode *) ((arg1)->owner);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_parent_set ( SEXP self, SEXP s_parent)
{
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  infomap::InfoNode *arg2 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_parent_set" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_parent, &argp2, SWIGTYPE_p_infomap__InfoNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfoNode_parent_set" "', argument " "2"" of type '" "infomap::InfoNode *""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  if (arg1) (arg1)->parent = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_parent_get ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_parent_get" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  result = (infomap::InfoNode *) ((arg1)->parent);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_previous_set ( SEXP self, SEXP s_previous)
{
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  infomap::InfoNode *arg2 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_previous_set" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_previous, &argp2, SWIGTYPE_p_infomap__InfoNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfoNode_previous_set" "', argument " "2"" of type '" "infomap::InfoNode *""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  if (arg1) (arg1)->previous = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_previous_get ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_previous_get" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  result = (infomap::InfoNode *) ((arg1)->previous);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode__next_set ( SEXP self, SEXP s_arg2)
{
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  infomap::InfoNode *arg2 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode__next_set" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_arg2, &argp2, SWIGTYPE_p_infomap__InfoNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfoNode__next_set" "', argument " "2"" of type '" "infomap::InfoNode *""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  if (arg1) (arg1)->next = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode__next_get ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode__next_get" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  result = (infomap::InfoNode *) ((arg1)->next);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_firstChild_set ( SEXP self, SEXP s_firstChild)
{
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  infomap::InfoNode *arg2 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_firstChild_set" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_firstChild, &argp2, SWIGTYPE_p_infomap__InfoNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfoNode_firstChild_set" "', argument " "2"" of type '" "infomap::InfoNode *""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  if (arg1) (arg1)->firstChild = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_firstChild_get ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_firstChild_get" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  result = (infomap::InfoNode *) ((arg1)->firstChild);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_lastChild_set ( SEXP self, SEXP s_lastChild)
{
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  infomap::InfoNode *arg2 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_lastChild_set" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_lastChild, &argp2, SWIGTYPE_p_infomap__InfoNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfoNode_lastChild_set" "', argument " "2"" of type '" "infomap::InfoNode *""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  if (arg1) (arg1)->lastChild = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_lastChild_get ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_lastChild_get" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  result = (infomap::InfoNode *) ((arg1)->lastChild);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_collapsedFirstChild_set ( SEXP self, SEXP s_collapsedFirstChild)
{
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  infomap::InfoNode *arg2 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_collapsedFirstChild_set" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_collapsedFirstChild, &argp2, SWIGTYPE_p_infomap__InfoNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfoNode_collapsedFirstChild_set" "', argument " "2"" of type '" "infomap::InfoNode *""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  if (arg1) (arg1)->collapsedFirstChild = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_collapsedFirstChild_get ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_collapsedFirstChild_get" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  result = (infomap::InfoNode *) ((arg1)->collapsedFirstChild);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_collapsedLastChild_set ( SEXP self, SEXP s_collapsedLastChild)
{
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  infomap::InfoNode *arg2 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_collapsedLastChild_set" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_collapsedLastChild, &argp2, SWIGTYPE_p_infomap__InfoNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfoNode_collapsedLastChild_set" "', argument " "2"" of type '" "infomap::InfoNode *""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  if (arg1) (arg1)->collapsedLastChild = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_collapsedLastChild_get ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_collapsedLastChild_get" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  result = (infomap::InfoNode *) ((arg1)->collapsedLastChild);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_codelength_set ( SEXP self, SEXP s_codelength)
{
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_codelength_set" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  arg2 = static_cast< double >(REAL(s_codelength)[0]);
  if (arg1) (arg1)->codelength = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_codelength_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_codelength_get" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  result = (double) ((arg1)->codelength);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_dirty_set ( SEXP self, SEXP s_dirty)
{
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_dirty_set" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  arg2 = LOGICAL(s_dirty)[0] ? true : false;
  if (arg1) (arg1)->dirty = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_dirty_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_dirty_get" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  result = (bool) ((arg1)->dirty);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_physicalNodes_set ( SEXP self, SEXP s_physicalNodes)
{
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  std::vector< infomap::PhysData,std::allocator< infomap::PhysData > > *arg2 = (std::vector< infomap::PhysData,std::allocator< infomap::PhysData > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_physicalNodes_set" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_physicalNodes, &argp2, SWIGTYPE_p_std__vectorT_infomap__PhysData_std__allocatorT_infomap__PhysData_t_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfoNode_physicalNodes_set" "', argument " "2"" of type '" "std::vector< infomap::PhysData,std::allocator< infomap::PhysData > > *""'"); 
  }
  arg2 = reinterpret_cast< std::vector< infomap::PhysData,std::allocator< infomap::PhysData > > * >(argp2);
  if (arg1) (arg1)->physicalNodes = *arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_physicalNodes_get ( SEXP self)
{
  std::vector< infomap::PhysData,std::allocator< infomap::PhysData > > *result = 0 ;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_physicalNodes_get" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  result = (std::vector< infomap::PhysData,std::allocator< infomap::PhysData > > *)& ((arg1)->physicalNodes);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_infomap__PhysData_std__allocatorT_infomap__PhysData_t_t, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_metaCollection_set ( SEXP self, SEXP s_metaCollection)
{
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  MetaCollection arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_metaCollection_set" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    res2 = SWIG_R_ConvertPtr(s_metaCollection, &argp2, SWIGTYPE_p_MetaCollection,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfoNode_metaCollection_set" "', argument " "2"" of type '" "MetaCollection""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfoNode_metaCollection_set" "', argument " "2"" of type '" "MetaCollection""'");
    } else {
      arg2 = *(reinterpret_cast< MetaCollection * >(argp2));
    }
  }
  if (arg1) (arg1)->metaCollection = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_metaCollection_get ( SEXP self, SEXP s_swig_copy)
{
  MetaCollection result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_metaCollection_get" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  result =  ((arg1)->metaCollection);
  r_ans = SWIG_R_NewPointerObj((new MetaCollection(static_cast< const MetaCollection& >(result))), SWIGTYPE_p_MetaCollection, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_stateNodes_set ( SEXP self, SEXP s_stateNodes)
{
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  std::vector< unsigned int,std::allocator< unsigned int > > *arg2 = (std::vector< unsigned int,std::allocator< unsigned int > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_stateNodes_set" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_stateNodes, &argp2, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfoNode_stateNodes_set" "', argument " "2"" of type '" "std::vector< unsigned int,std::allocator< unsigned int > > *""'"); 
  }
  arg2 = reinterpret_cast< std::vector< unsigned int,std::allocator< unsigned int > > * >(argp2);
  if (arg1) (arg1)->stateNodes = *arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_stateNodes_get ( SEXP self)
{
  std::vector< unsigned int,std::allocator< unsigned int > > *result = 0 ;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_stateNodes_get" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  result = (std::vector< unsigned int,std::allocator< unsigned int > > *)& ((arg1)->stateNodes);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfoNode__SWIG_0 ( SEXP flowData)
{
  infomap::InfoNode *result = 0 ;
  infomap::FlowData *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(flowData, &argp1, SWIGTYPE_p_infomap__FlowData,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InfoNode" "', argument " "1"" of type '" "infomap::FlowData const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InfoNode" "', argument " "1"" of type '" "infomap::FlowData const &""'"); 
  }
  arg1 = reinterpret_cast< infomap::FlowData * >(argp1);
  {
    try {
      result = (infomap::InfoNode *)new infomap::InfoNode((infomap::FlowData const &)*arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfoNode__SWIG_1 ( SEXP flowData, SEXP stateId)
{
  infomap::InfoNode *result = 0 ;
  infomap::FlowData *arg1 = 0 ;
  unsigned int arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(flowData, &argp1, SWIGTYPE_p_infomap__FlowData,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InfoNode" "', argument " "1"" of type '" "infomap::FlowData const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InfoNode" "', argument " "1"" of type '" "infomap::FlowData const &""'"); 
  }
  arg1 = reinterpret_cast< infomap::FlowData * >(argp1);
  ecode2 = SWIG_AsVal_int(stateId, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_InfoNode" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (infomap::InfoNode *)new infomap::InfoNode((infomap::FlowData const &)*arg1,arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfoNode__SWIG_2 ( SEXP flowData, SEXP stateId, SEXP physicalId)
{
  infomap::InfoNode *result = 0 ;
  infomap::FlowData *arg1 = 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  void *argp1 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(flowData, &argp1, SWIGTYPE_p_infomap__FlowData,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InfoNode" "', argument " "1"" of type '" "infomap::FlowData const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InfoNode" "', argument " "1"" of type '" "infomap::FlowData const &""'"); 
  }
  arg1 = reinterpret_cast< infomap::FlowData * >(argp1);
  ecode2 = SWIG_AsVal_int(stateId, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_InfoNode" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_int(physicalId, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_InfoNode" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    try {
      result = (infomap::InfoNode *)new infomap::InfoNode((infomap::FlowData const &)*arg1,arg2,arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfoNode__SWIG_3 ( SEXP flowData, SEXP stateId, SEXP physicalId, SEXP layerId)
{
  infomap::InfoNode *result = 0 ;
  infomap::FlowData *arg1 = 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  void *argp1 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(flowData, &argp1, SWIGTYPE_p_infomap__FlowData,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InfoNode" "', argument " "1"" of type '" "infomap::FlowData const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InfoNode" "', argument " "1"" of type '" "infomap::FlowData const &""'"); 
  }
  arg1 = reinterpret_cast< infomap::FlowData * >(argp1);
  ecode2 = SWIG_AsVal_int(stateId, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_InfoNode" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_int(physicalId, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_InfoNode" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_int(layerId, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_InfoNode" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  {
    try {
      result = (infomap::InfoNode *)new infomap::InfoNode((infomap::FlowData const &)*arg1,arg2,arg3,arg4);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfoNode__SWIG_4 ( )
{
  infomap::InfoNode *result = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    try {
      result = (infomap::InfoNode *)new infomap::InfoNode();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfoNode__SWIG_5 ( SEXP other)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfoNode *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(other, &argp1, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InfoNode" "', argument " "1"" of type '" "infomap::InfoNode const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InfoNode" "', argument " "1"" of type '" "infomap::InfoNode const &""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (infomap::InfoNode *)new infomap::InfoNode((infomap::InfoNode const &)*arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_InfoNode ( SEXP self)
{
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_InfoNode" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_Equal ( SEXP self, SEXP other, SEXP s_swig_copy)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_Equal" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  res2 = SWIG_R_ConvertPtr(other, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfoNode_Equal" "', argument " "2"" of type '" "infomap::InfoNode const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfoNode_Equal" "', argument " "2"" of type '" "infomap::InfoNode const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  {
    try {
      result = (infomap::InfoNode *) &(arg1)->operator =((infomap::InfoNode const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_getMetaData__SWIG_0 ( SEXP self, SEXP dimension, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_getMetaData" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  ecode2 = SWIG_AsVal_int(dimension, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfoNode_getMetaData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (unsigned int)(arg1)->getMetaData(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_getMetaData__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_getMetaData" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (unsigned int)(arg1)->getMetaData();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_getInfomap ( SEXP self, SEXP s_swig_copy)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_getInfomap" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (infomap::InfomapBase *) &(arg1)->getInfomap();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_setInfomap ( SEXP self, SEXP s_arg2, SEXP s_swig_copy)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  infomap::InfomapBase *arg2 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_setInfomap" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_arg2, &argp2, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfoNode_setInfomap" "', argument " "2"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfomapBase * >(argp2);
  {
    try {
      result = (infomap::InfomapBase *) &(arg1)->setInfomap(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_getInfomapRoot__SWIG_0 ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_getInfomapRoot" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (infomap::InfoNode *)(arg1)->getInfomapRoot();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_getInfomapRoot__SWIG_1 ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_getInfomapRoot" "', argument " "1"" of type '" "infomap::InfoNode const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (infomap::InfoNode *)((infomap::InfoNode const *)arg1)->getInfomapRoot();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_disposeInfomap ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_disposeInfomap" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (bool)(arg1)->disposeInfomap();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_numPhysicalNodes ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_numPhysicalNodes" "', argument " "1"" of type '" "infomap::InfoNode const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (unsigned int)((infomap::InfoNode const *)arg1)->numPhysicalNodes();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_begin__SWIG_0 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< ChildIterator< infomap::InfoNode * > > result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_begin" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (arg1)->begin();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::child_iterator(static_cast< const infomap::InfoNode::child_iterator& >(result))), SWIGTYPE_p_ChildIteratorT_infomap__InfoNode_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_end__SWIG_0 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< ChildIterator< infomap::InfoNode * > > result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_end" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (arg1)->end();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::child_iterator(static_cast< const infomap::InfoNode::child_iterator& >(result))), SWIGTYPE_p_ChildIteratorT_infomap__InfoNode_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_begin__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< ChildIterator< infomap::InfoNode const * > > result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_begin" "', argument " "1"" of type '" "infomap::InfoNode const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = ((infomap::InfoNode const *)arg1)->begin();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::const_child_iterator(static_cast< const infomap::InfoNode::const_child_iterator& >(result))), SWIGTYPE_p_ChildIteratorT_infomap__InfoNode_const_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_end__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< ChildIterator< infomap::InfoNode const * > > result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_end" "', argument " "1"" of type '" "infomap::InfoNode const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = ((infomap::InfoNode const *)arg1)->end();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::const_child_iterator(static_cast< const infomap::InfoNode::const_child_iterator& >(result))), SWIGTYPE_p_ChildIteratorT_infomap__InfoNode_const_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_begin_child__SWIG_0 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< ChildIterator< infomap::InfoNode * > > result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_begin_child" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (arg1)->begin_child();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::child_iterator(static_cast< const infomap::InfoNode::child_iterator& >(result))), SWIGTYPE_p_ChildIteratorT_infomap__InfoNode_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_end_child__SWIG_0 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< ChildIterator< infomap::InfoNode * > > result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_end_child" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (arg1)->end_child();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::child_iterator(static_cast< const infomap::InfoNode::child_iterator& >(result))), SWIGTYPE_p_ChildIteratorT_infomap__InfoNode_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_begin_child__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< ChildIterator< infomap::InfoNode const * > > result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_begin_child" "', argument " "1"" of type '" "infomap::InfoNode const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = ((infomap::InfoNode const *)arg1)->begin_child();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::const_child_iterator(static_cast< const infomap::InfoNode::const_child_iterator& >(result))), SWIGTYPE_p_ChildIteratorT_infomap__InfoNode_const_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_end_child__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< ChildIterator< infomap::InfoNode const * > > result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_end_child" "', argument " "1"" of type '" "infomap::InfoNode const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = ((infomap::InfoNode const *)arg1)->end_child();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::const_child_iterator(static_cast< const infomap::InfoNode::const_child_iterator& >(result))), SWIGTYPE_p_ChildIteratorT_infomap__InfoNode_const_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_children__SWIG_0 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< IterWrapper< ChildIterator< infomap::InfoNode * > > > result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_children" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (arg1)->children();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::child_iterator_wrapper(static_cast< const infomap::InfoNode::child_iterator_wrapper& >(result))), SWIGTYPE_p_IterWrapperT_ChildIteratorT_infomap__InfoNode_p_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_children__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< IterWrapper< ChildIterator< infomap::InfoNode const * > > > result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_children" "', argument " "1"" of type '" "infomap::InfoNode const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = ((infomap::InfoNode const *)arg1)->children();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::const_child_iterator_wrapper(static_cast< const infomap::InfoNode::const_child_iterator_wrapper& >(result))), SWIGTYPE_p_IterWrapperT_ChildIteratorT_infomap__InfoNode_const_p_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_infomap_children__SWIG_0 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< IterWrapper< InfomapChildIterator< infomap::InfoNode * > > > result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_infomap_children" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (arg1)->infomap_children();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::infomap_child_iterator_wrapper(static_cast< const infomap::InfoNode::infomap_child_iterator_wrapper& >(result))), SWIGTYPE_p_IterWrapperT_InfomapChildIteratorT_infomap__InfoNode_p_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_infomap_children__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< IterWrapper< InfomapChildIterator< infomap::InfoNode const * > > > result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_infomap_children" "', argument " "1"" of type '" "infomap::InfoNode const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = ((infomap::InfoNode const *)arg1)->infomap_children();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::const_infomap_child_iterator_wrapper(static_cast< const infomap::InfoNode::const_infomap_child_iterator_wrapper& >(result))), SWIGTYPE_p_IterWrapperT_InfomapChildIteratorT_infomap__InfoNode_const_p_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_begin_post_depth_first ( SEXP self, SEXP s_swig_copy)
{
  infomap::InfoNode::post_depth_first_iterator result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_begin_post_depth_first" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (arg1)->begin_post_depth_first();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::post_depth_first_iterator(static_cast< const infomap::InfoNode::post_depth_first_iterator& >(result))), SWIGTYPE_p_DepthFirstIteratorT_infomap__InfoNode_p_false_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_begin_leaf_nodes ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< LeafNodeIterator< infomap::InfoNode * > > result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_begin_leaf_nodes" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (arg1)->begin_leaf_nodes();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::leaf_node_iterator(static_cast< const infomap::InfoNode::leaf_node_iterator& >(result))), SWIGTYPE_p_LeafNodeIteratorT_infomap__InfoNode_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_begin_leaf_modules ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< LeafModuleIterator< infomap::InfoNode * > > result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_begin_leaf_modules" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (arg1)->begin_leaf_modules();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::leaf_module_iterator(static_cast< const infomap::InfoNode::leaf_module_iterator& >(result))), SWIGTYPE_p_LeafModuleIteratorT_infomap__InfoNode_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_begin_tree__SWIG_0 ( SEXP self, SEXP maxClusterLevel, SEXP s_swig_copy)
{
  SwigValueWrapper< TreeIterator< infomap::InfoNode * > > result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_begin_tree" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  ecode2 = SWIG_AsVal_int(maxClusterLevel, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfoNode_begin_tree" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (arg1)->begin_tree(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::tree_iterator(static_cast< const infomap::InfoNode::tree_iterator& >(result))), SWIGTYPE_p_TreeIteratorT_infomap__InfoNode_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_begin_tree__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< TreeIterator< infomap::InfoNode * > > result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_begin_tree" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (arg1)->begin_tree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::tree_iterator(static_cast< const infomap::InfoNode::tree_iterator& >(result))), SWIGTYPE_p_TreeIteratorT_infomap__InfoNode_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_end_tree__SWIG_0 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< TreeIterator< infomap::InfoNode * > > result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_end_tree" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (arg1)->end_tree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::tree_iterator(static_cast< const infomap::InfoNode::tree_iterator& >(result))), SWIGTYPE_p_TreeIteratorT_infomap__InfoNode_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_begin_tree__SWIG_2 ( SEXP self, SEXP maxClusterLevel, SEXP s_swig_copy)
{
  SwigValueWrapper< TreeIterator< infomap::InfoNode const * > > result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_begin_tree" "', argument " "1"" of type '" "infomap::InfoNode const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  ecode2 = SWIG_AsVal_int(maxClusterLevel, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfoNode_begin_tree" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = ((infomap::InfoNode const *)arg1)->begin_tree(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::const_tree_iterator(static_cast< const infomap::InfoNode::const_tree_iterator& >(result))), SWIGTYPE_p_TreeIteratorT_infomap__InfoNode_const_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_begin_tree__SWIG_3 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< TreeIterator< infomap::InfoNode const * > > result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_begin_tree" "', argument " "1"" of type '" "infomap::InfoNode const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = ((infomap::InfoNode const *)arg1)->begin_tree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::const_tree_iterator(static_cast< const infomap::InfoNode::const_tree_iterator& >(result))), SWIGTYPE_p_TreeIteratorT_infomap__InfoNode_const_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_end_tree__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< TreeIterator< infomap::InfoNode const * > > result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_end_tree" "', argument " "1"" of type '" "infomap::InfoNode const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = ((infomap::InfoNode const *)arg1)->end_tree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::const_tree_iterator(static_cast< const infomap::InfoNode::const_tree_iterator& >(result))), SWIGTYPE_p_TreeIteratorT_infomap__InfoNode_const_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_infomapTree__SWIG_0 ( SEXP self, SEXP maxClusterLevel, SEXP s_swig_copy)
{
  SwigValueWrapper< IterWrapper< TreeIterator< infomap::InfoNode * > > > result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_infomapTree" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  ecode2 = SWIG_AsVal_int(maxClusterLevel, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfoNode_infomapTree" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (arg1)->infomapTree(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::infomap_iterator_wrapper(static_cast< const infomap::InfoNode::infomap_iterator_wrapper& >(result))), SWIGTYPE_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_p_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_infomapTree__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< IterWrapper< TreeIterator< infomap::InfoNode * > > > result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_infomapTree" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (arg1)->infomapTree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::infomap_iterator_wrapper(static_cast< const infomap::InfoNode::infomap_iterator_wrapper& >(result))), SWIGTYPE_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_p_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_infomapTree__SWIG_2 ( SEXP self, SEXP maxClusterLevel, SEXP s_swig_copy)
{
  SwigValueWrapper< IterWrapper< TreeIterator< infomap::InfoNode const * > > > result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_infomapTree" "', argument " "1"" of type '" "infomap::InfoNode const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  ecode2 = SWIG_AsVal_int(maxClusterLevel, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfoNode_infomapTree" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = ((infomap::InfoNode const *)arg1)->infomapTree(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::const_infomap_iterator_wrapper(static_cast< const infomap::InfoNode::const_infomap_iterator_wrapper& >(result))), SWIGTYPE_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_const_p_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_infomapTree__SWIG_3 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< IterWrapper< TreeIterator< infomap::InfoNode const * > > > result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_infomapTree" "', argument " "1"" of type '" "infomap::InfoNode const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = ((infomap::InfoNode const *)arg1)->infomapTree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::const_infomap_iterator_wrapper(static_cast< const infomap::InfoNode::const_infomap_iterator_wrapper& >(result))), SWIGTYPE_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_const_p_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_begin_outEdge ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< std::vector< Edge< infomap::InfoNode > *,std::allocator< Edge< infomap::InfoNode > * > >::iterator > result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_begin_outEdge" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (arg1)->begin_outEdge();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::edge_iterator(static_cast< const infomap::InfoNode::edge_iterator& >(result))), SWIGTYPE_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_end_outEdge ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< std::vector< Edge< infomap::InfoNode > *,std::allocator< Edge< infomap::InfoNode > * > >::iterator > result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_end_outEdge" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (arg1)->end_outEdge();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::edge_iterator(static_cast< const infomap::InfoNode::edge_iterator& >(result))), SWIGTYPE_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_begin_inEdge ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< std::vector< Edge< infomap::InfoNode > *,std::allocator< Edge< infomap::InfoNode > * > >::iterator > result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_begin_inEdge" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (arg1)->begin_inEdge();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::edge_iterator(static_cast< const infomap::InfoNode::edge_iterator& >(result))), SWIGTYPE_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_end_inEdge ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< std::vector< Edge< infomap::InfoNode > *,std::allocator< Edge< infomap::InfoNode > * > >::iterator > result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_end_inEdge" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (arg1)->end_inEdge();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::edge_iterator(static_cast< const infomap::InfoNode::edge_iterator& >(result))), SWIGTYPE_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_outEdges ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< IterWrapper< std::vector< Edge< infomap::InfoNode > *,std::allocator< Edge< infomap::InfoNode > * > >::iterator > > result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_outEdges" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (arg1)->outEdges();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::edge_iterator_wrapper(static_cast< const infomap::InfoNode::edge_iterator_wrapper& >(result))), SWIGTYPE_p_IterWrapperT_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_inEdges ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< IterWrapper< std::vector< Edge< infomap::InfoNode > *,std::allocator< Edge< infomap::InfoNode > * > >::iterator > > result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_inEdges" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (arg1)->inEdges();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::edge_iterator_wrapper(static_cast< const infomap::InfoNode::edge_iterator_wrapper& >(result))), SWIGTYPE_p_IterWrapperT_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_childDegree ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_childDegree" "', argument " "1"" of type '" "infomap::InfoNode const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (unsigned int)((infomap::InfoNode const *)arg1)->childDegree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_isLeaf ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_isLeaf" "', argument " "1"" of type '" "infomap::InfoNode const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (bool)((infomap::InfoNode const *)arg1)->isLeaf();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_isLeafModule ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_isLeafModule" "', argument " "1"" of type '" "infomap::InfoNode const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (bool)((infomap::InfoNode const *)arg1)->isLeafModule();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_isRoot ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_isRoot" "', argument " "1"" of type '" "infomap::InfoNode const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (bool)((infomap::InfoNode const *)arg1)->isRoot();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_depth ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_depth" "', argument " "1"" of type '" "infomap::InfoNode const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (unsigned int)((infomap::InfoNode const *)arg1)->depth();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_firstDepthBelow ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_firstDepthBelow" "', argument " "1"" of type '" "infomap::InfoNode const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (unsigned int)((infomap::InfoNode const *)arg1)->firstDepthBelow();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_numLeafMembers ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_numLeafMembers" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (unsigned int)(arg1)->numLeafMembers();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_isDangling ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_isDangling" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (bool)(arg1)->isDangling();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_outDegree ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_outDegree" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (unsigned int)(arg1)->outDegree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_inDegree ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_inDegree" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (unsigned int)(arg1)->inDegree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_degree ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_degree" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (unsigned int)(arg1)->degree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_isFirst ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_isFirst" "', argument " "1"" of type '" "infomap::InfoNode const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (bool)((infomap::InfoNode const *)arg1)->isFirst();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_isLast ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_isLast" "', argument " "1"" of type '" "infomap::InfoNode const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (bool)((infomap::InfoNode const *)arg1)->isLast();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_childIndex ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_childIndex" "', argument " "1"" of type '" "infomap::InfoNode const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (unsigned int)((infomap::InfoNode const *)arg1)->childIndex();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_calculatePath ( SEXP self, SEXP s_swig_copy)
{
  std::vector< unsigned int,std::allocator< unsigned int > > result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_calculatePath" "', argument " "1"" of type '" "infomap::InfoNode const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = ((infomap::InfoNode const *)arg1)->calculatePath();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = swig::from(static_cast< std::vector< unsigned int,std::allocator< unsigned int > > >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_infomapChildDegree ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_infomapChildDegree" "', argument " "1"" of type '" "infomap::InfoNode const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (unsigned int)((infomap::InfoNode const *)arg1)->infomapChildDegree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_id ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_id" "', argument " "1"" of type '" "infomap::InfoNode const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (unsigned int)((infomap::InfoNode const *)arg1)->id();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_EqualEqual ( SEXP self, SEXP rhs, SEXP s_swig_copy)
{
  bool result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_EqualEqual" "', argument " "1"" of type '" "infomap::InfoNode const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  res2 = SWIG_R_ConvertPtr(rhs, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfoNode_EqualEqual" "', argument " "2"" of type '" "infomap::InfoNode const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfoNode_EqualEqual" "', argument " "2"" of type '" "infomap::InfoNode const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  {
    try {
      result = (bool)((infomap::InfoNode const *)arg1)->operator ==((infomap::InfoNode const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_NotEqual ( SEXP self, SEXP rhs, SEXP s_swig_copy)
{
  bool result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_NotEqual" "', argument " "1"" of type '" "infomap::InfoNode const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  res2 = SWIG_R_ConvertPtr(rhs, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfoNode_NotEqual" "', argument " "2"" of type '" "infomap::InfoNode const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfoNode_NotEqual" "', argument " "2"" of type '" "infomap::InfoNode const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  {
    try {
      result = (bool)((infomap::InfoNode const *)arg1)->operator !=((infomap::InfoNode const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_initClean ( SEXP self)
{
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_initClean" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      (arg1)->initClean();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_sortChildrenOnFlow__SWIG_0 ( SEXP self, SEXP recurse)
{
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_sortChildrenOnFlow" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  arg2 = LOGICAL(recurse)[0] ? true : false;
  {
    try {
      (arg1)->sortChildrenOnFlow(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_sortChildrenOnFlow__SWIG_1 ( SEXP self)
{
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_sortChildrenOnFlow" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      (arg1)->sortChildrenOnFlow();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_collapseChildren ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_collapseChildren" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (unsigned int)(arg1)->collapseChildren();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_expandChildren ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_expandChildren" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (unsigned int)(arg1)->expandChildren();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_setChildDegree ( SEXP self, SEXP value)
{
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_setChildDegree" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  ecode2 = SWIG_AsVal_int(value, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfoNode_setChildDegree" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      (arg1)->setChildDegree(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_setNumLeafNodes ( SEXP self, SEXP value)
{
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_setNumLeafNodes" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  ecode2 = SWIG_AsVal_int(value, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfoNode_setNumLeafNodes" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      (arg1)->setNumLeafNodes(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_addChild ( SEXP self, SEXP child)
{
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  infomap::InfoNode *arg2 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_addChild" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  res2 = SWIG_R_ConvertPtr(child, &argp2, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfoNode_addChild" "', argument " "2"" of type '" "infomap::InfoNode *""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  {
    try {
      (arg1)->addChild(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_releaseChildren ( SEXP self)
{
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_releaseChildren" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      (arg1)->releaseChildren();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_replaceChildrenWithOneNode ( SEXP self, SEXP s_swig_copy)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_replaceChildrenWithOneNode" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (infomap::InfoNode *) &(arg1)->replaceChildrenWithOneNode();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_replaceWithChildren ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_replaceWithChildren" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (unsigned int)(arg1)->replaceWithChildren();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_replaceWithChildrenDebug ( SEXP self)
{
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_replaceWithChildrenDebug" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      (arg1)->replaceWithChildrenDebug();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_replaceChildrenWithGrandChildren ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_replaceChildrenWithGrandChildren" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (unsigned int)(arg1)->replaceChildrenWithGrandChildren();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_replaceChildrenWithGrandChildrenDebug ( SEXP self)
{
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_replaceChildrenWithGrandChildrenDebug" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      (arg1)->replaceChildrenWithGrandChildrenDebug();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_remove ( SEXP self, SEXP removeChildren)
{
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_remove" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  arg2 = LOGICAL(removeChildren)[0] ? true : false;
  {
    try {
      (arg1)->remove(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_deleteChildren ( SEXP self)
{
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_deleteChildren" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      (arg1)->deleteChildren();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_addOutEdge__SWIG_0 ( SEXP self, SEXP target, SEXP weight, SEXP flow)
{
  infomap::InfoNode::EdgeType *result = 0 ;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_addOutEdge" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  res2 = SWIG_R_ConvertPtr(target, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfoNode_addOutEdge" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfoNode_addOutEdge" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  arg3 = static_cast< double >(REAL(weight)[0]);
  arg4 = static_cast< double >(REAL(flow)[0]);
  {
    try {
      result = (infomap::InfoNode::EdgeType *)(arg1)->addOutEdge(*arg2,arg3,arg4);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EdgeT_infomap__InfoNode_t, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfoNode_addOutEdge__SWIG_1 ( SEXP self, SEXP target, SEXP weight)
{
  infomap::InfoNode::EdgeType *result = 0 ;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfoNode_addOutEdge" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  res2 = SWIG_R_ConvertPtr(target, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfoNode_addOutEdge" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfoNode_addOutEdge" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  arg3 = static_cast< double >(REAL(weight)[0]);
  {
    try {
      result = (infomap::InfoNode::EdgeType *)(arg1)->addOutEdge(*arg2,arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EdgeT_infomap__InfoNode_t, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_deque_uint__SWIG_0 ( )
{
  std::deque< unsigned int > *result = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    try {
      result = (std::deque< unsigned int > *)new std::deque< unsigned int >();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_deque_uint__SWIG_1 ( SEXP other)
{
  std::deque< unsigned int > *result = 0 ;
  std::deque< unsigned int > *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    std::deque< unsigned int,std::allocator< unsigned int > > *ptr = (std::deque< unsigned int,std::allocator< unsigned int > > *)0;
    res1 = swig::asptr(other, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_deque_uint" "', argument " "1"" of type '" "std::deque< unsigned int > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_deque_uint" "', argument " "1"" of type '" "std::deque< unsigned int > const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (std::deque< unsigned int > *)new std::deque< unsigned int >((std::deque< unsigned int > const &)*arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  if (SWIG_IsNewObj(res1)) delete arg1;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_deque_uint_empty ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  std::deque< unsigned int > *arg1 = (std::deque< unsigned int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "deque_uint_empty" "', argument " "1"" of type '" "std::deque< unsigned int > const *""'"); 
  }
  arg1 = reinterpret_cast< std::deque< unsigned int > * >(argp1);
  {
    try {
      result = (bool)((std::deque< unsigned int > const *)arg1)->empty();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_deque_uint_size ( SEXP self, SEXP s_swig_copy)
{
  std::deque< unsigned int >::size_type result;
  std::deque< unsigned int > *arg1 = (std::deque< unsigned int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "deque_uint_size" "', argument " "1"" of type '" "std::deque< unsigned int > const *""'"); 
  }
  arg1 = reinterpret_cast< std::deque< unsigned int > * >(argp1);
  {
    try {
      result = ((std::deque< unsigned int > const *)arg1)->size();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_deque_uint_swap ( SEXP self, SEXP v)
{
  std::deque< unsigned int > *arg1 = (std::deque< unsigned int > *) 0 ;
  std::deque< unsigned int > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "deque_uint_swap" "', argument " "1"" of type '" "std::deque< unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::deque< unsigned int > * >(argp1);
  res2 = SWIG_R_ConvertPtr(v, &argp2, SWIGTYPE_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "deque_uint_swap" "', argument " "2"" of type '" "std::deque< unsigned int > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "deque_uint_swap" "', argument " "2"" of type '" "std::deque< unsigned int > &""'"); 
  }
  arg2 = reinterpret_cast< std::deque< unsigned int > * >(argp2);
  {
    try {
      (arg1)->swap(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_deque_uint_clear ( SEXP self)
{
  std::deque< unsigned int > *arg1 = (std::deque< unsigned int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "deque_uint_clear" "', argument " "1"" of type '" "std::deque< unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::deque< unsigned int > * >(argp1);
  {
    try {
      (arg1)->clear();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_deque_uint_get_allocator ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< std::allocator< unsigned int > > result;
  std::deque< unsigned int > *arg1 = (std::deque< unsigned int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "deque_uint_get_allocator" "', argument " "1"" of type '" "std::deque< unsigned int > const *""'"); 
  }
  arg1 = reinterpret_cast< std::deque< unsigned int > * >(argp1);
  {
    try {
      result = ((std::deque< unsigned int > const *)arg1)->get_allocator();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new std::deque< unsigned int >::allocator_type(static_cast< const std::deque< unsigned int >::allocator_type& >(result))), SWIGTYPE_p_std__allocatorT_unsigned_int_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_deque_uint__SWIG_2 ( SEXP size)
{
  std::deque< unsigned int > *result = 0 ;
  std::deque< unsigned int >::size_type arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  ecode1 = SWIG_AsVal_int(size, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_deque_uint" "', argument " "1"" of type '" "std::deque< unsigned int >::size_type""'");
  } 
  arg1 = static_cast< std::deque< unsigned int >::size_type >(val1);
  {
    try {
      result = (std::deque< unsigned int > *)new std::deque< unsigned int >(arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_deque_uint_pop_back ( SEXP self)
{
  std::deque< unsigned int > *arg1 = (std::deque< unsigned int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "deque_uint_pop_back" "', argument " "1"" of type '" "std::deque< unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::deque< unsigned int > * >(argp1);
  {
    try {
      (arg1)->pop_back();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_deque_uint_resize__SWIG_0 ( SEXP self, SEXP new_size)
{
  std::deque< unsigned int > *arg1 = (std::deque< unsigned int > *) 0 ;
  std::deque< unsigned int >::size_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "deque_uint_resize" "', argument " "1"" of type '" "std::deque< unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::deque< unsigned int > * >(argp1);
  ecode2 = SWIG_AsVal_int(new_size, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "deque_uint_resize" "', argument " "2"" of type '" "std::deque< unsigned int >::size_type""'");
  } 
  arg2 = static_cast< std::deque< unsigned int >::size_type >(val2);
  {
    try {
      (arg1)->resize(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_deque_uint__SWIG_3 ( SEXP size, SEXP value)
{
  std::deque< unsigned int > *result = 0 ;
  std::deque< unsigned int >::size_type arg1 ;
  std::deque< unsigned int >::value_type *arg2 = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  std::deque< unsigned int >::value_type temp2 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  ecode1 = SWIG_AsVal_int(size, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_deque_uint" "', argument " "1"" of type '" "std::deque< unsigned int >::size_type""'");
  } 
  arg1 = static_cast< std::deque< unsigned int >::size_type >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(value, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_deque_uint" "', argument " "2"" of type '" "std::deque< unsigned int >::value_type""'");
  } 
  temp2 = static_cast< std::deque< unsigned int >::value_type >(val2);
  arg2 = &temp2;
  {
    try {
      result = (std::deque< unsigned int > *)new std::deque< unsigned int >(arg1,(std::deque< unsigned int >::value_type const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_deque_uint_push_back ( SEXP self, SEXP x)
{
  std::deque< unsigned int > *arg1 = (std::deque< unsigned int > *) 0 ;
  std::deque< unsigned int >::value_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::deque< unsigned int >::value_type temp2 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "deque_uint_push_back" "', argument " "1"" of type '" "std::deque< unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::deque< unsigned int > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(x, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "deque_uint_push_back" "', argument " "2"" of type '" "std::deque< unsigned int >::value_type""'");
  } 
  temp2 = static_cast< std::deque< unsigned int >::value_type >(val2);
  arg2 = &temp2;
  {
    try {
      (arg1)->push_back((std::deque< unsigned int >::value_type const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_deque_uint_front ( SEXP self, SEXP s_swig_copy)
{
  std::deque< unsigned int >::value_type *result = 0 ;
  std::deque< unsigned int > *arg1 = (std::deque< unsigned int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "deque_uint_front" "', argument " "1"" of type '" "std::deque< unsigned int > const *""'"); 
  }
  arg1 = reinterpret_cast< std::deque< unsigned int > * >(argp1);
  {
    try {
      result = (std::deque< unsigned int >::value_type *) &((std::deque< unsigned int > const *)arg1)->front();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(*result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_deque_uint_back ( SEXP self, SEXP s_swig_copy)
{
  std::deque< unsigned int >::value_type *result = 0 ;
  std::deque< unsigned int > *arg1 = (std::deque< unsigned int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "deque_uint_back" "', argument " "1"" of type '" "std::deque< unsigned int > const *""'"); 
  }
  arg1 = reinterpret_cast< std::deque< unsigned int > * >(argp1);
  {
    try {
      result = (std::deque< unsigned int >::value_type *) &((std::deque< unsigned int > const *)arg1)->back();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(*result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_deque_uint_assign ( SEXP self, SEXP n, SEXP x)
{
  std::deque< unsigned int > *arg1 = (std::deque< unsigned int > *) 0 ;
  std::deque< unsigned int >::size_type arg2 ;
  std::deque< unsigned int >::value_type *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  std::deque< unsigned int >::value_type temp3 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "deque_uint_assign" "', argument " "1"" of type '" "std::deque< unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::deque< unsigned int > * >(argp1);
  ecode2 = SWIG_AsVal_int(n, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "deque_uint_assign" "', argument " "2"" of type '" "std::deque< unsigned int >::size_type""'");
  } 
  arg2 = static_cast< std::deque< unsigned int >::size_type >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(x, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "deque_uint_assign" "', argument " "3"" of type '" "std::deque< unsigned int >::value_type""'");
  } 
  temp3 = static_cast< std::deque< unsigned int >::value_type >(val3);
  arg3 = &temp3;
  {
    try {
      (arg1)->assign(arg2,(std::deque< unsigned int >::value_type const &)*arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_deque_uint_resize__SWIG_1 ( SEXP self, SEXP new_size, SEXP x)
{
  std::deque< unsigned int > *arg1 = (std::deque< unsigned int > *) 0 ;
  std::deque< unsigned int >::size_type arg2 ;
  std::deque< unsigned int >::value_type *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  std::deque< unsigned int >::value_type temp3 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "deque_uint_resize" "', argument " "1"" of type '" "std::deque< unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::deque< unsigned int > * >(argp1);
  ecode2 = SWIG_AsVal_int(new_size, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "deque_uint_resize" "', argument " "2"" of type '" "std::deque< unsigned int >::size_type""'");
  } 
  arg2 = static_cast< std::deque< unsigned int >::size_type >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(x, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "deque_uint_resize" "', argument " "3"" of type '" "std::deque< unsigned int >::value_type""'");
  } 
  temp3 = static_cast< std::deque< unsigned int >::value_type >(val3);
  arg3 = &temp3;
  {
    try {
      (arg1)->resize(arg2,(std::deque< unsigned int >::value_type const &)*arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_deque_uint_pop_front ( SEXP self)
{
  std::deque< unsigned int > *arg1 = (std::deque< unsigned int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "deque_uint_pop_front" "', argument " "1"" of type '" "std::deque< unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::deque< unsigned int > * >(argp1);
  {
    try {
      (arg1)->pop_front();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_deque_uint_push_front ( SEXP self, SEXP x)
{
  std::deque< unsigned int > *arg1 = (std::deque< unsigned int > *) 0 ;
  std::deque< unsigned int >::value_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::deque< unsigned int >::value_type temp2 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "deque_uint_push_front" "', argument " "1"" of type '" "std::deque< unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::deque< unsigned int > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(x, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "deque_uint_push_front" "', argument " "2"" of type '" "std::deque< unsigned int >::value_type""'");
  } 
  temp2 = static_cast< std::deque< unsigned int >::value_type >(val2);
  arg2 = &temp2;
  {
    try {
      (arg1)->push_front((std::deque< unsigned int >::value_type const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_deque_uint ( SEXP self)
{
  std::deque< unsigned int > *arg1 = (std::deque< unsigned int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_deque_uint" "', argument " "1"" of type '" "std::deque< unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::deque< unsigned int > * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfomapIterator__SWIG_0 ( )
{
  infomap::InfomapIterator *result = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    try {
      result = (infomap::InfomapIterator *)new infomap::InfomapIterator();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfomapIterator__SWIG_1 ( SEXP nodePointer, SEXP moduleIndexLevel)
{
  infomap::InfomapIterator *result = 0 ;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(nodePointer, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InfomapIterator" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  arg2 = static_cast< int >(INTEGER(moduleIndexLevel)[0]);
  {
    try {
      result = (infomap::InfomapIterator *)new infomap::InfomapIterator(arg1,arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfomapIterator__SWIG_2 ( SEXP nodePointer)
{
  infomap::InfomapIterator *result = 0 ;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(nodePointer, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InfomapIterator" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (infomap::InfomapIterator *)new infomap::InfomapIterator(arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfomapIterator__SWIG_3 ( SEXP other)
{
  infomap::InfomapIterator *result = 0 ;
  infomap::InfomapIterator *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(other, &argp1, SWIGTYPE_p_infomap__InfomapIterator,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InfomapIterator" "', argument " "1"" of type '" "infomap::InfomapIterator const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InfomapIterator" "', argument " "1"" of type '" "infomap::InfomapIterator const &""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (infomap::InfomapIterator *)new infomap::InfomapIterator((infomap::InfomapIterator const &)*arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_InfomapIterator ( SEXP self)
{
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_InfomapIterator" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_Equal ( SEXP self, SEXP other, SEXP s_swig_copy)
{
  infomap::InfomapIterator *result = 0 ;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  infomap::InfomapIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_Equal" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(other, &argp2, SWIGTYPE_p_infomap__InfomapIterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapIterator_Equal" "', argument " "2"" of type '" "infomap::InfomapIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapIterator_Equal" "', argument " "2"" of type '" "infomap::InfomapIterator const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfomapIterator * >(argp2);
  {
    try {
      result = (infomap::InfomapIterator *) &(arg1)->operator =((infomap::InfomapIterator const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_current__SWIG_0 ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_current" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (infomap::InfoNode *)(arg1)->current();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_current__SWIG_1 ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_current" "', argument " "1"" of type '" "infomap::InfomapIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (infomap::InfoNode *)((infomap::InfomapIterator const *)arg1)->current();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator___ref____SWIG_0 ( SEXP self, SEXP s_swig_copy)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator___ref__" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (infomap::InfoNode *) &(arg1)->operator *();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator___ref____SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator___ref__" "', argument " "1"" of type '" "infomap::InfomapIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (infomap::InfoNode *) &((infomap::InfomapIterator const *)arg1)->operator *();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator___deref____SWIG_0 ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator___deref__" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (infomap::InfoNode *)(arg1)->operator ->();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator___deref____SWIG_1 ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator___deref__" "', argument " "1"" of type '" "infomap::InfomapIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (infomap::InfoNode *)((infomap::InfomapIterator const *)arg1)->operator ->();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_EqualEqual ( SEXP self, SEXP other, SEXP s_swig_copy)
{
  bool result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  infomap::InfomapIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_EqualEqual" "', argument " "1"" of type '" "infomap::InfomapIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(other, &argp2, SWIGTYPE_p_infomap__InfomapIterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapIterator_EqualEqual" "', argument " "2"" of type '" "infomap::InfomapIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapIterator_EqualEqual" "', argument " "2"" of type '" "infomap::InfomapIterator const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfomapIterator * >(argp2);
  {
    try {
      result = (bool)((infomap::InfomapIterator const *)arg1)->operator ==((infomap::InfomapIterator const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_NotEqual ( SEXP self, SEXP other, SEXP s_swig_copy)
{
  bool result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  infomap::InfomapIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_NotEqual" "', argument " "1"" of type '" "infomap::InfomapIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(other, &argp2, SWIGTYPE_p_infomap__InfomapIterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapIterator_NotEqual" "', argument " "2"" of type '" "infomap::InfomapIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapIterator_NotEqual" "', argument " "2"" of type '" "infomap::InfomapIterator const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfomapIterator * >(argp2);
  {
    try {
      result = (bool)((infomap::InfomapIterator const *)arg1)->operator !=((infomap::InfomapIterator const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_PlusPlusPrefix ( SEXP self, SEXP s_swig_copy)
{
  infomap::InfomapIterator *result = 0 ;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_PlusPlusPrefix" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (infomap::InfomapIterator *) &(arg1)->operator ++();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_PlusPlusPostfix ( SEXP self, SEXP s_arg2, SEXP s_swig_copy)
{
  infomap::InfomapIterator result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_PlusPlusPostfix" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  arg2 = static_cast< int >(INTEGER(s_arg2)[0]);
  {
    try {
      result = (arg1)->operator ++(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfomapIterator(static_cast< const infomap::InfomapIterator& >(result))), SWIGTYPE_p_infomap__InfomapIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_stepForward ( SEXP self, SEXP s_swig_copy)
{
  infomap::InfomapIterator *result = 0 ;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_stepForward" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (infomap::InfomapIterator *) &(arg1)->stepForward();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_path ( SEXP self, SEXP s_swig_copy)
{
  std::deque< unsigned int,std::allocator< unsigned int > > *result = 0 ;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_path" "', argument " "1"" of type '" "infomap::InfomapIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (std::deque< unsigned int,std::allocator< unsigned int > > *) &((infomap::InfomapIterator const *)arg1)->path();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = swig::from(static_cast< std::deque< unsigned int,std::allocator< unsigned int > > >(*result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_moduleIndex ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_moduleIndex" "', argument " "1"" of type '" "infomap::InfomapIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (unsigned int)((infomap::InfomapIterator const *)arg1)->moduleIndex();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_moduleId ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_moduleId" "', argument " "1"" of type '" "infomap::InfomapIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (unsigned int)((infomap::InfomapIterator const *)arg1)->moduleId();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_childIndex ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_childIndex" "', argument " "1"" of type '" "infomap::InfomapIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (unsigned int)((infomap::InfomapIterator const *)arg1)->childIndex();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_depth ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_depth" "', argument " "1"" of type '" "infomap::InfomapIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (unsigned int)((infomap::InfomapIterator const *)arg1)->depth();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_isEnd ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_isEnd" "', argument " "1"" of type '" "infomap::InfomapIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (bool)((infomap::InfomapIterator const *)arg1)->isEnd();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_data_set ( SEXP self, SEXP s_data)
{
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  infomap::FlowData *arg2 = (infomap::FlowData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_data_set" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_data, &argp2, SWIGTYPE_p_infomap__FlowData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapIterator_data_set" "', argument " "2"" of type '" "infomap::FlowData *""'"); 
  }
  arg2 = reinterpret_cast< infomap::FlowData * >(argp2);
  if (arg1) (*arg1)->data = *arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_data_get ( SEXP self)
{
  infomap::FlowData *result = 0 ;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_data_get" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  result = (infomap::FlowData *)& ((*(infomap::InfomapIterator const *)arg1)->data);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__FlowData, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_index_set ( SEXP self, SEXP s_index)
{
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_index_set" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  ecode2 = SWIG_AsVal_int(s_index, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapIterator_index_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (*arg1)->index = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_index_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_index_get" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  result = (unsigned int) ((*(infomap::InfomapIterator const *)arg1)->index);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_stateId_set ( SEXP self, SEXP s_stateId)
{
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_stateId_set" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  ecode2 = SWIG_AsVal_int(s_stateId, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapIterator_stateId_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (*arg1)->stateId = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_stateId_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_stateId_get" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  result = (unsigned int) ((*(infomap::InfomapIterator const *)arg1)->stateId);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_physicalId_set ( SEXP self, SEXP s_physicalId)
{
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_physicalId_set" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  ecode2 = SWIG_AsVal_int(s_physicalId, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapIterator_physicalId_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (*arg1)->physicalId = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_physicalId_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_physicalId_get" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  result = (unsigned int) ((*(infomap::InfomapIterator const *)arg1)->physicalId);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_layerId_set ( SEXP self, SEXP s_layerId)
{
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_layerId_set" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  ecode2 = SWIG_AsVal_int(s_layerId, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapIterator_layerId_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (*arg1)->layerId = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_layerId_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_layerId_get" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  result = (unsigned int) ((*(infomap::InfomapIterator const *)arg1)->layerId);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_metaData_set ( SEXP self, SEXP s_metaData)
{
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  std::vector< int,std::allocator< int > > *arg2 = (std::vector< int,std::allocator< int > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_metaData_set" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_metaData, &argp2, SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapIterator_metaData_set" "', argument " "2"" of type '" "std::vector< int,std::allocator< int > > *""'"); 
  }
  arg2 = reinterpret_cast< std::vector< int,std::allocator< int > > * >(argp2);
  if (arg1) (*arg1)->metaData = *arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_metaData_get ( SEXP self)
{
  std::vector< int,std::allocator< int > > *result = 0 ;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_metaData_get" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  result = (std::vector< int,std::allocator< int > > *)& ((*(infomap::InfomapIterator const *)arg1)->metaData);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_owner_set ( SEXP self, SEXP s_owner)
{
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  infomap::InfoNode *arg2 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_owner_set" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_owner, &argp2, SWIGTYPE_p_infomap__InfoNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapIterator_owner_set" "', argument " "2"" of type '" "infomap::InfoNode *""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  if (arg1) (*arg1)->owner = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_owner_get ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_owner_get" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  result = (infomap::InfoNode *) ((*(infomap::InfomapIterator const *)arg1)->owner);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_parent_set ( SEXP self, SEXP s_parent)
{
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  infomap::InfoNode *arg2 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_parent_set" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_parent, &argp2, SWIGTYPE_p_infomap__InfoNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapIterator_parent_set" "', argument " "2"" of type '" "infomap::InfoNode *""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  if (arg1) (*arg1)->parent = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_parent_get ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_parent_get" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  result = (infomap::InfoNode *) ((*(infomap::InfomapIterator const *)arg1)->parent);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_previous_set ( SEXP self, SEXP s_previous)
{
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  infomap::InfoNode *arg2 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_previous_set" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_previous, &argp2, SWIGTYPE_p_infomap__InfoNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapIterator_previous_set" "', argument " "2"" of type '" "infomap::InfoNode *""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  if (arg1) (*arg1)->previous = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_previous_get ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_previous_get" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  result = (infomap::InfoNode *) ((*(infomap::InfomapIterator const *)arg1)->previous);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator__next_set ( SEXP self, SEXP s_arg2)
{
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  infomap::InfoNode *arg2 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator__next_set" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_arg2, &argp2, SWIGTYPE_p_infomap__InfoNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapIterator__next_set" "', argument " "2"" of type '" "infomap::InfoNode *""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  if (arg1) (*arg1)->next = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator__next_get ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator__next_get" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  result = (infomap::InfoNode *) ((*(infomap::InfomapIterator const *)arg1)->next);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_firstChild_set ( SEXP self, SEXP s_firstChild)
{
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  infomap::InfoNode *arg2 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_firstChild_set" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_firstChild, &argp2, SWIGTYPE_p_infomap__InfoNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapIterator_firstChild_set" "', argument " "2"" of type '" "infomap::InfoNode *""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  if (arg1) (*arg1)->firstChild = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_firstChild_get ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_firstChild_get" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  result = (infomap::InfoNode *) ((*(infomap::InfomapIterator const *)arg1)->firstChild);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_lastChild_set ( SEXP self, SEXP s_lastChild)
{
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  infomap::InfoNode *arg2 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_lastChild_set" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_lastChild, &argp2, SWIGTYPE_p_infomap__InfoNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapIterator_lastChild_set" "', argument " "2"" of type '" "infomap::InfoNode *""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  if (arg1) (*arg1)->lastChild = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_lastChild_get ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_lastChild_get" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  result = (infomap::InfoNode *) ((*(infomap::InfomapIterator const *)arg1)->lastChild);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_collapsedFirstChild_set ( SEXP self, SEXP s_collapsedFirstChild)
{
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  infomap::InfoNode *arg2 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_collapsedFirstChild_set" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_collapsedFirstChild, &argp2, SWIGTYPE_p_infomap__InfoNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapIterator_collapsedFirstChild_set" "', argument " "2"" of type '" "infomap::InfoNode *""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  if (arg1) (*arg1)->collapsedFirstChild = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_collapsedFirstChild_get ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_collapsedFirstChild_get" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  result = (infomap::InfoNode *) ((*(infomap::InfomapIterator const *)arg1)->collapsedFirstChild);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_collapsedLastChild_set ( SEXP self, SEXP s_collapsedLastChild)
{
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  infomap::InfoNode *arg2 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_collapsedLastChild_set" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_collapsedLastChild, &argp2, SWIGTYPE_p_infomap__InfoNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapIterator_collapsedLastChild_set" "', argument " "2"" of type '" "infomap::InfoNode *""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  if (arg1) (*arg1)->collapsedLastChild = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_collapsedLastChild_get ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_collapsedLastChild_get" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  result = (infomap::InfoNode *) ((*(infomap::InfomapIterator const *)arg1)->collapsedLastChild);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_codelength_set ( SEXP self, SEXP s_codelength)
{
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_codelength_set" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  arg2 = static_cast< double >(REAL(s_codelength)[0]);
  if (arg1) (*arg1)->codelength = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_codelength_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_codelength_get" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  result = (double) ((*(infomap::InfomapIterator const *)arg1)->codelength);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_dirty_set ( SEXP self, SEXP s_dirty)
{
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_dirty_set" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  arg2 = LOGICAL(s_dirty)[0] ? true : false;
  if (arg1) (*arg1)->dirty = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_dirty_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_dirty_get" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  result = (bool) ((*(infomap::InfomapIterator const *)arg1)->dirty);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_physicalNodes_set ( SEXP self, SEXP s_physicalNodes)
{
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  std::vector< infomap::PhysData,std::allocator< infomap::PhysData > > *arg2 = (std::vector< infomap::PhysData,std::allocator< infomap::PhysData > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_physicalNodes_set" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_physicalNodes, &argp2, SWIGTYPE_p_std__vectorT_infomap__PhysData_std__allocatorT_infomap__PhysData_t_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapIterator_physicalNodes_set" "', argument " "2"" of type '" "std::vector< infomap::PhysData,std::allocator< infomap::PhysData > > *""'"); 
  }
  arg2 = reinterpret_cast< std::vector< infomap::PhysData,std::allocator< infomap::PhysData > > * >(argp2);
  if (arg1) (*arg1)->physicalNodes = *arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_physicalNodes_get ( SEXP self)
{
  std::vector< infomap::PhysData,std::allocator< infomap::PhysData > > *result = 0 ;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_physicalNodes_get" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  result = (std::vector< infomap::PhysData,std::allocator< infomap::PhysData > > *)& ((*(infomap::InfomapIterator const *)arg1)->physicalNodes);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_infomap__PhysData_std__allocatorT_infomap__PhysData_t_t, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_metaCollection_set ( SEXP self, SEXP s_metaCollection)
{
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  MetaCollection arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_metaCollection_set" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    res2 = SWIG_R_ConvertPtr(s_metaCollection, &argp2, SWIGTYPE_p_MetaCollection,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapIterator_metaCollection_set" "', argument " "2"" of type '" "MetaCollection""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapIterator_metaCollection_set" "', argument " "2"" of type '" "MetaCollection""'");
    } else {
      arg2 = *(reinterpret_cast< MetaCollection * >(argp2));
    }
  }
  if (arg1) (*arg1)->metaCollection = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_metaCollection_get ( SEXP self, SEXP s_swig_copy)
{
  MetaCollection result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_metaCollection_get" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  result =  ((*(infomap::InfomapIterator const *)arg1)->metaCollection);
  r_ans = SWIG_R_NewPointerObj((new MetaCollection(static_cast< const MetaCollection& >(result))), SWIGTYPE_p_MetaCollection, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_stateNodes_set ( SEXP self, SEXP s_stateNodes)
{
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  std::vector< unsigned int,std::allocator< unsigned int > > *arg2 = (std::vector< unsigned int,std::allocator< unsigned int > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_stateNodes_set" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_stateNodes, &argp2, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapIterator_stateNodes_set" "', argument " "2"" of type '" "std::vector< unsigned int,std::allocator< unsigned int > > *""'"); 
  }
  arg2 = reinterpret_cast< std::vector< unsigned int,std::allocator< unsigned int > > * >(argp2);
  if (arg1) (*arg1)->stateNodes = *arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_stateNodes_get ( SEXP self)
{
  std::vector< unsigned int,std::allocator< unsigned int > > *result = 0 ;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_stateNodes_get" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  result = (std::vector< unsigned int,std::allocator< unsigned int > > *)& ((*(infomap::InfomapIterator const *)arg1)->stateNodes);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_getMetaData__SWIG_0 ( SEXP self, SEXP dimension, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_getMetaData" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  ecode2 = SWIG_AsVal_int(dimension, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapIterator_getMetaData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (unsigned int)(*arg1)->getMetaData(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_getMetaData__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_getMetaData" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (unsigned int)(*arg1)->getMetaData();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_getInfomap ( SEXP self, SEXP s_swig_copy)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_getInfomap" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (infomap::InfomapBase *) &(*arg1)->getInfomap();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_setInfomap ( SEXP self, SEXP s_arg2, SEXP s_swig_copy)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  infomap::InfomapBase *arg2 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_setInfomap" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_arg2, &argp2, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapIterator_setInfomap" "', argument " "2"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfomapBase * >(argp2);
  {
    try {
      result = (infomap::InfomapBase *) &(*arg1)->setInfomap(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_getInfomapRoot__SWIG_0 ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_getInfomapRoot" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (infomap::InfoNode *)(*arg1)->getInfomapRoot();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_getInfomapRoot__SWIG_1 ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_getInfomapRoot" "', argument " "1"" of type '" "infomap::InfomapIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (infomap::InfoNode *)(*((infomap::InfomapIterator const *)arg1))->getInfomapRoot();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_disposeInfomap ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_disposeInfomap" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (bool)(*arg1)->disposeInfomap();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_numPhysicalNodes ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_numPhysicalNodes" "', argument " "1"" of type '" "infomap::InfomapIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (unsigned int)(*((infomap::InfomapIterator const *)arg1))->numPhysicalNodes();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_begin__SWIG_0 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< ChildIterator< infomap::InfoNode * > > result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_begin" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (*arg1)->begin();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::child_iterator(static_cast< const infomap::InfoNode::child_iterator& >(result))), SWIGTYPE_p_ChildIteratorT_infomap__InfoNode_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_begin__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< ChildIterator< infomap::InfoNode const * > > result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_begin" "', argument " "1"" of type '" "infomap::InfomapIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (*((infomap::InfomapIterator const *)arg1))->begin();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::const_child_iterator(static_cast< const infomap::InfoNode::const_child_iterator& >(result))), SWIGTYPE_p_ChildIteratorT_infomap__InfoNode_const_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_end__SWIG_0 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< ChildIterator< infomap::InfoNode * > > result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_end" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (*arg1)->end();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::child_iterator(static_cast< const infomap::InfoNode::child_iterator& >(result))), SWIGTYPE_p_ChildIteratorT_infomap__InfoNode_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_end__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< ChildIterator< infomap::InfoNode const * > > result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_end" "', argument " "1"" of type '" "infomap::InfomapIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (*((infomap::InfomapIterator const *)arg1))->end();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::const_child_iterator(static_cast< const infomap::InfoNode::const_child_iterator& >(result))), SWIGTYPE_p_ChildIteratorT_infomap__InfoNode_const_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_begin_child__SWIG_0 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< ChildIterator< infomap::InfoNode * > > result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_begin_child" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (*arg1)->begin_child();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::child_iterator(static_cast< const infomap::InfoNode::child_iterator& >(result))), SWIGTYPE_p_ChildIteratorT_infomap__InfoNode_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_begin_child__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< ChildIterator< infomap::InfoNode const * > > result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_begin_child" "', argument " "1"" of type '" "infomap::InfomapIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (*((infomap::InfomapIterator const *)arg1))->begin_child();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::const_child_iterator(static_cast< const infomap::InfoNode::const_child_iterator& >(result))), SWIGTYPE_p_ChildIteratorT_infomap__InfoNode_const_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_end_child__SWIG_0 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< ChildIterator< infomap::InfoNode * > > result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_end_child" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (*arg1)->end_child();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::child_iterator(static_cast< const infomap::InfoNode::child_iterator& >(result))), SWIGTYPE_p_ChildIteratorT_infomap__InfoNode_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_end_child__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< ChildIterator< infomap::InfoNode const * > > result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_end_child" "', argument " "1"" of type '" "infomap::InfomapIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (*((infomap::InfomapIterator const *)arg1))->end_child();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::const_child_iterator(static_cast< const infomap::InfoNode::const_child_iterator& >(result))), SWIGTYPE_p_ChildIteratorT_infomap__InfoNode_const_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_children__SWIG_0 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< IterWrapper< ChildIterator< infomap::InfoNode * > > > result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_children" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (*arg1)->children();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::child_iterator_wrapper(static_cast< const infomap::InfoNode::child_iterator_wrapper& >(result))), SWIGTYPE_p_IterWrapperT_ChildIteratorT_infomap__InfoNode_p_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_children__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< IterWrapper< ChildIterator< infomap::InfoNode const * > > > result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_children" "', argument " "1"" of type '" "infomap::InfomapIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (*((infomap::InfomapIterator const *)arg1))->children();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::const_child_iterator_wrapper(static_cast< const infomap::InfoNode::const_child_iterator_wrapper& >(result))), SWIGTYPE_p_IterWrapperT_ChildIteratorT_infomap__InfoNode_const_p_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_infomap_children__SWIG_0 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< IterWrapper< InfomapChildIterator< infomap::InfoNode * > > > result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_infomap_children" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (*arg1)->infomap_children();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::infomap_child_iterator_wrapper(static_cast< const infomap::InfoNode::infomap_child_iterator_wrapper& >(result))), SWIGTYPE_p_IterWrapperT_InfomapChildIteratorT_infomap__InfoNode_p_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_infomap_children__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< IterWrapper< InfomapChildIterator< infomap::InfoNode const * > > > result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_infomap_children" "', argument " "1"" of type '" "infomap::InfomapIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (*((infomap::InfomapIterator const *)arg1))->infomap_children();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::const_infomap_child_iterator_wrapper(static_cast< const infomap::InfoNode::const_infomap_child_iterator_wrapper& >(result))), SWIGTYPE_p_IterWrapperT_InfomapChildIteratorT_infomap__InfoNode_const_p_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_begin_post_depth_first ( SEXP self, SEXP s_swig_copy)
{
  infomap::InfoNode::post_depth_first_iterator result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_begin_post_depth_first" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (*arg1)->begin_post_depth_first();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::post_depth_first_iterator(static_cast< const infomap::InfoNode::post_depth_first_iterator& >(result))), SWIGTYPE_p_DepthFirstIteratorT_infomap__InfoNode_p_false_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_begin_leaf_nodes ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< LeafNodeIterator< infomap::InfoNode * > > result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_begin_leaf_nodes" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (*arg1)->begin_leaf_nodes();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::leaf_node_iterator(static_cast< const infomap::InfoNode::leaf_node_iterator& >(result))), SWIGTYPE_p_LeafNodeIteratorT_infomap__InfoNode_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_begin_leaf_modules ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< LeafModuleIterator< infomap::InfoNode * > > result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_begin_leaf_modules" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (*arg1)->begin_leaf_modules();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::leaf_module_iterator(static_cast< const infomap::InfoNode::leaf_module_iterator& >(result))), SWIGTYPE_p_LeafModuleIteratorT_infomap__InfoNode_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_begin_tree__SWIG_0 ( SEXP self, SEXP maxClusterLevel, SEXP s_swig_copy)
{
  SwigValueWrapper< TreeIterator< infomap::InfoNode * > > result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_begin_tree" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  ecode2 = SWIG_AsVal_int(maxClusterLevel, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapIterator_begin_tree" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (*arg1)->begin_tree(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::tree_iterator(static_cast< const infomap::InfoNode::tree_iterator& >(result))), SWIGTYPE_p_TreeIteratorT_infomap__InfoNode_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_begin_tree__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< TreeIterator< infomap::InfoNode * > > result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_begin_tree" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (*arg1)->begin_tree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::tree_iterator(static_cast< const infomap::InfoNode::tree_iterator& >(result))), SWIGTYPE_p_TreeIteratorT_infomap__InfoNode_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_begin_tree__SWIG_2 ( SEXP self, SEXP maxClusterLevel, SEXP s_swig_copy)
{
  SwigValueWrapper< TreeIterator< infomap::InfoNode const * > > result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_begin_tree" "', argument " "1"" of type '" "infomap::InfomapIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  ecode2 = SWIG_AsVal_int(maxClusterLevel, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapIterator_begin_tree" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (*((infomap::InfomapIterator const *)arg1))->begin_tree(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::const_tree_iterator(static_cast< const infomap::InfoNode::const_tree_iterator& >(result))), SWIGTYPE_p_TreeIteratorT_infomap__InfoNode_const_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_begin_tree__SWIG_3 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< TreeIterator< infomap::InfoNode const * > > result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_begin_tree" "', argument " "1"" of type '" "infomap::InfomapIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (*((infomap::InfomapIterator const *)arg1))->begin_tree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::const_tree_iterator(static_cast< const infomap::InfoNode::const_tree_iterator& >(result))), SWIGTYPE_p_TreeIteratorT_infomap__InfoNode_const_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_end_tree__SWIG_0 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< TreeIterator< infomap::InfoNode * > > result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_end_tree" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (*arg1)->end_tree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::tree_iterator(static_cast< const infomap::InfoNode::tree_iterator& >(result))), SWIGTYPE_p_TreeIteratorT_infomap__InfoNode_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_end_tree__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< TreeIterator< infomap::InfoNode const * > > result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_end_tree" "', argument " "1"" of type '" "infomap::InfomapIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (*((infomap::InfomapIterator const *)arg1))->end_tree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::const_tree_iterator(static_cast< const infomap::InfoNode::const_tree_iterator& >(result))), SWIGTYPE_p_TreeIteratorT_infomap__InfoNode_const_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_infomapTree__SWIG_0 ( SEXP self, SEXP maxClusterLevel, SEXP s_swig_copy)
{
  SwigValueWrapper< IterWrapper< TreeIterator< infomap::InfoNode * > > > result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_infomapTree" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  ecode2 = SWIG_AsVal_int(maxClusterLevel, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapIterator_infomapTree" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (*arg1)->infomapTree(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::infomap_iterator_wrapper(static_cast< const infomap::InfoNode::infomap_iterator_wrapper& >(result))), SWIGTYPE_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_p_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_infomapTree__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< IterWrapper< TreeIterator< infomap::InfoNode * > > > result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_infomapTree" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (*arg1)->infomapTree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::infomap_iterator_wrapper(static_cast< const infomap::InfoNode::infomap_iterator_wrapper& >(result))), SWIGTYPE_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_p_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_infomapTree__SWIG_2 ( SEXP self, SEXP maxClusterLevel, SEXP s_swig_copy)
{
  SwigValueWrapper< IterWrapper< TreeIterator< infomap::InfoNode const * > > > result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_infomapTree" "', argument " "1"" of type '" "infomap::InfomapIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  ecode2 = SWIG_AsVal_int(maxClusterLevel, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapIterator_infomapTree" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (*((infomap::InfomapIterator const *)arg1))->infomapTree(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::const_infomap_iterator_wrapper(static_cast< const infomap::InfoNode::const_infomap_iterator_wrapper& >(result))), SWIGTYPE_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_const_p_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_infomapTree__SWIG_3 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< IterWrapper< TreeIterator< infomap::InfoNode const * > > > result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_infomapTree" "', argument " "1"" of type '" "infomap::InfomapIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (*((infomap::InfomapIterator const *)arg1))->infomapTree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::const_infomap_iterator_wrapper(static_cast< const infomap::InfoNode::const_infomap_iterator_wrapper& >(result))), SWIGTYPE_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_const_p_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_begin_outEdge ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< std::vector< Edge< infomap::InfoNode > *,std::allocator< Edge< infomap::InfoNode > * > >::iterator > result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_begin_outEdge" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (*arg1)->begin_outEdge();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::edge_iterator(static_cast< const infomap::InfoNode::edge_iterator& >(result))), SWIGTYPE_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_end_outEdge ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< std::vector< Edge< infomap::InfoNode > *,std::allocator< Edge< infomap::InfoNode > * > >::iterator > result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_end_outEdge" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (*arg1)->end_outEdge();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::edge_iterator(static_cast< const infomap::InfoNode::edge_iterator& >(result))), SWIGTYPE_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_begin_inEdge ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< std::vector< Edge< infomap::InfoNode > *,std::allocator< Edge< infomap::InfoNode > * > >::iterator > result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_begin_inEdge" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (*arg1)->begin_inEdge();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::edge_iterator(static_cast< const infomap::InfoNode::edge_iterator& >(result))), SWIGTYPE_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_end_inEdge ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< std::vector< Edge< infomap::InfoNode > *,std::allocator< Edge< infomap::InfoNode > * > >::iterator > result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_end_inEdge" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (*arg1)->end_inEdge();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::edge_iterator(static_cast< const infomap::InfoNode::edge_iterator& >(result))), SWIGTYPE_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_outEdges ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< IterWrapper< std::vector< Edge< infomap::InfoNode > *,std::allocator< Edge< infomap::InfoNode > * > >::iterator > > result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_outEdges" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (*arg1)->outEdges();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::edge_iterator_wrapper(static_cast< const infomap::InfoNode::edge_iterator_wrapper& >(result))), SWIGTYPE_p_IterWrapperT_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_inEdges ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< IterWrapper< std::vector< Edge< infomap::InfoNode > *,std::allocator< Edge< infomap::InfoNode > * > >::iterator > > result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_inEdges" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (*arg1)->inEdges();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::edge_iterator_wrapper(static_cast< const infomap::InfoNode::edge_iterator_wrapper& >(result))), SWIGTYPE_p_IterWrapperT_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_childDegree ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_childDegree" "', argument " "1"" of type '" "infomap::InfomapIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (unsigned int)(*((infomap::InfomapIterator const *)arg1))->childDegree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_isLeaf ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_isLeaf" "', argument " "1"" of type '" "infomap::InfomapIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (bool)(*((infomap::InfomapIterator const *)arg1))->isLeaf();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_isLeafModule ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_isLeafModule" "', argument " "1"" of type '" "infomap::InfomapIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (bool)(*((infomap::InfomapIterator const *)arg1))->isLeafModule();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_isRoot ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_isRoot" "', argument " "1"" of type '" "infomap::InfomapIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (bool)(*((infomap::InfomapIterator const *)arg1))->isRoot();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_firstDepthBelow ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_firstDepthBelow" "', argument " "1"" of type '" "infomap::InfomapIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (unsigned int)(*((infomap::InfomapIterator const *)arg1))->firstDepthBelow();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_numLeafMembers ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_numLeafMembers" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (unsigned int)(*arg1)->numLeafMembers();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_isDangling ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_isDangling" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (bool)(*arg1)->isDangling();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_outDegree ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_outDegree" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (unsigned int)(*arg1)->outDegree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_inDegree ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_inDegree" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (unsigned int)(*arg1)->inDegree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_degree ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_degree" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (unsigned int)(*arg1)->degree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_isFirst ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_isFirst" "', argument " "1"" of type '" "infomap::InfomapIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (bool)(*((infomap::InfomapIterator const *)arg1))->isFirst();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_isLast ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_isLast" "', argument " "1"" of type '" "infomap::InfomapIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (bool)(*((infomap::InfomapIterator const *)arg1))->isLast();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_calculatePath ( SEXP self, SEXP s_swig_copy)
{
  std::vector< unsigned int,std::allocator< unsigned int > > result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_calculatePath" "', argument " "1"" of type '" "infomap::InfomapIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (*((infomap::InfomapIterator const *)arg1))->calculatePath();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = swig::from(static_cast< std::vector< unsigned int,std::allocator< unsigned int > > >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_infomapChildDegree ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_infomapChildDegree" "', argument " "1"" of type '" "infomap::InfomapIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (unsigned int)(*((infomap::InfomapIterator const *)arg1))->infomapChildDegree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_id ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_id" "', argument " "1"" of type '" "infomap::InfomapIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (unsigned int)(*((infomap::InfomapIterator const *)arg1))->id();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_initClean ( SEXP self)
{
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_initClean" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      (*arg1)->initClean();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_sortChildrenOnFlow__SWIG_0 ( SEXP self, SEXP recurse)
{
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_sortChildrenOnFlow" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  arg2 = LOGICAL(recurse)[0] ? true : false;
  {
    try {
      (*arg1)->sortChildrenOnFlow(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_sortChildrenOnFlow__SWIG_1 ( SEXP self)
{
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_sortChildrenOnFlow" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      (*arg1)->sortChildrenOnFlow();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_collapseChildren ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_collapseChildren" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (unsigned int)(*arg1)->collapseChildren();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_expandChildren ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_expandChildren" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (unsigned int)(*arg1)->expandChildren();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_setChildDegree ( SEXP self, SEXP value)
{
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_setChildDegree" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  ecode2 = SWIG_AsVal_int(value, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapIterator_setChildDegree" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      (*arg1)->setChildDegree(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_setNumLeafNodes ( SEXP self, SEXP value)
{
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_setNumLeafNodes" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  ecode2 = SWIG_AsVal_int(value, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapIterator_setNumLeafNodes" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      (*arg1)->setNumLeafNodes(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_addChild ( SEXP self, SEXP child)
{
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  infomap::InfoNode *arg2 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_addChild" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(child, &argp2, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapIterator_addChild" "', argument " "2"" of type '" "infomap::InfoNode *""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  {
    try {
      (*arg1)->addChild(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_releaseChildren ( SEXP self)
{
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_releaseChildren" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      (*arg1)->releaseChildren();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_replaceChildrenWithOneNode ( SEXP self, SEXP s_swig_copy)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_replaceChildrenWithOneNode" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (infomap::InfoNode *) &(*arg1)->replaceChildrenWithOneNode();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_replaceWithChildren ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_replaceWithChildren" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (unsigned int)(*arg1)->replaceWithChildren();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_replaceWithChildrenDebug ( SEXP self)
{
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_replaceWithChildrenDebug" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      (*arg1)->replaceWithChildrenDebug();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_replaceChildrenWithGrandChildren ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_replaceChildrenWithGrandChildren" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (unsigned int)(*arg1)->replaceChildrenWithGrandChildren();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_replaceChildrenWithGrandChildrenDebug ( SEXP self)
{
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_replaceChildrenWithGrandChildrenDebug" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      (*arg1)->replaceChildrenWithGrandChildrenDebug();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_remove ( SEXP self, SEXP removeChildren)
{
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_remove" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  arg2 = LOGICAL(removeChildren)[0] ? true : false;
  {
    try {
      (*arg1)->remove(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_deleteChildren ( SEXP self)
{
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_deleteChildren" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      (*arg1)->deleteChildren();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_addOutEdge__SWIG_0 ( SEXP self, SEXP target, SEXP weight, SEXP flow)
{
  infomap::InfoNode::EdgeType *result = 0 ;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_addOutEdge" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(target, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapIterator_addOutEdge" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapIterator_addOutEdge" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  arg3 = static_cast< double >(REAL(weight)[0]);
  arg4 = static_cast< double >(REAL(flow)[0]);
  {
    try {
      result = (infomap::InfoNode::EdgeType *)(*arg1)->addOutEdge(*arg2,arg3,arg4);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EdgeT_infomap__InfoNode_t, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIterator_addOutEdge__SWIG_1 ( SEXP self, SEXP target, SEXP weight)
{
  infomap::InfoNode::EdgeType *result = 0 ;
  infomap::InfomapIterator *arg1 = (infomap::InfomapIterator *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIterator_addOutEdge" "', argument " "1"" of type '" "infomap::InfomapIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(target, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapIterator_addOutEdge" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapIterator_addOutEdge" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  arg3 = static_cast< double >(REAL(weight)[0]);
  {
    try {
      result = (infomap::InfoNode::EdgeType *)(*arg1)->addOutEdge(*arg2,arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EdgeT_infomap__InfoNode_t, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfomapModuleIterator__SWIG_0 ( )
{
  infomap::InfomapModuleIterator *result = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    try {
      result = (infomap::InfomapModuleIterator *)new infomap::InfomapModuleIterator();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapModuleIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfomapModuleIterator__SWIG_1 ( SEXP nodePointer, SEXP moduleIndexLevel)
{
  infomap::InfomapModuleIterator *result = 0 ;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(nodePointer, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InfomapModuleIterator" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  arg2 = static_cast< int >(INTEGER(moduleIndexLevel)[0]);
  {
    try {
      result = (infomap::InfomapModuleIterator *)new infomap::InfomapModuleIterator(arg1,arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapModuleIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfomapModuleIterator__SWIG_2 ( SEXP nodePointer)
{
  infomap::InfomapModuleIterator *result = 0 ;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(nodePointer, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InfomapModuleIterator" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (infomap::InfomapModuleIterator *)new infomap::InfomapModuleIterator(arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapModuleIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfomapModuleIterator__SWIG_3 ( SEXP other)
{
  infomap::InfomapModuleIterator *result = 0 ;
  infomap::InfomapModuleIterator *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(other, &argp1, SWIGTYPE_p_infomap__InfomapModuleIterator,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InfomapModuleIterator" "', argument " "1"" of type '" "infomap::InfomapModuleIterator const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InfomapModuleIterator" "', argument " "1"" of type '" "infomap::InfomapModuleIterator const &""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapModuleIterator * >(argp1);
  {
    try {
      result = (infomap::InfomapModuleIterator *)new infomap::InfomapModuleIterator((infomap::InfomapModuleIterator const &)*arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapModuleIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapModuleIterator_Equal ( SEXP self, SEXP other, SEXP s_swig_copy)
{
  infomap::InfomapModuleIterator *result = 0 ;
  infomap::InfomapModuleIterator *arg1 = (infomap::InfomapModuleIterator *) 0 ;
  infomap::InfomapModuleIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapModuleIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapModuleIterator_Equal" "', argument " "1"" of type '" "infomap::InfomapModuleIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapModuleIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(other, &argp2, SWIGTYPE_p_infomap__InfomapModuleIterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapModuleIterator_Equal" "', argument " "2"" of type '" "infomap::InfomapModuleIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapModuleIterator_Equal" "', argument " "2"" of type '" "infomap::InfomapModuleIterator const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfomapModuleIterator * >(argp2);
  {
    try {
      result = (infomap::InfomapModuleIterator *) &(arg1)->operator =((infomap::InfomapModuleIterator const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapModuleIterator, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapModuleIterator_PlusPlusPrefix ( SEXP self, SEXP s_swig_copy)
{
  infomap::InfomapIterator *result = 0 ;
  infomap::InfomapModuleIterator *arg1 = (infomap::InfomapModuleIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapModuleIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapModuleIterator_PlusPlusPrefix" "', argument " "1"" of type '" "infomap::InfomapModuleIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapModuleIterator * >(argp1);
  {
    try {
      result = (infomap::InfomapIterator *) &(arg1)->operator ++();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapModuleIterator_PlusPlusPostfix ( SEXP self, SEXP s_arg2, SEXP s_swig_copy)
{
  infomap::InfomapIterator result;
  infomap::InfomapModuleIterator *arg1 = (infomap::InfomapModuleIterator *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapModuleIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapModuleIterator_PlusPlusPostfix" "', argument " "1"" of type '" "infomap::InfomapModuleIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapModuleIterator * >(argp1);
  arg2 = static_cast< int >(INTEGER(s_arg2)[0]);
  {
    try {
      result = (arg1)->operator ++(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfomapIterator(static_cast< const infomap::InfomapIterator& >(result))), SWIGTYPE_p_infomap__InfomapIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapModuleIterator_childIndex ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapModuleIterator *arg1 = (infomap::InfomapModuleIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapModuleIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapModuleIterator_childIndex" "', argument " "1"" of type '" "infomap::InfomapModuleIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapModuleIterator * >(argp1);
  {
    try {
      result = (unsigned int)((infomap::InfomapModuleIterator const *)arg1)->childIndex();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapModuleIterator_current_SWIG_0_0 ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapModuleIterator *arg1 = (infomap::InfomapModuleIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapModuleIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapModuleIterator_current" "', argument " "1"" of type '" "infomap::InfomapModuleIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapModuleIterator * >(argp1);
  {
    try {
      result = (infomap::InfoNode *)(arg1)->current();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapModuleIterator_current_SWIG_0_1 ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapModuleIterator *arg1 = (infomap::InfomapModuleIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapModuleIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapModuleIterator_current" "', argument " "1"" of type '" "infomap::InfomapModuleIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapModuleIterator * >(argp1);
  {
    try {
      result = (infomap::InfoNode *)((infomap::InfomapModuleIterator const *)arg1)->current();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapModuleIterator_depth ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapModuleIterator *arg1 = (infomap::InfomapModuleIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapModuleIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapModuleIterator_depth" "', argument " "1"" of type '" "infomap::InfomapModuleIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapModuleIterator * >(argp1);
  {
    try {
      result = (unsigned int)((infomap::InfomapModuleIterator const *)arg1)->depth();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapModuleIterator_path ( SEXP self, SEXP s_swig_copy)
{
  std::deque< unsigned int,std::allocator< unsigned int > > *result = 0 ;
  infomap::InfomapModuleIterator *arg1 = (infomap::InfomapModuleIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapModuleIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapModuleIterator_path" "', argument " "1"" of type '" "infomap::InfomapModuleIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapModuleIterator * >(argp1);
  {
    try {
      result = (std::deque< unsigned int,std::allocator< unsigned int > > *) &((infomap::InfomapModuleIterator const *)arg1)->path();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = swig::from(static_cast< std::deque< unsigned int,std::allocator< unsigned int > > >(*result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_InfomapModuleIterator ( SEXP self)
{
  infomap::InfomapModuleIterator *arg1 = (infomap::InfomapModuleIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapModuleIterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_InfomapModuleIterator" "', argument " "1"" of type '" "infomap::InfomapModuleIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapModuleIterator * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfomapLeafModuleIterator__SWIG_0 ( )
{
  infomap::InfomapLeafModuleIterator *result = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    try {
      result = (infomap::InfomapLeafModuleIterator *)new infomap::InfomapLeafModuleIterator();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapLeafModuleIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfomapLeafModuleIterator__SWIG_1 ( SEXP nodePointer, SEXP moduleIndexLevel)
{
  infomap::InfomapLeafModuleIterator *result = 0 ;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(nodePointer, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InfomapLeafModuleIterator" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  arg2 = static_cast< int >(INTEGER(moduleIndexLevel)[0]);
  {
    try {
      result = (infomap::InfomapLeafModuleIterator *)new infomap::InfomapLeafModuleIterator(arg1,arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapLeafModuleIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfomapLeafModuleIterator__SWIG_2 ( SEXP nodePointer)
{
  infomap::InfomapLeafModuleIterator *result = 0 ;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(nodePointer, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InfomapLeafModuleIterator" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (infomap::InfomapLeafModuleIterator *)new infomap::InfomapLeafModuleIterator(arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapLeafModuleIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfomapLeafModuleIterator__SWIG_3 ( SEXP other)
{
  infomap::InfomapLeafModuleIterator *result = 0 ;
  infomap::InfomapLeafModuleIterator *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(other, &argp1, SWIGTYPE_p_infomap__InfomapLeafModuleIterator,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InfomapLeafModuleIterator" "', argument " "1"" of type '" "infomap::InfomapLeafModuleIterator const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InfomapLeafModuleIterator" "', argument " "1"" of type '" "infomap::InfomapLeafModuleIterator const &""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapLeafModuleIterator * >(argp1);
  {
    try {
      result = (infomap::InfomapLeafModuleIterator *)new infomap::InfomapLeafModuleIterator((infomap::InfomapLeafModuleIterator const &)*arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapLeafModuleIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapLeafModuleIterator_Equal ( SEXP self, SEXP other, SEXP s_swig_copy)
{
  infomap::InfomapLeafModuleIterator *result = 0 ;
  infomap::InfomapLeafModuleIterator *arg1 = (infomap::InfomapLeafModuleIterator *) 0 ;
  infomap::InfomapLeafModuleIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapLeafModuleIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapLeafModuleIterator_Equal" "', argument " "1"" of type '" "infomap::InfomapLeafModuleIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapLeafModuleIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(other, &argp2, SWIGTYPE_p_infomap__InfomapLeafModuleIterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapLeafModuleIterator_Equal" "', argument " "2"" of type '" "infomap::InfomapLeafModuleIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapLeafModuleIterator_Equal" "', argument " "2"" of type '" "infomap::InfomapLeafModuleIterator const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfomapLeafModuleIterator * >(argp2);
  {
    try {
      result = (infomap::InfomapLeafModuleIterator *) &(arg1)->operator =((infomap::InfomapLeafModuleIterator const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapLeafModuleIterator, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapLeafModuleIterator_init ( SEXP self)
{
  infomap::InfomapLeafModuleIterator *arg1 = (infomap::InfomapLeafModuleIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapLeafModuleIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapLeafModuleIterator_init" "', argument " "1"" of type '" "infomap::InfomapLeafModuleIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapLeafModuleIterator * >(argp1);
  {
    try {
      (arg1)->init();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapLeafModuleIterator_PlusPlusPrefix ( SEXP self, SEXP s_swig_copy)
{
  infomap::InfomapIterator *result = 0 ;
  infomap::InfomapLeafModuleIterator *arg1 = (infomap::InfomapLeafModuleIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapLeafModuleIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapLeafModuleIterator_PlusPlusPrefix" "', argument " "1"" of type '" "infomap::InfomapLeafModuleIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapLeafModuleIterator * >(argp1);
  {
    try {
      result = (infomap::InfomapIterator *) &(arg1)->operator ++();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapLeafModuleIterator_PlusPlusPostfix ( SEXP self, SEXP s_arg2, SEXP s_swig_copy)
{
  infomap::InfomapIterator result;
  infomap::InfomapLeafModuleIterator *arg1 = (infomap::InfomapLeafModuleIterator *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapLeafModuleIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapLeafModuleIterator_PlusPlusPostfix" "', argument " "1"" of type '" "infomap::InfomapLeafModuleIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapLeafModuleIterator * >(argp1);
  arg2 = static_cast< int >(INTEGER(s_arg2)[0]);
  {
    try {
      result = (arg1)->operator ++(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfomapIterator(static_cast< const infomap::InfomapIterator& >(result))), SWIGTYPE_p_infomap__InfomapIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapLeafModuleIterator_childIndex ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapLeafModuleIterator *arg1 = (infomap::InfomapLeafModuleIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapLeafModuleIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapLeafModuleIterator_childIndex" "', argument " "1"" of type '" "infomap::InfomapLeafModuleIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapLeafModuleIterator * >(argp1);
  {
    try {
      result = (unsigned int)((infomap::InfomapLeafModuleIterator const *)arg1)->childIndex();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapLeafModuleIterator_current_SWIG_0_0 ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapLeafModuleIterator *arg1 = (infomap::InfomapLeafModuleIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapLeafModuleIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapLeafModuleIterator_current" "', argument " "1"" of type '" "infomap::InfomapLeafModuleIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapLeafModuleIterator * >(argp1);
  {
    try {
      result = (infomap::InfoNode *)(arg1)->current();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapLeafModuleIterator_current_SWIG_0_1 ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapLeafModuleIterator *arg1 = (infomap::InfomapLeafModuleIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapLeafModuleIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapLeafModuleIterator_current" "', argument " "1"" of type '" "infomap::InfomapLeafModuleIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapLeafModuleIterator * >(argp1);
  {
    try {
      result = (infomap::InfoNode *)((infomap::InfomapLeafModuleIterator const *)arg1)->current();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapLeafModuleIterator_depth ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapLeafModuleIterator *arg1 = (infomap::InfomapLeafModuleIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapLeafModuleIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapLeafModuleIterator_depth" "', argument " "1"" of type '" "infomap::InfomapLeafModuleIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapLeafModuleIterator * >(argp1);
  {
    try {
      result = (unsigned int)((infomap::InfomapLeafModuleIterator const *)arg1)->depth();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapLeafModuleIterator_path ( SEXP self, SEXP s_swig_copy)
{
  std::deque< unsigned int,std::allocator< unsigned int > > *result = 0 ;
  infomap::InfomapLeafModuleIterator *arg1 = (infomap::InfomapLeafModuleIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapLeafModuleIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapLeafModuleIterator_path" "', argument " "1"" of type '" "infomap::InfomapLeafModuleIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapLeafModuleIterator * >(argp1);
  {
    try {
      result = (std::deque< unsigned int,std::allocator< unsigned int > > *) &((infomap::InfomapLeafModuleIterator const *)arg1)->path();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = swig::from(static_cast< std::deque< unsigned int,std::allocator< unsigned int > > >(*result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_InfomapLeafModuleIterator ( SEXP self)
{
  infomap::InfomapLeafModuleIterator *arg1 = (infomap::InfomapLeafModuleIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapLeafModuleIterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_InfomapLeafModuleIterator" "', argument " "1"" of type '" "infomap::InfomapLeafModuleIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapLeafModuleIterator * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfomapLeafIterator__SWIG_0 ( )
{
  infomap::InfomapLeafIterator *result = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    try {
      result = (infomap::InfomapLeafIterator *)new infomap::InfomapLeafIterator();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapLeafIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfomapLeafIterator__SWIG_1 ( SEXP nodePointer, SEXP moduleIndexLevel)
{
  infomap::InfomapLeafIterator *result = 0 ;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(nodePointer, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InfomapLeafIterator" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  arg2 = static_cast< int >(INTEGER(moduleIndexLevel)[0]);
  {
    try {
      result = (infomap::InfomapLeafIterator *)new infomap::InfomapLeafIterator(arg1,arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapLeafIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfomapLeafIterator__SWIG_2 ( SEXP nodePointer)
{
  infomap::InfomapLeafIterator *result = 0 ;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(nodePointer, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InfomapLeafIterator" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (infomap::InfomapLeafIterator *)new infomap::InfomapLeafIterator(arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapLeafIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfomapLeafIterator__SWIG_3 ( SEXP other)
{
  infomap::InfomapLeafIterator *result = 0 ;
  infomap::InfomapLeafIterator *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(other, &argp1, SWIGTYPE_p_infomap__InfomapLeafIterator,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InfomapLeafIterator" "', argument " "1"" of type '" "infomap::InfomapLeafIterator const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InfomapLeafIterator" "', argument " "1"" of type '" "infomap::InfomapLeafIterator const &""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapLeafIterator * >(argp1);
  {
    try {
      result = (infomap::InfomapLeafIterator *)new infomap::InfomapLeafIterator((infomap::InfomapLeafIterator const &)*arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapLeafIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapLeafIterator_Equal ( SEXP self, SEXP other, SEXP s_swig_copy)
{
  infomap::InfomapLeafIterator *result = 0 ;
  infomap::InfomapLeafIterator *arg1 = (infomap::InfomapLeafIterator *) 0 ;
  infomap::InfomapLeafIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapLeafIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapLeafIterator_Equal" "', argument " "1"" of type '" "infomap::InfomapLeafIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapLeafIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(other, &argp2, SWIGTYPE_p_infomap__InfomapLeafIterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapLeafIterator_Equal" "', argument " "2"" of type '" "infomap::InfomapLeafIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapLeafIterator_Equal" "', argument " "2"" of type '" "infomap::InfomapLeafIterator const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfomapLeafIterator * >(argp2);
  {
    try {
      result = (infomap::InfomapLeafIterator *) &(arg1)->operator =((infomap::InfomapLeafIterator const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapLeafIterator, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapLeafIterator_init ( SEXP self)
{
  infomap::InfomapLeafIterator *arg1 = (infomap::InfomapLeafIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapLeafIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapLeafIterator_init" "', argument " "1"" of type '" "infomap::InfomapLeafIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapLeafIterator * >(argp1);
  {
    try {
      (arg1)->init();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapLeafIterator_PlusPlusPrefix ( SEXP self, SEXP s_swig_copy)
{
  infomap::InfomapIterator *result = 0 ;
  infomap::InfomapLeafIterator *arg1 = (infomap::InfomapLeafIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapLeafIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapLeafIterator_PlusPlusPrefix" "', argument " "1"" of type '" "infomap::InfomapLeafIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapLeafIterator * >(argp1);
  {
    try {
      result = (infomap::InfomapIterator *) &(arg1)->operator ++();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapLeafIterator_PlusPlusPostfix ( SEXP self, SEXP s_arg2, SEXP s_swig_copy)
{
  infomap::InfomapIterator result;
  infomap::InfomapLeafIterator *arg1 = (infomap::InfomapLeafIterator *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapLeafIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapLeafIterator_PlusPlusPostfix" "', argument " "1"" of type '" "infomap::InfomapLeafIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapLeafIterator * >(argp1);
  arg2 = static_cast< int >(INTEGER(s_arg2)[0]);
  {
    try {
      result = (arg1)->operator ++(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfomapIterator(static_cast< const infomap::InfomapIterator& >(result))), SWIGTYPE_p_infomap__InfomapIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapLeafIterator_childIndex ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapLeafIterator *arg1 = (infomap::InfomapLeafIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapLeafIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapLeafIterator_childIndex" "', argument " "1"" of type '" "infomap::InfomapLeafIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapLeafIterator * >(argp1);
  {
    try {
      result = (unsigned int)((infomap::InfomapLeafIterator const *)arg1)->childIndex();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapLeafIterator_current_SWIG_0_0 ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapLeafIterator *arg1 = (infomap::InfomapLeafIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapLeafIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapLeafIterator_current" "', argument " "1"" of type '" "infomap::InfomapLeafIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapLeafIterator * >(argp1);
  {
    try {
      result = (infomap::InfoNode *)(arg1)->current();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapLeafIterator_current_SWIG_0_1 ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapLeafIterator *arg1 = (infomap::InfomapLeafIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapLeafIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapLeafIterator_current" "', argument " "1"" of type '" "infomap::InfomapLeafIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapLeafIterator * >(argp1);
  {
    try {
      result = (infomap::InfoNode *)((infomap::InfomapLeafIterator const *)arg1)->current();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapLeafIterator_depth ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapLeafIterator *arg1 = (infomap::InfomapLeafIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapLeafIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapLeafIterator_depth" "', argument " "1"" of type '" "infomap::InfomapLeafIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapLeafIterator * >(argp1);
  {
    try {
      result = (unsigned int)((infomap::InfomapLeafIterator const *)arg1)->depth();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapLeafIterator_path ( SEXP self, SEXP s_swig_copy)
{
  std::deque< unsigned int,std::allocator< unsigned int > > *result = 0 ;
  infomap::InfomapLeafIterator *arg1 = (infomap::InfomapLeafIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapLeafIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapLeafIterator_path" "', argument " "1"" of type '" "infomap::InfomapLeafIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapLeafIterator * >(argp1);
  {
    try {
      result = (std::deque< unsigned int,std::allocator< unsigned int > > *) &((infomap::InfomapLeafIterator const *)arg1)->path();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = swig::from(static_cast< std::deque< unsigned int,std::allocator< unsigned int > > >(*result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_InfomapLeafIterator ( SEXP self)
{
  infomap::InfomapLeafIterator *arg1 = (infomap::InfomapLeafIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapLeafIterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_InfomapLeafIterator" "', argument " "1"" of type '" "infomap::InfomapLeafIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapLeafIterator * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfomapIteratorPhysical__SWIG_0 ( )
{
  infomap::InfomapIteratorPhysical *result = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    try {
      result = (infomap::InfomapIteratorPhysical *)new infomap::InfomapIteratorPhysical();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapIteratorPhysical, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfomapIteratorPhysical__SWIG_1 ( SEXP nodePointer, SEXP moduleIndexLevel)
{
  infomap::InfomapIteratorPhysical *result = 0 ;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(nodePointer, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InfomapIteratorPhysical" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  arg2 = static_cast< int >(INTEGER(moduleIndexLevel)[0]);
  {
    try {
      result = (infomap::InfomapIteratorPhysical *)new infomap::InfomapIteratorPhysical(arg1,arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapIteratorPhysical, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfomapIteratorPhysical__SWIG_2 ( SEXP nodePointer)
{
  infomap::InfomapIteratorPhysical *result = 0 ;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(nodePointer, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InfomapIteratorPhysical" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (infomap::InfomapIteratorPhysical *)new infomap::InfomapIteratorPhysical(arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapIteratorPhysical, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfomapIteratorPhysical__SWIG_3 ( SEXP other)
{
  infomap::InfomapIteratorPhysical *result = 0 ;
  infomap::InfomapIteratorPhysical *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(other, &argp1, SWIGTYPE_p_infomap__InfomapIteratorPhysical,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InfomapIteratorPhysical" "', argument " "1"" of type '" "infomap::InfomapIteratorPhysical const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InfomapIteratorPhysical" "', argument " "1"" of type '" "infomap::InfomapIteratorPhysical const &""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIteratorPhysical * >(argp1);
  {
    try {
      result = (infomap::InfomapIteratorPhysical *)new infomap::InfomapIteratorPhysical((infomap::InfomapIteratorPhysical const &)*arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapIteratorPhysical, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfomapIteratorPhysical__SWIG_4 ( SEXP other)
{
  infomap::InfomapIteratorPhysical *result = 0 ;
  infomap::InfomapIterator *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(other, &argp1, SWIGTYPE_p_infomap__InfomapIterator,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InfomapIteratorPhysical" "', argument " "1"" of type '" "infomap::InfomapIterator const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InfomapIteratorPhysical" "', argument " "1"" of type '" "infomap::InfomapIterator const &""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIterator * >(argp1);
  {
    try {
      result = (infomap::InfomapIteratorPhysical *)new infomap::InfomapIteratorPhysical((infomap::InfomapIterator const &)*arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapIteratorPhysical, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIteratorPhysical_Equal__SWIG_0 ( SEXP self, SEXP other, SEXP s_swig_copy)
{
  infomap::InfomapIteratorPhysical *result = 0 ;
  infomap::InfomapIteratorPhysical *arg1 = (infomap::InfomapIteratorPhysical *) 0 ;
  infomap::InfomapIteratorPhysical *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIteratorPhysical, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIteratorPhysical_Equal" "', argument " "1"" of type '" "infomap::InfomapIteratorPhysical *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIteratorPhysical * >(argp1);
  res2 = SWIG_R_ConvertPtr(other, &argp2, SWIGTYPE_p_infomap__InfomapIteratorPhysical,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapIteratorPhysical_Equal" "', argument " "2"" of type '" "infomap::InfomapIteratorPhysical const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapIteratorPhysical_Equal" "', argument " "2"" of type '" "infomap::InfomapIteratorPhysical const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfomapIteratorPhysical * >(argp2);
  {
    try {
      result = (infomap::InfomapIteratorPhysical *) &(arg1)->operator =((infomap::InfomapIteratorPhysical const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapIteratorPhysical, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIteratorPhysical_Equal__SWIG_1 ( SEXP self, SEXP other, SEXP s_swig_copy)
{
  infomap::InfomapIteratorPhysical *result = 0 ;
  infomap::InfomapIteratorPhysical *arg1 = (infomap::InfomapIteratorPhysical *) 0 ;
  infomap::InfomapIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIteratorPhysical, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIteratorPhysical_Equal" "', argument " "1"" of type '" "infomap::InfomapIteratorPhysical *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIteratorPhysical * >(argp1);
  res2 = SWIG_R_ConvertPtr(other, &argp2, SWIGTYPE_p_infomap__InfomapIterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapIteratorPhysical_Equal" "', argument " "2"" of type '" "infomap::InfomapIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapIteratorPhysical_Equal" "', argument " "2"" of type '" "infomap::InfomapIterator const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfomapIterator * >(argp2);
  {
    try {
      result = (infomap::InfomapIteratorPhysical *) &(arg1)->operator =((infomap::InfomapIterator const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapIteratorPhysical, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIteratorPhysical_PlusPlusPrefix ( SEXP self, SEXP s_swig_copy)
{
  infomap::InfomapIterator *result = 0 ;
  infomap::InfomapIteratorPhysical *arg1 = (infomap::InfomapIteratorPhysical *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIteratorPhysical, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIteratorPhysical_PlusPlusPrefix" "', argument " "1"" of type '" "infomap::InfomapIteratorPhysical *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIteratorPhysical * >(argp1);
  {
    try {
      result = (infomap::InfomapIterator *) &(arg1)->operator ++();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIteratorPhysical_PlusPlusPostfix ( SEXP self, SEXP s_arg2, SEXP s_swig_copy)
{
  infomap::InfomapIterator result;
  infomap::InfomapIteratorPhysical *arg1 = (infomap::InfomapIteratorPhysical *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIteratorPhysical, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIteratorPhysical_PlusPlusPostfix" "', argument " "1"" of type '" "infomap::InfomapIteratorPhysical *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIteratorPhysical * >(argp1);
  arg2 = static_cast< int >(INTEGER(s_arg2)[0]);
  {
    try {
      result = (arg1)->operator ++(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfomapIterator(static_cast< const infomap::InfomapIterator& >(result))), SWIGTYPE_p_infomap__InfomapIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIteratorPhysical_childIndex ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapIteratorPhysical *arg1 = (infomap::InfomapIteratorPhysical *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIteratorPhysical, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIteratorPhysical_childIndex" "', argument " "1"" of type '" "infomap::InfomapIteratorPhysical const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIteratorPhysical * >(argp1);
  {
    try {
      result = (unsigned int)((infomap::InfomapIteratorPhysical const *)arg1)->childIndex();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIteratorPhysical_current_SWIG_0_0 ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapIteratorPhysical *arg1 = (infomap::InfomapIteratorPhysical *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIteratorPhysical, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIteratorPhysical_current" "', argument " "1"" of type '" "infomap::InfomapIteratorPhysical *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIteratorPhysical * >(argp1);
  {
    try {
      result = (infomap::InfoNode *)(arg1)->current();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIteratorPhysical_current_SWIG_0_1 ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapIteratorPhysical *arg1 = (infomap::InfomapIteratorPhysical *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIteratorPhysical, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIteratorPhysical_current" "', argument " "1"" of type '" "infomap::InfomapIteratorPhysical const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIteratorPhysical * >(argp1);
  {
    try {
      result = (infomap::InfoNode *)((infomap::InfomapIteratorPhysical const *)arg1)->current();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIteratorPhysical_depth ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapIteratorPhysical *arg1 = (infomap::InfomapIteratorPhysical *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIteratorPhysical, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIteratorPhysical_depth" "', argument " "1"" of type '" "infomap::InfomapIteratorPhysical const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIteratorPhysical * >(argp1);
  {
    try {
      result = (unsigned int)((infomap::InfomapIteratorPhysical const *)arg1)->depth();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapIteratorPhysical_path ( SEXP self, SEXP s_swig_copy)
{
  std::deque< unsigned int,std::allocator< unsigned int > > *result = 0 ;
  infomap::InfomapIteratorPhysical *arg1 = (infomap::InfomapIteratorPhysical *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIteratorPhysical, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapIteratorPhysical_path" "', argument " "1"" of type '" "infomap::InfomapIteratorPhysical const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIteratorPhysical * >(argp1);
  {
    try {
      result = (std::deque< unsigned int,std::allocator< unsigned int > > *) &((infomap::InfomapIteratorPhysical const *)arg1)->path();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = swig::from(static_cast< std::deque< unsigned int,std::allocator< unsigned int > > >(*result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_InfomapIteratorPhysical ( SEXP self)
{
  infomap::InfomapIteratorPhysical *arg1 = (infomap::InfomapIteratorPhysical *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapIteratorPhysical, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_InfomapIteratorPhysical" "', argument " "1"" of type '" "infomap::InfomapIteratorPhysical *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapIteratorPhysical * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfomapLeafIteratorPhysical__SWIG_0 ( )
{
  infomap::InfomapLeafIteratorPhysical *result = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    try {
      result = (infomap::InfomapLeafIteratorPhysical *)new infomap::InfomapLeafIteratorPhysical();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapLeafIteratorPhysical, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfomapLeafIteratorPhysical__SWIG_1 ( SEXP nodePointer, SEXP moduleIndexLevel)
{
  infomap::InfomapLeafIteratorPhysical *result = 0 ;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(nodePointer, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InfomapLeafIteratorPhysical" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  arg2 = static_cast< int >(INTEGER(moduleIndexLevel)[0]);
  {
    try {
      result = (infomap::InfomapLeafIteratorPhysical *)new infomap::InfomapLeafIteratorPhysical(arg1,arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapLeafIteratorPhysical, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfomapLeafIteratorPhysical__SWIG_2 ( SEXP nodePointer)
{
  infomap::InfomapLeafIteratorPhysical *result = 0 ;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(nodePointer, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InfomapLeafIteratorPhysical" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (infomap::InfomapLeafIteratorPhysical *)new infomap::InfomapLeafIteratorPhysical(arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapLeafIteratorPhysical, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfomapLeafIteratorPhysical__SWIG_3 ( SEXP other)
{
  infomap::InfomapLeafIteratorPhysical *result = 0 ;
  infomap::InfomapLeafIteratorPhysical *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(other, &argp1, SWIGTYPE_p_infomap__InfomapLeafIteratorPhysical,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InfomapLeafIteratorPhysical" "', argument " "1"" of type '" "infomap::InfomapLeafIteratorPhysical const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InfomapLeafIteratorPhysical" "', argument " "1"" of type '" "infomap::InfomapLeafIteratorPhysical const &""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapLeafIteratorPhysical * >(argp1);
  {
    try {
      result = (infomap::InfomapLeafIteratorPhysical *)new infomap::InfomapLeafIteratorPhysical((infomap::InfomapLeafIteratorPhysical const &)*arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapLeafIteratorPhysical, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapLeafIteratorPhysical_Equal ( SEXP self, SEXP other, SEXP s_swig_copy)
{
  infomap::InfomapLeafIteratorPhysical *result = 0 ;
  infomap::InfomapLeafIteratorPhysical *arg1 = (infomap::InfomapLeafIteratorPhysical *) 0 ;
  infomap::InfomapLeafIteratorPhysical *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapLeafIteratorPhysical, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapLeafIteratorPhysical_Equal" "', argument " "1"" of type '" "infomap::InfomapLeafIteratorPhysical *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapLeafIteratorPhysical * >(argp1);
  res2 = SWIG_R_ConvertPtr(other, &argp2, SWIGTYPE_p_infomap__InfomapLeafIteratorPhysical,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapLeafIteratorPhysical_Equal" "', argument " "2"" of type '" "infomap::InfomapLeafIteratorPhysical const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapLeafIteratorPhysical_Equal" "', argument " "2"" of type '" "infomap::InfomapLeafIteratorPhysical const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfomapLeafIteratorPhysical * >(argp2);
  {
    try {
      result = (infomap::InfomapLeafIteratorPhysical *) &(arg1)->operator =((infomap::InfomapLeafIteratorPhysical const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapLeafIteratorPhysical, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapLeafIteratorPhysical_init ( SEXP self)
{
  infomap::InfomapLeafIteratorPhysical *arg1 = (infomap::InfomapLeafIteratorPhysical *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapLeafIteratorPhysical, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapLeafIteratorPhysical_init" "', argument " "1"" of type '" "infomap::InfomapLeafIteratorPhysical *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapLeafIteratorPhysical * >(argp1);
  {
    try {
      (arg1)->init();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapLeafIteratorPhysical_PlusPlusPrefix ( SEXP self, SEXP s_swig_copy)
{
  infomap::InfomapIterator *result = 0 ;
  infomap::InfomapLeafIteratorPhysical *arg1 = (infomap::InfomapLeafIteratorPhysical *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapLeafIteratorPhysical, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapLeafIteratorPhysical_PlusPlusPrefix" "', argument " "1"" of type '" "infomap::InfomapLeafIteratorPhysical *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapLeafIteratorPhysical * >(argp1);
  {
    try {
      result = (infomap::InfomapIterator *) &(arg1)->operator ++();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapIterator, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapLeafIteratorPhysical_PlusPlusPostfix ( SEXP self, SEXP s_arg2, SEXP s_swig_copy)
{
  infomap::InfomapIterator result;
  infomap::InfomapLeafIteratorPhysical *arg1 = (infomap::InfomapLeafIteratorPhysical *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapLeafIteratorPhysical, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapLeafIteratorPhysical_PlusPlusPostfix" "', argument " "1"" of type '" "infomap::InfomapLeafIteratorPhysical *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapLeafIteratorPhysical * >(argp1);
  arg2 = static_cast< int >(INTEGER(s_arg2)[0]);
  {
    try {
      result = (arg1)->operator ++(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfomapIterator(static_cast< const infomap::InfomapIterator& >(result))), SWIGTYPE_p_infomap__InfomapIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapLeafIteratorPhysical_childIndex ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapLeafIteratorPhysical *arg1 = (infomap::InfomapLeafIteratorPhysical *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapLeafIteratorPhysical, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapLeafIteratorPhysical_childIndex" "', argument " "1"" of type '" "infomap::InfomapLeafIteratorPhysical const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapLeafIteratorPhysical * >(argp1);
  {
    try {
      result = (unsigned int)((infomap::InfomapLeafIteratorPhysical const *)arg1)->childIndex();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapLeafIteratorPhysical_current_SWIG_0_0 ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapLeafIteratorPhysical *arg1 = (infomap::InfomapLeafIteratorPhysical *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapLeafIteratorPhysical, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapLeafIteratorPhysical_current" "', argument " "1"" of type '" "infomap::InfomapLeafIteratorPhysical *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapLeafIteratorPhysical * >(argp1);
  {
    try {
      result = (infomap::InfoNode *)(arg1)->current();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapLeafIteratorPhysical_current_SWIG_0_1 ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapLeafIteratorPhysical *arg1 = (infomap::InfomapLeafIteratorPhysical *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapLeafIteratorPhysical, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapLeafIteratorPhysical_current" "', argument " "1"" of type '" "infomap::InfomapLeafIteratorPhysical const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapLeafIteratorPhysical * >(argp1);
  {
    try {
      result = (infomap::InfoNode *)((infomap::InfomapLeafIteratorPhysical const *)arg1)->current();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapLeafIteratorPhysical_depth ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapLeafIteratorPhysical *arg1 = (infomap::InfomapLeafIteratorPhysical *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapLeafIteratorPhysical, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapLeafIteratorPhysical_depth" "', argument " "1"" of type '" "infomap::InfomapLeafIteratorPhysical const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapLeafIteratorPhysical * >(argp1);
  {
    try {
      result = (unsigned int)((infomap::InfomapLeafIteratorPhysical const *)arg1)->depth();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapLeafIteratorPhysical_path ( SEXP self, SEXP s_swig_copy)
{
  std::deque< unsigned int,std::allocator< unsigned int > > *result = 0 ;
  infomap::InfomapLeafIteratorPhysical *arg1 = (infomap::InfomapLeafIteratorPhysical *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapLeafIteratorPhysical, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapLeafIteratorPhysical_path" "', argument " "1"" of type '" "infomap::InfomapLeafIteratorPhysical const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapLeafIteratorPhysical * >(argp1);
  {
    try {
      result = (std::deque< unsigned int,std::allocator< unsigned int > > *) &((infomap::InfomapLeafIteratorPhysical const *)arg1)->path();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = swig::from(static_cast< std::deque< unsigned int,std::allocator< unsigned int > > >(*result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_InfomapLeafIteratorPhysical ( SEXP self)
{
  infomap::InfomapLeafIteratorPhysical *arg1 = (infomap::InfomapLeafIteratorPhysical *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapLeafIteratorPhysical, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_InfomapLeafIteratorPhysical" "', argument " "1"" of type '" "infomap::InfomapLeafIteratorPhysical *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapLeafIteratorPhysical * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfomapParentIterator__SWIG_0 ( )
{
  infomap::InfomapParentIterator *result = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    try {
      result = (infomap::InfomapParentIterator *)new infomap::InfomapParentIterator();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapParentIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfomapParentIterator__SWIG_1 ( SEXP nodePointer)
{
  infomap::InfomapParentIterator *result = 0 ;
  infomap::InfoNode *arg1 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(nodePointer, &argp1, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InfomapParentIterator" "', argument " "1"" of type '" "infomap::InfoNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfoNode * >(argp1);
  {
    try {
      result = (infomap::InfomapParentIterator *)new infomap::InfomapParentIterator(arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapParentIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfomapParentIterator__SWIG_2 ( SEXP other)
{
  infomap::InfomapParentIterator *result = 0 ;
  infomap::InfomapParentIterator *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(other, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InfomapParentIterator" "', argument " "1"" of type '" "infomap::InfomapParentIterator const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InfomapParentIterator" "', argument " "1"" of type '" "infomap::InfomapParentIterator const &""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (infomap::InfomapParentIterator *)new infomap::InfomapParentIterator((infomap::InfomapParentIterator const &)*arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapParentIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_InfomapParentIterator ( SEXP self)
{
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_InfomapParentIterator" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_Equal ( SEXP self, SEXP other, SEXP s_swig_copy)
{
  infomap::InfomapParentIterator *result = 0 ;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  infomap::InfomapParentIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_Equal" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(other, &argp2, SWIGTYPE_p_infomap__InfomapParentIterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapParentIterator_Equal" "', argument " "2"" of type '" "infomap::InfomapParentIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapParentIterator_Equal" "', argument " "2"" of type '" "infomap::InfomapParentIterator const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfomapParentIterator * >(argp2);
  {
    try {
      result = (infomap::InfomapParentIterator *) &(arg1)->operator =((infomap::InfomapParentIterator const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_current__SWIG_0 ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_current" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (infomap::InfoNode *)(arg1)->current();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_current__SWIG_1 ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_current" "', argument " "1"" of type '" "infomap::InfomapParentIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (infomap::InfoNode *)((infomap::InfomapParentIterator const *)arg1)->current();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator___ref____SWIG_0 ( SEXP self, SEXP s_swig_copy)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator___ref__" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (infomap::InfoNode *) &(arg1)->operator *();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator___ref____SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator___ref__" "', argument " "1"" of type '" "infomap::InfomapParentIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (infomap::InfoNode *) &((infomap::InfomapParentIterator const *)arg1)->operator *();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator___deref____SWIG_0 ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator___deref__" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (infomap::InfoNode *)(arg1)->operator ->();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator___deref____SWIG_1 ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator___deref__" "', argument " "1"" of type '" "infomap::InfomapParentIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (infomap::InfoNode *)((infomap::InfomapParentIterator const *)arg1)->operator ->();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_EqualEqual ( SEXP self, SEXP other, SEXP s_swig_copy)
{
  bool result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  infomap::InfomapParentIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_EqualEqual" "', argument " "1"" of type '" "infomap::InfomapParentIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(other, &argp2, SWIGTYPE_p_infomap__InfomapParentIterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapParentIterator_EqualEqual" "', argument " "2"" of type '" "infomap::InfomapParentIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapParentIterator_EqualEqual" "', argument " "2"" of type '" "infomap::InfomapParentIterator const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfomapParentIterator * >(argp2);
  {
    try {
      result = (bool)((infomap::InfomapParentIterator const *)arg1)->operator ==((infomap::InfomapParentIterator const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_NotEqual ( SEXP self, SEXP other, SEXP s_swig_copy)
{
  bool result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  infomap::InfomapParentIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_NotEqual" "', argument " "1"" of type '" "infomap::InfomapParentIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(other, &argp2, SWIGTYPE_p_infomap__InfomapParentIterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapParentIterator_NotEqual" "', argument " "2"" of type '" "infomap::InfomapParentIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapParentIterator_NotEqual" "', argument " "2"" of type '" "infomap::InfomapParentIterator const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfomapParentIterator * >(argp2);
  {
    try {
      result = (bool)((infomap::InfomapParentIterator const *)arg1)->operator !=((infomap::InfomapParentIterator const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_PlusPlusPrefix ( SEXP self, SEXP s_swig_copy)
{
  infomap::InfomapParentIterator *result = 0 ;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_PlusPlusPrefix" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (infomap::InfomapParentIterator *) &(arg1)->operator ++();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_PlusPlusPostfix ( SEXP self, SEXP s_arg2, SEXP s_swig_copy)
{
  infomap::InfomapParentIterator result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_PlusPlusPostfix" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  arg2 = static_cast< int >(INTEGER(s_arg2)[0]);
  {
    try {
      result = (arg1)->operator ++(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfomapParentIterator(static_cast< const infomap::InfomapParentIterator& >(result))), SWIGTYPE_p_infomap__InfomapParentIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_stepForward ( SEXP self, SEXP s_swig_copy)
{
  infomap::InfomapParentIterator *result = 0 ;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_stepForward" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (infomap::InfomapParentIterator *) &(arg1)->stepForward();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_isEnd ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_isEnd" "', argument " "1"" of type '" "infomap::InfomapParentIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (bool)((infomap::InfomapParentIterator const *)arg1)->isEnd();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_data_set ( SEXP self, SEXP s_data)
{
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  infomap::FlowData *arg2 = (infomap::FlowData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_data_set" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_data, &argp2, SWIGTYPE_p_infomap__FlowData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapParentIterator_data_set" "', argument " "2"" of type '" "infomap::FlowData *""'"); 
  }
  arg2 = reinterpret_cast< infomap::FlowData * >(argp2);
  if (arg1) (*arg1)->data = *arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_data_get ( SEXP self)
{
  infomap::FlowData *result = 0 ;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_data_get" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  result = (infomap::FlowData *)& ((*(infomap::InfomapParentIterator const *)arg1)->data);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__FlowData, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_index_set ( SEXP self, SEXP s_index)
{
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_index_set" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  ecode2 = SWIG_AsVal_int(s_index, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapParentIterator_index_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (*arg1)->index = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_index_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_index_get" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  result = (unsigned int) ((*(infomap::InfomapParentIterator const *)arg1)->index);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_stateId_set ( SEXP self, SEXP s_stateId)
{
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_stateId_set" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  ecode2 = SWIG_AsVal_int(s_stateId, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapParentIterator_stateId_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (*arg1)->stateId = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_stateId_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_stateId_get" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  result = (unsigned int) ((*(infomap::InfomapParentIterator const *)arg1)->stateId);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_physicalId_set ( SEXP self, SEXP s_physicalId)
{
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_physicalId_set" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  ecode2 = SWIG_AsVal_int(s_physicalId, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapParentIterator_physicalId_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (*arg1)->physicalId = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_physicalId_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_physicalId_get" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  result = (unsigned int) ((*(infomap::InfomapParentIterator const *)arg1)->physicalId);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_layerId_set ( SEXP self, SEXP s_layerId)
{
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_layerId_set" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  ecode2 = SWIG_AsVal_int(s_layerId, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapParentIterator_layerId_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (*arg1)->layerId = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_layerId_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_layerId_get" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  result = (unsigned int) ((*(infomap::InfomapParentIterator const *)arg1)->layerId);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_metaData_set ( SEXP self, SEXP s_metaData)
{
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  std::vector< int,std::allocator< int > > *arg2 = (std::vector< int,std::allocator< int > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_metaData_set" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_metaData, &argp2, SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapParentIterator_metaData_set" "', argument " "2"" of type '" "std::vector< int,std::allocator< int > > *""'"); 
  }
  arg2 = reinterpret_cast< std::vector< int,std::allocator< int > > * >(argp2);
  if (arg1) (*arg1)->metaData = *arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_metaData_get ( SEXP self)
{
  std::vector< int,std::allocator< int > > *result = 0 ;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_metaData_get" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  result = (std::vector< int,std::allocator< int > > *)& ((*(infomap::InfomapParentIterator const *)arg1)->metaData);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_owner_set ( SEXP self, SEXP s_owner)
{
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  infomap::InfoNode *arg2 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_owner_set" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_owner, &argp2, SWIGTYPE_p_infomap__InfoNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapParentIterator_owner_set" "', argument " "2"" of type '" "infomap::InfoNode *""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  if (arg1) (*arg1)->owner = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_owner_get ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_owner_get" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  result = (infomap::InfoNode *) ((*(infomap::InfomapParentIterator const *)arg1)->owner);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_parent_set ( SEXP self, SEXP s_parent)
{
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  infomap::InfoNode *arg2 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_parent_set" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_parent, &argp2, SWIGTYPE_p_infomap__InfoNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapParentIterator_parent_set" "', argument " "2"" of type '" "infomap::InfoNode *""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  if (arg1) (*arg1)->parent = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_parent_get ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_parent_get" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  result = (infomap::InfoNode *) ((*(infomap::InfomapParentIterator const *)arg1)->parent);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_previous_set ( SEXP self, SEXP s_previous)
{
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  infomap::InfoNode *arg2 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_previous_set" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_previous, &argp2, SWIGTYPE_p_infomap__InfoNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapParentIterator_previous_set" "', argument " "2"" of type '" "infomap::InfoNode *""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  if (arg1) (*arg1)->previous = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_previous_get ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_previous_get" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  result = (infomap::InfoNode *) ((*(infomap::InfomapParentIterator const *)arg1)->previous);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator__next_set ( SEXP self, SEXP s_arg2)
{
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  infomap::InfoNode *arg2 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator__next_set" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_arg2, &argp2, SWIGTYPE_p_infomap__InfoNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapParentIterator__next_set" "', argument " "2"" of type '" "infomap::InfoNode *""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  if (arg1) (*arg1)->next = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator__next_get ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator__next_get" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  result = (infomap::InfoNode *) ((*(infomap::InfomapParentIterator const *)arg1)->next);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_firstChild_set ( SEXP self, SEXP s_firstChild)
{
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  infomap::InfoNode *arg2 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_firstChild_set" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_firstChild, &argp2, SWIGTYPE_p_infomap__InfoNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapParentIterator_firstChild_set" "', argument " "2"" of type '" "infomap::InfoNode *""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  if (arg1) (*arg1)->firstChild = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_firstChild_get ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_firstChild_get" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  result = (infomap::InfoNode *) ((*(infomap::InfomapParentIterator const *)arg1)->firstChild);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_lastChild_set ( SEXP self, SEXP s_lastChild)
{
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  infomap::InfoNode *arg2 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_lastChild_set" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_lastChild, &argp2, SWIGTYPE_p_infomap__InfoNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapParentIterator_lastChild_set" "', argument " "2"" of type '" "infomap::InfoNode *""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  if (arg1) (*arg1)->lastChild = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_lastChild_get ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_lastChild_get" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  result = (infomap::InfoNode *) ((*(infomap::InfomapParentIterator const *)arg1)->lastChild);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_collapsedFirstChild_set ( SEXP self, SEXP s_collapsedFirstChild)
{
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  infomap::InfoNode *arg2 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_collapsedFirstChild_set" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_collapsedFirstChild, &argp2, SWIGTYPE_p_infomap__InfoNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapParentIterator_collapsedFirstChild_set" "', argument " "2"" of type '" "infomap::InfoNode *""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  if (arg1) (*arg1)->collapsedFirstChild = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_collapsedFirstChild_get ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_collapsedFirstChild_get" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  result = (infomap::InfoNode *) ((*(infomap::InfomapParentIterator const *)arg1)->collapsedFirstChild);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_collapsedLastChild_set ( SEXP self, SEXP s_collapsedLastChild)
{
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  infomap::InfoNode *arg2 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_collapsedLastChild_set" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_collapsedLastChild, &argp2, SWIGTYPE_p_infomap__InfoNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapParentIterator_collapsedLastChild_set" "', argument " "2"" of type '" "infomap::InfoNode *""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  if (arg1) (*arg1)->collapsedLastChild = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_collapsedLastChild_get ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_collapsedLastChild_get" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  result = (infomap::InfoNode *) ((*(infomap::InfomapParentIterator const *)arg1)->collapsedLastChild);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_codelength_set ( SEXP self, SEXP s_codelength)
{
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_codelength_set" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  arg2 = static_cast< double >(REAL(s_codelength)[0]);
  if (arg1) (*arg1)->codelength = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_codelength_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_codelength_get" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  result = (double) ((*(infomap::InfomapParentIterator const *)arg1)->codelength);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_dirty_set ( SEXP self, SEXP s_dirty)
{
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_dirty_set" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  arg2 = LOGICAL(s_dirty)[0] ? true : false;
  if (arg1) (*arg1)->dirty = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_dirty_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_dirty_get" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  result = (bool) ((*(infomap::InfomapParentIterator const *)arg1)->dirty);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_physicalNodes_set ( SEXP self, SEXP s_physicalNodes)
{
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  std::vector< infomap::PhysData,std::allocator< infomap::PhysData > > *arg2 = (std::vector< infomap::PhysData,std::allocator< infomap::PhysData > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_physicalNodes_set" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_physicalNodes, &argp2, SWIGTYPE_p_std__vectorT_infomap__PhysData_std__allocatorT_infomap__PhysData_t_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapParentIterator_physicalNodes_set" "', argument " "2"" of type '" "std::vector< infomap::PhysData,std::allocator< infomap::PhysData > > *""'"); 
  }
  arg2 = reinterpret_cast< std::vector< infomap::PhysData,std::allocator< infomap::PhysData > > * >(argp2);
  if (arg1) (*arg1)->physicalNodes = *arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_physicalNodes_get ( SEXP self)
{
  std::vector< infomap::PhysData,std::allocator< infomap::PhysData > > *result = 0 ;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_physicalNodes_get" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  result = (std::vector< infomap::PhysData,std::allocator< infomap::PhysData > > *)& ((*(infomap::InfomapParentIterator const *)arg1)->physicalNodes);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_infomap__PhysData_std__allocatorT_infomap__PhysData_t_t, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_metaCollection_set ( SEXP self, SEXP s_metaCollection)
{
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  MetaCollection arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_metaCollection_set" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    res2 = SWIG_R_ConvertPtr(s_metaCollection, &argp2, SWIGTYPE_p_MetaCollection,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapParentIterator_metaCollection_set" "', argument " "2"" of type '" "MetaCollection""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapParentIterator_metaCollection_set" "', argument " "2"" of type '" "MetaCollection""'");
    } else {
      arg2 = *(reinterpret_cast< MetaCollection * >(argp2));
    }
  }
  if (arg1) (*arg1)->metaCollection = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_metaCollection_get ( SEXP self, SEXP s_swig_copy)
{
  MetaCollection result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_metaCollection_get" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  result =  ((*(infomap::InfomapParentIterator const *)arg1)->metaCollection);
  r_ans = SWIG_R_NewPointerObj((new MetaCollection(static_cast< const MetaCollection& >(result))), SWIGTYPE_p_MetaCollection, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_stateNodes_set ( SEXP self, SEXP s_stateNodes)
{
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  std::vector< unsigned int,std::allocator< unsigned int > > *arg2 = (std::vector< unsigned int,std::allocator< unsigned int > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_stateNodes_set" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_stateNodes, &argp2, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapParentIterator_stateNodes_set" "', argument " "2"" of type '" "std::vector< unsigned int,std::allocator< unsigned int > > *""'"); 
  }
  arg2 = reinterpret_cast< std::vector< unsigned int,std::allocator< unsigned int > > * >(argp2);
  if (arg1) (*arg1)->stateNodes = *arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_stateNodes_get ( SEXP self)
{
  std::vector< unsigned int,std::allocator< unsigned int > > *result = 0 ;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_stateNodes_get" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  result = (std::vector< unsigned int,std::allocator< unsigned int > > *)& ((*(infomap::InfomapParentIterator const *)arg1)->stateNodes);
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_getMetaData__SWIG_0 ( SEXP self, SEXP dimension, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_getMetaData" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  ecode2 = SWIG_AsVal_int(dimension, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapParentIterator_getMetaData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (unsigned int)(*arg1)->getMetaData(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_getMetaData__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_getMetaData" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (unsigned int)(*arg1)->getMetaData();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_getInfomap ( SEXP self, SEXP s_swig_copy)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_getInfomap" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (infomap::InfomapBase *) &(*arg1)->getInfomap();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_setInfomap ( SEXP self, SEXP s_arg2, SEXP s_swig_copy)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  infomap::InfomapBase *arg2 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_setInfomap" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_arg2, &argp2, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapParentIterator_setInfomap" "', argument " "2"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfomapBase * >(argp2);
  {
    try {
      result = (infomap::InfomapBase *) &(*arg1)->setInfomap(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_getInfomapRoot__SWIG_0 ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_getInfomapRoot" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (infomap::InfoNode *)(*arg1)->getInfomapRoot();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_getInfomapRoot__SWIG_1 ( SEXP self)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_getInfomapRoot" "', argument " "1"" of type '" "infomap::InfomapParentIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (infomap::InfoNode *)(*((infomap::InfomapParentIterator const *)arg1))->getInfomapRoot();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_disposeInfomap ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_disposeInfomap" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (bool)(*arg1)->disposeInfomap();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_numPhysicalNodes ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_numPhysicalNodes" "', argument " "1"" of type '" "infomap::InfomapParentIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (unsigned int)(*((infomap::InfomapParentIterator const *)arg1))->numPhysicalNodes();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_begin__SWIG_0 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< ChildIterator< infomap::InfoNode * > > result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_begin" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (*arg1)->begin();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::child_iterator(static_cast< const infomap::InfoNode::child_iterator& >(result))), SWIGTYPE_p_ChildIteratorT_infomap__InfoNode_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_begin__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< ChildIterator< infomap::InfoNode const * > > result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_begin" "', argument " "1"" of type '" "infomap::InfomapParentIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (*((infomap::InfomapParentIterator const *)arg1))->begin();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::const_child_iterator(static_cast< const infomap::InfoNode::const_child_iterator& >(result))), SWIGTYPE_p_ChildIteratorT_infomap__InfoNode_const_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_end__SWIG_0 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< ChildIterator< infomap::InfoNode * > > result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_end" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (*arg1)->end();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::child_iterator(static_cast< const infomap::InfoNode::child_iterator& >(result))), SWIGTYPE_p_ChildIteratorT_infomap__InfoNode_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_end__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< ChildIterator< infomap::InfoNode const * > > result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_end" "', argument " "1"" of type '" "infomap::InfomapParentIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (*((infomap::InfomapParentIterator const *)arg1))->end();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::const_child_iterator(static_cast< const infomap::InfoNode::const_child_iterator& >(result))), SWIGTYPE_p_ChildIteratorT_infomap__InfoNode_const_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_begin_child__SWIG_0 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< ChildIterator< infomap::InfoNode * > > result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_begin_child" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (*arg1)->begin_child();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::child_iterator(static_cast< const infomap::InfoNode::child_iterator& >(result))), SWIGTYPE_p_ChildIteratorT_infomap__InfoNode_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_begin_child__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< ChildIterator< infomap::InfoNode const * > > result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_begin_child" "', argument " "1"" of type '" "infomap::InfomapParentIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (*((infomap::InfomapParentIterator const *)arg1))->begin_child();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::const_child_iterator(static_cast< const infomap::InfoNode::const_child_iterator& >(result))), SWIGTYPE_p_ChildIteratorT_infomap__InfoNode_const_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_end_child__SWIG_0 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< ChildIterator< infomap::InfoNode * > > result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_end_child" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (*arg1)->end_child();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::child_iterator(static_cast< const infomap::InfoNode::child_iterator& >(result))), SWIGTYPE_p_ChildIteratorT_infomap__InfoNode_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_end_child__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< ChildIterator< infomap::InfoNode const * > > result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_end_child" "', argument " "1"" of type '" "infomap::InfomapParentIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (*((infomap::InfomapParentIterator const *)arg1))->end_child();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::const_child_iterator(static_cast< const infomap::InfoNode::const_child_iterator& >(result))), SWIGTYPE_p_ChildIteratorT_infomap__InfoNode_const_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_children__SWIG_0 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< IterWrapper< ChildIterator< infomap::InfoNode * > > > result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_children" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (*arg1)->children();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::child_iterator_wrapper(static_cast< const infomap::InfoNode::child_iterator_wrapper& >(result))), SWIGTYPE_p_IterWrapperT_ChildIteratorT_infomap__InfoNode_p_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_children__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< IterWrapper< ChildIterator< infomap::InfoNode const * > > > result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_children" "', argument " "1"" of type '" "infomap::InfomapParentIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (*((infomap::InfomapParentIterator const *)arg1))->children();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::const_child_iterator_wrapper(static_cast< const infomap::InfoNode::const_child_iterator_wrapper& >(result))), SWIGTYPE_p_IterWrapperT_ChildIteratorT_infomap__InfoNode_const_p_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_infomap_children__SWIG_0 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< IterWrapper< InfomapChildIterator< infomap::InfoNode * > > > result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_infomap_children" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (*arg1)->infomap_children();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::infomap_child_iterator_wrapper(static_cast< const infomap::InfoNode::infomap_child_iterator_wrapper& >(result))), SWIGTYPE_p_IterWrapperT_InfomapChildIteratorT_infomap__InfoNode_p_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_infomap_children__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< IterWrapper< InfomapChildIterator< infomap::InfoNode const * > > > result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_infomap_children" "', argument " "1"" of type '" "infomap::InfomapParentIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (*((infomap::InfomapParentIterator const *)arg1))->infomap_children();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::const_infomap_child_iterator_wrapper(static_cast< const infomap::InfoNode::const_infomap_child_iterator_wrapper& >(result))), SWIGTYPE_p_IterWrapperT_InfomapChildIteratorT_infomap__InfoNode_const_p_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_begin_post_depth_first ( SEXP self, SEXP s_swig_copy)
{
  infomap::InfoNode::post_depth_first_iterator result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_begin_post_depth_first" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (*arg1)->begin_post_depth_first();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::post_depth_first_iterator(static_cast< const infomap::InfoNode::post_depth_first_iterator& >(result))), SWIGTYPE_p_DepthFirstIteratorT_infomap__InfoNode_p_false_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_begin_leaf_nodes ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< LeafNodeIterator< infomap::InfoNode * > > result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_begin_leaf_nodes" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (*arg1)->begin_leaf_nodes();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::leaf_node_iterator(static_cast< const infomap::InfoNode::leaf_node_iterator& >(result))), SWIGTYPE_p_LeafNodeIteratorT_infomap__InfoNode_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_begin_leaf_modules ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< LeafModuleIterator< infomap::InfoNode * > > result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_begin_leaf_modules" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (*arg1)->begin_leaf_modules();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::leaf_module_iterator(static_cast< const infomap::InfoNode::leaf_module_iterator& >(result))), SWIGTYPE_p_LeafModuleIteratorT_infomap__InfoNode_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_begin_tree__SWIG_0 ( SEXP self, SEXP maxClusterLevel, SEXP s_swig_copy)
{
  SwigValueWrapper< TreeIterator< infomap::InfoNode * > > result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_begin_tree" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  ecode2 = SWIG_AsVal_int(maxClusterLevel, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapParentIterator_begin_tree" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (*arg1)->begin_tree(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::tree_iterator(static_cast< const infomap::InfoNode::tree_iterator& >(result))), SWIGTYPE_p_TreeIteratorT_infomap__InfoNode_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_begin_tree__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< TreeIterator< infomap::InfoNode * > > result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_begin_tree" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (*arg1)->begin_tree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::tree_iterator(static_cast< const infomap::InfoNode::tree_iterator& >(result))), SWIGTYPE_p_TreeIteratorT_infomap__InfoNode_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_begin_tree__SWIG_2 ( SEXP self, SEXP maxClusterLevel, SEXP s_swig_copy)
{
  SwigValueWrapper< TreeIterator< infomap::InfoNode const * > > result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_begin_tree" "', argument " "1"" of type '" "infomap::InfomapParentIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  ecode2 = SWIG_AsVal_int(maxClusterLevel, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapParentIterator_begin_tree" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (*((infomap::InfomapParentIterator const *)arg1))->begin_tree(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::const_tree_iterator(static_cast< const infomap::InfoNode::const_tree_iterator& >(result))), SWIGTYPE_p_TreeIteratorT_infomap__InfoNode_const_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_begin_tree__SWIG_3 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< TreeIterator< infomap::InfoNode const * > > result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_begin_tree" "', argument " "1"" of type '" "infomap::InfomapParentIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (*((infomap::InfomapParentIterator const *)arg1))->begin_tree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::const_tree_iterator(static_cast< const infomap::InfoNode::const_tree_iterator& >(result))), SWIGTYPE_p_TreeIteratorT_infomap__InfoNode_const_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_end_tree__SWIG_0 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< TreeIterator< infomap::InfoNode * > > result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_end_tree" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (*arg1)->end_tree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::tree_iterator(static_cast< const infomap::InfoNode::tree_iterator& >(result))), SWIGTYPE_p_TreeIteratorT_infomap__InfoNode_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_end_tree__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< TreeIterator< infomap::InfoNode const * > > result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_end_tree" "', argument " "1"" of type '" "infomap::InfomapParentIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (*((infomap::InfomapParentIterator const *)arg1))->end_tree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::const_tree_iterator(static_cast< const infomap::InfoNode::const_tree_iterator& >(result))), SWIGTYPE_p_TreeIteratorT_infomap__InfoNode_const_p_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_infomapTree__SWIG_0 ( SEXP self, SEXP maxClusterLevel, SEXP s_swig_copy)
{
  SwigValueWrapper< IterWrapper< TreeIterator< infomap::InfoNode * > > > result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_infomapTree" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  ecode2 = SWIG_AsVal_int(maxClusterLevel, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapParentIterator_infomapTree" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (*arg1)->infomapTree(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::infomap_iterator_wrapper(static_cast< const infomap::InfoNode::infomap_iterator_wrapper& >(result))), SWIGTYPE_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_p_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_infomapTree__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< IterWrapper< TreeIterator< infomap::InfoNode * > > > result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_infomapTree" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (*arg1)->infomapTree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::infomap_iterator_wrapper(static_cast< const infomap::InfoNode::infomap_iterator_wrapper& >(result))), SWIGTYPE_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_p_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_infomapTree__SWIG_2 ( SEXP self, SEXP maxClusterLevel, SEXP s_swig_copy)
{
  SwigValueWrapper< IterWrapper< TreeIterator< infomap::InfoNode const * > > > result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_infomapTree" "', argument " "1"" of type '" "infomap::InfomapParentIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  ecode2 = SWIG_AsVal_int(maxClusterLevel, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapParentIterator_infomapTree" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (*((infomap::InfomapParentIterator const *)arg1))->infomapTree(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::const_infomap_iterator_wrapper(static_cast< const infomap::InfoNode::const_infomap_iterator_wrapper& >(result))), SWIGTYPE_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_const_p_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_infomapTree__SWIG_3 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< IterWrapper< TreeIterator< infomap::InfoNode const * > > > result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_infomapTree" "', argument " "1"" of type '" "infomap::InfomapParentIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (*((infomap::InfomapParentIterator const *)arg1))->infomapTree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::const_infomap_iterator_wrapper(static_cast< const infomap::InfoNode::const_infomap_iterator_wrapper& >(result))), SWIGTYPE_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_const_p_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_begin_outEdge ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< std::vector< Edge< infomap::InfoNode > *,std::allocator< Edge< infomap::InfoNode > * > >::iterator > result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_begin_outEdge" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (*arg1)->begin_outEdge();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::edge_iterator(static_cast< const infomap::InfoNode::edge_iterator& >(result))), SWIGTYPE_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_end_outEdge ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< std::vector< Edge< infomap::InfoNode > *,std::allocator< Edge< infomap::InfoNode > * > >::iterator > result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_end_outEdge" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (*arg1)->end_outEdge();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::edge_iterator(static_cast< const infomap::InfoNode::edge_iterator& >(result))), SWIGTYPE_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_begin_inEdge ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< std::vector< Edge< infomap::InfoNode > *,std::allocator< Edge< infomap::InfoNode > * > >::iterator > result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_begin_inEdge" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (*arg1)->begin_inEdge();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::edge_iterator(static_cast< const infomap::InfoNode::edge_iterator& >(result))), SWIGTYPE_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_end_inEdge ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< std::vector< Edge< infomap::InfoNode > *,std::allocator< Edge< infomap::InfoNode > * > >::iterator > result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_end_inEdge" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (*arg1)->end_inEdge();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::edge_iterator(static_cast< const infomap::InfoNode::edge_iterator& >(result))), SWIGTYPE_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_outEdges ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< IterWrapper< std::vector< Edge< infomap::InfoNode > *,std::allocator< Edge< infomap::InfoNode > * > >::iterator > > result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_outEdges" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (*arg1)->outEdges();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::edge_iterator_wrapper(static_cast< const infomap::InfoNode::edge_iterator_wrapper& >(result))), SWIGTYPE_p_IterWrapperT_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_inEdges ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< IterWrapper< std::vector< Edge< infomap::InfoNode > *,std::allocator< Edge< infomap::InfoNode > * > >::iterator > > result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_inEdges" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (*arg1)->inEdges();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfoNode::edge_iterator_wrapper(static_cast< const infomap::InfoNode::edge_iterator_wrapper& >(result))), SWIGTYPE_p_IterWrapperT_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_childDegree ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_childDegree" "', argument " "1"" of type '" "infomap::InfomapParentIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (unsigned int)(*((infomap::InfomapParentIterator const *)arg1))->childDegree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_isLeaf ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_isLeaf" "', argument " "1"" of type '" "infomap::InfomapParentIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (bool)(*((infomap::InfomapParentIterator const *)arg1))->isLeaf();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_isLeafModule ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_isLeafModule" "', argument " "1"" of type '" "infomap::InfomapParentIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (bool)(*((infomap::InfomapParentIterator const *)arg1))->isLeafModule();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_isRoot ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_isRoot" "', argument " "1"" of type '" "infomap::InfomapParentIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (bool)(*((infomap::InfomapParentIterator const *)arg1))->isRoot();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_depth ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_depth" "', argument " "1"" of type '" "infomap::InfomapParentIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (unsigned int)(*((infomap::InfomapParentIterator const *)arg1))->depth();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_firstDepthBelow ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_firstDepthBelow" "', argument " "1"" of type '" "infomap::InfomapParentIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (unsigned int)(*((infomap::InfomapParentIterator const *)arg1))->firstDepthBelow();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_numLeafMembers ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_numLeafMembers" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (unsigned int)(*arg1)->numLeafMembers();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_isDangling ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_isDangling" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (bool)(*arg1)->isDangling();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_outDegree ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_outDegree" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (unsigned int)(*arg1)->outDegree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_inDegree ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_inDegree" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (unsigned int)(*arg1)->inDegree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_degree ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_degree" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (unsigned int)(*arg1)->degree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_isFirst ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_isFirst" "', argument " "1"" of type '" "infomap::InfomapParentIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (bool)(*((infomap::InfomapParentIterator const *)arg1))->isFirst();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_isLast ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_isLast" "', argument " "1"" of type '" "infomap::InfomapParentIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (bool)(*((infomap::InfomapParentIterator const *)arg1))->isLast();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_childIndex ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_childIndex" "', argument " "1"" of type '" "infomap::InfomapParentIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (unsigned int)(*((infomap::InfomapParentIterator const *)arg1))->childIndex();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_calculatePath ( SEXP self, SEXP s_swig_copy)
{
  std::vector< unsigned int,std::allocator< unsigned int > > result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_calculatePath" "', argument " "1"" of type '" "infomap::InfomapParentIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (*((infomap::InfomapParentIterator const *)arg1))->calculatePath();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = swig::from(static_cast< std::vector< unsigned int,std::allocator< unsigned int > > >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_infomapChildDegree ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_infomapChildDegree" "', argument " "1"" of type '" "infomap::InfomapParentIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (unsigned int)(*((infomap::InfomapParentIterator const *)arg1))->infomapChildDegree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_id ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_id" "', argument " "1"" of type '" "infomap::InfomapParentIterator const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (unsigned int)(*((infomap::InfomapParentIterator const *)arg1))->id();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_initClean ( SEXP self)
{
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_initClean" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      (*arg1)->initClean();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_sortChildrenOnFlow__SWIG_0 ( SEXP self, SEXP recurse)
{
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_sortChildrenOnFlow" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  arg2 = LOGICAL(recurse)[0] ? true : false;
  {
    try {
      (*arg1)->sortChildrenOnFlow(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_sortChildrenOnFlow__SWIG_1 ( SEXP self)
{
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_sortChildrenOnFlow" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      (*arg1)->sortChildrenOnFlow();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_collapseChildren ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_collapseChildren" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (unsigned int)(*arg1)->collapseChildren();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_expandChildren ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_expandChildren" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (unsigned int)(*arg1)->expandChildren();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_setChildDegree ( SEXP self, SEXP value)
{
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_setChildDegree" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  ecode2 = SWIG_AsVal_int(value, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapParentIterator_setChildDegree" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      (*arg1)->setChildDegree(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_setNumLeafNodes ( SEXP self, SEXP value)
{
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_setNumLeafNodes" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  ecode2 = SWIG_AsVal_int(value, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapParentIterator_setNumLeafNodes" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      (*arg1)->setNumLeafNodes(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_addChild ( SEXP self, SEXP child)
{
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  infomap::InfoNode *arg2 = (infomap::InfoNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_addChild" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(child, &argp2, SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapParentIterator_addChild" "', argument " "2"" of type '" "infomap::InfoNode *""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  {
    try {
      (*arg1)->addChild(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_releaseChildren ( SEXP self)
{
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_releaseChildren" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      (*arg1)->releaseChildren();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_replaceChildrenWithOneNode ( SEXP self, SEXP s_swig_copy)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_replaceChildrenWithOneNode" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (infomap::InfoNode *) &(*arg1)->replaceChildrenWithOneNode();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_replaceWithChildren ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_replaceWithChildren" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (unsigned int)(*arg1)->replaceWithChildren();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_replaceWithChildrenDebug ( SEXP self)
{
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_replaceWithChildrenDebug" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      (*arg1)->replaceWithChildrenDebug();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_replaceChildrenWithGrandChildren ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_replaceChildrenWithGrandChildren" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      result = (unsigned int)(*arg1)->replaceChildrenWithGrandChildren();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_replaceChildrenWithGrandChildrenDebug ( SEXP self)
{
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_replaceChildrenWithGrandChildrenDebug" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      (*arg1)->replaceChildrenWithGrandChildrenDebug();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_remove ( SEXP self, SEXP removeChildren)
{
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_remove" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  arg2 = LOGICAL(removeChildren)[0] ? true : false;
  {
    try {
      (*arg1)->remove(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_deleteChildren ( SEXP self)
{
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_deleteChildren" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  {
    try {
      (*arg1)->deleteChildren();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_addOutEdge__SWIG_0 ( SEXP self, SEXP target, SEXP weight, SEXP flow)
{
  infomap::InfoNode::EdgeType *result = 0 ;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_addOutEdge" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(target, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapParentIterator_addOutEdge" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapParentIterator_addOutEdge" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  arg3 = static_cast< double >(REAL(weight)[0]);
  arg4 = static_cast< double >(REAL(flow)[0]);
  {
    try {
      result = (infomap::InfoNode::EdgeType *)(*arg1)->addOutEdge(*arg2,arg3,arg4);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EdgeT_infomap__InfoNode_t, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapParentIterator_addOutEdge__SWIG_1 ( SEXP self, SEXP target, SEXP weight)
{
  infomap::InfoNode::EdgeType *result = 0 ;
  infomap::InfomapParentIterator *arg1 = (infomap::InfomapParentIterator *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapParentIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapParentIterator_addOutEdge" "', argument " "1"" of type '" "infomap::InfomapParentIterator *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapParentIterator * >(argp1);
  res2 = SWIG_R_ConvertPtr(target, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapParentIterator_addOutEdge" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapParentIterator_addOutEdge" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  arg3 = static_cast< double >(REAL(weight)[0]);
  {
    try {
      result = (infomap::InfoNode::EdgeType *)(*arg1)->addOutEdge(*arg2,arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EdgeT_infomap__InfoNode_t, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_StateNetwork__SWIG_0 ( )
{
  infomap::StateNetwork *result = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    try {
      result = (infomap::StateNetwork *)new infomap::StateNetwork();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__StateNetwork, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_StateNetwork__SWIG_1 ( SEXP config)
{
  infomap::StateNetwork *result = 0 ;
  infomap::Config *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(config, &argp1, SWIGTYPE_p_infomap__Config,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_StateNetwork" "', argument " "1"" of type '" "infomap::Config const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_StateNetwork" "', argument " "1"" of type '" "infomap::Config const &""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  {
    try {
      result = (infomap::StateNetwork *)new infomap::StateNetwork((infomap::Config const &)*arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__StateNetwork, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_StateNetwork ( SEXP self)
{
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_StateNetwork" "', argument " "1"" of type '" "infomap::StateNetwork *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_setConfig ( SEXP self, SEXP config)
{
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  infomap::Config *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_setConfig" "', argument " "1"" of type '" "infomap::StateNetwork *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  res2 = SWIG_R_ConvertPtr(config, &argp2, SWIGTYPE_p_infomap__Config,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "StateNetwork_setConfig" "', argument " "2"" of type '" "infomap::Config const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "StateNetwork_setConfig" "', argument " "2"" of type '" "infomap::Config const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::Config * >(argp2);
  {
    try {
      (arg1)->setConfig((infomap::Config const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_getConfig ( SEXP self, SEXP s_swig_copy)
{
  infomap::Config *result = 0 ;
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_getConfig" "', argument " "1"" of type '" "infomap::StateNetwork *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  {
    try {
      result = (infomap::Config *) &(arg1)->getConfig();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__Config, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_addStateNode__SWIG_0 ( SEXP self, SEXP node, SEXP s_swig_copy)
{
  SwigValueWrapper< std::pair< std::map< unsigned int,infomap::StateNetwork::StateNode,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,infomap::StateNetwork::StateNode > > >::iterator,bool > > result;
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  infomap::StateNetwork::StateNode arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_addStateNode" "', argument " "1"" of type '" "infomap::StateNetwork *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  {
    res2 = SWIG_R_ConvertPtr(node, &argp2, SWIGTYPE_p_infomap__StateNetwork__StateNode,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "StateNetwork_addStateNode" "', argument " "2"" of type '" "infomap::StateNetwork::StateNode""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "StateNetwork_addStateNode" "', argument " "2"" of type '" "infomap::StateNetwork::StateNode""'");
    } else {
      arg2 = *(reinterpret_cast< infomap::StateNetwork::StateNode * >(argp2));
    }
  }
  {
    try {
      result = (arg1)->addStateNode(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new std::pair< infomap::StateNetwork::NodeMap::iterator,bool >(static_cast< const std::pair< infomap::StateNetwork::NodeMap::iterator,bool >& >(result))), SWIGTYPE_p_std__pairT_std__mapT_unsigned_int_infomap__StateNetwork__StateNode_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_infomap__StateNetwork__StateNode_t_t_t__iterator_bool_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_addStateNode__SWIG_1 ( SEXP self, SEXP id, SEXP physId, SEXP s_swig_copy)
{
  SwigValueWrapper< std::pair< std::map< unsigned int,infomap::StateNetwork::StateNode,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,infomap::StateNetwork::StateNode > > >::iterator,bool > > result;
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_addStateNode" "', argument " "1"" of type '" "infomap::StateNetwork *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  ecode2 = SWIG_AsVal_int(id, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "StateNetwork_addStateNode" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_int(physId, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "StateNetwork_addStateNode" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    try {
      result = (arg1)->addStateNode(arg2,arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new std::pair< infomap::StateNetwork::NodeMap::iterator,bool >(static_cast< const std::pair< infomap::StateNetwork::NodeMap::iterator,bool >& >(result))), SWIGTYPE_p_std__pairT_std__mapT_unsigned_int_infomap__StateNetwork__StateNode_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_infomap__StateNetwork__StateNode_t_t_t__iterator_bool_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_addNode__SWIG_0 ( SEXP self, SEXP id, SEXP s_swig_copy)
{
  SwigValueWrapper< std::pair< std::map< unsigned int,infomap::StateNetwork::StateNode,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,infomap::StateNetwork::StateNode > > >::iterator,bool > > result;
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_addNode" "', argument " "1"" of type '" "infomap::StateNetwork *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  ecode2 = SWIG_AsVal_int(id, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "StateNetwork_addNode" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (arg1)->addNode(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new std::pair< infomap::StateNetwork::NodeMap::iterator,bool >(static_cast< const std::pair< infomap::StateNetwork::NodeMap::iterator,bool >& >(result))), SWIGTYPE_p_std__pairT_std__mapT_unsigned_int_infomap__StateNetwork__StateNode_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_infomap__StateNetwork__StateNode_t_t_t__iterator_bool_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_addNode__SWIG_1 ( SEXP self, SEXP id, SEXP name, SEXP s_swig_copy)
{
  SwigValueWrapper< std::pair< std::map< unsigned int,infomap::StateNetwork::StateNode,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,infomap::StateNetwork::StateNode > > >::iterator,bool > > result;
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  unsigned int arg2 ;
  std::string arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_addNode" "', argument " "1"" of type '" "infomap::StateNetwork *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  ecode2 = SWIG_AsVal_int(id, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "StateNetwork_addNode" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(name, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "StateNetwork_addNode" "', argument " "3"" of type '" "std::string""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      result = (arg1)->addNode(arg2,arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new std::pair< infomap::StateNetwork::NodeMap::iterator,bool >(static_cast< const std::pair< infomap::StateNetwork::NodeMap::iterator,bool >& >(result))), SWIGTYPE_p_std__pairT_std__mapT_unsigned_int_infomap__StateNetwork__StateNode_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_infomap__StateNetwork__StateNode_t_t_t__iterator_bool_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_addNode__SWIG_2 ( SEXP self, SEXP id, SEXP weight, SEXP s_swig_copy)
{
  SwigValueWrapper< std::pair< std::map< unsigned int,infomap::StateNetwork::StateNode,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,infomap::StateNetwork::StateNode > > >::iterator,bool > > result;
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  unsigned int arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_addNode" "', argument " "1"" of type '" "infomap::StateNetwork *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  ecode2 = SWIG_AsVal_int(id, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "StateNetwork_addNode" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  arg3 = static_cast< double >(REAL(weight)[0]);
  {
    try {
      result = (arg1)->addNode(arg2,arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new std::pair< infomap::StateNetwork::NodeMap::iterator,bool >(static_cast< const std::pair< infomap::StateNetwork::NodeMap::iterator,bool >& >(result))), SWIGTYPE_p_std__pairT_std__mapT_unsigned_int_infomap__StateNetwork__StateNode_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_infomap__StateNetwork__StateNode_t_t_t__iterator_bool_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_addNode__SWIG_3 ( SEXP self, SEXP id, SEXP s_arg3, SEXP weight, SEXP s_swig_copy)
{
  SwigValueWrapper< std::pair< std::map< unsigned int,infomap::StateNetwork::StateNode,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,infomap::StateNetwork::StateNode > > >::iterator,bool > > result;
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  unsigned int arg2 ;
  std::string arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_addNode" "', argument " "1"" of type '" "infomap::StateNetwork *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  ecode2 = SWIG_AsVal_int(id, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "StateNetwork_addNode" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(s_arg3, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "StateNetwork_addNode" "', argument " "3"" of type '" "std::string""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  arg4 = static_cast< double >(REAL(weight)[0]);
  {
    try {
      result = (arg1)->addNode(arg2,arg3,arg4);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new std::pair< infomap::StateNetwork::NodeMap::iterator,bool >(static_cast< const std::pair< infomap::StateNetwork::NodeMap::iterator,bool >& >(result))), SWIGTYPE_p_std__pairT_std__mapT_unsigned_int_infomap__StateNetwork__StateNode_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_infomap__StateNetwork__StateNode_t_t_t__iterator_bool_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_addPhysicalNode__SWIG_0 ( SEXP self, SEXP physId, SEXP s_swig_copy)
{
  infomap::StateNetwork::PhysNode *result = 0 ;
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_addPhysicalNode" "', argument " "1"" of type '" "infomap::StateNetwork *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  ecode2 = SWIG_AsVal_int(physId, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "StateNetwork_addPhysicalNode" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (infomap::StateNetwork::PhysNode *) &(arg1)->addPhysicalNode(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__StateNetwork__PhysNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_addPhysicalNode__SWIG_1 ( SEXP self, SEXP physId, SEXP weight, SEXP s_swig_copy)
{
  infomap::StateNetwork::PhysNode *result = 0 ;
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  unsigned int arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_addPhysicalNode" "', argument " "1"" of type '" "infomap::StateNetwork *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  ecode2 = SWIG_AsVal_int(physId, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "StateNetwork_addPhysicalNode" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  arg3 = static_cast< double >(REAL(weight)[0]);
  {
    try {
      result = (infomap::StateNetwork::PhysNode *) &(arg1)->addPhysicalNode(arg2,arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__StateNetwork__PhysNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_addPhysicalNode__SWIG_2 ( SEXP self, SEXP physId, SEXP name, SEXP s_swig_copy)
{
  infomap::StateNetwork::PhysNode *result = 0 ;
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  unsigned int arg2 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_addPhysicalNode" "', argument " "1"" of type '" "infomap::StateNetwork *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  ecode2 = SWIG_AsVal_int(physId, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "StateNetwork_addPhysicalNode" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(name, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "StateNetwork_addPhysicalNode" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "StateNetwork_addPhysicalNode" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  {
    try {
      result = (infomap::StateNetwork::PhysNode *) &(arg1)->addPhysicalNode(arg2,(std::string const &)*arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__StateNetwork__PhysNode, 0 |  0 );
  if (SWIG_IsNewObj(res3)) delete arg3;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  if (SWIG_IsNewObj(res3)) delete arg3;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_addPhysicalNode__SWIG_3 ( SEXP self, SEXP physId, SEXP weight, SEXP name, SEXP s_swig_copy)
{
  infomap::StateNetwork::PhysNode *result = 0 ;
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  unsigned int arg2 ;
  double arg3 ;
  std::string *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_addPhysicalNode" "', argument " "1"" of type '" "infomap::StateNetwork *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  ecode2 = SWIG_AsVal_int(physId, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "StateNetwork_addPhysicalNode" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  arg3 = static_cast< double >(REAL(weight)[0]);
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(name, &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "StateNetwork_addPhysicalNode" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "StateNetwork_addPhysicalNode" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    arg4 = ptr;
  }
  {
    try {
      result = (infomap::StateNetwork::PhysNode *) &(arg1)->addPhysicalNode(arg2,arg3,(std::string const &)*arg4);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__StateNetwork__PhysNode, 0 |  0 );
  if (SWIG_IsNewObj(res4)) delete arg4;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  if (SWIG_IsNewObj(res4)) delete arg4;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_addName ( SEXP self, SEXP id, SEXP s_arg3, SEXP s_swig_copy)
{
  SwigValueWrapper< std::pair< std::map< unsigned int,std::string,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,std::string > > >::iterator,bool > > result;
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  unsigned int arg2 ;
  std::string arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_addName" "', argument " "1"" of type '" "infomap::StateNetwork *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  ecode2 = SWIG_AsVal_int(id, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "StateNetwork_addName" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(s_arg3, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "StateNetwork_addName" "', argument " "3"" of type '" "std::string""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      result = (arg1)->addName(arg2,arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new std::pair< std::map< unsigned int,std::string,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,std::string > > >::iterator,bool >(static_cast< const std::pair< std::map< unsigned int,std::string,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,std::string > > >::iterator,bool >& >(result))), SWIGTYPE_p_std__pairT_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t__iterator_bool_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_addLink__SWIG_0 ( SEXP self, SEXP sourceId, SEXP targetId, SEXP weight, SEXP s_swig_copy)
{
  bool result;
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_addLink" "', argument " "1"" of type '" "infomap::StateNetwork *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  ecode2 = SWIG_AsVal_int(sourceId, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "StateNetwork_addLink" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_int(targetId, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "StateNetwork_addLink" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  arg4 = static_cast< double >(REAL(weight)[0]);
  {
    try {
      result = (bool)(arg1)->addLink(arg2,arg3,arg4);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_addLink__SWIG_1 ( SEXP self, SEXP sourceId, SEXP targetId, SEXP s_swig_copy)
{
  bool result;
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_addLink" "', argument " "1"" of type '" "infomap::StateNetwork *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  ecode2 = SWIG_AsVal_int(sourceId, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "StateNetwork_addLink" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_int(targetId, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "StateNetwork_addLink" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    try {
      result = (bool)(arg1)->addLink(arg2,arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_addLink__SWIG_2 ( SEXP self, SEXP sourceId, SEXP targetId, SEXP weight, SEXP s_swig_copy)
{
  bool result;
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_addLink" "', argument " "1"" of type '" "infomap::StateNetwork *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  ecode2 = SWIG_AsVal_int(sourceId, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "StateNetwork_addLink" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_int(targetId, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "StateNetwork_addLink" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_long(weight, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "StateNetwork_addLink" "', argument " "4"" of type '" "unsigned long""'");
  } 
  arg4 = static_cast< unsigned long >(val4);
  {
    try {
      result = (bool)(arg1)->addLink(arg2,arg3,arg4);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_removeLink ( SEXP self, SEXP sourceId, SEXP targetId, SEXP s_swig_copy)
{
  bool result;
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_removeLink" "', argument " "1"" of type '" "infomap::StateNetwork *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  ecode2 = SWIG_AsVal_int(sourceId, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "StateNetwork_removeLink" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_int(targetId, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "StateNetwork_removeLink" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    try {
      result = (bool)(arg1)->removeLink(arg2,arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_undirectedToDirected ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_undirectedToDirected" "', argument " "1"" of type '" "infomap::StateNetwork *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  {
    try {
      result = (bool)(arg1)->undirectedToDirected();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_calculateFlow ( SEXP self)
{
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_calculateFlow" "', argument " "1"" of type '" "infomap::StateNetwork *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  {
    try {
      (arg1)->calculateFlow();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_clear ( SEXP self)
{
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_clear" "', argument " "1"" of type '" "infomap::StateNetwork *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  {
    try {
      (arg1)->clear();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_clearLinks ( SEXP self)
{
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_clearLinks" "', argument " "1"" of type '" "infomap::StateNetwork *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  {
    try {
      (arg1)->clearLinks();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_nodes ( SEXP self, SEXP s_swig_copy)
{
  infomap::StateNetwork::NodeMap *result = 0 ;
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_nodes" "', argument " "1"" of type '" "infomap::StateNetwork const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  {
    try {
      result = (infomap::StateNetwork::NodeMap *) &((infomap::StateNetwork const *)arg1)->nodes();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_unsigned_int_infomap__StateNetwork__StateNode_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_infomap__StateNetwork__StateNode_t_t_t, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_numNodes ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_numNodes" "', argument " "1"" of type '" "infomap::StateNetwork const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  {
    try {
      result = (unsigned int)((infomap::StateNetwork const *)arg1)->numNodes();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_numPhysicalNodes ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_numPhysicalNodes" "', argument " "1"" of type '" "infomap::StateNetwork const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  {
    try {
      result = (unsigned int)((infomap::StateNetwork const *)arg1)->numPhysicalNodes();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_nodeLinkMap__SWIG_0 ( SEXP self, SEXP s_swig_copy)
{
  infomap::StateNetwork::NodeLinkMap *result = 0 ;
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_nodeLinkMap" "', argument " "1"" of type '" "infomap::StateNetwork const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  {
    try {
      result = (infomap::StateNetwork::NodeLinkMap *) &((infomap::StateNetwork const *)arg1)->nodeLinkMap();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_infomap__StateNetwork__StateNode_std__mapT_infomap__StateNetwork__StateNode_infomap__StateNetwork__LinkData_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_infomap__StateNetwork__LinkData_t_t_t_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_std__mapT_infomap__StateNetwork__StateNode_infomap__StateNetwork__LinkData_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_infomap__StateNetwork__LinkData_t_t_t_t_t_t, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_nodeLinkMap__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  infomap::StateNetwork::NodeLinkMap *result = 0 ;
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_nodeLinkMap" "', argument " "1"" of type '" "infomap::StateNetwork *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  {
    try {
      result = (infomap::StateNetwork::NodeLinkMap *) &(arg1)->nodeLinkMap();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_infomap__StateNetwork__StateNode_std__mapT_infomap__StateNetwork__StateNode_infomap__StateNetwork__LinkData_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_infomap__StateNetwork__LinkData_t_t_t_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_std__mapT_infomap__StateNetwork__StateNode_infomap__StateNetwork__LinkData_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_infomap__StateNetwork__LinkData_t_t_t_t_t_t, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_numLinks ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_numLinks" "', argument " "1"" of type '" "infomap::StateNetwork const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  {
    try {
      result = (unsigned int)((infomap::StateNetwork const *)arg1)->numLinks();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_sumLinkWeight ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_sumLinkWeight" "', argument " "1"" of type '" "infomap::StateNetwork const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  {
    try {
      result = (double)((infomap::StateNetwork const *)arg1)->sumLinkWeight();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_sumSelfLinkWeight ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_sumSelfLinkWeight" "', argument " "1"" of type '" "infomap::StateNetwork const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  {
    try {
      result = (double)((infomap::StateNetwork const *)arg1)->sumSelfLinkWeight();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_outWeights ( SEXP self, SEXP s_swig_copy)
{
  std::map< unsigned int,double,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,double > > > *result = 0 ;
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_outWeights" "', argument " "1"" of type '" "infomap::StateNetwork *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  {
    try {
      result = (std::map< unsigned int,double,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,double > > > *) &(arg1)->outWeights();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_unsigned_int_double_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_double_t_t_t, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_names__SWIG_0 ( SEXP self, SEXP s_swig_copy)
{
  std::map< unsigned int,std::string,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,std::string > > > *result = 0 ;
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_names" "', argument " "1"" of type '" "infomap::StateNetwork *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  {
    try {
      result = (std::map< unsigned int,std::string,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,std::string > > > *) &(arg1)->names();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_names__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  std::map< unsigned int,std::string,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,std::string > > > *result = 0 ;
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_names" "', argument " "1"" of type '" "infomap::StateNetwork const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  {
    try {
      result = (std::map< unsigned int,std::string,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,std::string > > > *) &((infomap::StateNetwork const *)arg1)->names();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_haveDirectedInput ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_haveDirectedInput" "', argument " "1"" of type '" "infomap::StateNetwork const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  {
    try {
      result = (bool)((infomap::StateNetwork const *)arg1)->haveDirectedInput();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_haveMemoryInput ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_haveMemoryInput" "', argument " "1"" of type '" "infomap::StateNetwork const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  {
    try {
      result = (bool)((infomap::StateNetwork const *)arg1)->haveMemoryInput();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_isBipartite ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_isBipartite" "', argument " "1"" of type '" "infomap::StateNetwork const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  {
    try {
      result = (bool)((infomap::StateNetwork const *)arg1)->isBipartite();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_bipartiteStartId ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_bipartiteStartId" "', argument " "1"" of type '" "infomap::StateNetwork const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  {
    try {
      result = (unsigned int)((infomap::StateNetwork const *)arg1)->bipartiteStartId();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_setBipartiteStartId ( SEXP self, SEXP value)
{
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_setBipartiteStartId" "', argument " "1"" of type '" "infomap::StateNetwork *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  ecode2 = SWIG_AsVal_int(value, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "StateNetwork_setBipartiteStartId" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      (arg1)->setBipartiteStartId(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_writeStateNetwork ( SEXP self, SEXP filename)
{
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_writeStateNetwork" "', argument " "1"" of type '" "infomap::StateNetwork const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(filename, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "StateNetwork_writeStateNetwork" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      ((infomap::StateNetwork const *)arg1)->writeStateNetwork(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_writePajekNetwork__SWIG_0 ( SEXP self, SEXP filename, SEXP printFlow)
{
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  std::string arg2 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_writePajekNetwork" "', argument " "1"" of type '" "infomap::StateNetwork const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(filename, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "StateNetwork_writePajekNetwork" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  arg3 = LOGICAL(printFlow)[0] ? true : false;
  {
    try {
      ((infomap::StateNetwork const *)arg1)->writePajekNetwork(arg2,arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_StateNetwork_writePajekNetwork__SWIG_1 ( SEXP self, SEXP filename)
{
  infomap::StateNetwork *arg1 = (infomap::StateNetwork *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__StateNetwork, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StateNetwork_writePajekNetwork" "', argument " "1"" of type '" "infomap::StateNetwork const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::StateNetwork * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(filename, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "StateNetwork_writePajekNetwork" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      ((infomap::StateNetwork const *)arg1)->writePajekNetwork(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_Network__SWIG_0 ( )
{
  infomap::Network *result = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    try {
      result = (infomap::Network *)new infomap::Network();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__Network, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_Network__SWIG_1 ( SEXP config)
{
  infomap::Network *result = 0 ;
  infomap::Config *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(config, &argp1, SWIGTYPE_p_infomap__Config,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Network" "', argument " "1"" of type '" "infomap::Config const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Network" "', argument " "1"" of type '" "infomap::Config const &""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  {
    try {
      result = (infomap::Network *)new infomap::Network((infomap::Config const &)*arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__Network, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_Network__SWIG_2 ( SEXP flags)
{
  infomap::Network *result = 0 ;
  std::string arg1 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(flags, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "new_Network" "', argument " "1"" of type '" "std::string""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      result = (infomap::Network *)new infomap::Network(arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__Network, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_Network ( SEXP self)
{
  infomap::Network *arg1 = (infomap::Network *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Network, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Network" "', argument " "1"" of type '" "infomap::Network *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Network * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Network_clear ( SEXP self)
{
  infomap::Network *arg1 = (infomap::Network *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Network, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Network_clear" "', argument " "1"" of type '" "infomap::Network *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Network * >(argp1);
  {
    try {
      (arg1)->clear();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Network_readInputData__SWIG_0 ( SEXP self, SEXP filename, SEXP accumulate)
{
  infomap::Network *arg1 = (infomap::Network *) 0 ;
  std::string arg2 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Network, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Network_readInputData" "', argument " "1"" of type '" "infomap::Network *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Network * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(filename, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "Network_readInputData" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  arg3 = LOGICAL(accumulate)[0] ? true : false;
  {
    try {
      (arg1)->readInputData(arg2,arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Network_readInputData__SWIG_1 ( SEXP self, SEXP filename)
{
  infomap::Network *arg1 = (infomap::Network *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Network, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Network_readInputData" "', argument " "1"" of type '" "infomap::Network *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Network * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(filename, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "Network_readInputData" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      (arg1)->readInputData(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Network_readInputData__SWIG_2 ( SEXP self)
{
  infomap::Network *arg1 = (infomap::Network *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Network, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Network_readInputData" "', argument " "1"" of type '" "infomap::Network *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Network * >(argp1);
  {
    try {
      (arg1)->readInputData();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Network_readMetaData ( SEXP self, SEXP filename)
{
  infomap::Network *arg1 = (infomap::Network *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Network, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Network_readMetaData" "', argument " "1"" of type '" "infomap::Network *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Network * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(filename, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "Network_readMetaData" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      (arg1)->readMetaData(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Network_numMetaDataColumns ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::Network *arg1 = (infomap::Network *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Network, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Network_numMetaDataColumns" "', argument " "1"" of type '" "infomap::Network const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Network * >(argp1);
  {
    try {
      result = (unsigned int)((infomap::Network const *)arg1)->numMetaDataColumns();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Network_metaData ( SEXP self, SEXP s_swig_copy)
{
  std::map< unsigned int,std::vector< int,std::allocator< int > >,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,std::vector< int,std::allocator< int > > > > > *result = 0 ;
  infomap::Network *arg1 = (infomap::Network *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Network, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Network_metaData" "', argument " "1"" of type '" "infomap::Network const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Network * >(argp1);
  {
    try {
      result = (std::map< unsigned int,std::vector< int,std::allocator< int > >,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,std::vector< int,std::allocator< int > > > > > *) &((infomap::Network const *)arg1)->metaData();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_unsigned_int_std__vectorT_int_std__allocatorT_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_int_std__allocatorT_int_t_t_t_t_t, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Network_isMultilayerNetwork ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::Network *arg1 = (infomap::Network *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Network, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Network_isMultilayerNetwork" "', argument " "1"" of type '" "infomap::Network const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Network * >(argp1);
  {
    try {
      result = (bool)((infomap::Network const *)arg1)->isMultilayerNetwork();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Network_generateStateNetworkFromMultilayer ( SEXP self)
{
  infomap::Network *arg1 = (infomap::Network *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Network, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Network_generateStateNetworkFromMultilayer" "', argument " "1"" of type '" "infomap::Network *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Network * >(argp1);
  {
    try {
      (arg1)->generateStateNetworkFromMultilayer();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Network_generateStateNetworkFromMultilayerWithInterLinks ( SEXP self)
{
  infomap::Network *arg1 = (infomap::Network *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Network, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Network_generateStateNetworkFromMultilayerWithInterLinks" "', argument " "1"" of type '" "infomap::Network *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Network * >(argp1);
  {
    try {
      (arg1)->generateStateNetworkFromMultilayerWithInterLinks();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Network_generateStateNetworkFromMultilayerWithSimulatedInterLinks ( SEXP self)
{
  infomap::Network *arg1 = (infomap::Network *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Network, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Network_generateStateNetworkFromMultilayerWithSimulatedInterLinks" "', argument " "1"" of type '" "infomap::Network *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Network * >(argp1);
  {
    try {
      (arg1)->generateStateNetworkFromMultilayerWithSimulatedInterLinks();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Network_simulateInterLayerLinks ( SEXP self)
{
  infomap::Network *arg1 = (infomap::Network *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Network, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Network_simulateInterLayerLinks" "', argument " "1"" of type '" "infomap::Network *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Network * >(argp1);
  {
    try {
      (arg1)->simulateInterLayerLinks();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Network_addMultilayerLink ( SEXP self, SEXP layer1, SEXP n1, SEXP layer2, SEXP n2, SEXP weight)
{
  infomap::Network *arg1 = (infomap::Network *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  unsigned int arg5 ;
  double arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Network, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Network_addMultilayerLink" "', argument " "1"" of type '" "infomap::Network *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Network * >(argp1);
  ecode2 = SWIG_AsVal_int(layer1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Network_addMultilayerLink" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_int(n1, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Network_addMultilayerLink" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_int(layer2, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Network_addMultilayerLink" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  ecode5 = SWIG_AsVal_int(n2, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Network_addMultilayerLink" "', argument " "5"" of type '" "unsigned int""'");
  } 
  arg5 = static_cast< unsigned int >(val5);
  arg6 = static_cast< double >(REAL(weight)[0]);
  {
    try {
      (arg1)->addMultilayerLink(arg2,arg3,arg4,arg5,arg6);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Network_addMultilayerIntraLink ( SEXP self, SEXP layer, SEXP n1, SEXP n2, SEXP weight)
{
  infomap::Network *arg1 = (infomap::Network *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  double arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Network, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Network_addMultilayerIntraLink" "', argument " "1"" of type '" "infomap::Network *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Network * >(argp1);
  ecode2 = SWIG_AsVal_int(layer, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Network_addMultilayerIntraLink" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_int(n1, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Network_addMultilayerIntraLink" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_int(n2, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Network_addMultilayerIntraLink" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  arg5 = static_cast< double >(REAL(weight)[0]);
  {
    try {
      (arg1)->addMultilayerIntraLink(arg2,arg3,arg4,arg5);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Network_addMultilayerInterLink ( SEXP self, SEXP layer1, SEXP n, SEXP layer2, SEXP interWeight)
{
  infomap::Network *arg1 = (infomap::Network *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  double arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Network, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Network_addMultilayerInterLink" "', argument " "1"" of type '" "infomap::Network *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Network * >(argp1);
  ecode2 = SWIG_AsVal_int(layer1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Network_addMultilayerInterLink" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_int(n, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Network_addMultilayerInterLink" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_int(layer2, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Network_addMultilayerInterLink" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  arg5 = static_cast< double >(REAL(interWeight)[0]);
  {
    try {
      (arg1)->addMultilayerInterLink(arg2,arg3,arg4,arg5);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Network_addMetaData__SWIG_0 ( SEXP self, SEXP nodeId, SEXP meta)
{
  infomap::Network *arg1 = (infomap::Network *) 0 ;
  unsigned int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Network, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Network_addMetaData" "', argument " "1"" of type '" "infomap::Network *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Network * >(argp1);
  ecode2 = SWIG_AsVal_int(nodeId, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Network_addMetaData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  arg3 = static_cast< int >(INTEGER(meta)[0]);
  {
    try {
      (arg1)->addMetaData(arg2,arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Network_addMetaData__SWIG_1 ( SEXP self, SEXP nodeId, SEXP metaData)
{
  infomap::Network *arg1 = (infomap::Network *) 0 ;
  unsigned int arg2 ;
  std::vector< int,std::allocator< int > > *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Network, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Network_addMetaData" "', argument " "1"" of type '" "infomap::Network *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Network * >(argp1);
  ecode2 = SWIG_AsVal_int(nodeId, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Network_addMetaData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    std::vector<int> *ptr = (std::vector<int> *)0;
    res3 = swig::asptr(metaData, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Network_addMetaData" "', argument " "3"" of type '" "std::vector< int,std::allocator< int > > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Network_addMetaData" "', argument " "3"" of type '" "std::vector< int,std::allocator< int > > const &""'"); 
    }
    arg3 = ptr;
  }
  {
    try {
      (arg1)->addMetaData(arg2,(std::vector< int,std::allocator< int > > const &)*arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  if (SWIG_IsNewObj(res3)) delete arg3;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  if (SWIG_IsNewObj(res3)) delete arg3;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_LayerNode_layer_set ( SEXP self, SEXP s_layer)
{
  infomap::LayerNode *arg1 = (infomap::LayerNode *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__LayerNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LayerNode_layer_set" "', argument " "1"" of type '" "infomap::LayerNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::LayerNode * >(argp1);
  ecode2 = SWIG_AsVal_int(s_layer, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "LayerNode_layer_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->layer = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_LayerNode_layer_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::LayerNode *arg1 = (infomap::LayerNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__LayerNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LayerNode_layer_get" "', argument " "1"" of type '" "infomap::LayerNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::LayerNode * >(argp1);
  result = (unsigned int) ((arg1)->layer);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_LayerNode_node_set ( SEXP self, SEXP s_node)
{
  infomap::LayerNode *arg1 = (infomap::LayerNode *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__LayerNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LayerNode_node_set" "', argument " "1"" of type '" "infomap::LayerNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::LayerNode * >(argp1);
  ecode2 = SWIG_AsVal_int(s_node, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "LayerNode_node_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->node = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_LayerNode_node_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::LayerNode *arg1 = (infomap::LayerNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__LayerNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LayerNode_node_get" "', argument " "1"" of type '" "infomap::LayerNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::LayerNode * >(argp1);
  result = (unsigned int) ((arg1)->node);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_LayerNode__SWIG_0 ( SEXP layer, SEXP node)
{
  infomap::LayerNode *result = 0 ;
  unsigned int arg1 ;
  unsigned int arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  ecode1 = SWIG_AsVal_int(layer, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_LayerNode" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_int(node, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_LayerNode" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (infomap::LayerNode *)new infomap::LayerNode(arg1,arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__LayerNode, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_LayerNode__SWIG_1 ( SEXP layer)
{
  infomap::LayerNode *result = 0 ;
  unsigned int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  ecode1 = SWIG_AsVal_int(layer, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_LayerNode" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  {
    try {
      result = (infomap::LayerNode *)new infomap::LayerNode(arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__LayerNode, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_LayerNode__SWIG_2 ( )
{
  infomap::LayerNode *result = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    try {
      result = (infomap::LayerNode *)new infomap::LayerNode();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__LayerNode, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_LayerNode_LessThan ( SEXP self, SEXP other, SEXP s_swig_copy)
{
  bool result;
  infomap::LayerNode *arg1 = (infomap::LayerNode *) 0 ;
  infomap::LayerNode arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__LayerNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LayerNode_LessThan" "', argument " "1"" of type '" "infomap::LayerNode const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::LayerNode * >(argp1);
  {
    res2 = SWIG_R_ConvertPtr(other, &argp2, SWIGTYPE_p_infomap__LayerNode,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LayerNode_LessThan" "', argument " "2"" of type '" "infomap::LayerNode const""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "LayerNode_LessThan" "', argument " "2"" of type '" "infomap::LayerNode const""'");
    } else {
      arg2 = *(reinterpret_cast< infomap::LayerNode * >(argp2));
    }
  }
  {
    try {
      result = (bool)((infomap::LayerNode const *)arg1)->operator <(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_LayerNode ( SEXP self)
{
  infomap::LayerNode *arg1 = (infomap::LayerNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__LayerNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_LayerNode" "', argument " "1"" of type '" "infomap::LayerNode *""'"); 
  }
  arg1 = reinterpret_cast< infomap::LayerNode * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Bigram_first_set ( SEXP self, SEXP s_first)
{
  infomap::Bigram *arg1 = (infomap::Bigram *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Bigram, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Bigram_first_set" "', argument " "1"" of type '" "infomap::Bigram *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Bigram * >(argp1);
  ecode2 = SWIG_AsVal_int(s_first, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Bigram_first_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->first = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Bigram_first_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::Bigram *arg1 = (infomap::Bigram *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Bigram, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Bigram_first_get" "', argument " "1"" of type '" "infomap::Bigram *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Bigram * >(argp1);
  result = (unsigned int) ((arg1)->first);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Bigram_second_set ( SEXP self, SEXP s_second)
{
  infomap::Bigram *arg1 = (infomap::Bigram *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Bigram, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Bigram_second_set" "', argument " "1"" of type '" "infomap::Bigram *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Bigram * >(argp1);
  ecode2 = SWIG_AsVal_int(s_second, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Bigram_second_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->second = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Bigram_second_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::Bigram *arg1 = (infomap::Bigram *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Bigram, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Bigram_second_get" "', argument " "1"" of type '" "infomap::Bigram *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Bigram * >(argp1);
  result = (unsigned int) ((arg1)->second);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_Bigram__SWIG_0 ( SEXP first, SEXP second)
{
  infomap::Bigram *result = 0 ;
  unsigned int arg1 ;
  unsigned int arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  ecode1 = SWIG_AsVal_int(first, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Bigram" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_int(second, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Bigram" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (infomap::Bigram *)new infomap::Bigram(arg1,arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__Bigram, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_Bigram__SWIG_1 ( SEXP first)
{
  infomap::Bigram *result = 0 ;
  unsigned int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  ecode1 = SWIG_AsVal_int(first, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Bigram" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  {
    try {
      result = (infomap::Bigram *)new infomap::Bigram(arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__Bigram, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_Bigram__SWIG_2 ( )
{
  infomap::Bigram *result = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    try {
      result = (infomap::Bigram *)new infomap::Bigram();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__Bigram, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Bigram_LessThan ( SEXP self, SEXP other, SEXP s_swig_copy)
{
  bool result;
  infomap::Bigram *arg1 = (infomap::Bigram *) 0 ;
  infomap::Bigram arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Bigram, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Bigram_LessThan" "', argument " "1"" of type '" "infomap::Bigram const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Bigram * >(argp1);
  {
    res2 = SWIG_R_ConvertPtr(other, &argp2, SWIGTYPE_p_infomap__Bigram,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Bigram_LessThan" "', argument " "2"" of type '" "infomap::Bigram const""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Bigram_LessThan" "', argument " "2"" of type '" "infomap::Bigram const""'");
    } else {
      arg2 = *(reinterpret_cast< infomap::Bigram * >(argp2));
    }
  }
  {
    try {
      result = (bool)((infomap::Bigram const *)arg1)->operator <(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_Bigram ( SEXP self)
{
  infomap::Bigram *arg1 = (infomap::Bigram *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Bigram, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Bigram" "', argument " "1"" of type '" "infomap::Bigram *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Bigram * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_BipartiteLink_featureNode_set ( SEXP self, SEXP s_featureNode)
{
  infomap::BipartiteLink *arg1 = (infomap::BipartiteLink *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__BipartiteLink, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BipartiteLink_featureNode_set" "', argument " "1"" of type '" "infomap::BipartiteLink *""'"); 
  }
  arg1 = reinterpret_cast< infomap::BipartiteLink * >(argp1);
  ecode2 = SWIG_AsVal_int(s_featureNode, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "BipartiteLink_featureNode_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->featureNode = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_BipartiteLink_featureNode_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::BipartiteLink *arg1 = (infomap::BipartiteLink *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__BipartiteLink, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BipartiteLink_featureNode_get" "', argument " "1"" of type '" "infomap::BipartiteLink *""'"); 
  }
  arg1 = reinterpret_cast< infomap::BipartiteLink * >(argp1);
  result = (unsigned int) ((arg1)->featureNode);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_BipartiteLink_node_set ( SEXP self, SEXP s_node)
{
  infomap::BipartiteLink *arg1 = (infomap::BipartiteLink *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__BipartiteLink, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BipartiteLink_node_set" "', argument " "1"" of type '" "infomap::BipartiteLink *""'"); 
  }
  arg1 = reinterpret_cast< infomap::BipartiteLink * >(argp1);
  ecode2 = SWIG_AsVal_int(s_node, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "BipartiteLink_node_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->node = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_BipartiteLink_node_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::BipartiteLink *arg1 = (infomap::BipartiteLink *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__BipartiteLink, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BipartiteLink_node_get" "', argument " "1"" of type '" "infomap::BipartiteLink *""'"); 
  }
  arg1 = reinterpret_cast< infomap::BipartiteLink * >(argp1);
  result = (unsigned int) ((arg1)->node);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_BipartiteLink_swapOrder_set ( SEXP self, SEXP s_swapOrder)
{
  infomap::BipartiteLink *arg1 = (infomap::BipartiteLink *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__BipartiteLink, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BipartiteLink_swapOrder_set" "', argument " "1"" of type '" "infomap::BipartiteLink *""'"); 
  }
  arg1 = reinterpret_cast< infomap::BipartiteLink * >(argp1);
  arg2 = LOGICAL(s_swapOrder)[0] ? true : false;
  if (arg1) (arg1)->swapOrder = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_BipartiteLink_swapOrder_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::BipartiteLink *arg1 = (infomap::BipartiteLink *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__BipartiteLink, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BipartiteLink_swapOrder_get" "', argument " "1"" of type '" "infomap::BipartiteLink *""'"); 
  }
  arg1 = reinterpret_cast< infomap::BipartiteLink * >(argp1);
  result = (bool) ((arg1)->swapOrder);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_BipartiteLink__SWIG_0 ( SEXP featureNode, SEXP node, SEXP swapOrder)
{
  infomap::BipartiteLink *result = 0 ;
  unsigned int arg1 ;
  unsigned int arg2 ;
  bool arg3 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  ecode1 = SWIG_AsVal_int(featureNode, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_BipartiteLink" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_int(node, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_BipartiteLink" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  arg3 = LOGICAL(swapOrder)[0] ? true : false;
  {
    try {
      result = (infomap::BipartiteLink *)new infomap::BipartiteLink(arg1,arg2,arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__BipartiteLink, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_BipartiteLink__SWIG_1 ( SEXP featureNode, SEXP node)
{
  infomap::BipartiteLink *result = 0 ;
  unsigned int arg1 ;
  unsigned int arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  ecode1 = SWIG_AsVal_int(featureNode, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_BipartiteLink" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_int(node, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_BipartiteLink" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (infomap::BipartiteLink *)new infomap::BipartiteLink(arg1,arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__BipartiteLink, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_BipartiteLink__SWIG_2 ( SEXP featureNode)
{
  infomap::BipartiteLink *result = 0 ;
  unsigned int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  ecode1 = SWIG_AsVal_int(featureNode, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_BipartiteLink" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  {
    try {
      result = (infomap::BipartiteLink *)new infomap::BipartiteLink(arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__BipartiteLink, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_BipartiteLink__SWIG_3 ( )
{
  infomap::BipartiteLink *result = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    try {
      result = (infomap::BipartiteLink *)new infomap::BipartiteLink();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__BipartiteLink, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_BipartiteLink_LessThan ( SEXP self, SEXP other, SEXP s_swig_copy)
{
  bool result;
  infomap::BipartiteLink *arg1 = (infomap::BipartiteLink *) 0 ;
  infomap::BipartiteLink arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__BipartiteLink, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BipartiteLink_LessThan" "', argument " "1"" of type '" "infomap::BipartiteLink const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::BipartiteLink * >(argp1);
  {
    res2 = SWIG_R_ConvertPtr(other, &argp2, SWIGTYPE_p_infomap__BipartiteLink,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BipartiteLink_LessThan" "', argument " "2"" of type '" "infomap::BipartiteLink const""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BipartiteLink_LessThan" "', argument " "2"" of type '" "infomap::BipartiteLink const""'");
    } else {
      arg2 = *(reinterpret_cast< infomap::BipartiteLink * >(argp2));
    }
  }
  {
    try {
      result = (bool)((infomap::BipartiteLink const *)arg1)->operator <(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_BipartiteLink ( SEXP self)
{
  infomap::BipartiteLink *arg1 = (infomap::BipartiteLink *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__BipartiteLink, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_BipartiteLink" "', argument " "1"" of type '" "infomap::BipartiteLink *""'"); 
  }
  arg1 = reinterpret_cast< infomap::BipartiteLink * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Weight_weight_set ( SEXP self, SEXP s_weight)
{
  infomap::Weight *arg1 = (infomap::Weight *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Weight, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Weight_weight_set" "', argument " "1"" of type '" "infomap::Weight *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Weight * >(argp1);
  arg2 = static_cast< double >(REAL(s_weight)[0]);
  if (arg1) (arg1)->weight = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Weight_weight_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::Weight *arg1 = (infomap::Weight *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Weight, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Weight_weight_get" "', argument " "1"" of type '" "infomap::Weight *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Weight * >(argp1);
  result = (double) ((arg1)->weight);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_Weight__SWIG_0 ( SEXP weight)
{
  infomap::Weight *result = 0 ;
  double arg1 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  arg1 = static_cast< double >(REAL(weight)[0]);
  {
    try {
      result = (infomap::Weight *)new infomap::Weight(arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__Weight, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_Weight__SWIG_1 ( )
{
  infomap::Weight *result = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    try {
      result = (infomap::Weight *)new infomap::Weight();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__Weight, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Weight_PlusEqual ( SEXP self, SEXP w, SEXP s_swig_copy)
{
  infomap::Weight *result = 0 ;
  infomap::Weight *arg1 = (infomap::Weight *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Weight, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Weight_PlusEqual" "', argument " "1"" of type '" "infomap::Weight *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Weight * >(argp1);
  arg2 = static_cast< double >(REAL(w)[0]);
  {
    try {
      result = (infomap::Weight *) &(arg1)->operator +=(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__Weight, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_Weight ( SEXP self)
{
  infomap::Weight *arg1 = (infomap::Weight *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Weight, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Weight" "', argument " "1"" of type '" "infomap::Weight *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Weight * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_Triple__SWIG_0 ( )
{
  infomap::Triple *result = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    try {
      result = (infomap::Triple *)new infomap::Triple();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__Triple, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_Triple__SWIG_1 ( SEXP value1, SEXP value2, SEXP value3)
{
  infomap::Triple *result = 0 ;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  ecode1 = SWIG_AsVal_int(value1, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Triple" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_int(value2, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Triple" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_int(value3, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Triple" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    try {
      result = (infomap::Triple *)new infomap::Triple(arg1,arg2,arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__Triple, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_Triple__SWIG_2 ( SEXP other)
{
  infomap::Triple *result = 0 ;
  infomap::Triple *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(other, &argp1, SWIGTYPE_p_infomap__Triple,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Triple" "', argument " "1"" of type '" "infomap::Triple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Triple" "', argument " "1"" of type '" "infomap::Triple const &""'"); 
  }
  arg1 = reinterpret_cast< infomap::Triple * >(argp1);
  {
    try {
      result = (infomap::Triple *)new infomap::Triple((infomap::Triple const &)*arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__Triple, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Triple_LessThan ( SEXP self, SEXP other, SEXP s_swig_copy)
{
  bool result;
  infomap::Triple *arg1 = (infomap::Triple *) 0 ;
  infomap::Triple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Triple, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Triple_LessThan" "', argument " "1"" of type '" "infomap::Triple const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Triple * >(argp1);
  res2 = SWIG_R_ConvertPtr(other, &argp2, SWIGTYPE_p_infomap__Triple,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Triple_LessThan" "', argument " "2"" of type '" "infomap::Triple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Triple_LessThan" "', argument " "2"" of type '" "infomap::Triple const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::Triple * >(argp2);
  {
    try {
      result = (bool)((infomap::Triple const *)arg1)->operator <((infomap::Triple const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Triple_EqualEqual ( SEXP self, SEXP other, SEXP s_swig_copy)
{
  bool result;
  infomap::Triple *arg1 = (infomap::Triple *) 0 ;
  infomap::Triple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Triple, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Triple_EqualEqual" "', argument " "1"" of type '" "infomap::Triple const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Triple * >(argp1);
  res2 = SWIG_R_ConvertPtr(other, &argp2, SWIGTYPE_p_infomap__Triple,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Triple_EqualEqual" "', argument " "2"" of type '" "infomap::Triple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Triple_EqualEqual" "', argument " "2"" of type '" "infomap::Triple const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::Triple * >(argp2);
  {
    try {
      result = (bool)((infomap::Triple const *)arg1)->operator ==((infomap::Triple const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Triple_n1_set ( SEXP self, SEXP s_n1)
{
  infomap::Triple *arg1 = (infomap::Triple *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Triple, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Triple_n1_set" "', argument " "1"" of type '" "infomap::Triple *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Triple * >(argp1);
  ecode2 = SWIG_AsVal_int(s_n1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Triple_n1_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->n1 = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Triple_n1_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::Triple *arg1 = (infomap::Triple *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Triple, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Triple_n1_get" "', argument " "1"" of type '" "infomap::Triple *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Triple * >(argp1);
  result = (unsigned int) ((arg1)->n1);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Triple_n2_set ( SEXP self, SEXP s_n2)
{
  infomap::Triple *arg1 = (infomap::Triple *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Triple, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Triple_n2_set" "', argument " "1"" of type '" "infomap::Triple *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Triple * >(argp1);
  ecode2 = SWIG_AsVal_int(s_n2, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Triple_n2_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->n2 = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Triple_n2_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::Triple *arg1 = (infomap::Triple *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Triple, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Triple_n2_get" "', argument " "1"" of type '" "infomap::Triple *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Triple * >(argp1);
  result = (unsigned int) ((arg1)->n2);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Triple_n3_set ( SEXP self, SEXP s_n3)
{
  infomap::Triple *arg1 = (infomap::Triple *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Triple, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Triple_n3_set" "', argument " "1"" of type '" "infomap::Triple *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Triple * >(argp1);
  ecode2 = SWIG_AsVal_int(s_n3, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Triple_n3_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->n3 = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_Triple_n3_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::Triple *arg1 = (infomap::Triple *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Triple, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Triple_n3_get" "', argument " "1"" of type '" "infomap::Triple *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Triple * >(argp1);
  result = (unsigned int) ((arg1)->n3);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_Triple ( SEXP self)
{
  infomap::Triple *arg1 = (infomap::Triple *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__Triple, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Triple" "', argument " "1"" of type '" "infomap::Triple *""'"); 
  }
  arg1 = reinterpret_cast< infomap::Triple * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_map_uint_uint__SWIG_0 ( SEXP other)
{
  std::map< unsigned int,unsigned int > *result = 0 ;
  std::less< unsigned int > *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(other, &argp1, SWIGTYPE_p_std__lessT_unsigned_int_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_map_uint_uint" "', argument " "1"" of type '" "std::less< unsigned int > const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_map_uint_uint" "', argument " "1"" of type '" "std::less< unsigned int > const &""'"); 
  }
  arg1 = reinterpret_cast< std::less< unsigned int > * >(argp1);
  {
    try {
      result = (std::map< unsigned int,unsigned int > *)new std::map< unsigned int,unsigned int >((std::less< unsigned int > const &)*arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_map_uint_uint__SWIG_1 ( )
{
  std::map< unsigned int,unsigned int > *result = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    try {
      result = (std::map< unsigned int,unsigned int > *)new std::map< unsigned int,unsigned int >();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_map_uint_uint__SWIG_2 ( SEXP other)
{
  std::map< unsigned int,unsigned int > *result = 0 ;
  std::map< unsigned int,unsigned int > *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    std::map< unsigned int,unsigned int,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,unsigned int > > > *ptr = (std::map< unsigned int,unsigned int,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,unsigned int > > > *)0;
    res1 = swig::asptr(other, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_map_uint_uint" "', argument " "1"" of type '" "std::map< unsigned int,unsigned int > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_map_uint_uint" "', argument " "1"" of type '" "std::map< unsigned int,unsigned int > const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (std::map< unsigned int,unsigned int > *)new std::map< unsigned int,unsigned int >((std::map< unsigned int,unsigned int > const &)*arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  if (SWIG_IsNewObj(res1)) delete arg1;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_map_uint_uint_empty ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  std::map< unsigned int,unsigned int > *arg1 = (std::map< unsigned int,unsigned int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "map_uint_uint_empty" "', argument " "1"" of type '" "std::map< unsigned int,unsigned int > const *""'"); 
  }
  arg1 = reinterpret_cast< std::map< unsigned int,unsigned int > * >(argp1);
  {
    try {
      result = (bool)((std::map< unsigned int,unsigned int > const *)arg1)->empty();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_map_uint_uint_size ( SEXP self, SEXP s_swig_copy)
{
  std::map< unsigned int,unsigned int >::size_type result;
  std::map< unsigned int,unsigned int > *arg1 = (std::map< unsigned int,unsigned int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "map_uint_uint_size" "', argument " "1"" of type '" "std::map< unsigned int,unsigned int > const *""'"); 
  }
  arg1 = reinterpret_cast< std::map< unsigned int,unsigned int > * >(argp1);
  {
    try {
      result = ((std::map< unsigned int,unsigned int > const *)arg1)->size();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_map_uint_uint_swap ( SEXP self, SEXP v)
{
  std::map< unsigned int,unsigned int > *arg1 = (std::map< unsigned int,unsigned int > *) 0 ;
  std::map< unsigned int,unsigned int > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "map_uint_uint_swap" "', argument " "1"" of type '" "std::map< unsigned int,unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::map< unsigned int,unsigned int > * >(argp1);
  res2 = SWIG_R_ConvertPtr(v, &argp2, SWIGTYPE_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "map_uint_uint_swap" "', argument " "2"" of type '" "std::map< unsigned int,unsigned int > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "map_uint_uint_swap" "', argument " "2"" of type '" "std::map< unsigned int,unsigned int > &""'"); 
  }
  arg2 = reinterpret_cast< std::map< unsigned int,unsigned int > * >(argp2);
  {
    try {
      (arg1)->swap(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_map_uint_uint_clear ( SEXP self)
{
  std::map< unsigned int,unsigned int > *arg1 = (std::map< unsigned int,unsigned int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "map_uint_uint_clear" "', argument " "1"" of type '" "std::map< unsigned int,unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::map< unsigned int,unsigned int > * >(argp1);
  {
    try {
      (arg1)->clear();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_map_uint_uint_get_allocator ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< std::allocator< std::pair< unsigned int const,unsigned int > > > result;
  std::map< unsigned int,unsigned int > *arg1 = (std::map< unsigned int,unsigned int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "map_uint_uint_get_allocator" "', argument " "1"" of type '" "std::map< unsigned int,unsigned int > const *""'"); 
  }
  arg1 = reinterpret_cast< std::map< unsigned int,unsigned int > * >(argp1);
  {
    try {
      result = ((std::map< unsigned int,unsigned int > const *)arg1)->get_allocator();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new std::map< unsigned int,unsigned int >::allocator_type(static_cast< const std::map< unsigned int,unsigned int >::allocator_type& >(result))), SWIGTYPE_p_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_map_uint_uint_erase ( SEXP self, SEXP x, SEXP s_swig_copy)
{
  std::map< unsigned int,unsigned int >::size_type result;
  std::map< unsigned int,unsigned int > *arg1 = (std::map< unsigned int,unsigned int > *) 0 ;
  std::map< unsigned int,unsigned int >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< unsigned int,unsigned int >::key_type temp2 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "map_uint_uint_erase" "', argument " "1"" of type '" "std::map< unsigned int,unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::map< unsigned int,unsigned int > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(x, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "map_uint_uint_erase" "', argument " "2"" of type '" "std::map< unsigned int,unsigned int >::key_type""'");
  } 
  temp2 = static_cast< std::map< unsigned int,unsigned int >::key_type >(val2);
  arg2 = &temp2;
  {
    try {
      result = (arg1)->erase((std::map< unsigned int,unsigned int >::key_type const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_map_uint_uint_count ( SEXP self, SEXP x, SEXP s_swig_copy)
{
  std::map< unsigned int,unsigned int >::size_type result;
  std::map< unsigned int,unsigned int > *arg1 = (std::map< unsigned int,unsigned int > *) 0 ;
  std::map< unsigned int,unsigned int >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< unsigned int,unsigned int >::key_type temp2 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "map_uint_uint_count" "', argument " "1"" of type '" "std::map< unsigned int,unsigned int > const *""'"); 
  }
  arg1 = reinterpret_cast< std::map< unsigned int,unsigned int > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(x, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "map_uint_uint_count" "', argument " "2"" of type '" "std::map< unsigned int,unsigned int >::key_type""'");
  } 
  temp2 = static_cast< std::map< unsigned int,unsigned int >::key_type >(val2);
  arg2 = &temp2;
  {
    try {
      result = ((std::map< unsigned int,unsigned int > const *)arg1)->count((std::map< unsigned int,unsigned int >::key_type const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_map_uint_uint ( SEXP self)
{
  std::map< unsigned int,unsigned int > *arg1 = (std::map< unsigned int,unsigned int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_map_uint_uint" "', argument " "1"" of type '" "std::map< unsigned int,unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::map< unsigned int,unsigned int > * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_double___nonzero__ ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_double___nonzero__" "', argument " "1"" of type '" "std::vector< double > const *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  {
    try {
      result = (bool)std_vector_Sl_double_Sg____nonzero__((std::vector< double > const *)arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_double___len__ ( SEXP self, SEXP s_swig_copy)
{
  std::vector< double >::size_type result;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_double___len__" "', argument " "1"" of type '" "std::vector< double > const *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  {
    try {
      result = std_vector_Sl_double_Sg____len__((std::vector< double > const *)arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_double_pop ( SEXP self, SEXP s_swig_copy)
{
  std::vector< double >::value_type result;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_double_pop" "', argument " "1"" of type '" "std::vector< double > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  {
    try {
      try {
        result = (std::vector< double >::value_type)std_vector_Sl_double_Sg__pop(arg1);
      } catch(std::out_of_range &_e) {
        /*@SWIG:/usr/local/Cellar/swig/4.0.2/share/swig/4.0.2/r/r.swg,29,%raise@*/ 
        return R_NilValue;
        /*@SWIG@*/;
      }
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_double___getslice__ ( SEXP self, SEXP i, SEXP j)
{
  std::vector< double,std::allocator< double > > *result = 0 ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  std::vector< double >::difference_type arg2 ;
  std::vector< double >::difference_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_double___getslice__" "', argument " "1"" of type '" "std::vector< double > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  ecode2 = SWIG_AsVal_int(i, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "vector_double___getslice__" "', argument " "2"" of type '" "std::vector< double >::difference_type""'");
  } 
  arg2 = static_cast< std::vector< double >::difference_type >(val2);
  ecode3 = SWIG_AsVal_int(j, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "vector_double___getslice__" "', argument " "3"" of type '" "std::vector< double >::difference_type""'");
  } 
  arg3 = static_cast< std::vector< double >::difference_type >(val3);
  {
    try {
      try {
        result = (std::vector< double,std::allocator< double > > *)std_vector_Sl_double_Sg____getslice__(arg1,arg2,arg3);
      } catch(std::out_of_range &_e) {
        /*@SWIG:/usr/local/Cellar/swig/4.0.2/share/swig/4.0.2/r/r.swg,29,%raise@*/ 
        return R_NilValue;
        /*@SWIG@*/;
      }
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_double___setslice__ ( SEXP self, SEXP i, SEXP j, SEXP v)
{
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  std::vector< double >::difference_type arg2 ;
  std::vector< double >::difference_type arg3 ;
  std::vector< double,std::allocator< double > > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_double___setslice__" "', argument " "1"" of type '" "std::vector< double > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  ecode2 = SWIG_AsVal_int(i, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "vector_double___setslice__" "', argument " "2"" of type '" "std::vector< double >::difference_type""'");
  } 
  arg2 = static_cast< std::vector< double >::difference_type >(val2);
  ecode3 = SWIG_AsVal_int(j, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "vector_double___setslice__" "', argument " "3"" of type '" "std::vector< double >::difference_type""'");
  } 
  arg3 = static_cast< std::vector< double >::difference_type >(val3);
  {
    std::vector< double,std::allocator< double > > *ptr = (std::vector< double,std::allocator< double > > *)0;
    res4 = swig::asptr(v, &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "vector_double___setslice__" "', argument " "4"" of type '" "std::vector< double,std::allocator< double > > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "vector_double___setslice__" "', argument " "4"" of type '" "std::vector< double,std::allocator< double > > const &""'"); 
    }
    arg4 = ptr;
  }
  {
    try {
      try {
        std_vector_Sl_double_Sg____setslice__(arg1,arg2,arg3,(std::vector< double,std::allocator< double > > const &)*arg4);
      } catch(std::out_of_range &_e) {
        /*@SWIG:/usr/local/Cellar/swig/4.0.2/share/swig/4.0.2/r/r.swg,29,%raise@*/ 
        return R_NilValue;
        /*@SWIG@*/;
      } catch(std::invalid_argument &_e) {
        /*@SWIG:/usr/local/Cellar/swig/4.0.2/share/swig/4.0.2/r/r.swg,29,%raise@*/ 
        return R_NilValue;
        /*@SWIG@*/;
      }
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  if (SWIG_IsNewObj(res4)) delete arg4;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  if (SWIG_IsNewObj(res4)) delete arg4;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_double___delslice__ ( SEXP self, SEXP i, SEXP j)
{
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  std::vector< double >::difference_type arg2 ;
  std::vector< double >::difference_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_double___delslice__" "', argument " "1"" of type '" "std::vector< double > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  ecode2 = SWIG_AsVal_int(i, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "vector_double___delslice__" "', argument " "2"" of type '" "std::vector< double >::difference_type""'");
  } 
  arg2 = static_cast< std::vector< double >::difference_type >(val2);
  ecode3 = SWIG_AsVal_int(j, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "vector_double___delslice__" "', argument " "3"" of type '" "std::vector< double >::difference_type""'");
  } 
  arg3 = static_cast< std::vector< double >::difference_type >(val3);
  {
    try {
      try {
        std_vector_Sl_double_Sg____delslice__(arg1,arg2,arg3);
      } catch(std::out_of_range &_e) {
        /*@SWIG:/usr/local/Cellar/swig/4.0.2/share/swig/4.0.2/r/r.swg,29,%raise@*/ 
        return R_NilValue;
        /*@SWIG@*/;
      }
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_double___delitem__ ( SEXP self, SEXP i)
{
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  std::vector< double >::difference_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_double___delitem__" "', argument " "1"" of type '" "std::vector< double > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  ecode2 = SWIG_AsVal_int(i, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "vector_double___delitem__" "', argument " "2"" of type '" "std::vector< double >::difference_type""'");
  } 
  arg2 = static_cast< std::vector< double >::difference_type >(val2);
  {
    try {
      try {
        std_vector_Sl_double_Sg____delitem__(arg1,arg2);
      } catch(std::out_of_range &_e) {
        /*@SWIG:/usr/local/Cellar/swig/4.0.2/share/swig/4.0.2/r/r.swg,29,%raise@*/ 
        return R_NilValue;
        /*@SWIG@*/;
      }
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_double___getitem__ ( SEXP self, SEXP i, SEXP s_swig_copy)
{
  std::vector< double >::value_type *result = 0 ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  std::vector< double >::difference_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_double___getitem__" "', argument " "1"" of type '" "std::vector< double > const *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  ecode2 = SWIG_AsVal_int(i, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "vector_double___getitem__" "', argument " "2"" of type '" "std::vector< double >::difference_type""'");
  } 
  arg2 = static_cast< std::vector< double >::difference_type >(val2);
  {
    try {
      try {
        result = (std::vector< double >::value_type *) &std_vector_Sl_double_Sg____getitem__((std::vector< double > const *)arg1,arg2);
      } catch(std::out_of_range &_e) {
        /*@SWIG:/usr/local/Cellar/swig/4.0.2/share/swig/4.0.2/r/r.swg,29,%raise@*/ 
        return R_NilValue;
        /*@SWIG@*/;
      }
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(*result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_double___setitem__ ( SEXP self, SEXP i, SEXP x)
{
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  std::vector< double >::difference_type arg2 ;
  std::vector< double >::value_type *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  std::vector< double >::value_type temp3 ;
  double val3 ;
  int ecode3 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_double___setitem__" "', argument " "1"" of type '" "std::vector< double > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  ecode2 = SWIG_AsVal_int(i, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "vector_double___setitem__" "', argument " "2"" of type '" "std::vector< double >::difference_type""'");
  } 
  arg2 = static_cast< std::vector< double >::difference_type >(val2);
  ecode3 = SWIG_AsVal_double(x, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "vector_double___setitem__" "', argument " "3"" of type '" "std::vector< double >::value_type""'");
  } 
  temp3 = static_cast< std::vector< double >::value_type >(val3);
  arg3 = &temp3;
  {
    try {
      try {
        std_vector_Sl_double_Sg____setitem__(arg1,arg2,(double const &)*arg3);
      } catch(std::out_of_range &_e) {
        /*@SWIG:/usr/local/Cellar/swig/4.0.2/share/swig/4.0.2/r/r.swg,29,%raise@*/ 
        return R_NilValue;
        /*@SWIG@*/;
      }
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_double_append ( SEXP self, SEXP x)
{
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  std::vector< double >::value_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< double >::value_type temp2 ;
  double val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_double_append" "', argument " "1"" of type '" "std::vector< double > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  ecode2 = SWIG_AsVal_double(x, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "vector_double_append" "', argument " "2"" of type '" "std::vector< double >::value_type""'");
  } 
  temp2 = static_cast< std::vector< double >::value_type >(val2);
  arg2 = &temp2;
  {
    try {
      std_vector_Sl_double_Sg__append(arg1,(double const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_vector_double__SWIG_0 ( )
{
  std::vector< double > *result = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    try {
      result = (std::vector< double > *)new std::vector< double >();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_vector_double__SWIG_1 ( SEXP other)
{
  std::vector< double > *result = 0 ;
  std::vector< double > *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    std::vector< double,std::allocator< double > > *ptr = (std::vector< double,std::allocator< double > > *)0;
    res1 = swig::asptr(other, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_vector_double" "', argument " "1"" of type '" "std::vector< double > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_vector_double" "', argument " "1"" of type '" "std::vector< double > const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (std::vector< double > *)new std::vector< double >((std::vector< double > const &)*arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  if (SWIG_IsNewObj(res1)) delete arg1;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_double_empty ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_double_empty" "', argument " "1"" of type '" "std::vector< double > const *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  {
    try {
      result = (bool)((std::vector< double > const *)arg1)->empty();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_double_size ( SEXP self, SEXP s_swig_copy)
{
  std::vector< double >::size_type result;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_double_size" "', argument " "1"" of type '" "std::vector< double > const *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  {
    try {
      result = ((std::vector< double > const *)arg1)->size();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_double_swap ( SEXP self, SEXP v)
{
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  std::vector< double > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_double_swap" "', argument " "1"" of type '" "std::vector< double > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  res2 = SWIG_R_ConvertPtr(v, &argp2, SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "vector_double_swap" "', argument " "2"" of type '" "std::vector< double > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "vector_double_swap" "', argument " "2"" of type '" "std::vector< double > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector< double > * >(argp2);
  {
    try {
      (arg1)->swap(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_double_clear ( SEXP self)
{
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_double_clear" "', argument " "1"" of type '" "std::vector< double > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  {
    try {
      (arg1)->clear();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_double_get_allocator ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< std::allocator< double > > result;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_double_get_allocator" "', argument " "1"" of type '" "std::vector< double > const *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  {
    try {
      result = ((std::vector< double > const *)arg1)->get_allocator();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new std::vector< double >::allocator_type(static_cast< const std::vector< double >::allocator_type& >(result))), SWIGTYPE_p_std__allocatorT_double_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_vector_double__SWIG_2 ( SEXP size)
{
  std::vector< double > *result = 0 ;
  std::vector< double >::size_type arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  ecode1 = SWIG_AsVal_int(size, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_vector_double" "', argument " "1"" of type '" "std::vector< double >::size_type""'");
  } 
  arg1 = static_cast< std::vector< double >::size_type >(val1);
  {
    try {
      result = (std::vector< double > *)new std::vector< double >(arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_double_pop_back ( SEXP self)
{
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_double_pop_back" "', argument " "1"" of type '" "std::vector< double > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  {
    try {
      (arg1)->pop_back();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_double_resize__SWIG_0 ( SEXP self, SEXP new_size)
{
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  std::vector< double >::size_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_double_resize" "', argument " "1"" of type '" "std::vector< double > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  ecode2 = SWIG_AsVal_int(new_size, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "vector_double_resize" "', argument " "2"" of type '" "std::vector< double >::size_type""'");
  } 
  arg2 = static_cast< std::vector< double >::size_type >(val2);
  {
    try {
      (arg1)->resize(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_vector_double__SWIG_3 ( SEXP size, SEXP value)
{
  std::vector< double > *result = 0 ;
  std::vector< double >::size_type arg1 ;
  std::vector< double >::value_type *arg2 = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  std::vector< double >::value_type temp2 ;
  double val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  ecode1 = SWIG_AsVal_int(size, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_vector_double" "', argument " "1"" of type '" "std::vector< double >::size_type""'");
  } 
  arg1 = static_cast< std::vector< double >::size_type >(val1);
  ecode2 = SWIG_AsVal_double(value, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_vector_double" "', argument " "2"" of type '" "std::vector< double >::value_type""'");
  } 
  temp2 = static_cast< std::vector< double >::value_type >(val2);
  arg2 = &temp2;
  {
    try {
      result = (std::vector< double > *)new std::vector< double >(arg1,(std::vector< double >::value_type const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_double_push_back ( SEXP self, SEXP x)
{
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  std::vector< double >::value_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< double >::value_type temp2 ;
  double val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_double_push_back" "', argument " "1"" of type '" "std::vector< double > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  ecode2 = SWIG_AsVal_double(x, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "vector_double_push_back" "', argument " "2"" of type '" "std::vector< double >::value_type""'");
  } 
  temp2 = static_cast< std::vector< double >::value_type >(val2);
  arg2 = &temp2;
  {
    try {
      (arg1)->push_back((std::vector< double >::value_type const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_double_front ( SEXP self, SEXP s_swig_copy)
{
  std::vector< double >::value_type *result = 0 ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_double_front" "', argument " "1"" of type '" "std::vector< double > const *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  {
    try {
      result = (std::vector< double >::value_type *) &((std::vector< double > const *)arg1)->front();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(*result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_double_back ( SEXP self, SEXP s_swig_copy)
{
  std::vector< double >::value_type *result = 0 ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_double_back" "', argument " "1"" of type '" "std::vector< double > const *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  {
    try {
      result = (std::vector< double >::value_type *) &((std::vector< double > const *)arg1)->back();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(*result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_double_assign ( SEXP self, SEXP n, SEXP x)
{
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  std::vector< double >::size_type arg2 ;
  std::vector< double >::value_type *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  std::vector< double >::value_type temp3 ;
  double val3 ;
  int ecode3 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_double_assign" "', argument " "1"" of type '" "std::vector< double > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  ecode2 = SWIG_AsVal_int(n, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "vector_double_assign" "', argument " "2"" of type '" "std::vector< double >::size_type""'");
  } 
  arg2 = static_cast< std::vector< double >::size_type >(val2);
  ecode3 = SWIG_AsVal_double(x, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "vector_double_assign" "', argument " "3"" of type '" "std::vector< double >::value_type""'");
  } 
  temp3 = static_cast< std::vector< double >::value_type >(val3);
  arg3 = &temp3;
  {
    try {
      (arg1)->assign(arg2,(std::vector< double >::value_type const &)*arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_double_resize__SWIG_1 ( SEXP self, SEXP new_size, SEXP x)
{
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  std::vector< double >::size_type arg2 ;
  std::vector< double >::value_type *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  std::vector< double >::value_type temp3 ;
  double val3 ;
  int ecode3 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_double_resize" "', argument " "1"" of type '" "std::vector< double > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  ecode2 = SWIG_AsVal_int(new_size, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "vector_double_resize" "', argument " "2"" of type '" "std::vector< double >::size_type""'");
  } 
  arg2 = static_cast< std::vector< double >::size_type >(val2);
  ecode3 = SWIG_AsVal_double(x, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "vector_double_resize" "', argument " "3"" of type '" "std::vector< double >::value_type""'");
  } 
  temp3 = static_cast< std::vector< double >::value_type >(val3);
  arg3 = &temp3;
  {
    try {
      (arg1)->resize(arg2,(std::vector< double >::value_type const &)*arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_double_reserve ( SEXP self, SEXP n)
{
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  std::vector< double >::size_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_double_reserve" "', argument " "1"" of type '" "std::vector< double > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  ecode2 = SWIG_AsVal_int(n, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "vector_double_reserve" "', argument " "2"" of type '" "std::vector< double >::size_type""'");
  } 
  arg2 = static_cast< std::vector< double >::size_type >(val2);
  {
    try {
      (arg1)->reserve(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_vector_double_capacity ( SEXP self, SEXP s_swig_copy)
{
  std::vector< double >::size_type result;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vector_double_capacity" "', argument " "1"" of type '" "std::vector< double > const *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  {
    try {
      result = ((std::vector< double > const *)arg1)->capacity();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_vector_double ( SEXP self)
{
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_vector_double" "', argument " "1"" of type '" "std::vector< double > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfomapConfigInfomapBase__SWIG_0 ( )
{
  infomap::InfomapConfig< infomap::InfomapBase > *result = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    try {
      result = (infomap::InfomapConfig< infomap::InfomapBase > *)new infomap::InfomapConfig< infomap::InfomapBase >();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapConfigT_infomap__InfomapBase_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfomapConfigInfomapBase__SWIG_1 ( SEXP flags)
{
  infomap::InfomapConfig< infomap::InfomapBase > *result = 0 ;
  std::string arg1 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(flags, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "new_InfomapConfigInfomapBase" "', argument " "1"" of type '" "std::string const""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      result = (infomap::InfomapConfig< infomap::InfomapBase > *)new infomap::InfomapConfig< infomap::InfomapBase >(arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapConfigT_infomap__InfomapBase_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfomapConfigInfomapBase__SWIG_2 ( SEXP conf)
{
  infomap::InfomapConfig< infomap::InfomapBase > *result = 0 ;
  infomap::Config *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(conf, &argp1, SWIGTYPE_p_infomap__Config,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InfomapConfigInfomapBase" "', argument " "1"" of type '" "infomap::Config const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InfomapConfigInfomapBase" "', argument " "1"" of type '" "infomap::Config const &""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  {
    try {
      result = (infomap::InfomapConfig< infomap::InfomapBase > *)new infomap::InfomapConfig< infomap::InfomapBase >((infomap::Config const &)*arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapConfigT_infomap__InfomapBase_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_InfomapConfigInfomapBase ( SEXP self)
{
  infomap::InfomapConfig< infomap::InfomapBase > *arg1 = (infomap::InfomapConfig< infomap::InfomapBase > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapConfigT_infomap__InfomapBase_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_InfomapConfigInfomapBase" "', argument " "1"" of type '" "infomap::InfomapConfig< infomap::InfomapBase > *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapConfig< infomap::InfomapBase > * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapConfigInfomapBase_getConfig__SWIG_0 ( SEXP self, SEXP s_swig_copy)
{
  infomap::Config *result = 0 ;
  infomap::InfomapConfig< infomap::InfomapBase > *arg1 = (infomap::InfomapConfig< infomap::InfomapBase > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapConfigT_infomap__InfomapBase_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapConfigInfomapBase_getConfig" "', argument " "1"" of type '" "infomap::InfomapConfig< infomap::InfomapBase > *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapConfig< infomap::InfomapBase > * >(argp1);
  {
    try {
      result = (infomap::Config *) &(arg1)->getConfig();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__Config, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapConfigInfomapBase_getConfig__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  infomap::Config *result = 0 ;
  infomap::InfomapConfig< infomap::InfomapBase > *arg1 = (infomap::InfomapConfig< infomap::InfomapBase > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapConfigT_infomap__InfomapBase_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapConfigInfomapBase_getConfig" "', argument " "1"" of type '" "infomap::InfomapConfig< infomap::InfomapBase > const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapConfig< infomap::InfomapBase > * >(argp1);
  {
    try {
      result = (infomap::Config *) &((infomap::InfomapConfig< infomap::InfomapBase > const *)arg1)->getConfig();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__Config, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapConfigInfomapBase_setConfig ( SEXP self, SEXP conf, SEXP s_swig_copy)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfomapConfig< infomap::InfomapBase > *arg1 = (infomap::InfomapConfig< infomap::InfomapBase > *) 0 ;
  infomap::Config *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapConfigT_infomap__InfomapBase_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapConfigInfomapBase_setConfig" "', argument " "1"" of type '" "infomap::InfomapConfig< infomap::InfomapBase > *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapConfig< infomap::InfomapBase > * >(argp1);
  res2 = SWIG_R_ConvertPtr(conf, &argp2, SWIGTYPE_p_infomap__Config,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapConfigInfomapBase_setConfig" "', argument " "2"" of type '" "infomap::Config const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapConfigInfomapBase_setConfig" "', argument " "2"" of type '" "infomap::Config const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::Config * >(argp2);
  {
    try {
      result = (infomap::InfomapBase *) &(arg1)->setConfig((infomap::Config const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapConfigInfomapBase_setNonMainConfig ( SEXP self, SEXP conf, SEXP s_swig_copy)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfomapConfig< infomap::InfomapBase > *arg1 = (infomap::InfomapConfig< infomap::InfomapBase > *) 0 ;
  infomap::Config *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapConfigT_infomap__InfomapBase_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapConfigInfomapBase_setNonMainConfig" "', argument " "1"" of type '" "infomap::InfomapConfig< infomap::InfomapBase > *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapConfig< infomap::InfomapBase > * >(argp1);
  res2 = SWIG_R_ConvertPtr(conf, &argp2, SWIGTYPE_p_infomap__Config,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapConfigInfomapBase_setNonMainConfig" "', argument " "2"" of type '" "infomap::Config const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapConfigInfomapBase_setNonMainConfig" "', argument " "2"" of type '" "infomap::Config const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::Config * >(argp2);
  {
    try {
      result = (infomap::InfomapBase *) &(arg1)->setNonMainConfig((infomap::Config const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapConfigInfomapBase_setNumTrials ( SEXP self, SEXP N, SEXP s_swig_copy)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfomapConfig< infomap::InfomapBase > *arg1 = (infomap::InfomapConfig< infomap::InfomapBase > *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapConfigT_infomap__InfomapBase_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapConfigInfomapBase_setNumTrials" "', argument " "1"" of type '" "infomap::InfomapConfig< infomap::InfomapBase > *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapConfig< infomap::InfomapBase > * >(argp1);
  ecode2 = SWIG_AsVal_int(N, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapConfigInfomapBase_setNumTrials" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (infomap::InfomapBase *) &(arg1)->setNumTrials(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapConfigInfomapBase_setVerbosity ( SEXP self, SEXP level, SEXP s_swig_copy)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfomapConfig< infomap::InfomapBase > *arg1 = (infomap::InfomapConfig< infomap::InfomapBase > *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapConfigT_infomap__InfomapBase_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapConfigInfomapBase_setVerbosity" "', argument " "1"" of type '" "infomap::InfomapConfig< infomap::InfomapBase > *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapConfig< infomap::InfomapBase > * >(argp1);
  ecode2 = SWIG_AsVal_int(level, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapConfigInfomapBase_setVerbosity" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (infomap::InfomapBase *) &(arg1)->setVerbosity(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapConfigInfomapBase_setTwoLevel ( SEXP self, SEXP value, SEXP s_swig_copy)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfomapConfig< infomap::InfomapBase > *arg1 = (infomap::InfomapConfig< infomap::InfomapBase > *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapConfigT_infomap__InfomapBase_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapConfigInfomapBase_setTwoLevel" "', argument " "1"" of type '" "infomap::InfomapConfig< infomap::InfomapBase > *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapConfig< infomap::InfomapBase > * >(argp1);
  arg2 = LOGICAL(value)[0] ? true : false;
  {
    try {
      result = (infomap::InfomapBase *) &(arg1)->setTwoLevel(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapConfigInfomapBase_setTuneIterationLimit ( SEXP self, SEXP value, SEXP s_swig_copy)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfomapConfig< infomap::InfomapBase > *arg1 = (infomap::InfomapConfig< infomap::InfomapBase > *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapConfigT_infomap__InfomapBase_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapConfigInfomapBase_setTuneIterationLimit" "', argument " "1"" of type '" "infomap::InfomapConfig< infomap::InfomapBase > *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapConfig< infomap::InfomapBase > * >(argp1);
  ecode2 = SWIG_AsVal_int(value, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapConfigInfomapBase_setTuneIterationLimit" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (infomap::InfomapBase *) &(arg1)->setTuneIterationLimit(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapConfigInfomapBase_setFastHierarchicalSolution ( SEXP self, SEXP level, SEXP s_swig_copy)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfomapConfig< infomap::InfomapBase > *arg1 = (infomap::InfomapConfig< infomap::InfomapBase > *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapConfigT_infomap__InfomapBase_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapConfigInfomapBase_setFastHierarchicalSolution" "', argument " "1"" of type '" "infomap::InfomapConfig< infomap::InfomapBase > *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapConfig< infomap::InfomapBase > * >(argp1);
  ecode2 = SWIG_AsVal_int(level, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapConfigInfomapBase_setFastHierarchicalSolution" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (infomap::InfomapBase *) &(arg1)->setFastHierarchicalSolution(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapConfigInfomapBase_setOnlySuperModules ( SEXP self, SEXP value, SEXP s_swig_copy)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfomapConfig< infomap::InfomapBase > *arg1 = (infomap::InfomapConfig< infomap::InfomapBase > *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapConfigT_infomap__InfomapBase_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapConfigInfomapBase_setOnlySuperModules" "', argument " "1"" of type '" "infomap::InfomapConfig< infomap::InfomapBase > *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapConfig< infomap::InfomapBase > * >(argp1);
  arg2 = LOGICAL(value)[0] ? true : false;
  {
    try {
      result = (infomap::InfomapBase *) &(arg1)->setOnlySuperModules(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapConfigInfomapBase_setNoCoarseTune ( SEXP self, SEXP value, SEXP s_swig_copy)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfomapConfig< infomap::InfomapBase > *arg1 = (infomap::InfomapConfig< infomap::InfomapBase > *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapConfigT_infomap__InfomapBase_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapConfigInfomapBase_setNoCoarseTune" "', argument " "1"" of type '" "infomap::InfomapConfig< infomap::InfomapBase > *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapConfig< infomap::InfomapBase > * >(argp1);
  arg2 = LOGICAL(value)[0] ? true : false;
  {
    try {
      result = (infomap::InfomapBase *) &(arg1)->setNoCoarseTune(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapConfigInfomapBase_setNoInfomap__SWIG_0 ( SEXP self, SEXP value, SEXP s_swig_copy)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfomapConfig< infomap::InfomapBase > *arg1 = (infomap::InfomapConfig< infomap::InfomapBase > *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapConfigT_infomap__InfomapBase_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapConfigInfomapBase_setNoInfomap" "', argument " "1"" of type '" "infomap::InfomapConfig< infomap::InfomapBase > *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapConfig< infomap::InfomapBase > * >(argp1);
  arg2 = LOGICAL(value)[0] ? true : false;
  {
    try {
      result = (infomap::InfomapBase *) &(arg1)->setNoInfomap(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapConfigInfomapBase_setNoInfomap__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfomapConfig< infomap::InfomapBase > *arg1 = (infomap::InfomapConfig< infomap::InfomapBase > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapConfigT_infomap__InfomapBase_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapConfigInfomapBase_setNoInfomap" "', argument " "1"" of type '" "infomap::InfomapConfig< infomap::InfomapBase > *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapConfig< infomap::InfomapBase > * >(argp1);
  {
    try {
      result = (infomap::InfomapBase *) &(arg1)->setNoInfomap();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapConfigInfomapBase_setMarkovTime ( SEXP self, SEXP codeRate, SEXP s_swig_copy)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfomapConfig< infomap::InfomapBase > *arg1 = (infomap::InfomapConfig< infomap::InfomapBase > *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapConfigT_infomap__InfomapBase_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapConfigInfomapBase_setMarkovTime" "', argument " "1"" of type '" "infomap::InfomapConfig< infomap::InfomapBase > *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapConfig< infomap::InfomapBase > * >(argp1);
  arg2 = static_cast< double >(REAL(codeRate)[0]);
  {
    try {
      result = (infomap::InfomapBase *) &(arg1)->setMarkovTime(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapConfigInfomapBase_reseed ( SEXP self, SEXP seed, SEXP s_swig_copy)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfomapConfig< infomap::InfomapBase > *arg1 = (infomap::InfomapConfig< infomap::InfomapBase > *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapConfigT_infomap__InfomapBase_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapConfigInfomapBase_reseed" "', argument " "1"" of type '" "infomap::InfomapConfig< infomap::InfomapBase > *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapConfig< infomap::InfomapBase > * >(argp1);
  ecode2 = SWIG_AsVal_int(seed, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapConfigInfomapBase_reseed" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (infomap::InfomapBase *) &(arg1)->reseed(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_InfomapBase ( SEXP self)
{
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_InfomapBase" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_network__SWIG_0 ( SEXP self, SEXP s_swig_copy)
{
  infomap::Network *result = 0 ;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_network" "', argument " "1"" of type '" "infomap::InfomapBase const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (infomap::Network *) &((infomap::InfomapBase const *)arg1)->network();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__Network, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_network__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  infomap::Network *result = 0 ;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_network" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (infomap::Network *) &(arg1)->network();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__Network, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_root__SWIG_0 ( SEXP self, SEXP s_swig_copy)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_root" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (infomap::InfoNode *) &(arg1)->root();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_root__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  infomap::InfoNode *result = 0 ;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_root" "', argument " "1"" of type '" "infomap::InfomapBase const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (infomap::InfoNode *) &((infomap::InfomapBase const *)arg1)->root();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfoNode, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_iterTree__SWIG_0 ( SEXP self, SEXP maxClusterLevel, SEXP s_swig_copy)
{
  infomap::InfomapIterator result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_iterTree" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  arg2 = static_cast< int >(INTEGER(maxClusterLevel)[0]);
  {
    try {
      result = (arg1)->iterTree(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfomapIterator(static_cast< const infomap::InfomapIterator& >(result))), SWIGTYPE_p_infomap__InfomapIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_iterTree__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  infomap::InfomapIterator result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_iterTree" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (arg1)->iterTree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfomapIterator(static_cast< const infomap::InfomapIterator& >(result))), SWIGTYPE_p_infomap__InfomapIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_iterTreePhysical__SWIG_0 ( SEXP self, SEXP maxClusterLevel, SEXP s_swig_copy)
{
  infomap::InfomapIteratorPhysical result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_iterTreePhysical" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  arg2 = static_cast< int >(INTEGER(maxClusterLevel)[0]);
  {
    try {
      result = (arg1)->iterTreePhysical(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfomapIteratorPhysical(static_cast< const infomap::InfomapIteratorPhysical& >(result))), SWIGTYPE_p_infomap__InfomapIteratorPhysical, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_iterTreePhysical__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  infomap::InfomapIteratorPhysical result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_iterTreePhysical" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (arg1)->iterTreePhysical();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfomapIteratorPhysical(static_cast< const infomap::InfomapIteratorPhysical& >(result))), SWIGTYPE_p_infomap__InfomapIteratorPhysical, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_iterModules__SWIG_0 ( SEXP self, SEXP maxClusterLevel, SEXP s_swig_copy)
{
  infomap::InfomapModuleIterator result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_iterModules" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  arg2 = static_cast< int >(INTEGER(maxClusterLevel)[0]);
  {
    try {
      result = (arg1)->iterModules(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfomapModuleIterator(static_cast< const infomap::InfomapModuleIterator& >(result))), SWIGTYPE_p_infomap__InfomapModuleIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_iterModules__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  infomap::InfomapModuleIterator result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_iterModules" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (arg1)->iterModules();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfomapModuleIterator(static_cast< const infomap::InfomapModuleIterator& >(result))), SWIGTYPE_p_infomap__InfomapModuleIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_iterLeafModules__SWIG_0 ( SEXP self, SEXP maxClusterLevel, SEXP s_swig_copy)
{
  infomap::InfomapLeafModuleIterator result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_iterLeafModules" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  arg2 = static_cast< int >(INTEGER(maxClusterLevel)[0]);
  {
    try {
      result = (arg1)->iterLeafModules(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfomapLeafModuleIterator(static_cast< const infomap::InfomapLeafModuleIterator& >(result))), SWIGTYPE_p_infomap__InfomapLeafModuleIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_iterLeafModules__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  infomap::InfomapLeafModuleIterator result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_iterLeafModules" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (arg1)->iterLeafModules();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfomapLeafModuleIterator(static_cast< const infomap::InfomapLeafModuleIterator& >(result))), SWIGTYPE_p_infomap__InfomapLeafModuleIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_iterLeafNodes__SWIG_0 ( SEXP self, SEXP maxClusterLevel, SEXP s_swig_copy)
{
  infomap::InfomapLeafIterator result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_iterLeafNodes" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  arg2 = static_cast< int >(INTEGER(maxClusterLevel)[0]);
  {
    try {
      result = (arg1)->iterLeafNodes(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfomapLeafIterator(static_cast< const infomap::InfomapLeafIterator& >(result))), SWIGTYPE_p_infomap__InfomapLeafIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_iterLeafNodes__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  infomap::InfomapLeafIterator result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_iterLeafNodes" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (arg1)->iterLeafNodes();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfomapLeafIterator(static_cast< const infomap::InfomapLeafIterator& >(result))), SWIGTYPE_p_infomap__InfomapLeafIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_iterLeafNodesPhysical__SWIG_0 ( SEXP self, SEXP maxClusterLevel, SEXP s_swig_copy)
{
  infomap::InfomapLeafIteratorPhysical result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_iterLeafNodesPhysical" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  arg2 = static_cast< int >(INTEGER(maxClusterLevel)[0]);
  {
    try {
      result = (arg1)->iterLeafNodesPhysical(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfomapLeafIteratorPhysical(static_cast< const infomap::InfomapLeafIteratorPhysical& >(result))), SWIGTYPE_p_infomap__InfomapLeafIteratorPhysical, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_iterLeafNodesPhysical__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  infomap::InfomapLeafIteratorPhysical result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_iterLeafNodesPhysical" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (arg1)->iterLeafNodesPhysical();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfomapLeafIteratorPhysical(static_cast< const infomap::InfomapLeafIteratorPhysical& >(result))), SWIGTYPE_p_infomap__InfomapLeafIteratorPhysical, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_begin__SWIG_0 ( SEXP self, SEXP maxClusterLevel, SEXP s_swig_copy)
{
  infomap::InfomapIterator result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_begin" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  arg2 = static_cast< int >(INTEGER(maxClusterLevel)[0]);
  {
    try {
      result = (arg1)->begin(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfomapIterator(static_cast< const infomap::InfomapIterator& >(result))), SWIGTYPE_p_infomap__InfomapIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_begin__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  infomap::InfomapIterator result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_begin" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (arg1)->begin();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfomapIterator(static_cast< const infomap::InfomapIterator& >(result))), SWIGTYPE_p_infomap__InfomapIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_end ( SEXP self, SEXP s_swig_copy)
{
  infomap::InfomapIterator result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_end" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (arg1)->end();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfomapIterator(static_cast< const infomap::InfomapIterator& >(result))), SWIGTYPE_p_infomap__InfomapIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_numLeafNodes ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_numLeafNodes" "', argument " "1"" of type '" "infomap::InfomapBase const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (unsigned int)((infomap::InfomapBase const *)arg1)->numLeafNodes();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_leafNodes ( SEXP self, SEXP s_swig_copy)
{
  std::vector< infomap::InfoNode *,std::allocator< infomap::InfoNode * > > *result = 0 ;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_leafNodes" "', argument " "1"" of type '" "infomap::InfomapBase const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (std::vector< infomap::InfoNode *,std::allocator< infomap::InfoNode * > > *) &((infomap::InfomapBase const *)arg1)->leafNodes();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_infomap__InfoNode_p_std__allocatorT_infomap__InfoNode_p_t_t, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_numTopModules ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_numTopModules" "', argument " "1"" of type '" "infomap::InfomapBase const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (unsigned int)((infomap::InfomapBase const *)arg1)->numTopModules();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_numActiveModules ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_numActiveModules" "', argument " "1"" of type '" "infomap::InfomapBase const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (unsigned int)((infomap::InfomapBase const *)arg1)->numActiveModules();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_numNonTrivialTopModules ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_numNonTrivialTopModules" "', argument " "1"" of type '" "infomap::InfomapBase const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (unsigned int)((infomap::InfomapBase const *)arg1)->numNonTrivialTopModules();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_haveModules ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_haveModules" "', argument " "1"" of type '" "infomap::InfomapBase const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (bool)((infomap::InfomapBase const *)arg1)->haveModules();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_haveNonTrivialModules ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_haveNonTrivialModules" "', argument " "1"" of type '" "infomap::InfomapBase const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (bool)((infomap::InfomapBase const *)arg1)->haveNonTrivialModules();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_numLevels ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_numLevels" "', argument " "1"" of type '" "infomap::InfomapBase const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (unsigned int)((infomap::InfomapBase const *)arg1)->numLevels();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_maxTreeDepth ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_maxTreeDepth" "', argument " "1"" of type '" "infomap::InfomapBase const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (unsigned int)((infomap::InfomapBase const *)arg1)->maxTreeDepth();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_getCodelength ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_getCodelength" "', argument " "1"" of type '" "infomap::InfomapBase const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (double)((infomap::InfomapBase const *)arg1)->getCodelength();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_getMetaCodelength__SWIG_0 ( SEXP self, SEXP unweighted, SEXP s_swig_copy)
{
  double result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_getMetaCodelength" "', argument " "1"" of type '" "infomap::InfomapBase const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  arg2 = LOGICAL(unweighted)[0] ? true : false;
  {
    try {
      result = (double)((infomap::InfomapBase const *)arg1)->getMetaCodelength(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_getMetaCodelength__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_getMetaCodelength" "', argument " "1"" of type '" "infomap::InfomapBase const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (double)((infomap::InfomapBase const *)arg1)->getMetaCodelength();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_codelength ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_codelength" "', argument " "1"" of type '" "infomap::InfomapBase const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (double)((infomap::InfomapBase const *)arg1)->codelength();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_codelengths ( SEXP self, SEXP s_swig_copy)
{
  std::vector< double,std::allocator< double > > *result = 0 ;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_codelengths" "', argument " "1"" of type '" "infomap::InfomapBase const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (std::vector< double,std::allocator< double > > *) &((infomap::InfomapBase const *)arg1)->codelengths();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = swig::from(static_cast< std::vector< double,std::allocator< double > > >(*result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_getIndexCodelength ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_getIndexCodelength" "', argument " "1"" of type '" "infomap::InfomapBase const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (double)((infomap::InfomapBase const *)arg1)->getIndexCodelength();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_getModuleCodelength ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_getModuleCodelength" "', argument " "1"" of type '" "infomap::InfomapBase const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (double)((infomap::InfomapBase const *)arg1)->getModuleCodelength();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_getHierarchicalCodelength ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_getHierarchicalCodelength" "', argument " "1"" of type '" "infomap::InfomapBase const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (double)((infomap::InfomapBase const *)arg1)->getHierarchicalCodelength();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_getOneLevelCodelength ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_getOneLevelCodelength" "', argument " "1"" of type '" "infomap::InfomapBase const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (double)((infomap::InfomapBase const *)arg1)->getOneLevelCodelength();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_getRelativeCodelengthSavings ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_getRelativeCodelengthSavings" "', argument " "1"" of type '" "infomap::InfomapBase const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (double)((infomap::InfomapBase const *)arg1)->getRelativeCodelengthSavings();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_isFullNetwork ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_isFullNetwork" "', argument " "1"" of type '" "infomap::InfomapBase const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (bool)((infomap::InfomapBase const *)arg1)->isFullNetwork();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_isFirstLoop ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_isFirstLoop" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (bool)(arg1)->isFirstLoop();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_getNewInfomapInstance ( SEXP self)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_getNewInfomapInstance" "', argument " "1"" of type '" "infomap::InfomapBase const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (infomap::InfomapBase *)((infomap::InfomapBase const *)arg1)->getNewInfomapInstance();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_getNewInfomapInstanceWithoutMemory ( SEXP self)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_getNewInfomapInstanceWithoutMemory" "', argument " "1"" of type '" "infomap::InfomapBase const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (infomap::InfomapBase *)((infomap::InfomapBase const *)arg1)->getNewInfomapInstanceWithoutMemory();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_getSubInfomap ( SEXP self, SEXP node, SEXP s_swig_copy)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_getSubInfomap" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  res2 = SWIG_R_ConvertPtr(node, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapBase_getSubInfomap" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapBase_getSubInfomap" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  {
    try {
      result = (infomap::InfomapBase *) &(arg1)->getSubInfomap(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_getSuperInfomap ( SEXP self, SEXP node, SEXP s_swig_copy)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_getSuperInfomap" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  res2 = SWIG_R_ConvertPtr(node, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapBase_getSuperInfomap" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapBase_getSuperInfomap" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  {
    try {
      result = (infomap::InfomapBase *) &(arg1)->getSuperInfomap(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_setIsMain ( SEXP self, SEXP isMain, SEXP s_swig_copy)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_setIsMain" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  arg2 = LOGICAL(isMain)[0] ? true : false;
  {
    try {
      result = (infomap::InfomapBase *) &(arg1)->setIsMain(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_setSubLevel ( SEXP self, SEXP level, SEXP s_swig_copy)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_setSubLevel" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  ecode2 = SWIG_AsVal_int(level, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapBase_setSubLevel" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (infomap::InfomapBase *) &(arg1)->setSubLevel(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_isTopLevel ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_isTopLevel" "', argument " "1"" of type '" "infomap::InfomapBase const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (bool)((infomap::InfomapBase const *)arg1)->isTopLevel();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_isSuperLevelOnTopLevel ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_isSuperLevelOnTopLevel" "', argument " "1"" of type '" "infomap::InfomapBase const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (bool)((infomap::InfomapBase const *)arg1)->isSuperLevelOnTopLevel();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_isMainInfomap ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_isMainInfomap" "', argument " "1"" of type '" "infomap::InfomapBase const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (bool)((infomap::InfomapBase const *)arg1)->isMainInfomap();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_haveHardPartition ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_haveHardPartition" "', argument " "1"" of type '" "infomap::InfomapBase const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (bool)((infomap::InfomapBase const *)arg1)->haveHardPartition();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_activeNetwork ( SEXP self, SEXP s_swig_copy)
{
  std::vector< infomap::InfoNode *,std::allocator< infomap::InfoNode * > > *result = 0 ;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_activeNetwork" "', argument " "1"" of type '" "infomap::InfomapBase const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (std::vector< infomap::InfoNode *,std::allocator< infomap::InfoNode * > > *) &((infomap::InfomapBase const *)arg1)->activeNetwork();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_infomap__InfoNode_p_std__allocatorT_infomap__InfoNode_p_t_t, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_toString ( SEXP self, SEXP out, SEXP s_swig_copy)
{
  std::ostream *result = 0 ;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  std::ostream *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_toString" "', argument " "1"" of type '" "infomap::InfomapBase const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  res2 = SWIG_R_ConvertPtr(out, &argp2, SWIGTYPE_p_std__ostream,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapBase_toString" "', argument " "2"" of type '" "std::ostream &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapBase_toString" "', argument " "2"" of type '" "std::ostream &""'"); 
  }
  arg2 = reinterpret_cast< std::ostream * >(argp2);
  {
    try {
      result = (std::ostream *) &((infomap::InfomapBase const *)arg1)->toString(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__ostream, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_getInitialPartition ( SEXP self, SEXP s_swig_copy)
{
  std::map< unsigned int,unsigned int,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,unsigned int > > > *result = 0 ;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_getInitialPartition" "', argument " "1"" of type '" "infomap::InfomapBase const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (std::map< unsigned int,unsigned int,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,unsigned int > > > *) &((infomap::InfomapBase const *)arg1)->getInitialPartition();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = swig::from(static_cast< std::map< unsigned int,unsigned int,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,unsigned int > > > >(*result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_calcEntropyRate ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_calcEntropyRate" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (double)(arg1)->calcEntropyRate();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_setInitialPartition ( SEXP self, SEXP moduleIds, SEXP s_swig_copy)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  std::map< unsigned int,unsigned int,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,unsigned int > > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_setInitialPartition" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    std::map< unsigned int,unsigned int,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,unsigned int > > > *ptr = (std::map< unsigned int,unsigned int,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,unsigned int > > > *)0;
    res2 = swig::asptr(moduleIds, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapBase_setInitialPartition" "', argument " "2"" of type '" "std::map< unsigned int,unsigned int,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,unsigned int > > > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapBase_setInitialPartition" "', argument " "2"" of type '" "std::map< unsigned int,unsigned int,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,unsigned int > > > const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      result = (infomap::InfomapBase *) &(arg1)->setInitialPartition((std::map< unsigned int,unsigned int,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,unsigned int > > > const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  if (SWIG_IsNewObj(res2)) delete arg2;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_run__SWIG_0 ( SEXP self, SEXP parameters)
{
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_run" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(parameters, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "InfomapBase_run" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      (arg1)->run(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_run__SWIG_1 ( SEXP self)
{
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_run" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      (arg1)->run();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_run__SWIG_2 ( SEXP self, SEXP network)
{
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  infomap::Network *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_run" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  res2 = SWIG_R_ConvertPtr(network, &argp2, SWIGTYPE_p_infomap__Network,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapBase_run" "', argument " "2"" of type '" "infomap::Network &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapBase_run" "', argument " "2"" of type '" "infomap::Network &""'"); 
  }
  arg2 = reinterpret_cast< infomap::Network * >(argp2);
  {
    try {
      (arg1)->run(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_initNetwork__SWIG_0 ( SEXP self, SEXP network, SEXP s_swig_copy)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  infomap::Network *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_initNetwork" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  res2 = SWIG_R_ConvertPtr(network, &argp2, SWIGTYPE_p_infomap__Network,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapBase_initNetwork" "', argument " "2"" of type '" "infomap::Network &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapBase_initNetwork" "', argument " "2"" of type '" "infomap::Network &""'"); 
  }
  arg2 = reinterpret_cast< infomap::Network * >(argp2);
  {
    try {
      result = (infomap::InfomapBase *) &(arg1)->initNetwork(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_initNetwork__SWIG_1 ( SEXP self, SEXP parent, SEXP asSuperNetwork, SEXP s_swig_copy)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_initNetwork" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  res2 = SWIG_R_ConvertPtr(parent, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapBase_initNetwork" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapBase_initNetwork" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  arg3 = LOGICAL(asSuperNetwork)[0] ? true : false;
  {
    try {
      result = (infomap::InfomapBase *) &(arg1)->initNetwork(*arg2,arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_initNetwork__SWIG_2 ( SEXP self, SEXP parent, SEXP s_swig_copy)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_initNetwork" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  res2 = SWIG_R_ConvertPtr(parent, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapBase_initNetwork" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapBase_initNetwork" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  {
    try {
      result = (infomap::InfomapBase *) &(arg1)->initNetwork(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_generateSubNetwork__SWIG_0 ( SEXP self, SEXP network)
{
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  infomap::Network *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_generateSubNetwork" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  res2 = SWIG_R_ConvertPtr(network, &argp2, SWIGTYPE_p_infomap__Network,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapBase_generateSubNetwork" "', argument " "2"" of type '" "infomap::Network &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapBase_generateSubNetwork" "', argument " "2"" of type '" "infomap::Network &""'"); 
  }
  arg2 = reinterpret_cast< infomap::Network * >(argp2);
  {
    try {
      (arg1)->generateSubNetwork(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_generateSubNetwork__SWIG_1 ( SEXP self, SEXP parent)
{
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_generateSubNetwork" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  res2 = SWIG_R_ConvertPtr(parent, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapBase_generateSubNetwork" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapBase_generateSubNetwork" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  {
    try {
      (arg1)->generateSubNetwork(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_initMetaData ( SEXP self, SEXP metaDataFile, SEXP s_swig_copy)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_initMetaData" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(metaDataFile, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "InfomapBase_initMetaData" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      result = (infomap::InfomapBase *) &(arg1)->initMetaData(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_initPartition__SWIG_0 ( SEXP self, SEXP clusterDataFile, SEXP hard, SEXP s_swig_copy)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  std::string arg2 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_initPartition" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(clusterDataFile, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "InfomapBase_initPartition" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  arg3 = LOGICAL(hard)[0] ? true : false;
  {
    try {
      result = (infomap::InfomapBase *) &(arg1)->initPartition(arg2,arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_initPartition__SWIG_1 ( SEXP self, SEXP clusterDataFile, SEXP s_swig_copy)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_initPartition" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(clusterDataFile, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "InfomapBase_initPartition" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      result = (infomap::InfomapBase *) &(arg1)->initPartition(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_initPartition__SWIG_2 ( SEXP self, SEXP clusterIds, SEXP hard, SEXP s_swig_copy)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  std::map< unsigned int,unsigned int,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,unsigned int > > > *arg2 = 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_initPartition" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    std::map< unsigned int,unsigned int,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,unsigned int > > > *ptr = (std::map< unsigned int,unsigned int,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,unsigned int > > > *)0;
    res2 = swig::asptr(clusterIds, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapBase_initPartition" "', argument " "2"" of type '" "std::map< unsigned int,unsigned int,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,unsigned int > > > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapBase_initPartition" "', argument " "2"" of type '" "std::map< unsigned int,unsigned int,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,unsigned int > > > const &""'"); 
    }
    arg2 = ptr;
  }
  arg3 = LOGICAL(hard)[0] ? true : false;
  {
    try {
      result = (infomap::InfomapBase *) &(arg1)->initPartition((std::map< unsigned int,unsigned int,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,unsigned int > > > const &)*arg2,arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  if (SWIG_IsNewObj(res2)) delete arg2;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_initPartition__SWIG_3 ( SEXP self, SEXP clusterIds, SEXP s_swig_copy)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  std::map< unsigned int,unsigned int,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,unsigned int > > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_initPartition" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    std::map< unsigned int,unsigned int,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,unsigned int > > > *ptr = (std::map< unsigned int,unsigned int,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,unsigned int > > > *)0;
    res2 = swig::asptr(clusterIds, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapBase_initPartition" "', argument " "2"" of type '" "std::map< unsigned int,unsigned int,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,unsigned int > > > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapBase_initPartition" "', argument " "2"" of type '" "std::map< unsigned int,unsigned int,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,unsigned int > > > const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      result = (infomap::InfomapBase *) &(arg1)->initPartition((std::map< unsigned int,unsigned int,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,unsigned int > > > const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  if (SWIG_IsNewObj(res2)) delete arg2;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_initPartition__SWIG_4 ( SEXP self, SEXP clusters, SEXP hard, SEXP s_swig_copy)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  std::vector< std::vector< unsigned int,std::allocator< unsigned int > >,std::allocator< std::vector< unsigned int,std::allocator< unsigned int > > > > *arg2 = 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_initPartition" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  res2 = SWIG_R_ConvertPtr(clusters, &argp2, SWIGTYPE_p_std__vectorT_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__allocatorT_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapBase_initPartition" "', argument " "2"" of type '" "std::vector< std::vector< unsigned int,std::allocator< unsigned int > >,std::allocator< std::vector< unsigned int,std::allocator< unsigned int > > > > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapBase_initPartition" "', argument " "2"" of type '" "std::vector< std::vector< unsigned int,std::allocator< unsigned int > >,std::allocator< std::vector< unsigned int,std::allocator< unsigned int > > > > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector< std::vector< unsigned int,std::allocator< unsigned int > >,std::allocator< std::vector< unsigned int,std::allocator< unsigned int > > > > * >(argp2);
  arg3 = LOGICAL(hard)[0] ? true : false;
  {
    try {
      result = (infomap::InfomapBase *) &(arg1)->initPartition(*arg2,arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_initPartition__SWIG_5 ( SEXP self, SEXP clusters, SEXP s_swig_copy)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  std::vector< std::vector< unsigned int,std::allocator< unsigned int > >,std::allocator< std::vector< unsigned int,std::allocator< unsigned int > > > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_initPartition" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  res2 = SWIG_R_ConvertPtr(clusters, &argp2, SWIGTYPE_p_std__vectorT_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__allocatorT_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapBase_initPartition" "', argument " "2"" of type '" "std::vector< std::vector< unsigned int,std::allocator< unsigned int > >,std::allocator< std::vector< unsigned int,std::allocator< unsigned int > > > > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapBase_initPartition" "', argument " "2"" of type '" "std::vector< std::vector< unsigned int,std::allocator< unsigned int > >,std::allocator< std::vector< unsigned int,std::allocator< unsigned int > > > > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector< std::vector< unsigned int,std::allocator< unsigned int > >,std::allocator< std::vector< unsigned int,std::allocator< unsigned int > > > > * >(argp2);
  {
    try {
      result = (infomap::InfomapBase *) &(arg1)->initPartition(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_initPartition__SWIG_6 ( SEXP self, SEXP modules, SEXP hard, SEXP s_swig_copy)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  std::vector< unsigned int,std::allocator< unsigned int > > *arg2 = 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_initPartition" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  res2 = SWIG_R_ConvertPtr(modules, &argp2, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapBase_initPartition" "', argument " "2"" of type '" "std::vector< unsigned int,std::allocator< unsigned int > > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapBase_initPartition" "', argument " "2"" of type '" "std::vector< unsigned int,std::allocator< unsigned int > > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector< unsigned int,std::allocator< unsigned int > > * >(argp2);
  arg3 = LOGICAL(hard)[0] ? true : false;
  {
    try {
      result = (infomap::InfomapBase *) &(arg1)->initPartition(*arg2,arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_initPartition__SWIG_7 ( SEXP self, SEXP modules, SEXP s_swig_copy)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  std::vector< unsigned int,std::allocator< unsigned int > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_initPartition" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  res2 = SWIG_R_ConvertPtr(modules, &argp2, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapBase_initPartition" "', argument " "2"" of type '" "std::vector< unsigned int,std::allocator< unsigned int > > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapBase_initPartition" "', argument " "2"" of type '" "std::vector< unsigned int,std::allocator< unsigned int > > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector< unsigned int,std::allocator< unsigned int > > * >(argp2);
  {
    try {
      result = (infomap::InfomapBase *) &(arg1)->initPartition(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_initTree ( SEXP self, SEXP tree, SEXP s_swig_copy)
{
  infomap::InfomapBase *result = 0 ;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  NodePaths *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_initTree" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  res2 = SWIG_R_ConvertPtr(tree, &argp2, SWIGTYPE_p_NodePaths,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapBase_initTree" "', argument " "2"" of type '" "NodePaths const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapBase_initTree" "', argument " "2"" of type '" "NodePaths const &""'"); 
  }
  arg2 = reinterpret_cast< NodePaths * >(argp2);
  {
    try {
      result = (infomap::InfomapBase *) &(arg1)->initTree((NodePaths const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_init ( SEXP self)
{
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_init" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      (arg1)->init();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_runPartition ( SEXP self)
{
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_runPartition" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      (arg1)->runPartition();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_restoreHardPartition ( SEXP self)
{
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_restoreHardPartition" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      (arg1)->restoreHardPartition();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_sortTreeOnFlow ( SEXP self)
{
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_sortTreeOnFlow" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      (arg1)->sortTreeOnFlow();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_writeResult ( SEXP self)
{
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_writeResult" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      (arg1)->writeResult();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_hierarchicalPartition ( SEXP self)
{
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_hierarchicalPartition" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      (arg1)->hierarchicalPartition();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_partition ( SEXP self)
{
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_partition" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      (arg1)->partition();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_initEnterExitFlow ( SEXP self)
{
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_initEnterExitFlow" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      (arg1)->initEnterExitFlow();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_aggregateFlowValuesFromLeafToRoot ( SEXP self)
{
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_aggregateFlowValuesFromLeafToRoot" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      (arg1)->aggregateFlowValuesFromLeafToRoot();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_initNetwork__SWIG_3 ( SEXP self)
{
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_initNetwork" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      (arg1)->initNetwork();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_initSuperNetwork ( SEXP self)
{
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_initSuperNetwork" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      (arg1)->initSuperNetwork();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_calcCodelength ( SEXP self, SEXP parent, SEXP s_swig_copy)
{
  double result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_calcCodelength" "', argument " "1"" of type '" "infomap::InfomapBase const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  res2 = SWIG_R_ConvertPtr(parent, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapBase_calcCodelength" "', argument " "2"" of type '" "infomap::InfoNode const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapBase_calcCodelength" "', argument " "2"" of type '" "infomap::InfoNode const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  {
    try {
      result = (double)((infomap::InfomapBase const *)arg1)->calcCodelength((infomap::InfoNode const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_calcCodelengthOnTree__SWIG_0 ( SEXP self, SEXP includeRoot, SEXP s_swig_copy)
{
  double result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_calcCodelengthOnTree" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  arg2 = LOGICAL(includeRoot)[0] ? true : false;
  {
    try {
      result = (double)(arg1)->calcCodelengthOnTree(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_calcCodelengthOnTree__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_calcCodelengthOnTree" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (double)(arg1)->calcCodelengthOnTree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_setActiveNetworkFromLeafs ( SEXP self)
{
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_setActiveNetworkFromLeafs" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      (arg1)->setActiveNetworkFromLeafs();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_setActiveNetworkFromChildrenOfRoot ( SEXP self)
{
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_setActiveNetworkFromChildrenOfRoot" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      (arg1)->setActiveNetworkFromChildrenOfRoot();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_initPartition__SWIG_8 ( SEXP self)
{
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_initPartition" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      (arg1)->initPartition();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_findTopModulesRepeatedly ( SEXP self, SEXP maxLevels)
{
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_findTopModulesRepeatedly" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  ecode2 = SWIG_AsVal_int(maxLevels, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapBase_findTopModulesRepeatedly" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      (arg1)->findTopModulesRepeatedly(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_fineTune ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_fineTune" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (unsigned int)(arg1)->fineTune();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_coarseTune ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_coarseTune" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (unsigned int)(arg1)->coarseTune();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_optimizeActiveNetwork ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_optimizeActiveNetwork" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (unsigned int)(arg1)->optimizeActiveNetwork();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_moveActiveNodesToPredefinedModules ( SEXP self, SEXP modules)
{
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  std::vector< unsigned int,std::allocator< unsigned int > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_moveActiveNodesToPredefinedModules" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  res2 = SWIG_R_ConvertPtr(modules, &argp2, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapBase_moveActiveNodesToPredefinedModules" "', argument " "2"" of type '" "std::vector< unsigned int,std::allocator< unsigned int > > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapBase_moveActiveNodesToPredefinedModules" "', argument " "2"" of type '" "std::vector< unsigned int,std::allocator< unsigned int > > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector< unsigned int,std::allocator< unsigned int > > * >(argp2);
  {
    try {
      (arg1)->moveActiveNodesToPredefinedModules(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_consolidateModules__SWIG_0 ( SEXP self, SEXP replaceExistingModules)
{
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_consolidateModules" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  arg2 = LOGICAL(replaceExistingModules)[0] ? true : false;
  {
    try {
      (arg1)->consolidateModules(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_consolidateModules__SWIG_1 ( SEXP self)
{
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_consolidateModules" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      (arg1)->consolidateModules();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_calculateNumNonTrivialTopModules ( SEXP self)
{
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_calculateNumNonTrivialTopModules" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      (arg1)->calculateNumNonTrivialTopModules();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_calculateMaxDepth ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_calculateMaxDepth" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (unsigned int)(arg1)->calculateMaxDepth();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_restoreConsolidatedOptimizationPointIfNoImprovement__SWIG_0 ( SEXP self, SEXP forceRestore, SEXP s_swig_copy)
{
  bool result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_restoreConsolidatedOptimizationPointIfNoImprovement" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  arg2 = LOGICAL(forceRestore)[0] ? true : false;
  {
    try {
      result = (bool)(arg1)->restoreConsolidatedOptimizationPointIfNoImprovement(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_restoreConsolidatedOptimizationPointIfNoImprovement__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_restoreConsolidatedOptimizationPointIfNoImprovement" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (bool)(arg1)->restoreConsolidatedOptimizationPointIfNoImprovement();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_findHierarchicalSuperModules__SWIG_0 ( SEXP self, SEXP superLevelLimit, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_findHierarchicalSuperModules" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  ecode2 = SWIG_AsVal_int(superLevelLimit, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapBase_findHierarchicalSuperModules" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (unsigned int)(arg1)->findHierarchicalSuperModules(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_findHierarchicalSuperModules__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_findHierarchicalSuperModules" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (unsigned int)(arg1)->findHierarchicalSuperModules();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_findHierarchicalSuperModulesFast__SWIG_0 ( SEXP self, SEXP superLevelLimit, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_findHierarchicalSuperModulesFast" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  ecode2 = SWIG_AsVal_int(superLevelLimit, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapBase_findHierarchicalSuperModulesFast" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (unsigned int)(arg1)->findHierarchicalSuperModulesFast(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_findHierarchicalSuperModulesFast__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_findHierarchicalSuperModulesFast" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (unsigned int)(arg1)->findHierarchicalSuperModulesFast();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_transformNodeFlowToEnterFlow ( SEXP self, SEXP parent)
{
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_transformNodeFlowToEnterFlow" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  res2 = SWIG_R_ConvertPtr(parent, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapBase_transformNodeFlowToEnterFlow" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapBase_transformNodeFlowToEnterFlow" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  {
    try {
      (arg1)->transformNodeFlowToEnterFlow(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_resetFlowOnModules ( SEXP self)
{
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_resetFlowOnModules" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      (arg1)->resetFlowOnModules();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_removeModules ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_removeModules" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (unsigned int)(arg1)->removeModules();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_removeSubModules ( SEXP self, SEXP recalculateCodelengthOnTree, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_removeSubModules" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  arg2 = LOGICAL(recalculateCodelengthOnTree)[0] ? true : false;
  {
    try {
      result = (unsigned int)(arg1)->removeSubModules(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_recursivePartition ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_recursivePartition" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (unsigned int)(arg1)->recursivePartition();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_queueTopModules ( SEXP self, SEXP partitionQueue)
{
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  infomap::InfomapBase::PartitionQueue *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_queueTopModules" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  res2 = SWIG_R_ConvertPtr(partitionQueue, &argp2, SWIGTYPE_p_infomap__detail__PartitionQueue,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapBase_queueTopModules" "', argument " "2"" of type '" "infomap::InfomapBase::PartitionQueue &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapBase_queueTopModules" "', argument " "2"" of type '" "infomap::InfomapBase::PartitionQueue &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfomapBase::PartitionQueue * >(argp2);
  {
    try {
      (arg1)->queueTopModules(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_queueLeafModules ( SEXP self, SEXP partitionQueue)
{
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  infomap::InfomapBase::PartitionQueue *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_queueLeafModules" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  res2 = SWIG_R_ConvertPtr(partitionQueue, &argp2, SWIGTYPE_p_infomap__detail__PartitionQueue,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapBase_queueLeafModules" "', argument " "2"" of type '" "infomap::InfomapBase::PartitionQueue &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapBase_queueLeafModules" "', argument " "2"" of type '" "infomap::InfomapBase::PartitionQueue &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfomapBase::PartitionQueue * >(argp2);
  {
    try {
      (arg1)->queueLeafModules(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_processPartitionQueue ( SEXP self, SEXP queue, SEXP nextLevel, SEXP s_swig_copy)
{
  bool result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  infomap::InfomapBase::PartitionQueue *arg2 = 0 ;
  infomap::InfomapBase::PartitionQueue *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_processPartitionQueue" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  res2 = SWIG_R_ConvertPtr(queue, &argp2, SWIGTYPE_p_infomap__detail__PartitionQueue,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapBase_processPartitionQueue" "', argument " "2"" of type '" "infomap::InfomapBase::PartitionQueue &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapBase_processPartitionQueue" "', argument " "2"" of type '" "infomap::InfomapBase::PartitionQueue &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfomapBase::PartitionQueue * >(argp2);
  res3 = SWIG_R_ConvertPtr(nextLevel, &argp3, SWIGTYPE_p_infomap__detail__PartitionQueue,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "InfomapBase_processPartitionQueue" "', argument " "3"" of type '" "infomap::InfomapBase::PartitionQueue &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapBase_processPartitionQueue" "', argument " "3"" of type '" "infomap::InfomapBase::PartitionQueue &""'"); 
  }
  arg3 = reinterpret_cast< infomap::InfomapBase::PartitionQueue * >(argp3);
  {
    try {
      result = (bool)(arg1)->processPartitionQueue(*arg2,*arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_getOutputFileHeader ( SEXP self, SEXP s_swig_copy)
{
  std::string result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_getOutputFileHeader" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (arg1)->getOutputFileHeader();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_std_string(static_cast< std::string >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_writeTree__SWIG_0 ( SEXP self, SEXP filename, SEXP states, SEXP s_swig_copy)
{
  std::string result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  std::string arg2 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_writeTree" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(filename, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "InfomapBase_writeTree" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  arg3 = LOGICAL(states)[0] ? true : false;
  {
    try {
      result = (arg1)->writeTree(arg2,arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_std_string(static_cast< std::string >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_writeTree__SWIG_1 ( SEXP self, SEXP filename, SEXP s_swig_copy)
{
  std::string result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_writeTree" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(filename, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "InfomapBase_writeTree" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      result = (arg1)->writeTree(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_std_string(static_cast< std::string >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_writeTree__SWIG_2 ( SEXP self, SEXP s_swig_copy)
{
  std::string result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_writeTree" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (arg1)->writeTree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_std_string(static_cast< std::string >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_writeFlowTree__SWIG_0 ( SEXP self, SEXP filename, SEXP states, SEXP s_swig_copy)
{
  std::string result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  std::string arg2 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_writeFlowTree" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(filename, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "InfomapBase_writeFlowTree" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  arg3 = LOGICAL(states)[0] ? true : false;
  {
    try {
      result = (arg1)->writeFlowTree(arg2,arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_std_string(static_cast< std::string >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_writeFlowTree__SWIG_1 ( SEXP self, SEXP filename, SEXP s_swig_copy)
{
  std::string result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_writeFlowTree" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(filename, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "InfomapBase_writeFlowTree" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      result = (arg1)->writeFlowTree(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_std_string(static_cast< std::string >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_writeFlowTree__SWIG_2 ( SEXP self, SEXP s_swig_copy)
{
  std::string result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_writeFlowTree" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (arg1)->writeFlowTree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_std_string(static_cast< std::string >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_writeNewickTree__SWIG_0 ( SEXP self, SEXP filename, SEXP states, SEXP s_swig_copy)
{
  std::string result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  std::string arg2 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_writeNewickTree" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(filename, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "InfomapBase_writeNewickTree" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  arg3 = LOGICAL(states)[0] ? true : false;
  {
    try {
      result = (arg1)->writeNewickTree(arg2,arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_std_string(static_cast< std::string >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_writeNewickTree__SWIG_1 ( SEXP self, SEXP filename, SEXP s_swig_copy)
{
  std::string result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_writeNewickTree" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(filename, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "InfomapBase_writeNewickTree" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      result = (arg1)->writeNewickTree(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_std_string(static_cast< std::string >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_writeNewickTree__SWIG_2 ( SEXP self, SEXP s_swig_copy)
{
  std::string result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_writeNewickTree" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (arg1)->writeNewickTree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_std_string(static_cast< std::string >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_writeJsonTree__SWIG_0 ( SEXP self, SEXP filename, SEXP states, SEXP s_swig_copy)
{
  std::string result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  std::string arg2 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_writeJsonTree" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(filename, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "InfomapBase_writeJsonTree" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  arg3 = LOGICAL(states)[0] ? true : false;
  {
    try {
      result = (arg1)->writeJsonTree(arg2,arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_std_string(static_cast< std::string >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_writeJsonTree__SWIG_1 ( SEXP self, SEXP filename, SEXP s_swig_copy)
{
  std::string result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_writeJsonTree" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(filename, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "InfomapBase_writeJsonTree" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      result = (arg1)->writeJsonTree(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_std_string(static_cast< std::string >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_writeJsonTree__SWIG_2 ( SEXP self, SEXP s_swig_copy)
{
  std::string result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_writeJsonTree" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (arg1)->writeJsonTree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_std_string(static_cast< std::string >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_writeClu__SWIG_0 ( SEXP self, SEXP filename, SEXP states, SEXP moduleIndexLevel, SEXP s_swig_copy)
{
  std::string result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  std::string arg2 ;
  bool arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_writeClu" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(filename, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "InfomapBase_writeClu" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  arg3 = LOGICAL(states)[0] ? true : false;
  arg4 = static_cast< int >(INTEGER(moduleIndexLevel)[0]);
  {
    try {
      result = (arg1)->writeClu(arg2,arg3,arg4);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_std_string(static_cast< std::string >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_writeClu__SWIG_1 ( SEXP self, SEXP filename, SEXP states, SEXP s_swig_copy)
{
  std::string result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  std::string arg2 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_writeClu" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(filename, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "InfomapBase_writeClu" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  arg3 = LOGICAL(states)[0] ? true : false;
  {
    try {
      result = (arg1)->writeClu(arg2,arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_std_string(static_cast< std::string >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_writeClu__SWIG_2 ( SEXP self, SEXP filename, SEXP s_swig_copy)
{
  std::string result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_writeClu" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(filename, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "InfomapBase_writeClu" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      result = (arg1)->writeClu(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_std_string(static_cast< std::string >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_writeClu__SWIG_3 ( SEXP self, SEXP s_swig_copy)
{
  std::string result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_writeClu" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      result = (arg1)->writeClu();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_std_string(static_cast< std::string >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_printPerLevelCodelength ( SEXP self, SEXP out, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  std::ostream *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_printPerLevelCodelength" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  res2 = SWIG_R_ConvertPtr(out, &argp2, SWIGTYPE_p_std__ostream,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapBase_printPerLevelCodelength" "', argument " "2"" of type '" "std::ostream &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapBase_printPerLevelCodelength" "', argument " "2"" of type '" "std::ostream &""'"); 
  }
  arg2 = reinterpret_cast< std::ostream * >(argp2);
  {
    try {
      result = (unsigned int)(arg1)->printPerLevelCodelength(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_aggregatePerLevelCodelength__SWIG_0 ( SEXP self, SEXP perLevelStat, SEXP level)
{
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  std::vector< infomap::PerLevelStat,std::allocator< infomap::PerLevelStat > > *arg2 = 0 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_aggregatePerLevelCodelength" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  res2 = SWIG_R_ConvertPtr(perLevelStat, &argp2, SWIGTYPE_p_std__vectorT_infomap__PerLevelStat_std__allocatorT_infomap__PerLevelStat_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapBase_aggregatePerLevelCodelength" "', argument " "2"" of type '" "std::vector< infomap::PerLevelStat,std::allocator< infomap::PerLevelStat > > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapBase_aggregatePerLevelCodelength" "', argument " "2"" of type '" "std::vector< infomap::PerLevelStat,std::allocator< infomap::PerLevelStat > > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector< infomap::PerLevelStat,std::allocator< infomap::PerLevelStat > > * >(argp2);
  ecode3 = SWIG_AsVal_int(level, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "InfomapBase_aggregatePerLevelCodelength" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    try {
      (arg1)->aggregatePerLevelCodelength(*arg2,arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_aggregatePerLevelCodelength__SWIG_1 ( SEXP self, SEXP perLevelStat)
{
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  std::vector< infomap::PerLevelStat,std::allocator< infomap::PerLevelStat > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_aggregatePerLevelCodelength" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  res2 = SWIG_R_ConvertPtr(perLevelStat, &argp2, SWIGTYPE_p_std__vectorT_infomap__PerLevelStat_std__allocatorT_infomap__PerLevelStat_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapBase_aggregatePerLevelCodelength" "', argument " "2"" of type '" "std::vector< infomap::PerLevelStat,std::allocator< infomap::PerLevelStat > > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapBase_aggregatePerLevelCodelength" "', argument " "2"" of type '" "std::vector< infomap::PerLevelStat,std::allocator< infomap::PerLevelStat > > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector< infomap::PerLevelStat,std::allocator< infomap::PerLevelStat > > * >(argp2);
  {
    try {
      (arg1)->aggregatePerLevelCodelength(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_aggregatePerLevelCodelength__SWIG_2 ( SEXP self, SEXP parent, SEXP perLevelStat, SEXP level)
{
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  std::vector< infomap::PerLevelStat,std::allocator< infomap::PerLevelStat > > *arg3 = 0 ;
  unsigned int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_aggregatePerLevelCodelength" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  res2 = SWIG_R_ConvertPtr(parent, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapBase_aggregatePerLevelCodelength" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapBase_aggregatePerLevelCodelength" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  res3 = SWIG_R_ConvertPtr(perLevelStat, &argp3, SWIGTYPE_p_std__vectorT_infomap__PerLevelStat_std__allocatorT_infomap__PerLevelStat_t_t,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "InfomapBase_aggregatePerLevelCodelength" "', argument " "3"" of type '" "std::vector< infomap::PerLevelStat,std::allocator< infomap::PerLevelStat > > &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapBase_aggregatePerLevelCodelength" "', argument " "3"" of type '" "std::vector< infomap::PerLevelStat,std::allocator< infomap::PerLevelStat > > &""'"); 
  }
  arg3 = reinterpret_cast< std::vector< infomap::PerLevelStat,std::allocator< infomap::PerLevelStat > > * >(argp3);
  ecode4 = SWIG_AsVal_int(level, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "InfomapBase_aggregatePerLevelCodelength" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  {
    try {
      (arg1)->aggregatePerLevelCodelength(*arg2,*arg3,arg4);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapBase_printDebug ( SEXP self)
{
  infomap::InfomapBase *arg1 = (infomap::InfomapBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapBase_printDebug" "', argument " "1"" of type '" "infomap::InfomapBase *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapBase * >(argp1);
  {
    try {
      (arg1)->printDebug();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_PerLevelStat_codelength ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::PerLevelStat *arg1 = (infomap::PerLevelStat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__PerLevelStat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PerLevelStat_codelength" "', argument " "1"" of type '" "infomap::PerLevelStat const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::PerLevelStat * >(argp1);
  {
    try {
      result = (double)((infomap::PerLevelStat const *)arg1)->codelength();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_PerLevelStat_numNodes ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::PerLevelStat *arg1 = (infomap::PerLevelStat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__PerLevelStat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PerLevelStat_numNodes" "', argument " "1"" of type '" "infomap::PerLevelStat const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::PerLevelStat * >(argp1);
  {
    try {
      result = (unsigned int)((infomap::PerLevelStat const *)arg1)->numNodes();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_PerLevelStat_numModules_set ( SEXP self, SEXP s_numModules)
{
  infomap::PerLevelStat *arg1 = (infomap::PerLevelStat *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__PerLevelStat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PerLevelStat_numModules_set" "', argument " "1"" of type '" "infomap::PerLevelStat *""'"); 
  }
  arg1 = reinterpret_cast< infomap::PerLevelStat * >(argp1);
  ecode2 = SWIG_AsVal_int(s_numModules, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PerLevelStat_numModules_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->numModules = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_PerLevelStat_numModules_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::PerLevelStat *arg1 = (infomap::PerLevelStat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__PerLevelStat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PerLevelStat_numModules_get" "', argument " "1"" of type '" "infomap::PerLevelStat *""'"); 
  }
  arg1 = reinterpret_cast< infomap::PerLevelStat * >(argp1);
  result = (unsigned int) ((arg1)->numModules);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_PerLevelStat_numLeafNodes_set ( SEXP self, SEXP s_numLeafNodes)
{
  infomap::PerLevelStat *arg1 = (infomap::PerLevelStat *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__PerLevelStat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PerLevelStat_numLeafNodes_set" "', argument " "1"" of type '" "infomap::PerLevelStat *""'"); 
  }
  arg1 = reinterpret_cast< infomap::PerLevelStat * >(argp1);
  ecode2 = SWIG_AsVal_int(s_numLeafNodes, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PerLevelStat_numLeafNodes_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->numLeafNodes = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_PerLevelStat_numLeafNodes_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::PerLevelStat *arg1 = (infomap::PerLevelStat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__PerLevelStat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PerLevelStat_numLeafNodes_get" "', argument " "1"" of type '" "infomap::PerLevelStat *""'"); 
  }
  arg1 = reinterpret_cast< infomap::PerLevelStat * >(argp1);
  result = (unsigned int) ((arg1)->numLeafNodes);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_PerLevelStat_indexLength_set ( SEXP self, SEXP s_indexLength)
{
  infomap::PerLevelStat *arg1 = (infomap::PerLevelStat *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__PerLevelStat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PerLevelStat_indexLength_set" "', argument " "1"" of type '" "infomap::PerLevelStat *""'"); 
  }
  arg1 = reinterpret_cast< infomap::PerLevelStat * >(argp1);
  arg2 = static_cast< double >(REAL(s_indexLength)[0]);
  if (arg1) (arg1)->indexLength = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_PerLevelStat_indexLength_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::PerLevelStat *arg1 = (infomap::PerLevelStat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__PerLevelStat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PerLevelStat_indexLength_get" "', argument " "1"" of type '" "infomap::PerLevelStat *""'"); 
  }
  arg1 = reinterpret_cast< infomap::PerLevelStat * >(argp1);
  result = (double) ((arg1)->indexLength);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_PerLevelStat_leafLength_set ( SEXP self, SEXP s_leafLength)
{
  infomap::PerLevelStat *arg1 = (infomap::PerLevelStat *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__PerLevelStat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PerLevelStat_leafLength_set" "', argument " "1"" of type '" "infomap::PerLevelStat *""'"); 
  }
  arg1 = reinterpret_cast< infomap::PerLevelStat * >(argp1);
  arg2 = static_cast< double >(REAL(s_leafLength)[0]);
  if (arg1) (arg1)->leafLength = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_PerLevelStat_leafLength_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::PerLevelStat *arg1 = (infomap::PerLevelStat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__PerLevelStat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PerLevelStat_leafLength_get" "', argument " "1"" of type '" "infomap::PerLevelStat *""'"); 
  }
  arg1 = reinterpret_cast< infomap::PerLevelStat * >(argp1);
  result = (double) ((arg1)->leafLength);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_PerLevelStat ( )
{
  infomap::PerLevelStat *result = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    try {
      result = (infomap::PerLevelStat *)new infomap::PerLevelStat();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__PerLevelStat, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_PerLevelStat ( SEXP self)
{
  infomap::PerLevelStat *arg1 = (infomap::PerLevelStat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__PerLevelStat, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_PerLevelStat" "', argument " "1"" of type '" "infomap::PerLevelStat *""'"); 
  }
  arg1 = reinterpret_cast< infomap::PerLevelStat * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_PartitionQueue_swap ( SEXP self, SEXP other)
{
  infomap::detail::PartitionQueue *arg1 = (infomap::detail::PartitionQueue *) 0 ;
  infomap::detail::PartitionQueue *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__detail__PartitionQueue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PartitionQueue_swap" "', argument " "1"" of type '" "infomap::detail::PartitionQueue *""'"); 
  }
  arg1 = reinterpret_cast< infomap::detail::PartitionQueue * >(argp1);
  res2 = SWIG_R_ConvertPtr(other, &argp2, SWIGTYPE_p_infomap__detail__PartitionQueue,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PartitionQueue_swap" "', argument " "2"" of type '" "infomap::detail::PartitionQueue &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "PartitionQueue_swap" "', argument " "2"" of type '" "infomap::detail::PartitionQueue &""'"); 
  }
  arg2 = reinterpret_cast< infomap::detail::PartitionQueue * >(argp2);
  {
    try {
      (arg1)->swap(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_PartitionQueue_size ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< std::deque< infomap::InfoNode *,std::allocator< infomap::InfoNode * > >::size_type > result;
  infomap::detail::PartitionQueue *arg1 = (infomap::detail::PartitionQueue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__detail__PartitionQueue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PartitionQueue_size" "', argument " "1"" of type '" "infomap::detail::PartitionQueue const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::detail::PartitionQueue * >(argp1);
  {
    try {
      result = ((infomap::detail::PartitionQueue const *)arg1)->size();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::detail::PartitionQueue::size_t(static_cast< const infomap::detail::PartitionQueue::size_t& >(result))), SWIGTYPE_p_std__dequeT_infomap__InfoNode_p_std__allocatorT_infomap__InfoNode_p_t_t__size_type, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_PartitionQueue_resize ( SEXP self, SEXP size)
{
  infomap::detail::PartitionQueue *arg1 = (infomap::detail::PartitionQueue *) 0 ;
  SwigValueWrapper< std::deque< infomap::InfoNode *,std::allocator< infomap::InfoNode * > >::size_type > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__detail__PartitionQueue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PartitionQueue_resize" "', argument " "1"" of type '" "infomap::detail::PartitionQueue *""'"); 
  }
  arg1 = reinterpret_cast< infomap::detail::PartitionQueue * >(argp1);
  {
    res2 = SWIG_R_ConvertPtr(size, &argp2, SWIGTYPE_p_std__dequeT_infomap__InfoNode_p_std__allocatorT_infomap__InfoNode_p_t_t__size_type,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PartitionQueue_resize" "', argument " "2"" of type '" "infomap::detail::PartitionQueue::size_t""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "PartitionQueue_resize" "', argument " "2"" of type '" "infomap::detail::PartitionQueue::size_t""'");
    } else {
      arg2 = *(reinterpret_cast< infomap::detail::PartitionQueue::size_t * >(argp2));
    }
  }
  {
    try {
      (arg1)->resize(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_PartitionQueue_level_set ( SEXP self, SEXP s_level)
{
  infomap::detail::PartitionQueue *arg1 = (infomap::detail::PartitionQueue *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__detail__PartitionQueue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PartitionQueue_level_set" "', argument " "1"" of type '" "infomap::detail::PartitionQueue *""'"); 
  }
  arg1 = reinterpret_cast< infomap::detail::PartitionQueue * >(argp1);
  ecode2 = SWIG_AsVal_int(s_level, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PartitionQueue_level_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->level = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_PartitionQueue_level_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::detail::PartitionQueue *arg1 = (infomap::detail::PartitionQueue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__detail__PartitionQueue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PartitionQueue_level_get" "', argument " "1"" of type '" "infomap::detail::PartitionQueue *""'"); 
  }
  arg1 = reinterpret_cast< infomap::detail::PartitionQueue * >(argp1);
  result = (unsigned int) ((arg1)->level);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_PartitionQueue_numNonTrivialModules_set ( SEXP self, SEXP s_numNonTrivialModules)
{
  infomap::detail::PartitionQueue *arg1 = (infomap::detail::PartitionQueue *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__detail__PartitionQueue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PartitionQueue_numNonTrivialModules_set" "', argument " "1"" of type '" "infomap::detail::PartitionQueue *""'"); 
  }
  arg1 = reinterpret_cast< infomap::detail::PartitionQueue * >(argp1);
  ecode2 = SWIG_AsVal_int(s_numNonTrivialModules, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PartitionQueue_numNonTrivialModules_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->numNonTrivialModules = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_PartitionQueue_numNonTrivialModules_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::detail::PartitionQueue *arg1 = (infomap::detail::PartitionQueue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__detail__PartitionQueue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PartitionQueue_numNonTrivialModules_get" "', argument " "1"" of type '" "infomap::detail::PartitionQueue *""'"); 
  }
  arg1 = reinterpret_cast< infomap::detail::PartitionQueue * >(argp1);
  result = (unsigned int) ((arg1)->numNonTrivialModules);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_PartitionQueue_flow_set ( SEXP self, SEXP s_flow)
{
  infomap::detail::PartitionQueue *arg1 = (infomap::detail::PartitionQueue *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__detail__PartitionQueue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PartitionQueue_flow_set" "', argument " "1"" of type '" "infomap::detail::PartitionQueue *""'"); 
  }
  arg1 = reinterpret_cast< infomap::detail::PartitionQueue * >(argp1);
  arg2 = static_cast< double >(REAL(s_flow)[0]);
  if (arg1) (arg1)->flow = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_PartitionQueue_flow_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::detail::PartitionQueue *arg1 = (infomap::detail::PartitionQueue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__detail__PartitionQueue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PartitionQueue_flow_get" "', argument " "1"" of type '" "infomap::detail::PartitionQueue *""'"); 
  }
  arg1 = reinterpret_cast< infomap::detail::PartitionQueue * >(argp1);
  result = (double) ((arg1)->flow);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_PartitionQueue_nonTrivialFlow_set ( SEXP self, SEXP s_nonTrivialFlow)
{
  infomap::detail::PartitionQueue *arg1 = (infomap::detail::PartitionQueue *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__detail__PartitionQueue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PartitionQueue_nonTrivialFlow_set" "', argument " "1"" of type '" "infomap::detail::PartitionQueue *""'"); 
  }
  arg1 = reinterpret_cast< infomap::detail::PartitionQueue * >(argp1);
  arg2 = static_cast< double >(REAL(s_nonTrivialFlow)[0]);
  if (arg1) (arg1)->nonTrivialFlow = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_PartitionQueue_nonTrivialFlow_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::detail::PartitionQueue *arg1 = (infomap::detail::PartitionQueue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__detail__PartitionQueue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PartitionQueue_nonTrivialFlow_get" "', argument " "1"" of type '" "infomap::detail::PartitionQueue *""'"); 
  }
  arg1 = reinterpret_cast< infomap::detail::PartitionQueue * >(argp1);
  result = (double) ((arg1)->nonTrivialFlow);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_PartitionQueue_skip_set ( SEXP self, SEXP s_skip)
{
  infomap::detail::PartitionQueue *arg1 = (infomap::detail::PartitionQueue *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__detail__PartitionQueue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PartitionQueue_skip_set" "', argument " "1"" of type '" "infomap::detail::PartitionQueue *""'"); 
  }
  arg1 = reinterpret_cast< infomap::detail::PartitionQueue * >(argp1);
  arg2 = LOGICAL(s_skip)[0] ? true : false;
  if (arg1) (arg1)->skip = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_PartitionQueue_skip_get ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  infomap::detail::PartitionQueue *arg1 = (infomap::detail::PartitionQueue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__detail__PartitionQueue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PartitionQueue_skip_get" "', argument " "1"" of type '" "infomap::detail::PartitionQueue *""'"); 
  }
  arg1 = reinterpret_cast< infomap::detail::PartitionQueue * >(argp1);
  result = (bool) ((arg1)->skip);
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_PartitionQueue_indexCodelength_set ( SEXP self, SEXP s_indexCodelength)
{
  infomap::detail::PartitionQueue *arg1 = (infomap::detail::PartitionQueue *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__detail__PartitionQueue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PartitionQueue_indexCodelength_set" "', argument " "1"" of type '" "infomap::detail::PartitionQueue *""'"); 
  }
  arg1 = reinterpret_cast< infomap::detail::PartitionQueue * >(argp1);
  arg2 = static_cast< double >(REAL(s_indexCodelength)[0]);
  if (arg1) (arg1)->indexCodelength = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_PartitionQueue_indexCodelength_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::detail::PartitionQueue *arg1 = (infomap::detail::PartitionQueue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__detail__PartitionQueue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PartitionQueue_indexCodelength_get" "', argument " "1"" of type '" "infomap::detail::PartitionQueue *""'"); 
  }
  arg1 = reinterpret_cast< infomap::detail::PartitionQueue * >(argp1);
  result = (double) ((arg1)->indexCodelength);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_PartitionQueue_leafCodelength_set ( SEXP self, SEXP s_leafCodelength)
{
  infomap::detail::PartitionQueue *arg1 = (infomap::detail::PartitionQueue *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__detail__PartitionQueue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PartitionQueue_leafCodelength_set" "', argument " "1"" of type '" "infomap::detail::PartitionQueue *""'"); 
  }
  arg1 = reinterpret_cast< infomap::detail::PartitionQueue * >(argp1);
  arg2 = static_cast< double >(REAL(s_leafCodelength)[0]);
  if (arg1) (arg1)->leafCodelength = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_PartitionQueue_leafCodelength_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::detail::PartitionQueue *arg1 = (infomap::detail::PartitionQueue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__detail__PartitionQueue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PartitionQueue_leafCodelength_get" "', argument " "1"" of type '" "infomap::detail::PartitionQueue *""'"); 
  }
  arg1 = reinterpret_cast< infomap::detail::PartitionQueue * >(argp1);
  result = (double) ((arg1)->leafCodelength);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_PartitionQueue_moduleCodelength_set ( SEXP self, SEXP s_moduleCodelength)
{
  infomap::detail::PartitionQueue *arg1 = (infomap::detail::PartitionQueue *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__detail__PartitionQueue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PartitionQueue_moduleCodelength_set" "', argument " "1"" of type '" "infomap::detail::PartitionQueue *""'"); 
  }
  arg1 = reinterpret_cast< infomap::detail::PartitionQueue * >(argp1);
  arg2 = static_cast< double >(REAL(s_moduleCodelength)[0]);
  if (arg1) (arg1)->moduleCodelength = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_PartitionQueue_moduleCodelength_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::detail::PartitionQueue *arg1 = (infomap::detail::PartitionQueue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__detail__PartitionQueue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PartitionQueue_moduleCodelength_get" "', argument " "1"" of type '" "infomap::detail::PartitionQueue *""'"); 
  }
  arg1 = reinterpret_cast< infomap::detail::PartitionQueue * >(argp1);
  result = (double) ((arg1)->moduleCodelength);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_PartitionQueue ( )
{
  infomap::detail::PartitionQueue *result = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    try {
      result = (infomap::detail::PartitionQueue *)new infomap::detail::PartitionQueue();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__detail__PartitionQueue, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_PartitionQueue ( SEXP self)
{
  infomap::detail::PartitionQueue *arg1 = (infomap::detail::PartitionQueue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__detail__PartitionQueue, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_PartitionQueue" "', argument " "1"" of type '" "infomap::detail::PartitionQueue *""'"); 
  }
  arg1 = reinterpret_cast< infomap::detail::PartitionQueue * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_MapEquation__SWIG_0 ( )
{
  infomap::MapEquation *result = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    try {
      result = (infomap::MapEquation *)new infomap::MapEquation();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__MapEquation, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_MapEquation__SWIG_1 ( SEXP other)
{
  infomap::MapEquation *result = 0 ;
  infomap::MapEquation *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(other, &argp1, SWIGTYPE_p_infomap__MapEquation,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_MapEquation" "', argument " "1"" of type '" "infomap::MapEquation const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MapEquation" "', argument " "1"" of type '" "infomap::MapEquation const &""'"); 
  }
  arg1 = reinterpret_cast< infomap::MapEquation * >(argp1);
  {
    try {
      result = (infomap::MapEquation *)new infomap::MapEquation((infomap::MapEquation const &)*arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__MapEquation, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MapEquation_Equal ( SEXP self, SEXP other, SEXP s_swig_copy)
{
  infomap::MapEquation *result = 0 ;
  infomap::MapEquation *arg1 = (infomap::MapEquation *) 0 ;
  infomap::MapEquation *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MapEquation_Equal" "', argument " "1"" of type '" "infomap::MapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MapEquation * >(argp1);
  res2 = SWIG_R_ConvertPtr(other, &argp2, SWIGTYPE_p_infomap__MapEquation,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MapEquation_Equal" "', argument " "2"" of type '" "infomap::MapEquation const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MapEquation_Equal" "', argument " "2"" of type '" "infomap::MapEquation const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::MapEquation * >(argp2);
  {
    try {
      result = (infomap::MapEquation *) &(arg1)->operator =((infomap::MapEquation const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__MapEquation, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_MapEquation ( SEXP self)
{
  infomap::MapEquation *arg1 = (infomap::MapEquation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MapEquation, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_MapEquation" "', argument " "1"" of type '" "infomap::MapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MapEquation * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MapEquation_getIndexCodelength ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::MapEquation *arg1 = (infomap::MapEquation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MapEquation_getIndexCodelength" "', argument " "1"" of type '" "infomap::MapEquation const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MapEquation * >(argp1);
  {
    try {
      result = (double)((infomap::MapEquation const *)arg1)->getIndexCodelength();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MapEquation_getModuleCodelength ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::MapEquation *arg1 = (infomap::MapEquation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MapEquation_getModuleCodelength" "', argument " "1"" of type '" "infomap::MapEquation const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MapEquation * >(argp1);
  {
    try {
      result = (double)((infomap::MapEquation const *)arg1)->getModuleCodelength();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MapEquation_getCodelength ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::MapEquation *arg1 = (infomap::MapEquation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MapEquation_getCodelength" "', argument " "1"" of type '" "infomap::MapEquation const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MapEquation * >(argp1);
  {
    try {
      result = (double)((infomap::MapEquation const *)arg1)->getCodelength();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MapEquation_print ( SEXP self, SEXP s_arg2, SEXP s_swig_copy)
{
  std::ostream *result = 0 ;
  infomap::MapEquation *arg1 = (infomap::MapEquation *) 0 ;
  std::ostream *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MapEquation_print" "', argument " "1"" of type '" "infomap::MapEquation const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MapEquation * >(argp1);
  res2 = SWIG_R_ConvertPtr(s_arg2, &argp2, SWIGTYPE_p_std__ostream,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MapEquation_print" "', argument " "2"" of type '" "std::ostream &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MapEquation_print" "', argument " "2"" of type '" "std::ostream &""'"); 
  }
  arg2 = reinterpret_cast< std::ostream * >(argp2);
  {
    try {
      result = (std::ostream *) &((infomap::MapEquation const *)arg1)->print(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__ostream, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MapEquation_init ( SEXP self, SEXP config)
{
  infomap::MapEquation *arg1 = (infomap::MapEquation *) 0 ;
  infomap::Config *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MapEquation_init" "', argument " "1"" of type '" "infomap::MapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MapEquation * >(argp1);
  res2 = SWIG_R_ConvertPtr(config, &argp2, SWIGTYPE_p_infomap__Config,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MapEquation_init" "', argument " "2"" of type '" "infomap::Config const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MapEquation_init" "', argument " "2"" of type '" "infomap::Config const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::Config * >(argp2);
  {
    try {
      (arg1)->init((infomap::Config const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MapEquation_initNetwork ( SEXP self, SEXP root)
{
  infomap::MapEquation *arg1 = (infomap::MapEquation *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MapEquation_initNetwork" "', argument " "1"" of type '" "infomap::MapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MapEquation * >(argp1);
  res2 = SWIG_R_ConvertPtr(root, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MapEquation_initNetwork" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MapEquation_initNetwork" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  {
    try {
      (arg1)->initNetwork(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MapEquation_initSuperNetwork ( SEXP self, SEXP root)
{
  infomap::MapEquation *arg1 = (infomap::MapEquation *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MapEquation_initSuperNetwork" "', argument " "1"" of type '" "infomap::MapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MapEquation * >(argp1);
  res2 = SWIG_R_ConvertPtr(root, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MapEquation_initSuperNetwork" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MapEquation_initSuperNetwork" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  {
    try {
      (arg1)->initSuperNetwork(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MapEquation_initSubNetwork ( SEXP self, SEXP root)
{
  infomap::MapEquation *arg1 = (infomap::MapEquation *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MapEquation_initSubNetwork" "', argument " "1"" of type '" "infomap::MapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MapEquation * >(argp1);
  res2 = SWIG_R_ConvertPtr(root, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MapEquation_initSubNetwork" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MapEquation_initSubNetwork" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  {
    try {
      (arg1)->initSubNetwork(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MapEquation_initPartition ( SEXP self, SEXP nodes)
{
  infomap::MapEquation *arg1 = (infomap::MapEquation *) 0 ;
  std::vector< infomap::InfoNode *,std::allocator< infomap::InfoNode * > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MapEquation_initPartition" "', argument " "1"" of type '" "infomap::MapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MapEquation * >(argp1);
  res2 = SWIG_R_ConvertPtr(nodes, &argp2, SWIGTYPE_p_std__vectorT_infomap__InfoNode_p_std__allocatorT_infomap__InfoNode_p_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MapEquation_initPartition" "', argument " "2"" of type '" "std::vector< infomap::InfoNode *,std::allocator< infomap::InfoNode * > > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MapEquation_initPartition" "', argument " "2"" of type '" "std::vector< infomap::InfoNode *,std::allocator< infomap::InfoNode * > > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector< infomap::InfoNode *,std::allocator< infomap::InfoNode * > > * >(argp2);
  {
    try {
      (arg1)->initPartition(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MapEquation_calcCodelength ( SEXP self, SEXP parent, SEXP s_swig_copy)
{
  double result;
  infomap::MapEquation *arg1 = (infomap::MapEquation *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MapEquation_calcCodelength" "', argument " "1"" of type '" "infomap::MapEquation const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MapEquation * >(argp1);
  res2 = SWIG_R_ConvertPtr(parent, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MapEquation_calcCodelength" "', argument " "2"" of type '" "infomap::InfoNode const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MapEquation_calcCodelength" "', argument " "2"" of type '" "infomap::InfoNode const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  {
    try {
      result = (double)((infomap::MapEquation const *)arg1)->calcCodelength((infomap::InfoNode const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MapEquation_addMemoryContributions__SWIG_0 ( SEXP self, SEXP current, SEXP oldModuleDelta, SEXP newModuleDelta)
{
  infomap::MapEquation *arg1 = (infomap::MapEquation *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  infomap::MapEquation::DeltaFlowDataType *arg3 = 0 ;
  infomap::MapEquation::DeltaFlowDataType *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MapEquation_addMemoryContributions" "', argument " "1"" of type '" "infomap::MapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MapEquation * >(argp1);
  res2 = SWIG_R_ConvertPtr(current, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MapEquation_addMemoryContributions" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MapEquation_addMemoryContributions" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  res3 = SWIG_R_ConvertPtr(oldModuleDelta, &argp3, SWIGTYPE_p_infomap__DeltaFlow,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "MapEquation_addMemoryContributions" "', argument " "3"" of type '" "infomap::MapEquation::DeltaFlowDataType &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MapEquation_addMemoryContributions" "', argument " "3"" of type '" "infomap::MapEquation::DeltaFlowDataType &""'"); 
  }
  arg3 = reinterpret_cast< infomap::MapEquation::DeltaFlowDataType * >(argp3);
  res4 = SWIG_R_ConvertPtr(newModuleDelta, &argp4, SWIGTYPE_p_infomap__DeltaFlow,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "MapEquation_addMemoryContributions" "', argument " "4"" of type '" "infomap::MapEquation::DeltaFlowDataType &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MapEquation_addMemoryContributions" "', argument " "4"" of type '" "infomap::MapEquation::DeltaFlowDataType &""'"); 
  }
  arg4 = reinterpret_cast< infomap::MapEquation::DeltaFlowDataType * >(argp4);
  {
    try {
      (arg1)->addMemoryContributions(*arg2,*arg3,*arg4);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MapEquation_addMemoryContributions__SWIG_1 ( SEXP self, SEXP current, SEXP oldModuleDelta, SEXP moduleDeltaFlow)
{
  infomap::MapEquation *arg1 = (infomap::MapEquation *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  infomap::MapEquation::DeltaFlowDataType *arg3 = 0 ;
  VectorMap< infomap::MapEquation::DeltaFlowDataType > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MapEquation_addMemoryContributions" "', argument " "1"" of type '" "infomap::MapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MapEquation * >(argp1);
  res2 = SWIG_R_ConvertPtr(current, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MapEquation_addMemoryContributions" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MapEquation_addMemoryContributions" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  res3 = SWIG_R_ConvertPtr(oldModuleDelta, &argp3, SWIGTYPE_p_infomap__DeltaFlow,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "MapEquation_addMemoryContributions" "', argument " "3"" of type '" "infomap::MapEquation::DeltaFlowDataType &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MapEquation_addMemoryContributions" "', argument " "3"" of type '" "infomap::MapEquation::DeltaFlowDataType &""'"); 
  }
  arg3 = reinterpret_cast< infomap::MapEquation::DeltaFlowDataType * >(argp3);
  res4 = SWIG_R_ConvertPtr(moduleDeltaFlow, &argp4, SWIGTYPE_p_VectorMapT_infomap__DeltaFlow_t,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "MapEquation_addMemoryContributions" "', argument " "4"" of type '" "VectorMap< infomap::MapEquation::DeltaFlowDataType > &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MapEquation_addMemoryContributions" "', argument " "4"" of type '" "VectorMap< infomap::MapEquation::DeltaFlowDataType > &""'"); 
  }
  arg4 = reinterpret_cast< VectorMap< infomap::MapEquation::DeltaFlowDataType > * >(argp4);
  {
    try {
      (arg1)->addMemoryContributions(*arg2,*arg3,*arg4);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MapEquation_getDeltaCodelengthOnMovingNode ( SEXP self, SEXP current, SEXP oldModuleDelta, SEXP newModuleDelta, SEXP moduleFlowData, SEXP moduleMembers, SEXP s_swig_copy)
{
  double result;
  infomap::MapEquation *arg1 = (infomap::MapEquation *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  infomap::MapEquation::DeltaFlowDataType *arg3 = 0 ;
  infomap::MapEquation::DeltaFlowDataType *arg4 = 0 ;
  std::vector< infomap::MapEquation::FlowDataType,std::allocator< infomap::MapEquation::FlowDataType > > *arg5 = 0 ;
  std::vector< unsigned int,std::allocator< unsigned int > > *arg6 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MapEquation_getDeltaCodelengthOnMovingNode" "', argument " "1"" of type '" "infomap::MapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MapEquation * >(argp1);
  res2 = SWIG_R_ConvertPtr(current, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MapEquation_getDeltaCodelengthOnMovingNode" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MapEquation_getDeltaCodelengthOnMovingNode" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  res3 = SWIG_R_ConvertPtr(oldModuleDelta, &argp3, SWIGTYPE_p_infomap__DeltaFlow,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "MapEquation_getDeltaCodelengthOnMovingNode" "', argument " "3"" of type '" "infomap::MapEquation::DeltaFlowDataType &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MapEquation_getDeltaCodelengthOnMovingNode" "', argument " "3"" of type '" "infomap::MapEquation::DeltaFlowDataType &""'"); 
  }
  arg3 = reinterpret_cast< infomap::MapEquation::DeltaFlowDataType * >(argp3);
  res4 = SWIG_R_ConvertPtr(newModuleDelta, &argp4, SWIGTYPE_p_infomap__DeltaFlow,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "MapEquation_getDeltaCodelengthOnMovingNode" "', argument " "4"" of type '" "infomap::MapEquation::DeltaFlowDataType &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MapEquation_getDeltaCodelengthOnMovingNode" "', argument " "4"" of type '" "infomap::MapEquation::DeltaFlowDataType &""'"); 
  }
  arg4 = reinterpret_cast< infomap::MapEquation::DeltaFlowDataType * >(argp4);
  res5 = SWIG_R_ConvertPtr(moduleFlowData, &argp5, SWIGTYPE_p_std__vectorT_infomap__FlowData_std__allocatorT_infomap__FlowData_t_t,  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "MapEquation_getDeltaCodelengthOnMovingNode" "', argument " "5"" of type '" "std::vector< infomap::MapEquation::FlowDataType,std::allocator< infomap::MapEquation::FlowDataType > > &""'"); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MapEquation_getDeltaCodelengthOnMovingNode" "', argument " "5"" of type '" "std::vector< infomap::MapEquation::FlowDataType,std::allocator< infomap::MapEquation::FlowDataType > > &""'"); 
  }
  arg5 = reinterpret_cast< std::vector< infomap::MapEquation::FlowDataType,std::allocator< infomap::MapEquation::FlowDataType > > * >(argp5);
  res6 = SWIG_R_ConvertPtr(moduleMembers, &argp6, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t,  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "MapEquation_getDeltaCodelengthOnMovingNode" "', argument " "6"" of type '" "std::vector< unsigned int,std::allocator< unsigned int > > &""'"); 
  }
  if (!argp6) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MapEquation_getDeltaCodelengthOnMovingNode" "', argument " "6"" of type '" "std::vector< unsigned int,std::allocator< unsigned int > > &""'"); 
  }
  arg6 = reinterpret_cast< std::vector< unsigned int,std::allocator< unsigned int > > * >(argp6);
  {
    try {
      result = (double)(arg1)->getDeltaCodelengthOnMovingNode(*arg2,*arg3,*arg4,*arg5,*arg6);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MapEquation_updateCodelengthOnMovingNode ( SEXP self, SEXP current, SEXP oldModuleDelta, SEXP newModuleDelta, SEXP moduleFlowData, SEXP moduleMembers)
{
  infomap::MapEquation *arg1 = (infomap::MapEquation *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  infomap::MapEquation::DeltaFlowDataType *arg3 = 0 ;
  infomap::MapEquation::DeltaFlowDataType *arg4 = 0 ;
  std::vector< infomap::MapEquation::FlowDataType,std::allocator< infomap::MapEquation::FlowDataType > > *arg5 = 0 ;
  std::vector< unsigned int,std::allocator< unsigned int > > *arg6 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MapEquation_updateCodelengthOnMovingNode" "', argument " "1"" of type '" "infomap::MapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MapEquation * >(argp1);
  res2 = SWIG_R_ConvertPtr(current, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MapEquation_updateCodelengthOnMovingNode" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MapEquation_updateCodelengthOnMovingNode" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  res3 = SWIG_R_ConvertPtr(oldModuleDelta, &argp3, SWIGTYPE_p_infomap__DeltaFlow,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "MapEquation_updateCodelengthOnMovingNode" "', argument " "3"" of type '" "infomap::MapEquation::DeltaFlowDataType &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MapEquation_updateCodelengthOnMovingNode" "', argument " "3"" of type '" "infomap::MapEquation::DeltaFlowDataType &""'"); 
  }
  arg3 = reinterpret_cast< infomap::MapEquation::DeltaFlowDataType * >(argp3);
  res4 = SWIG_R_ConvertPtr(newModuleDelta, &argp4, SWIGTYPE_p_infomap__DeltaFlow,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "MapEquation_updateCodelengthOnMovingNode" "', argument " "4"" of type '" "infomap::MapEquation::DeltaFlowDataType &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MapEquation_updateCodelengthOnMovingNode" "', argument " "4"" of type '" "infomap::MapEquation::DeltaFlowDataType &""'"); 
  }
  arg4 = reinterpret_cast< infomap::MapEquation::DeltaFlowDataType * >(argp4);
  res5 = SWIG_R_ConvertPtr(moduleFlowData, &argp5, SWIGTYPE_p_std__vectorT_infomap__FlowData_std__allocatorT_infomap__FlowData_t_t,  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "MapEquation_updateCodelengthOnMovingNode" "', argument " "5"" of type '" "std::vector< infomap::MapEquation::FlowDataType,std::allocator< infomap::MapEquation::FlowDataType > > &""'"); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MapEquation_updateCodelengthOnMovingNode" "', argument " "5"" of type '" "std::vector< infomap::MapEquation::FlowDataType,std::allocator< infomap::MapEquation::FlowDataType > > &""'"); 
  }
  arg5 = reinterpret_cast< std::vector< infomap::MapEquation::FlowDataType,std::allocator< infomap::MapEquation::FlowDataType > > * >(argp5);
  res6 = SWIG_R_ConvertPtr(moduleMembers, &argp6, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t,  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "MapEquation_updateCodelengthOnMovingNode" "', argument " "6"" of type '" "std::vector< unsigned int,std::allocator< unsigned int > > &""'"); 
  }
  if (!argp6) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MapEquation_updateCodelengthOnMovingNode" "', argument " "6"" of type '" "std::vector< unsigned int,std::allocator< unsigned int > > &""'"); 
  }
  arg6 = reinterpret_cast< std::vector< unsigned int,std::allocator< unsigned int > > * >(argp6);
  {
    try {
      (arg1)->updateCodelengthOnMovingNode(*arg2,*arg3,*arg4,*arg5,*arg6);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MapEquation_consolidateModules ( SEXP self, SEXP modules)
{
  infomap::MapEquation *arg1 = (infomap::MapEquation *) 0 ;
  std::vector< infomap::InfoNode *,std::allocator< infomap::InfoNode * > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MapEquation_consolidateModules" "', argument " "1"" of type '" "infomap::MapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MapEquation * >(argp1);
  res2 = SWIG_R_ConvertPtr(modules, &argp2, SWIGTYPE_p_std__vectorT_infomap__InfoNode_p_std__allocatorT_infomap__InfoNode_p_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MapEquation_consolidateModules" "', argument " "2"" of type '" "std::vector< infomap::InfoNode *,std::allocator< infomap::InfoNode * > > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MapEquation_consolidateModules" "', argument " "2"" of type '" "std::vector< infomap::InfoNode *,std::allocator< infomap::InfoNode * > > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector< infomap::InfoNode *,std::allocator< infomap::InfoNode * > > * >(argp2);
  {
    try {
      (arg1)->consolidateModules(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MapEquation_printDebug ( SEXP self)
{
  infomap::MapEquation *arg1 = (infomap::MapEquation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MapEquation_printDebug" "', argument " "1"" of type '" "infomap::MapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MapEquation * >(argp1);
  {
    try {
      (arg1)->printDebug();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MapEquation_codelength_set ( SEXP self, SEXP s_codelength)
{
  infomap::MapEquation *arg1 = (infomap::MapEquation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MapEquation_codelength_set" "', argument " "1"" of type '" "infomap::MapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MapEquation * >(argp1);
  arg2 = static_cast< double >(REAL(s_codelength)[0]);
  if (arg1) (arg1)->codelength = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MapEquation_codelength_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::MapEquation *arg1 = (infomap::MapEquation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MapEquation_codelength_get" "', argument " "1"" of type '" "infomap::MapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MapEquation * >(argp1);
  result = (double) ((arg1)->codelength);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MapEquation_indexCodelength_set ( SEXP self, SEXP s_indexCodelength)
{
  infomap::MapEquation *arg1 = (infomap::MapEquation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MapEquation_indexCodelength_set" "', argument " "1"" of type '" "infomap::MapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MapEquation * >(argp1);
  arg2 = static_cast< double >(REAL(s_indexCodelength)[0]);
  if (arg1) (arg1)->indexCodelength = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MapEquation_indexCodelength_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::MapEquation *arg1 = (infomap::MapEquation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MapEquation_indexCodelength_get" "', argument " "1"" of type '" "infomap::MapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MapEquation * >(argp1);
  result = (double) ((arg1)->indexCodelength);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MapEquation_moduleCodelength_set ( SEXP self, SEXP s_moduleCodelength)
{
  infomap::MapEquation *arg1 = (infomap::MapEquation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MapEquation_moduleCodelength_set" "', argument " "1"" of type '" "infomap::MapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MapEquation * >(argp1);
  arg2 = static_cast< double >(REAL(s_moduleCodelength)[0]);
  if (arg1) (arg1)->moduleCodelength = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MapEquation_moduleCodelength_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::MapEquation *arg1 = (infomap::MapEquation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MapEquation_moduleCodelength_get" "', argument " "1"" of type '" "infomap::MapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MapEquation * >(argp1);
  result = (double) ((arg1)->moduleCodelength);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_MemMapEquation__SWIG_0 ( )
{
  infomap::MemMapEquation *result = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    try {
      result = (infomap::MemMapEquation *)new infomap::MemMapEquation();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__MemMapEquation, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_MemMapEquation__SWIG_1 ( SEXP other)
{
  infomap::MemMapEquation *result = 0 ;
  infomap::MemMapEquation *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(other, &argp1, SWIGTYPE_p_infomap__MemMapEquation,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_MemMapEquation" "', argument " "1"" of type '" "infomap::MemMapEquation const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MemMapEquation" "', argument " "1"" of type '" "infomap::MemMapEquation const &""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemMapEquation * >(argp1);
  {
    try {
      result = (infomap::MemMapEquation *)new infomap::MemMapEquation((infomap::MemMapEquation const &)*arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__MemMapEquation, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MemMapEquation_Equal ( SEXP self, SEXP other, SEXP s_swig_copy)
{
  infomap::MemMapEquation *result = 0 ;
  infomap::MemMapEquation *arg1 = (infomap::MemMapEquation *) 0 ;
  infomap::MemMapEquation *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MemMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemMapEquation_Equal" "', argument " "1"" of type '" "infomap::MemMapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemMapEquation * >(argp1);
  res2 = SWIG_R_ConvertPtr(other, &argp2, SWIGTYPE_p_infomap__MemMapEquation,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MemMapEquation_Equal" "', argument " "2"" of type '" "infomap::MemMapEquation const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MemMapEquation_Equal" "', argument " "2"" of type '" "infomap::MemMapEquation const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::MemMapEquation * >(argp2);
  {
    try {
      result = (infomap::MemMapEquation *) &(arg1)->operator =((infomap::MemMapEquation const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__MemMapEquation, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_MemMapEquation ( SEXP self)
{
  infomap::MemMapEquation *arg1 = (infomap::MemMapEquation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MemMapEquation, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_MemMapEquation" "', argument " "1"" of type '" "infomap::MemMapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemMapEquation * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MemMapEquation_getIndexCodelength ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::MemMapEquation *arg1 = (infomap::MemMapEquation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MemMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemMapEquation_getIndexCodelength" "', argument " "1"" of type '" "infomap::MemMapEquation const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemMapEquation * >(argp1);
  {
    try {
      result = (double)((infomap::MemMapEquation const *)arg1)->getIndexCodelength();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MemMapEquation_getModuleCodelength ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::MemMapEquation *arg1 = (infomap::MemMapEquation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MemMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemMapEquation_getModuleCodelength" "', argument " "1"" of type '" "infomap::MemMapEquation const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemMapEquation * >(argp1);
  {
    try {
      result = (double)((infomap::MemMapEquation const *)arg1)->getModuleCodelength();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MemMapEquation_getCodelength ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::MemMapEquation *arg1 = (infomap::MemMapEquation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MemMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemMapEquation_getCodelength" "', argument " "1"" of type '" "infomap::MemMapEquation const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemMapEquation * >(argp1);
  {
    try {
      result = (double)((infomap::MemMapEquation const *)arg1)->getCodelength();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MemMapEquation_print ( SEXP self, SEXP out, SEXP s_swig_copy)
{
  std::ostream *result = 0 ;
  infomap::MemMapEquation *arg1 = (infomap::MemMapEquation *) 0 ;
  std::ostream *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MemMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemMapEquation_print" "', argument " "1"" of type '" "infomap::MemMapEquation const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemMapEquation * >(argp1);
  res2 = SWIG_R_ConvertPtr(out, &argp2, SWIGTYPE_p_std__ostream,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MemMapEquation_print" "', argument " "2"" of type '" "std::ostream &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MemMapEquation_print" "', argument " "2"" of type '" "std::ostream &""'"); 
  }
  arg2 = reinterpret_cast< std::ostream * >(argp2);
  {
    try {
      result = (std::ostream *) &((infomap::MemMapEquation const *)arg1)->print(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__ostream, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MemMapEquation_init ( SEXP self, SEXP config)
{
  infomap::MemMapEquation *arg1 = (infomap::MemMapEquation *) 0 ;
  infomap::Config *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MemMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemMapEquation_init" "', argument " "1"" of type '" "infomap::MemMapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemMapEquation * >(argp1);
  res2 = SWIG_R_ConvertPtr(config, &argp2, SWIGTYPE_p_infomap__Config,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MemMapEquation_init" "', argument " "2"" of type '" "infomap::Config const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MemMapEquation_init" "', argument " "2"" of type '" "infomap::Config const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::Config * >(argp2);
  {
    try {
      (arg1)->init((infomap::Config const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MemMapEquation_initNetwork ( SEXP self, SEXP root)
{
  infomap::MemMapEquation *arg1 = (infomap::MemMapEquation *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MemMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemMapEquation_initNetwork" "', argument " "1"" of type '" "infomap::MemMapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemMapEquation * >(argp1);
  res2 = SWIG_R_ConvertPtr(root, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MemMapEquation_initNetwork" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MemMapEquation_initNetwork" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  {
    try {
      (arg1)->initNetwork(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MemMapEquation_initSuperNetwork ( SEXP self, SEXP root)
{
  infomap::MemMapEquation *arg1 = (infomap::MemMapEquation *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MemMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemMapEquation_initSuperNetwork" "', argument " "1"" of type '" "infomap::MemMapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemMapEquation * >(argp1);
  res2 = SWIG_R_ConvertPtr(root, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MemMapEquation_initSuperNetwork" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MemMapEquation_initSuperNetwork" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  {
    try {
      (arg1)->initSuperNetwork(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MemMapEquation_initSubNetwork ( SEXP self, SEXP root)
{
  infomap::MemMapEquation *arg1 = (infomap::MemMapEquation *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MemMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemMapEquation_initSubNetwork" "', argument " "1"" of type '" "infomap::MemMapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemMapEquation * >(argp1);
  res2 = SWIG_R_ConvertPtr(root, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MemMapEquation_initSubNetwork" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MemMapEquation_initSubNetwork" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  {
    try {
      (arg1)->initSubNetwork(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MemMapEquation_initPartition ( SEXP self, SEXP nodes)
{
  infomap::MemMapEquation *arg1 = (infomap::MemMapEquation *) 0 ;
  std::vector< infomap::InfoNode *,std::allocator< infomap::InfoNode * > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MemMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemMapEquation_initPartition" "', argument " "1"" of type '" "infomap::MemMapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemMapEquation * >(argp1);
  res2 = SWIG_R_ConvertPtr(nodes, &argp2, SWIGTYPE_p_std__vectorT_infomap__InfoNode_p_std__allocatorT_infomap__InfoNode_p_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MemMapEquation_initPartition" "', argument " "2"" of type '" "std::vector< infomap::InfoNode *,std::allocator< infomap::InfoNode * > > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MemMapEquation_initPartition" "', argument " "2"" of type '" "std::vector< infomap::InfoNode *,std::allocator< infomap::InfoNode * > > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector< infomap::InfoNode *,std::allocator< infomap::InfoNode * > > * >(argp2);
  {
    try {
      (arg1)->initPartition(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MemMapEquation_calcCodelength ( SEXP self, SEXP parent, SEXP s_swig_copy)
{
  double result;
  infomap::MemMapEquation *arg1 = (infomap::MemMapEquation *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MemMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemMapEquation_calcCodelength" "', argument " "1"" of type '" "infomap::MemMapEquation const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemMapEquation * >(argp1);
  res2 = SWIG_R_ConvertPtr(parent, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MemMapEquation_calcCodelength" "', argument " "2"" of type '" "infomap::InfoNode const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MemMapEquation_calcCodelength" "', argument " "2"" of type '" "infomap::InfoNode const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  {
    try {
      result = (double)((infomap::MemMapEquation const *)arg1)->calcCodelength((infomap::InfoNode const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MemMapEquation_addMemoryContributions ( SEXP self, SEXP current, SEXP oldModuleDelta, SEXP moduleDeltaFlow)
{
  infomap::MemMapEquation *arg1 = (infomap::MemMapEquation *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  infomap::MemMapEquation::DeltaFlowDataType *arg3 = 0 ;
  VectorMap< infomap::MemMapEquation::DeltaFlowDataType > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MemMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemMapEquation_addMemoryContributions" "', argument " "1"" of type '" "infomap::MemMapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemMapEquation * >(argp1);
  res2 = SWIG_R_ConvertPtr(current, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MemMapEquation_addMemoryContributions" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MemMapEquation_addMemoryContributions" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  res3 = SWIG_R_ConvertPtr(oldModuleDelta, &argp3, SWIGTYPE_p_infomap__MemDeltaFlow,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "MemMapEquation_addMemoryContributions" "', argument " "3"" of type '" "infomap::MemMapEquation::DeltaFlowDataType &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MemMapEquation_addMemoryContributions" "', argument " "3"" of type '" "infomap::MemMapEquation::DeltaFlowDataType &""'"); 
  }
  arg3 = reinterpret_cast< infomap::MemMapEquation::DeltaFlowDataType * >(argp3);
  res4 = SWIG_R_ConvertPtr(moduleDeltaFlow, &argp4, SWIGTYPE_p_VectorMapT_infomap__MemDeltaFlow_t,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "MemMapEquation_addMemoryContributions" "', argument " "4"" of type '" "VectorMap< infomap::MemMapEquation::DeltaFlowDataType > &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MemMapEquation_addMemoryContributions" "', argument " "4"" of type '" "VectorMap< infomap::MemMapEquation::DeltaFlowDataType > &""'"); 
  }
  arg4 = reinterpret_cast< VectorMap< infomap::MemMapEquation::DeltaFlowDataType > * >(argp4);
  {
    try {
      (arg1)->addMemoryContributions(*arg2,*arg3,*arg4);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MemMapEquation_getDeltaCodelengthOnMovingNode ( SEXP self, SEXP current, SEXP oldModuleDelta, SEXP newModuleDelta, SEXP moduleFlowData, SEXP moduleMembers, SEXP s_swig_copy)
{
  double result;
  infomap::MemMapEquation *arg1 = (infomap::MemMapEquation *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  infomap::MemMapEquation::DeltaFlowDataType *arg3 = 0 ;
  infomap::MemMapEquation::DeltaFlowDataType *arg4 = 0 ;
  std::vector< infomap::MemMapEquation::FlowDataType,std::allocator< infomap::MemMapEquation::FlowDataType > > *arg5 = 0 ;
  std::vector< unsigned int,std::allocator< unsigned int > > *arg6 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MemMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemMapEquation_getDeltaCodelengthOnMovingNode" "', argument " "1"" of type '" "infomap::MemMapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemMapEquation * >(argp1);
  res2 = SWIG_R_ConvertPtr(current, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MemMapEquation_getDeltaCodelengthOnMovingNode" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MemMapEquation_getDeltaCodelengthOnMovingNode" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  res3 = SWIG_R_ConvertPtr(oldModuleDelta, &argp3, SWIGTYPE_p_infomap__MemDeltaFlow,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "MemMapEquation_getDeltaCodelengthOnMovingNode" "', argument " "3"" of type '" "infomap::MemMapEquation::DeltaFlowDataType &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MemMapEquation_getDeltaCodelengthOnMovingNode" "', argument " "3"" of type '" "infomap::MemMapEquation::DeltaFlowDataType &""'"); 
  }
  arg3 = reinterpret_cast< infomap::MemMapEquation::DeltaFlowDataType * >(argp3);
  res4 = SWIG_R_ConvertPtr(newModuleDelta, &argp4, SWIGTYPE_p_infomap__MemDeltaFlow,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "MemMapEquation_getDeltaCodelengthOnMovingNode" "', argument " "4"" of type '" "infomap::MemMapEquation::DeltaFlowDataType &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MemMapEquation_getDeltaCodelengthOnMovingNode" "', argument " "4"" of type '" "infomap::MemMapEquation::DeltaFlowDataType &""'"); 
  }
  arg4 = reinterpret_cast< infomap::MemMapEquation::DeltaFlowDataType * >(argp4);
  res5 = SWIG_R_ConvertPtr(moduleFlowData, &argp5, SWIGTYPE_p_std__vectorT_infomap__FlowData_std__allocatorT_infomap__FlowData_t_t,  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "MemMapEquation_getDeltaCodelengthOnMovingNode" "', argument " "5"" of type '" "std::vector< infomap::MemMapEquation::FlowDataType,std::allocator< infomap::MemMapEquation::FlowDataType > > &""'"); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MemMapEquation_getDeltaCodelengthOnMovingNode" "', argument " "5"" of type '" "std::vector< infomap::MemMapEquation::FlowDataType,std::allocator< infomap::MemMapEquation::FlowDataType > > &""'"); 
  }
  arg5 = reinterpret_cast< std::vector< infomap::MemMapEquation::FlowDataType,std::allocator< infomap::MemMapEquation::FlowDataType > > * >(argp5);
  res6 = SWIG_R_ConvertPtr(moduleMembers, &argp6, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t,  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "MemMapEquation_getDeltaCodelengthOnMovingNode" "', argument " "6"" of type '" "std::vector< unsigned int,std::allocator< unsigned int > > &""'"); 
  }
  if (!argp6) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MemMapEquation_getDeltaCodelengthOnMovingNode" "', argument " "6"" of type '" "std::vector< unsigned int,std::allocator< unsigned int > > &""'"); 
  }
  arg6 = reinterpret_cast< std::vector< unsigned int,std::allocator< unsigned int > > * >(argp6);
  {
    try {
      result = (double)(arg1)->getDeltaCodelengthOnMovingNode(*arg2,*arg3,*arg4,*arg5,*arg6);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MemMapEquation_updateCodelengthOnMovingNode ( SEXP self, SEXP current, SEXP oldModuleDelta, SEXP newModuleDelta, SEXP moduleFlowData, SEXP moduleMembers)
{
  infomap::MemMapEquation *arg1 = (infomap::MemMapEquation *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  infomap::MemMapEquation::DeltaFlowDataType *arg3 = 0 ;
  infomap::MemMapEquation::DeltaFlowDataType *arg4 = 0 ;
  std::vector< infomap::MemMapEquation::FlowDataType,std::allocator< infomap::MemMapEquation::FlowDataType > > *arg5 = 0 ;
  std::vector< unsigned int,std::allocator< unsigned int > > *arg6 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MemMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemMapEquation_updateCodelengthOnMovingNode" "', argument " "1"" of type '" "infomap::MemMapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemMapEquation * >(argp1);
  res2 = SWIG_R_ConvertPtr(current, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MemMapEquation_updateCodelengthOnMovingNode" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MemMapEquation_updateCodelengthOnMovingNode" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  res3 = SWIG_R_ConvertPtr(oldModuleDelta, &argp3, SWIGTYPE_p_infomap__MemDeltaFlow,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "MemMapEquation_updateCodelengthOnMovingNode" "', argument " "3"" of type '" "infomap::MemMapEquation::DeltaFlowDataType &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MemMapEquation_updateCodelengthOnMovingNode" "', argument " "3"" of type '" "infomap::MemMapEquation::DeltaFlowDataType &""'"); 
  }
  arg3 = reinterpret_cast< infomap::MemMapEquation::DeltaFlowDataType * >(argp3);
  res4 = SWIG_R_ConvertPtr(newModuleDelta, &argp4, SWIGTYPE_p_infomap__MemDeltaFlow,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "MemMapEquation_updateCodelengthOnMovingNode" "', argument " "4"" of type '" "infomap::MemMapEquation::DeltaFlowDataType &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MemMapEquation_updateCodelengthOnMovingNode" "', argument " "4"" of type '" "infomap::MemMapEquation::DeltaFlowDataType &""'"); 
  }
  arg4 = reinterpret_cast< infomap::MemMapEquation::DeltaFlowDataType * >(argp4);
  res5 = SWIG_R_ConvertPtr(moduleFlowData, &argp5, SWIGTYPE_p_std__vectorT_infomap__FlowData_std__allocatorT_infomap__FlowData_t_t,  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "MemMapEquation_updateCodelengthOnMovingNode" "', argument " "5"" of type '" "std::vector< infomap::MemMapEquation::FlowDataType,std::allocator< infomap::MemMapEquation::FlowDataType > > &""'"); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MemMapEquation_updateCodelengthOnMovingNode" "', argument " "5"" of type '" "std::vector< infomap::MemMapEquation::FlowDataType,std::allocator< infomap::MemMapEquation::FlowDataType > > &""'"); 
  }
  arg5 = reinterpret_cast< std::vector< infomap::MemMapEquation::FlowDataType,std::allocator< infomap::MemMapEquation::FlowDataType > > * >(argp5);
  res6 = SWIG_R_ConvertPtr(moduleMembers, &argp6, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t,  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "MemMapEquation_updateCodelengthOnMovingNode" "', argument " "6"" of type '" "std::vector< unsigned int,std::allocator< unsigned int > > &""'"); 
  }
  if (!argp6) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MemMapEquation_updateCodelengthOnMovingNode" "', argument " "6"" of type '" "std::vector< unsigned int,std::allocator< unsigned int > > &""'"); 
  }
  arg6 = reinterpret_cast< std::vector< unsigned int,std::allocator< unsigned int > > * >(argp6);
  {
    try {
      (arg1)->updateCodelengthOnMovingNode(*arg2,*arg3,*arg4,*arg5,*arg6);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MemMapEquation_consolidateModules ( SEXP self, SEXP modules)
{
  infomap::MemMapEquation *arg1 = (infomap::MemMapEquation *) 0 ;
  std::vector< infomap::InfoNode *,std::allocator< infomap::InfoNode * > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MemMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemMapEquation_consolidateModules" "', argument " "1"" of type '" "infomap::MemMapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemMapEquation * >(argp1);
  res2 = SWIG_R_ConvertPtr(modules, &argp2, SWIGTYPE_p_std__vectorT_infomap__InfoNode_p_std__allocatorT_infomap__InfoNode_p_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MemMapEquation_consolidateModules" "', argument " "2"" of type '" "std::vector< infomap::InfoNode *,std::allocator< infomap::InfoNode * > > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MemMapEquation_consolidateModules" "', argument " "2"" of type '" "std::vector< infomap::InfoNode *,std::allocator< infomap::InfoNode * > > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector< infomap::InfoNode *,std::allocator< infomap::InfoNode * > > * >(argp2);
  {
    try {
      (arg1)->consolidateModules(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MemMapEquation_printDebug ( SEXP self)
{
  infomap::MemMapEquation *arg1 = (infomap::MemMapEquation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MemMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemMapEquation_printDebug" "', argument " "1"" of type '" "infomap::MemMapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemMapEquation * >(argp1);
  {
    try {
      (arg1)->printDebug();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MemMapEquation_codelength_set ( SEXP self, SEXP s_codelength)
{
  infomap::MemMapEquation *arg1 = (infomap::MemMapEquation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MemMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemMapEquation_codelength_set" "', argument " "1"" of type '" "infomap::MemMapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemMapEquation * >(argp1);
  arg2 = static_cast< double >(REAL(s_codelength)[0]);
  if (arg1) (arg1)->codelength = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MemMapEquation_codelength_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::MemMapEquation *arg1 = (infomap::MemMapEquation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MemMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemMapEquation_codelength_get" "', argument " "1"" of type '" "infomap::MemMapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemMapEquation * >(argp1);
  result = (double) ((arg1)->codelength);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MemMapEquation_indexCodelength_set ( SEXP self, SEXP s_indexCodelength)
{
  infomap::MemMapEquation *arg1 = (infomap::MemMapEquation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MemMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemMapEquation_indexCodelength_set" "', argument " "1"" of type '" "infomap::MemMapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemMapEquation * >(argp1);
  arg2 = static_cast< double >(REAL(s_indexCodelength)[0]);
  if (arg1) (arg1)->indexCodelength = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MemMapEquation_indexCodelength_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::MemMapEquation *arg1 = (infomap::MemMapEquation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MemMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemMapEquation_indexCodelength_get" "', argument " "1"" of type '" "infomap::MemMapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemMapEquation * >(argp1);
  result = (double) ((arg1)->indexCodelength);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MemMapEquation_moduleCodelength_set ( SEXP self, SEXP s_moduleCodelength)
{
  infomap::MemMapEquation *arg1 = (infomap::MemMapEquation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MemMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemMapEquation_moduleCodelength_set" "', argument " "1"" of type '" "infomap::MemMapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemMapEquation * >(argp1);
  arg2 = static_cast< double >(REAL(s_moduleCodelength)[0]);
  if (arg1) (arg1)->moduleCodelength = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MemMapEquation_moduleCodelength_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::MemMapEquation *arg1 = (infomap::MemMapEquation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MemMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemMapEquation_moduleCodelength_get" "', argument " "1"" of type '" "infomap::MemMapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemMapEquation * >(argp1);
  result = (double) ((arg1)->moduleCodelength);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_MemNodeSet__SWIG_0 ( SEXP numMemNodes, SEXP sumFlow)
{
  infomap::MemNodeSet *result = 0 ;
  unsigned int arg1 ;
  double arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  ecode1 = SWIG_AsVal_int(numMemNodes, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_MemNodeSet" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  arg2 = static_cast< double >(REAL(sumFlow)[0]);
  {
    try {
      result = (infomap::MemNodeSet *)new infomap::MemNodeSet(arg1,arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__MemNodeSet, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_MemNodeSet__SWIG_1 ( SEXP other)
{
  infomap::MemNodeSet *result = 0 ;
  infomap::MemNodeSet *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(other, &argp1, SWIGTYPE_p_infomap__MemNodeSet,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_MemNodeSet" "', argument " "1"" of type '" "infomap::MemNodeSet const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MemNodeSet" "', argument " "1"" of type '" "infomap::MemNodeSet const &""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemNodeSet * >(argp1);
  {
    try {
      result = (infomap::MemNodeSet *)new infomap::MemNodeSet((infomap::MemNodeSet const &)*arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__MemNodeSet, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MemNodeSet_Equal ( SEXP self, SEXP other, SEXP s_swig_copy)
{
  infomap::MemNodeSet *result = 0 ;
  infomap::MemNodeSet *arg1 = (infomap::MemNodeSet *) 0 ;
  infomap::MemNodeSet *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MemNodeSet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemNodeSet_Equal" "', argument " "1"" of type '" "infomap::MemNodeSet *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemNodeSet * >(argp1);
  res2 = SWIG_R_ConvertPtr(other, &argp2, SWIGTYPE_p_infomap__MemNodeSet,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MemNodeSet_Equal" "', argument " "2"" of type '" "infomap::MemNodeSet const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MemNodeSet_Equal" "', argument " "2"" of type '" "infomap::MemNodeSet const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::MemNodeSet * >(argp2);
  {
    try {
      result = (infomap::MemNodeSet *) &(arg1)->operator =((infomap::MemNodeSet const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__MemNodeSet, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MemNodeSet_numMemNodes_set ( SEXP self, SEXP s_numMemNodes)
{
  infomap::MemNodeSet *arg1 = (infomap::MemNodeSet *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MemNodeSet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemNodeSet_numMemNodes_set" "', argument " "1"" of type '" "infomap::MemNodeSet *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemNodeSet * >(argp1);
  ecode2 = SWIG_AsVal_int(s_numMemNodes, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "MemNodeSet_numMemNodes_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->numMemNodes = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MemNodeSet_numMemNodes_get ( SEXP self, SEXP s_swig_copy)
{
  unsigned int result;
  infomap::MemNodeSet *arg1 = (infomap::MemNodeSet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MemNodeSet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemNodeSet_numMemNodes_get" "', argument " "1"" of type '" "infomap::MemNodeSet *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemNodeSet * >(argp1);
  result = (unsigned int) ((arg1)->numMemNodes);
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MemNodeSet_sumFlow_set ( SEXP self, SEXP s_sumFlow)
{
  infomap::MemNodeSet *arg1 = (infomap::MemNodeSet *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MemNodeSet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemNodeSet_sumFlow_set" "', argument " "1"" of type '" "infomap::MemNodeSet *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemNodeSet * >(argp1);
  arg2 = static_cast< double >(REAL(s_sumFlow)[0]);
  if (arg1) (arg1)->sumFlow = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MemNodeSet_sumFlow_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::MemNodeSet *arg1 = (infomap::MemNodeSet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MemNodeSet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemNodeSet_sumFlow_get" "', argument " "1"" of type '" "infomap::MemNodeSet *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemNodeSet * >(argp1);
  result = (double) ((arg1)->sumFlow);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_MemNodeSet ( SEXP self)
{
  infomap::MemNodeSet *arg1 = (infomap::MemNodeSet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MemNodeSet, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_MemNodeSet" "', argument " "1"" of type '" "infomap::MemNodeSet *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MemNodeSet * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_MetaMapEquation__SWIG_0 ( )
{
  infomap::MetaMapEquation *result = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    try {
      result = (infomap::MetaMapEquation *)new infomap::MetaMapEquation();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__MetaMapEquation, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_MetaMapEquation__SWIG_1 ( SEXP other)
{
  infomap::MetaMapEquation *result = 0 ;
  infomap::MetaMapEquation *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(other, &argp1, SWIGTYPE_p_infomap__MetaMapEquation,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_MetaMapEquation" "', argument " "1"" of type '" "infomap::MetaMapEquation const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MetaMapEquation" "', argument " "1"" of type '" "infomap::MetaMapEquation const &""'"); 
  }
  arg1 = reinterpret_cast< infomap::MetaMapEquation * >(argp1);
  {
    try {
      result = (infomap::MetaMapEquation *)new infomap::MetaMapEquation((infomap::MetaMapEquation const &)*arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__MetaMapEquation, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MetaMapEquation_Equal ( SEXP self, SEXP other, SEXP s_swig_copy)
{
  infomap::MetaMapEquation *result = 0 ;
  infomap::MetaMapEquation *arg1 = (infomap::MetaMapEquation *) 0 ;
  infomap::MetaMapEquation *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MetaMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaMapEquation_Equal" "', argument " "1"" of type '" "infomap::MetaMapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MetaMapEquation * >(argp1);
  res2 = SWIG_R_ConvertPtr(other, &argp2, SWIGTYPE_p_infomap__MetaMapEquation,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MetaMapEquation_Equal" "', argument " "2"" of type '" "infomap::MetaMapEquation const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MetaMapEquation_Equal" "', argument " "2"" of type '" "infomap::MetaMapEquation const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::MetaMapEquation * >(argp2);
  {
    try {
      result = (infomap::MetaMapEquation *) &(arg1)->operator =((infomap::MetaMapEquation const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__MetaMapEquation, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_MetaMapEquation ( SEXP self)
{
  infomap::MetaMapEquation *arg1 = (infomap::MetaMapEquation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MetaMapEquation, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_MetaMapEquation" "', argument " "1"" of type '" "infomap::MetaMapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MetaMapEquation * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MetaMapEquation_getIndexCodelength ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::MetaMapEquation *arg1 = (infomap::MetaMapEquation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MetaMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaMapEquation_getIndexCodelength" "', argument " "1"" of type '" "infomap::MetaMapEquation const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MetaMapEquation * >(argp1);
  {
    try {
      result = (double)((infomap::MetaMapEquation const *)arg1)->getIndexCodelength();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MetaMapEquation_getModuleCodelength ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::MetaMapEquation *arg1 = (infomap::MetaMapEquation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MetaMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaMapEquation_getModuleCodelength" "', argument " "1"" of type '" "infomap::MetaMapEquation const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MetaMapEquation * >(argp1);
  {
    try {
      result = (double)((infomap::MetaMapEquation const *)arg1)->getModuleCodelength();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MetaMapEquation_getCodelength ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::MetaMapEquation *arg1 = (infomap::MetaMapEquation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MetaMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaMapEquation_getCodelength" "', argument " "1"" of type '" "infomap::MetaMapEquation const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MetaMapEquation * >(argp1);
  {
    try {
      result = (double)((infomap::MetaMapEquation const *)arg1)->getCodelength();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MetaMapEquation_getMetaCodelength__SWIG_0 ( SEXP self, SEXP unweighted, SEXP s_swig_copy)
{
  double result;
  infomap::MetaMapEquation *arg1 = (infomap::MetaMapEquation *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MetaMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaMapEquation_getMetaCodelength" "', argument " "1"" of type '" "infomap::MetaMapEquation const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MetaMapEquation * >(argp1);
  arg2 = LOGICAL(unweighted)[0] ? true : false;
  {
    try {
      result = (double)((infomap::MetaMapEquation const *)arg1)->getMetaCodelength(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MetaMapEquation_getMetaCodelength__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::MetaMapEquation *arg1 = (infomap::MetaMapEquation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MetaMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaMapEquation_getMetaCodelength" "', argument " "1"" of type '" "infomap::MetaMapEquation const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MetaMapEquation * >(argp1);
  {
    try {
      result = (double)((infomap::MetaMapEquation const *)arg1)->getMetaCodelength();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MetaMapEquation_print ( SEXP self, SEXP out, SEXP s_swig_copy)
{
  std::ostream *result = 0 ;
  infomap::MetaMapEquation *arg1 = (infomap::MetaMapEquation *) 0 ;
  std::ostream *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MetaMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaMapEquation_print" "', argument " "1"" of type '" "infomap::MetaMapEquation const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MetaMapEquation * >(argp1);
  res2 = SWIG_R_ConvertPtr(out, &argp2, SWIGTYPE_p_std__ostream,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MetaMapEquation_print" "', argument " "2"" of type '" "std::ostream &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MetaMapEquation_print" "', argument " "2"" of type '" "std::ostream &""'"); 
  }
  arg2 = reinterpret_cast< std::ostream * >(argp2);
  {
    try {
      result = (std::ostream *) &((infomap::MetaMapEquation const *)arg1)->print(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__ostream, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MetaMapEquation_init ( SEXP self, SEXP config)
{
  infomap::MetaMapEquation *arg1 = (infomap::MetaMapEquation *) 0 ;
  infomap::Config *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MetaMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaMapEquation_init" "', argument " "1"" of type '" "infomap::MetaMapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MetaMapEquation * >(argp1);
  res2 = SWIG_R_ConvertPtr(config, &argp2, SWIGTYPE_p_infomap__Config,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MetaMapEquation_init" "', argument " "2"" of type '" "infomap::Config const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MetaMapEquation_init" "', argument " "2"" of type '" "infomap::Config const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::Config * >(argp2);
  {
    try {
      (arg1)->init((infomap::Config const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MetaMapEquation_initNetwork ( SEXP self, SEXP root)
{
  infomap::MetaMapEquation *arg1 = (infomap::MetaMapEquation *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MetaMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaMapEquation_initNetwork" "', argument " "1"" of type '" "infomap::MetaMapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MetaMapEquation * >(argp1);
  res2 = SWIG_R_ConvertPtr(root, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MetaMapEquation_initNetwork" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MetaMapEquation_initNetwork" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  {
    try {
      (arg1)->initNetwork(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MetaMapEquation_initSuperNetwork ( SEXP self, SEXP root)
{
  infomap::MetaMapEquation *arg1 = (infomap::MetaMapEquation *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MetaMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaMapEquation_initSuperNetwork" "', argument " "1"" of type '" "infomap::MetaMapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MetaMapEquation * >(argp1);
  res2 = SWIG_R_ConvertPtr(root, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MetaMapEquation_initSuperNetwork" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MetaMapEquation_initSuperNetwork" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  {
    try {
      (arg1)->initSuperNetwork(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MetaMapEquation_initSubNetwork ( SEXP self, SEXP root)
{
  infomap::MetaMapEquation *arg1 = (infomap::MetaMapEquation *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MetaMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaMapEquation_initSubNetwork" "', argument " "1"" of type '" "infomap::MetaMapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MetaMapEquation * >(argp1);
  res2 = SWIG_R_ConvertPtr(root, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MetaMapEquation_initSubNetwork" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MetaMapEquation_initSubNetwork" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  {
    try {
      (arg1)->initSubNetwork(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MetaMapEquation_initPartition ( SEXP self, SEXP nodes)
{
  infomap::MetaMapEquation *arg1 = (infomap::MetaMapEquation *) 0 ;
  std::vector< infomap::InfoNode *,std::allocator< infomap::InfoNode * > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MetaMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaMapEquation_initPartition" "', argument " "1"" of type '" "infomap::MetaMapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MetaMapEquation * >(argp1);
  res2 = SWIG_R_ConvertPtr(nodes, &argp2, SWIGTYPE_p_std__vectorT_infomap__InfoNode_p_std__allocatorT_infomap__InfoNode_p_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MetaMapEquation_initPartition" "', argument " "2"" of type '" "std::vector< infomap::InfoNode *,std::allocator< infomap::InfoNode * > > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MetaMapEquation_initPartition" "', argument " "2"" of type '" "std::vector< infomap::InfoNode *,std::allocator< infomap::InfoNode * > > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector< infomap::InfoNode *,std::allocator< infomap::InfoNode * > > * >(argp2);
  {
    try {
      (arg1)->initPartition(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MetaMapEquation_calcCodelength ( SEXP self, SEXP parent, SEXP s_swig_copy)
{
  double result;
  infomap::MetaMapEquation *arg1 = (infomap::MetaMapEquation *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MetaMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaMapEquation_calcCodelength" "', argument " "1"" of type '" "infomap::MetaMapEquation const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MetaMapEquation * >(argp1);
  res2 = SWIG_R_ConvertPtr(parent, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MetaMapEquation_calcCodelength" "', argument " "2"" of type '" "infomap::InfoNode const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MetaMapEquation_calcCodelength" "', argument " "2"" of type '" "infomap::InfoNode const &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  {
    try {
      result = (double)((infomap::MetaMapEquation const *)arg1)->calcCodelength((infomap::InfoNode const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MetaMapEquation_addMemoryContributions ( SEXP self, SEXP current, SEXP oldModuleDelta, SEXP moduleDeltaFlow)
{
  infomap::MetaMapEquation *arg1 = (infomap::MetaMapEquation *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  infomap::MetaMapEquation::DeltaFlowDataType *arg3 = 0 ;
  VectorMap< infomap::MetaMapEquation::DeltaFlowDataType > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MetaMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaMapEquation_addMemoryContributions" "', argument " "1"" of type '" "infomap::MetaMapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MetaMapEquation * >(argp1);
  res2 = SWIG_R_ConvertPtr(current, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MetaMapEquation_addMemoryContributions" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MetaMapEquation_addMemoryContributions" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  res3 = SWIG_R_ConvertPtr(oldModuleDelta, &argp3, SWIGTYPE_p_infomap__DeltaFlow,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "MetaMapEquation_addMemoryContributions" "', argument " "3"" of type '" "infomap::MetaMapEquation::DeltaFlowDataType &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MetaMapEquation_addMemoryContributions" "', argument " "3"" of type '" "infomap::MetaMapEquation::DeltaFlowDataType &""'"); 
  }
  arg3 = reinterpret_cast< infomap::MetaMapEquation::DeltaFlowDataType * >(argp3);
  res4 = SWIG_R_ConvertPtr(moduleDeltaFlow, &argp4, SWIGTYPE_p_VectorMapT_infomap__DeltaFlow_t,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "MetaMapEquation_addMemoryContributions" "', argument " "4"" of type '" "VectorMap< infomap::MetaMapEquation::DeltaFlowDataType > &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MetaMapEquation_addMemoryContributions" "', argument " "4"" of type '" "VectorMap< infomap::MetaMapEquation::DeltaFlowDataType > &""'"); 
  }
  arg4 = reinterpret_cast< VectorMap< infomap::MetaMapEquation::DeltaFlowDataType > * >(argp4);
  {
    try {
      (arg1)->addMemoryContributions(*arg2,*arg3,*arg4);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MetaMapEquation_getDeltaCodelengthOnMovingNode ( SEXP self, SEXP current, SEXP oldModuleDelta, SEXP newModuleDelta, SEXP moduleFlowData, SEXP moduleMembers, SEXP s_swig_copy)
{
  double result;
  infomap::MetaMapEquation *arg1 = (infomap::MetaMapEquation *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  infomap::MetaMapEquation::DeltaFlowDataType *arg3 = 0 ;
  infomap::MetaMapEquation::DeltaFlowDataType *arg4 = 0 ;
  std::vector< infomap::MetaMapEquation::FlowDataType,std::allocator< infomap::MetaMapEquation::FlowDataType > > *arg5 = 0 ;
  std::vector< unsigned int,std::allocator< unsigned int > > *arg6 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MetaMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaMapEquation_getDeltaCodelengthOnMovingNode" "', argument " "1"" of type '" "infomap::MetaMapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MetaMapEquation * >(argp1);
  res2 = SWIG_R_ConvertPtr(current, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MetaMapEquation_getDeltaCodelengthOnMovingNode" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MetaMapEquation_getDeltaCodelengthOnMovingNode" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  res3 = SWIG_R_ConvertPtr(oldModuleDelta, &argp3, SWIGTYPE_p_infomap__DeltaFlow,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "MetaMapEquation_getDeltaCodelengthOnMovingNode" "', argument " "3"" of type '" "infomap::MetaMapEquation::DeltaFlowDataType &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MetaMapEquation_getDeltaCodelengthOnMovingNode" "', argument " "3"" of type '" "infomap::MetaMapEquation::DeltaFlowDataType &""'"); 
  }
  arg3 = reinterpret_cast< infomap::MetaMapEquation::DeltaFlowDataType * >(argp3);
  res4 = SWIG_R_ConvertPtr(newModuleDelta, &argp4, SWIGTYPE_p_infomap__DeltaFlow,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "MetaMapEquation_getDeltaCodelengthOnMovingNode" "', argument " "4"" of type '" "infomap::MetaMapEquation::DeltaFlowDataType &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MetaMapEquation_getDeltaCodelengthOnMovingNode" "', argument " "4"" of type '" "infomap::MetaMapEquation::DeltaFlowDataType &""'"); 
  }
  arg4 = reinterpret_cast< infomap::MetaMapEquation::DeltaFlowDataType * >(argp4);
  res5 = SWIG_R_ConvertPtr(moduleFlowData, &argp5, SWIGTYPE_p_std__vectorT_infomap__FlowData_std__allocatorT_infomap__FlowData_t_t,  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "MetaMapEquation_getDeltaCodelengthOnMovingNode" "', argument " "5"" of type '" "std::vector< infomap::MetaMapEquation::FlowDataType,std::allocator< infomap::MetaMapEquation::FlowDataType > > &""'"); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MetaMapEquation_getDeltaCodelengthOnMovingNode" "', argument " "5"" of type '" "std::vector< infomap::MetaMapEquation::FlowDataType,std::allocator< infomap::MetaMapEquation::FlowDataType > > &""'"); 
  }
  arg5 = reinterpret_cast< std::vector< infomap::MetaMapEquation::FlowDataType,std::allocator< infomap::MetaMapEquation::FlowDataType > > * >(argp5);
  res6 = SWIG_R_ConvertPtr(moduleMembers, &argp6, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t,  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "MetaMapEquation_getDeltaCodelengthOnMovingNode" "', argument " "6"" of type '" "std::vector< unsigned int,std::allocator< unsigned int > > &""'"); 
  }
  if (!argp6) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MetaMapEquation_getDeltaCodelengthOnMovingNode" "', argument " "6"" of type '" "std::vector< unsigned int,std::allocator< unsigned int > > &""'"); 
  }
  arg6 = reinterpret_cast< std::vector< unsigned int,std::allocator< unsigned int > > * >(argp6);
  {
    try {
      result = (double)(arg1)->getDeltaCodelengthOnMovingNode(*arg2,*arg3,*arg4,*arg5,*arg6);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MetaMapEquation_updateCodelengthOnMovingNode ( SEXP self, SEXP current, SEXP oldModuleDelta, SEXP newModuleDelta, SEXP moduleFlowData, SEXP moduleMembers)
{
  infomap::MetaMapEquation *arg1 = (infomap::MetaMapEquation *) 0 ;
  infomap::InfoNode *arg2 = 0 ;
  infomap::MetaMapEquation::DeltaFlowDataType *arg3 = 0 ;
  infomap::MetaMapEquation::DeltaFlowDataType *arg4 = 0 ;
  std::vector< infomap::MetaMapEquation::FlowDataType,std::allocator< infomap::MetaMapEquation::FlowDataType > > *arg5 = 0 ;
  std::vector< unsigned int,std::allocator< unsigned int > > *arg6 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MetaMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaMapEquation_updateCodelengthOnMovingNode" "', argument " "1"" of type '" "infomap::MetaMapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MetaMapEquation * >(argp1);
  res2 = SWIG_R_ConvertPtr(current, &argp2, SWIGTYPE_p_infomap__InfoNode,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MetaMapEquation_updateCodelengthOnMovingNode" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MetaMapEquation_updateCodelengthOnMovingNode" "', argument " "2"" of type '" "infomap::InfoNode &""'"); 
  }
  arg2 = reinterpret_cast< infomap::InfoNode * >(argp2);
  res3 = SWIG_R_ConvertPtr(oldModuleDelta, &argp3, SWIGTYPE_p_infomap__DeltaFlow,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "MetaMapEquation_updateCodelengthOnMovingNode" "', argument " "3"" of type '" "infomap::MetaMapEquation::DeltaFlowDataType &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MetaMapEquation_updateCodelengthOnMovingNode" "', argument " "3"" of type '" "infomap::MetaMapEquation::DeltaFlowDataType &""'"); 
  }
  arg3 = reinterpret_cast< infomap::MetaMapEquation::DeltaFlowDataType * >(argp3);
  res4 = SWIG_R_ConvertPtr(newModuleDelta, &argp4, SWIGTYPE_p_infomap__DeltaFlow,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "MetaMapEquation_updateCodelengthOnMovingNode" "', argument " "4"" of type '" "infomap::MetaMapEquation::DeltaFlowDataType &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MetaMapEquation_updateCodelengthOnMovingNode" "', argument " "4"" of type '" "infomap::MetaMapEquation::DeltaFlowDataType &""'"); 
  }
  arg4 = reinterpret_cast< infomap::MetaMapEquation::DeltaFlowDataType * >(argp4);
  res5 = SWIG_R_ConvertPtr(moduleFlowData, &argp5, SWIGTYPE_p_std__vectorT_infomap__FlowData_std__allocatorT_infomap__FlowData_t_t,  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "MetaMapEquation_updateCodelengthOnMovingNode" "', argument " "5"" of type '" "std::vector< infomap::MetaMapEquation::FlowDataType,std::allocator< infomap::MetaMapEquation::FlowDataType > > &""'"); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MetaMapEquation_updateCodelengthOnMovingNode" "', argument " "5"" of type '" "std::vector< infomap::MetaMapEquation::FlowDataType,std::allocator< infomap::MetaMapEquation::FlowDataType > > &""'"); 
  }
  arg5 = reinterpret_cast< std::vector< infomap::MetaMapEquation::FlowDataType,std::allocator< infomap::MetaMapEquation::FlowDataType > > * >(argp5);
  res6 = SWIG_R_ConvertPtr(moduleMembers, &argp6, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t,  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "MetaMapEquation_updateCodelengthOnMovingNode" "', argument " "6"" of type '" "std::vector< unsigned int,std::allocator< unsigned int > > &""'"); 
  }
  if (!argp6) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MetaMapEquation_updateCodelengthOnMovingNode" "', argument " "6"" of type '" "std::vector< unsigned int,std::allocator< unsigned int > > &""'"); 
  }
  arg6 = reinterpret_cast< std::vector< unsigned int,std::allocator< unsigned int > > * >(argp6);
  {
    try {
      (arg1)->updateCodelengthOnMovingNode(*arg2,*arg3,*arg4,*arg5,*arg6);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MetaMapEquation_consolidateModules ( SEXP self, SEXP modules)
{
  infomap::MetaMapEquation *arg1 = (infomap::MetaMapEquation *) 0 ;
  std::vector< infomap::InfoNode *,std::allocator< infomap::InfoNode * > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MetaMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaMapEquation_consolidateModules" "', argument " "1"" of type '" "infomap::MetaMapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MetaMapEquation * >(argp1);
  res2 = SWIG_R_ConvertPtr(modules, &argp2, SWIGTYPE_p_std__vectorT_infomap__InfoNode_p_std__allocatorT_infomap__InfoNode_p_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MetaMapEquation_consolidateModules" "', argument " "2"" of type '" "std::vector< infomap::InfoNode *,std::allocator< infomap::InfoNode * > > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MetaMapEquation_consolidateModules" "', argument " "2"" of type '" "std::vector< infomap::InfoNode *,std::allocator< infomap::InfoNode * > > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector< infomap::InfoNode *,std::allocator< infomap::InfoNode * > > * >(argp2);
  {
    try {
      (arg1)->consolidateModules(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MetaMapEquation_printDebug ( SEXP self)
{
  infomap::MetaMapEquation *arg1 = (infomap::MetaMapEquation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MetaMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaMapEquation_printDebug" "', argument " "1"" of type '" "infomap::MetaMapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MetaMapEquation * >(argp1);
  {
    try {
      (arg1)->printDebug();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MetaMapEquation_codelength_set ( SEXP self, SEXP s_codelength)
{
  infomap::MetaMapEquation *arg1 = (infomap::MetaMapEquation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MetaMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaMapEquation_codelength_set" "', argument " "1"" of type '" "infomap::MetaMapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MetaMapEquation * >(argp1);
  arg2 = static_cast< double >(REAL(s_codelength)[0]);
  if (arg1) (arg1)->codelength = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MetaMapEquation_codelength_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::MetaMapEquation *arg1 = (infomap::MetaMapEquation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MetaMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaMapEquation_codelength_get" "', argument " "1"" of type '" "infomap::MetaMapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MetaMapEquation * >(argp1);
  result = (double) ((arg1)->codelength);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MetaMapEquation_indexCodelength_set ( SEXP self, SEXP s_indexCodelength)
{
  infomap::MetaMapEquation *arg1 = (infomap::MetaMapEquation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MetaMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaMapEquation_indexCodelength_set" "', argument " "1"" of type '" "infomap::MetaMapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MetaMapEquation * >(argp1);
  arg2 = static_cast< double >(REAL(s_indexCodelength)[0]);
  if (arg1) (arg1)->indexCodelength = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MetaMapEquation_indexCodelength_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::MetaMapEquation *arg1 = (infomap::MetaMapEquation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MetaMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaMapEquation_indexCodelength_get" "', argument " "1"" of type '" "infomap::MetaMapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MetaMapEquation * >(argp1);
  result = (double) ((arg1)->indexCodelength);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MetaMapEquation_moduleCodelength_set ( SEXP self, SEXP s_moduleCodelength)
{
  infomap::MetaMapEquation *arg1 = (infomap::MetaMapEquation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MetaMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaMapEquation_moduleCodelength_set" "', argument " "1"" of type '" "infomap::MetaMapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MetaMapEquation * >(argp1);
  arg2 = static_cast< double >(REAL(s_moduleCodelength)[0]);
  if (arg1) (arg1)->moduleCodelength = arg2;
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_MetaMapEquation_moduleCodelength_get ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::MetaMapEquation *arg1 = (infomap::MetaMapEquation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__MetaMapEquation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaMapEquation_moduleCodelength_get" "', argument " "1"" of type '" "infomap::MetaMapEquation *""'"); 
  }
  arg1 = reinterpret_cast< infomap::MetaMapEquation * >(argp1);
  result = (double) ((arg1)->moduleCodelength);
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfomapCore__SWIG_0 ( )
{
  infomap::InfomapCore *result = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    try {
      result = (infomap::InfomapCore *)new infomap::InfomapCore();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapCore, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfomapCore__SWIG_1 ( SEXP flags)
{
  infomap::InfomapCore *result = 0 ;
  std::string arg1 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(flags, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "new_InfomapCore" "', argument " "1"" of type '" "std::string const""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      result = (infomap::InfomapCore *)new infomap::InfomapCore(arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapCore, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfomapCore__SWIG_2 ( SEXP conf)
{
  infomap::InfomapCore *result = 0 ;
  infomap::Config *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(conf, &argp1, SWIGTYPE_p_infomap__Config,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InfomapCore" "', argument " "1"" of type '" "infomap::Config const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InfomapCore" "', argument " "1"" of type '" "infomap::Config const &""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  {
    try {
      result = (infomap::InfomapCore *)new infomap::InfomapCore((infomap::Config const &)*arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapCore, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_InfomapCore ( SEXP self)
{
  infomap::InfomapCore *arg1 = (infomap::InfomapCore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapCore, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_InfomapCore" "', argument " "1"" of type '" "infomap::InfomapCore *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapCore * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapCore_toString ( SEXP self, SEXP out, SEXP s_swig_copy)
{
  std::ostream *result = 0 ;
  infomap::InfomapCore *arg1 = (infomap::InfomapCore *) 0 ;
  std::ostream *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapCore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapCore_toString" "', argument " "1"" of type '" "infomap::InfomapCore const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapCore * >(argp1);
  res2 = SWIG_R_ConvertPtr(out, &argp2, SWIGTYPE_p_std__ostream,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapCore_toString" "', argument " "2"" of type '" "std::ostream &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapCore_toString" "', argument " "2"" of type '" "std::ostream &""'"); 
  }
  arg2 = reinterpret_cast< std::ostream * >(argp2);
  {
    try {
      result = (std::ostream *) &((infomap::InfomapCore const *)arg1)->toString(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__ostream, 0 |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapCore_getCodelength ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::InfomapCore *arg1 = (infomap::InfomapCore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapCore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapCore_getCodelength" "', argument " "1"" of type '" "infomap::InfomapCore const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapCore * >(argp1);
  {
    try {
      result = (double)((infomap::InfomapCore const *)arg1)->getCodelength();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapCore_getIndexCodelength ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::InfomapCore *arg1 = (infomap::InfomapCore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapCore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapCore_getIndexCodelength" "', argument " "1"" of type '" "infomap::InfomapCore const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapCore * >(argp1);
  {
    try {
      result = (double)((infomap::InfomapCore const *)arg1)->getIndexCodelength();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapCore_getModuleCodelength ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::InfomapCore *arg1 = (infomap::InfomapCore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapCore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapCore_getModuleCodelength" "', argument " "1"" of type '" "infomap::InfomapCore const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapCore * >(argp1);
  {
    try {
      result = (double)((infomap::InfomapCore const *)arg1)->getModuleCodelength();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapCore_getMetaCodelength__SWIG_0 ( SEXP self, SEXP unweighted, SEXP s_swig_copy)
{
  double result;
  infomap::InfomapCore *arg1 = (infomap::InfomapCore *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapCore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapCore_getMetaCodelength" "', argument " "1"" of type '" "infomap::InfomapCore const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapCore * >(argp1);
  arg2 = LOGICAL(unweighted)[0] ? true : false;
  {
    try {
      result = (double)((infomap::InfomapCore const *)arg1)->getMetaCodelength(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapCore_getMetaCodelength__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::InfomapCore *arg1 = (infomap::InfomapCore *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapCore, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapCore_getMetaCodelength" "', argument " "1"" of type '" "infomap::InfomapCore const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapCore * >(argp1);
  {
    try {
      result = (double)((infomap::InfomapCore const *)arg1)->getMetaCodelength();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_map_uint_vector_uint__SWIG_0 ( SEXP other)
{
  std::map< unsigned int,std::vector< unsigned int > > *result = 0 ;
  std::less< unsigned int > *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(other, &argp1, SWIGTYPE_p_std__lessT_unsigned_int_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_map_uint_vector_uint" "', argument " "1"" of type '" "std::less< unsigned int > const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_map_uint_vector_uint" "', argument " "1"" of type '" "std::less< unsigned int > const &""'"); 
  }
  arg1 = reinterpret_cast< std::less< unsigned int > * >(argp1);
  {
    try {
      result = (std::map< unsigned int,std::vector< unsigned int > > *)new std::map< unsigned int,std::vector< unsigned int > >((std::less< unsigned int > const &)*arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_map_uint_vector_uint__SWIG_1 ( )
{
  std::map< unsigned int,std::vector< unsigned int > > *result = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    try {
      result = (std::map< unsigned int,std::vector< unsigned int > > *)new std::map< unsigned int,std::vector< unsigned int > >();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_map_uint_vector_uint__SWIG_2 ( SEXP other)
{
  std::map< unsigned int,std::vector< unsigned int > > *result = 0 ;
  std::map< unsigned int,std::vector< unsigned int,std::allocator< unsigned int > > > *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    std::map< unsigned int,std::vector< unsigned int,std::allocator< unsigned int > >,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,std::vector< unsigned int,std::allocator< unsigned int > > > > > *ptr = (std::map< unsigned int,std::vector< unsigned int,std::allocator< unsigned int > >,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,std::vector< unsigned int,std::allocator< unsigned int > > > > > *)0;
    res1 = swig::asptr(other, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_map_uint_vector_uint" "', argument " "1"" of type '" "std::map< unsigned int,std::vector< unsigned int,std::allocator< unsigned int > > > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_map_uint_vector_uint" "', argument " "1"" of type '" "std::map< unsigned int,std::vector< unsigned int,std::allocator< unsigned int > > > const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (std::map< unsigned int,std::vector< unsigned int > > *)new std::map< unsigned int,std::vector< unsigned int > >((std::map< unsigned int,std::vector< unsigned int,std::allocator< unsigned int > > > const &)*arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  if (SWIG_IsNewObj(res1)) delete arg1;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_map_uint_vector_uint_empty ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  std::map< unsigned int,std::vector< unsigned int > > *arg1 = (std::map< unsigned int,std::vector< unsigned int > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "map_uint_vector_uint_empty" "', argument " "1"" of type '" "std::map< unsigned int,std::vector< unsigned int > > const *""'"); 
  }
  arg1 = reinterpret_cast< std::map< unsigned int,std::vector< unsigned int > > * >(argp1);
  {
    try {
      result = (bool)((std::map< unsigned int,std::vector< unsigned int > > const *)arg1)->empty();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_map_uint_vector_uint_size ( SEXP self, SEXP s_swig_copy)
{
  std::map< unsigned int,std::vector< unsigned int > >::size_type result;
  std::map< unsigned int,std::vector< unsigned int > > *arg1 = (std::map< unsigned int,std::vector< unsigned int > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "map_uint_vector_uint_size" "', argument " "1"" of type '" "std::map< unsigned int,std::vector< unsigned int > > const *""'"); 
  }
  arg1 = reinterpret_cast< std::map< unsigned int,std::vector< unsigned int > > * >(argp1);
  {
    try {
      result = ((std::map< unsigned int,std::vector< unsigned int > > const *)arg1)->size();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_map_uint_vector_uint_swap ( SEXP self, SEXP v)
{
  std::map< unsigned int,std::vector< unsigned int > > *arg1 = (std::map< unsigned int,std::vector< unsigned int > > *) 0 ;
  std::map< unsigned int,std::vector< unsigned int,std::allocator< unsigned int > > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "map_uint_vector_uint_swap" "', argument " "1"" of type '" "std::map< unsigned int,std::vector< unsigned int > > *""'"); 
  }
  arg1 = reinterpret_cast< std::map< unsigned int,std::vector< unsigned int > > * >(argp1);
  res2 = SWIG_R_ConvertPtr(v, &argp2, SWIGTYPE_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "map_uint_vector_uint_swap" "', argument " "2"" of type '" "std::map< unsigned int,std::vector< unsigned int,std::allocator< unsigned int > > > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "map_uint_vector_uint_swap" "', argument " "2"" of type '" "std::map< unsigned int,std::vector< unsigned int,std::allocator< unsigned int > > > &""'"); 
  }
  arg2 = reinterpret_cast< std::map< unsigned int,std::vector< unsigned int,std::allocator< unsigned int > > > * >(argp2);
  {
    try {
      (arg1)->swap(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_map_uint_vector_uint_clear ( SEXP self)
{
  std::map< unsigned int,std::vector< unsigned int > > *arg1 = (std::map< unsigned int,std::vector< unsigned int > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "map_uint_vector_uint_clear" "', argument " "1"" of type '" "std::map< unsigned int,std::vector< unsigned int > > *""'"); 
  }
  arg1 = reinterpret_cast< std::map< unsigned int,std::vector< unsigned int > > * >(argp1);
  {
    try {
      (arg1)->clear();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_map_uint_vector_uint_get_allocator ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< std::allocator< std::pair< unsigned int const,std::vector< unsigned int,std::allocator< unsigned int > > > > > result;
  std::map< unsigned int,std::vector< unsigned int > > *arg1 = (std::map< unsigned int,std::vector< unsigned int > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "map_uint_vector_uint_get_allocator" "', argument " "1"" of type '" "std::map< unsigned int,std::vector< unsigned int > > const *""'"); 
  }
  arg1 = reinterpret_cast< std::map< unsigned int,std::vector< unsigned int > > * >(argp1);
  {
    try {
      result = ((std::map< unsigned int,std::vector< unsigned int > > const *)arg1)->get_allocator();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new std::map< unsigned int,std::vector< unsigned int > >::allocator_type(static_cast< const std::map< unsigned int,std::vector< unsigned int > >::allocator_type& >(result))), SWIGTYPE_p_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_map_uint_vector_uint_erase ( SEXP self, SEXP x, SEXP s_swig_copy)
{
  std::map< unsigned int,std::vector< unsigned int > >::size_type result;
  std::map< unsigned int,std::vector< unsigned int > > *arg1 = (std::map< unsigned int,std::vector< unsigned int > > *) 0 ;
  std::map< unsigned int,std::vector< unsigned int > >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< unsigned int,std::vector< unsigned int > >::key_type temp2 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "map_uint_vector_uint_erase" "', argument " "1"" of type '" "std::map< unsigned int,std::vector< unsigned int > > *""'"); 
  }
  arg1 = reinterpret_cast< std::map< unsigned int,std::vector< unsigned int > > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(x, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "map_uint_vector_uint_erase" "', argument " "2"" of type '" "std::map< unsigned int,std::vector< unsigned int > >::key_type""'");
  } 
  temp2 = static_cast< std::map< unsigned int,std::vector< unsigned int > >::key_type >(val2);
  arg2 = &temp2;
  {
    try {
      result = (arg1)->erase((std::map< unsigned int,std::vector< unsigned int > >::key_type const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_map_uint_vector_uint_count ( SEXP self, SEXP x, SEXP s_swig_copy)
{
  std::map< unsigned int,std::vector< unsigned int > >::size_type result;
  std::map< unsigned int,std::vector< unsigned int > > *arg1 = (std::map< unsigned int,std::vector< unsigned int > > *) 0 ;
  std::map< unsigned int,std::vector< unsigned int > >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< unsigned int,std::vector< unsigned int > >::key_type temp2 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "map_uint_vector_uint_count" "', argument " "1"" of type '" "std::map< unsigned int,std::vector< unsigned int > > const *""'"); 
  }
  arg1 = reinterpret_cast< std::map< unsigned int,std::vector< unsigned int > > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(x, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "map_uint_vector_uint_count" "', argument " "2"" of type '" "std::map< unsigned int,std::vector< unsigned int > >::key_type""'");
  } 
  temp2 = static_cast< std::map< unsigned int,std::vector< unsigned int > >::key_type >(val2);
  arg2 = &temp2;
  {
    try {
      result = ((std::map< unsigned int,std::vector< unsigned int > > const *)arg1)->count((std::map< unsigned int,std::vector< unsigned int > >::key_type const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_map_uint_vector_uint ( SEXP self)
{
  std::map< unsigned int,std::vector< unsigned int > > *arg1 = (std::map< unsigned int,std::vector< unsigned int > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_map_uint_vector_uint" "', argument " "1"" of type '" "std::map< unsigned int,std::vector< unsigned int > > *""'"); 
  }
  arg1 = reinterpret_cast< std::map< unsigned int,std::vector< unsigned int > > * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_map_uint_string__SWIG_0 ( SEXP other)
{
  std::map< unsigned int,std::string > *result = 0 ;
  std::less< unsigned int > *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(other, &argp1, SWIGTYPE_p_std__lessT_unsigned_int_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_map_uint_string" "', argument " "1"" of type '" "std::less< unsigned int > const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_map_uint_string" "', argument " "1"" of type '" "std::less< unsigned int > const &""'"); 
  }
  arg1 = reinterpret_cast< std::less< unsigned int > * >(argp1);
  {
    try {
      result = (std::map< unsigned int,std::string > *)new std::map< unsigned int,std::string >((std::less< unsigned int > const &)*arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_map_uint_string__SWIG_1 ( )
{
  std::map< unsigned int,std::string > *result = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    try {
      result = (std::map< unsigned int,std::string > *)new std::map< unsigned int,std::string >();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_map_uint_string__SWIG_2 ( SEXP other)
{
  std::map< unsigned int,std::string > *result = 0 ;
  std::map< unsigned int,std::string > *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    std::map< unsigned int,std::string,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,std::string > > > *ptr = (std::map< unsigned int,std::string,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,std::string > > > *)0;
    res1 = swig::asptr(other, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_map_uint_string" "', argument " "1"" of type '" "std::map< unsigned int,std::string > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_map_uint_string" "', argument " "1"" of type '" "std::map< unsigned int,std::string > const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (std::map< unsigned int,std::string > *)new std::map< unsigned int,std::string >((std::map< unsigned int,std::string > const &)*arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  if (SWIG_IsNewObj(res1)) delete arg1;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_map_uint_string_empty ( SEXP self, SEXP s_swig_copy)
{
  bool result;
  std::map< unsigned int,std::string > *arg1 = (std::map< unsigned int,std::string > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "map_uint_string_empty" "', argument " "1"" of type '" "std::map< unsigned int,std::string > const *""'"); 
  }
  arg1 = reinterpret_cast< std::map< unsigned int,std::string > * >(argp1);
  {
    try {
      result = (bool)((std::map< unsigned int,std::string > const *)arg1)->empty();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = Rf_ScalarLogical(result);
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_map_uint_string_size ( SEXP self, SEXP s_swig_copy)
{
  std::map< unsigned int,std::string >::size_type result;
  std::map< unsigned int,std::string > *arg1 = (std::map< unsigned int,std::string > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "map_uint_string_size" "', argument " "1"" of type '" "std::map< unsigned int,std::string > const *""'"); 
  }
  arg1 = reinterpret_cast< std::map< unsigned int,std::string > * >(argp1);
  {
    try {
      result = ((std::map< unsigned int,std::string > const *)arg1)->size();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_map_uint_string_swap ( SEXP self, SEXP v)
{
  std::map< unsigned int,std::string > *arg1 = (std::map< unsigned int,std::string > *) 0 ;
  std::map< unsigned int,std::string > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "map_uint_string_swap" "', argument " "1"" of type '" "std::map< unsigned int,std::string > *""'"); 
  }
  arg1 = reinterpret_cast< std::map< unsigned int,std::string > * >(argp1);
  res2 = SWIG_R_ConvertPtr(v, &argp2, SWIGTYPE_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "map_uint_string_swap" "', argument " "2"" of type '" "std::map< unsigned int,std::string > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "map_uint_string_swap" "', argument " "2"" of type '" "std::map< unsigned int,std::string > &""'"); 
  }
  arg2 = reinterpret_cast< std::map< unsigned int,std::string > * >(argp2);
  {
    try {
      (arg1)->swap(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_map_uint_string_clear ( SEXP self)
{
  std::map< unsigned int,std::string > *arg1 = (std::map< unsigned int,std::string > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "map_uint_string_clear" "', argument " "1"" of type '" "std::map< unsigned int,std::string > *""'"); 
  }
  arg1 = reinterpret_cast< std::map< unsigned int,std::string > * >(argp1);
  {
    try {
      (arg1)->clear();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_map_uint_string_get_allocator ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< std::allocator< std::pair< unsigned int const,std::string > > > result;
  std::map< unsigned int,std::string > *arg1 = (std::map< unsigned int,std::string > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "map_uint_string_get_allocator" "', argument " "1"" of type '" "std::map< unsigned int,std::string > const *""'"); 
  }
  arg1 = reinterpret_cast< std::map< unsigned int,std::string > * >(argp1);
  {
    try {
      result = ((std::map< unsigned int,std::string > const *)arg1)->get_allocator();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new std::map< unsigned int,std::string >::allocator_type(static_cast< const std::map< unsigned int,std::string >::allocator_type& >(result))), SWIGTYPE_p_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_map_uint_string_erase ( SEXP self, SEXP x, SEXP s_swig_copy)
{
  std::map< unsigned int,std::string >::size_type result;
  std::map< unsigned int,std::string > *arg1 = (std::map< unsigned int,std::string > *) 0 ;
  std::map< unsigned int,std::string >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< unsigned int,std::string >::key_type temp2 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "map_uint_string_erase" "', argument " "1"" of type '" "std::map< unsigned int,std::string > *""'"); 
  }
  arg1 = reinterpret_cast< std::map< unsigned int,std::string > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(x, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "map_uint_string_erase" "', argument " "2"" of type '" "std::map< unsigned int,std::string >::key_type""'");
  } 
  temp2 = static_cast< std::map< unsigned int,std::string >::key_type >(val2);
  arg2 = &temp2;
  {
    try {
      result = (arg1)->erase((std::map< unsigned int,std::string >::key_type const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_map_uint_string_count ( SEXP self, SEXP x, SEXP s_swig_copy)
{
  std::map< unsigned int,std::string >::size_type result;
  std::map< unsigned int,std::string > *arg1 = (std::map< unsigned int,std::string > *) 0 ;
  std::map< unsigned int,std::string >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< unsigned int,std::string >::key_type temp2 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "map_uint_string_count" "', argument " "1"" of type '" "std::map< unsigned int,std::string > const *""'"); 
  }
  arg1 = reinterpret_cast< std::map< unsigned int,std::string > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(x, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "map_uint_string_count" "', argument " "2"" of type '" "std::map< unsigned int,std::string >::key_type""'");
  } 
  temp2 = static_cast< std::map< unsigned int,std::string >::key_type >(val2);
  arg2 = &temp2;
  {
    try {
      result = ((std::map< unsigned int,std::string > const *)arg1)->count((std::map< unsigned int,std::string >::key_type const &)*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_int(static_cast< int >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_map_uint_string ( SEXP self)
{
  std::map< unsigned int,std::string > *arg1 = (std::map< unsigned int,std::string > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_map_uint_string" "', argument " "1"" of type '" "std::map< unsigned int,std::string > *""'"); 
  }
  arg1 = reinterpret_cast< std::map< unsigned int,std::string > * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfomapWrapper__SWIG_0 ( )
{
  infomap::InfomapWrapper *result = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    try {
      result = (infomap::InfomapWrapper *)new infomap::InfomapWrapper();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapWrapper, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfomapWrapper__SWIG_1 ( SEXP flags)
{
  infomap::InfomapWrapper *result = 0 ;
  std::string arg1 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(flags, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "new_InfomapWrapper" "', argument " "1"" of type '" "std::string const""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      result = (infomap::InfomapWrapper *)new infomap::InfomapWrapper(arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapWrapper, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_new_InfomapWrapper__SWIG_2 ( SEXP conf)
{
  infomap::InfomapWrapper *result = 0 ;
  infomap::Config *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(conf, &argp1, SWIGTYPE_p_infomap__Config,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InfomapWrapper" "', argument " "1"" of type '" "infomap::Config const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InfomapWrapper" "', argument " "1"" of type '" "infomap::Config const &""'"); 
  }
  arg1 = reinterpret_cast< infomap::Config * >(argp1);
  {
    try {
      result = (infomap::InfomapWrapper *)new infomap::InfomapWrapper((infomap::Config const &)*arg1);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_infomap__InfomapWrapper, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_delete_InfomapWrapper ( SEXP self)
{
  infomap::InfomapWrapper *arg1 = (infomap::InfomapWrapper *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapWrapper, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_InfomapWrapper" "', argument " "1"" of type '" "infomap::InfomapWrapper *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapWrapper * >(argp1);
  {
    try {
      delete arg1;
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  R_ClearExternalPtr(self);
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapWrapper_readInputData__SWIG_0 ( SEXP self, SEXP filename, SEXP accumulate)
{
  infomap::InfomapWrapper *arg1 = (infomap::InfomapWrapper *) 0 ;
  std::string arg2 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapWrapper_readInputData" "', argument " "1"" of type '" "infomap::InfomapWrapper *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapWrapper * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(filename, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "InfomapWrapper_readInputData" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  arg3 = LOGICAL(accumulate)[0] ? true : false;
  {
    try {
      (arg1)->readInputData(arg2,arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapWrapper_readInputData__SWIG_1 ( SEXP self, SEXP filename)
{
  infomap::InfomapWrapper *arg1 = (infomap::InfomapWrapper *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapWrapper_readInputData" "', argument " "1"" of type '" "infomap::InfomapWrapper *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapWrapper * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(filename, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "InfomapWrapper_readInputData" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      (arg1)->readInputData(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapWrapper_readInputData__SWIG_2 ( SEXP self)
{
  infomap::InfomapWrapper *arg1 = (infomap::InfomapWrapper *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapWrapper_readInputData" "', argument " "1"" of type '" "infomap::InfomapWrapper *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapWrapper * >(argp1);
  {
    try {
      (arg1)->readInputData();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapWrapper_addNode__SWIG_0 ( SEXP self, SEXP id)
{
  infomap::InfomapWrapper *arg1 = (infomap::InfomapWrapper *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapWrapper_addNode" "', argument " "1"" of type '" "infomap::InfomapWrapper *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapWrapper * >(argp1);
  ecode2 = SWIG_AsVal_int(id, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapWrapper_addNode" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      (arg1)->addNode(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapWrapper_addNode__SWIG_1 ( SEXP self, SEXP id, SEXP name)
{
  infomap::InfomapWrapper *arg1 = (infomap::InfomapWrapper *) 0 ;
  unsigned int arg2 ;
  std::string arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapWrapper_addNode" "', argument " "1"" of type '" "infomap::InfomapWrapper *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapWrapper * >(argp1);
  ecode2 = SWIG_AsVal_int(id, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapWrapper_addNode" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(name, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "InfomapWrapper_addNode" "', argument " "3"" of type '" "std::string""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      (arg1)->addNode(arg2,arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapWrapper_addNode__SWIG_2 ( SEXP self, SEXP id, SEXP weight)
{
  infomap::InfomapWrapper *arg1 = (infomap::InfomapWrapper *) 0 ;
  unsigned int arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapWrapper_addNode" "', argument " "1"" of type '" "infomap::InfomapWrapper *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapWrapper * >(argp1);
  ecode2 = SWIG_AsVal_int(id, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapWrapper_addNode" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  arg3 = static_cast< double >(REAL(weight)[0]);
  {
    try {
      (arg1)->addNode(arg2,arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapWrapper_addNode__SWIG_3 ( SEXP self, SEXP id, SEXP name, SEXP weight)
{
  infomap::InfomapWrapper *arg1 = (infomap::InfomapWrapper *) 0 ;
  unsigned int arg2 ;
  std::string arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapWrapper_addNode" "', argument " "1"" of type '" "infomap::InfomapWrapper *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapWrapper * >(argp1);
  ecode2 = SWIG_AsVal_int(id, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapWrapper_addNode" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(name, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "InfomapWrapper_addNode" "', argument " "3"" of type '" "std::string""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  arg4 = static_cast< double >(REAL(weight)[0]);
  {
    try {
      (arg1)->addNode(arg2,arg3,arg4);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapWrapper_addName ( SEXP self, SEXP id, SEXP name)
{
  infomap::InfomapWrapper *arg1 = (infomap::InfomapWrapper *) 0 ;
  unsigned int arg2 ;
  std::string arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapWrapper_addName" "', argument " "1"" of type '" "infomap::InfomapWrapper *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapWrapper * >(argp1);
  ecode2 = SWIG_AsVal_int(id, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapWrapper_addName" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(name, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "InfomapWrapper_addName" "', argument " "3"" of type '" "std::string""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      (arg1)->addName(arg2,arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapWrapper_getName ( SEXP self, SEXP id, SEXP s_swig_copy)
{
  std::string result;
  infomap::InfomapWrapper *arg1 = (infomap::InfomapWrapper *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapWrapper_getName" "', argument " "1"" of type '" "infomap::InfomapWrapper const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapWrapper * >(argp1);
  ecode2 = SWIG_AsVal_int(id, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapWrapper_getName" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = ((infomap::InfomapWrapper const *)arg1)->getName(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_std_string(static_cast< std::string >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapWrapper_getNames ( SEXP self, SEXP s_swig_copy)
{
  std::map< unsigned int,std::string,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,std::string > > > *result = 0 ;
  infomap::InfomapWrapper *arg1 = (infomap::InfomapWrapper *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapWrapper_getNames" "', argument " "1"" of type '" "infomap::InfomapWrapper const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapWrapper * >(argp1);
  {
    try {
      result = (std::map< unsigned int,std::string,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,std::string > > > *) &((infomap::InfomapWrapper const *)arg1)->getNames();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = swig::from(static_cast< std::map< unsigned int,std::string,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,std::string > > > >(*result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapWrapper_addPhysicalNode__SWIG_0 ( SEXP self, SEXP id, SEXP name)
{
  infomap::InfomapWrapper *arg1 = (infomap::InfomapWrapper *) 0 ;
  unsigned int arg2 ;
  std::string arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapWrapper_addPhysicalNode" "', argument " "1"" of type '" "infomap::InfomapWrapper *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapWrapper * >(argp1);
  ecode2 = SWIG_AsVal_int(id, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapWrapper_addPhysicalNode" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(name, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "InfomapWrapper_addPhysicalNode" "', argument " "3"" of type '" "std::string""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      (arg1)->addPhysicalNode(arg2,arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapWrapper_addPhysicalNode__SWIG_1 ( SEXP self, SEXP id)
{
  infomap::InfomapWrapper *arg1 = (infomap::InfomapWrapper *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapWrapper_addPhysicalNode" "', argument " "1"" of type '" "infomap::InfomapWrapper *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapWrapper * >(argp1);
  ecode2 = SWIG_AsVal_int(id, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapWrapper_addPhysicalNode" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      (arg1)->addPhysicalNode(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapWrapper_addStateNode ( SEXP self, SEXP id, SEXP physId)
{
  infomap::InfomapWrapper *arg1 = (infomap::InfomapWrapper *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapWrapper_addStateNode" "', argument " "1"" of type '" "infomap::InfomapWrapper *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapWrapper * >(argp1);
  ecode2 = SWIG_AsVal_int(id, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapWrapper_addStateNode" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_int(physId, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "InfomapWrapper_addStateNode" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    try {
      (arg1)->addStateNode(arg2,arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapWrapper_addLink__SWIG_0 ( SEXP self, SEXP sourceId, SEXP targetId, SEXP weight)
{
  infomap::InfomapWrapper *arg1 = (infomap::InfomapWrapper *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapWrapper_addLink" "', argument " "1"" of type '" "infomap::InfomapWrapper *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapWrapper * >(argp1);
  ecode2 = SWIG_AsVal_int(sourceId, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapWrapper_addLink" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_int(targetId, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "InfomapWrapper_addLink" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  arg4 = static_cast< double >(REAL(weight)[0]);
  {
    try {
      (arg1)->addLink(arg2,arg3,arg4);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapWrapper_addLink__SWIG_1 ( SEXP self, SEXP sourceId, SEXP targetId)
{
  infomap::InfomapWrapper *arg1 = (infomap::InfomapWrapper *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapWrapper_addLink" "', argument " "1"" of type '" "infomap::InfomapWrapper *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapWrapper * >(argp1);
  ecode2 = SWIG_AsVal_int(sourceId, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapWrapper_addLink" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_int(targetId, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "InfomapWrapper_addLink" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    try {
      (arg1)->addLink(arg2,arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapWrapper_addLink__SWIG_2 ( SEXP self, SEXP sourceId, SEXP targetId, SEXP weight)
{
  infomap::InfomapWrapper *arg1 = (infomap::InfomapWrapper *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapWrapper_addLink" "', argument " "1"" of type '" "infomap::InfomapWrapper *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapWrapper * >(argp1);
  ecode2 = SWIG_AsVal_int(sourceId, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapWrapper_addLink" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_int(targetId, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "InfomapWrapper_addLink" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_long(weight, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "InfomapWrapper_addLink" "', argument " "4"" of type '" "unsigned long""'");
  } 
  arg4 = static_cast< unsigned long >(val4);
  {
    try {
      (arg1)->addLink(arg2,arg3,arg4);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapWrapper_addMultilayerLink__SWIG_0 ( SEXP self, SEXP layer1, SEXP n1, SEXP layer2, SEXP n2, SEXP weight)
{
  infomap::InfomapWrapper *arg1 = (infomap::InfomapWrapper *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  unsigned int arg5 ;
  double arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapWrapper_addMultilayerLink" "', argument " "1"" of type '" "infomap::InfomapWrapper *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapWrapper * >(argp1);
  ecode2 = SWIG_AsVal_int(layer1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapWrapper_addMultilayerLink" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_int(n1, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "InfomapWrapper_addMultilayerLink" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_int(layer2, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "InfomapWrapper_addMultilayerLink" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  ecode5 = SWIG_AsVal_int(n2, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "InfomapWrapper_addMultilayerLink" "', argument " "5"" of type '" "unsigned int""'");
  } 
  arg5 = static_cast< unsigned int >(val5);
  arg6 = static_cast< double >(REAL(weight)[0]);
  {
    try {
      (arg1)->addMultilayerLink(arg2,arg3,arg4,arg5,arg6);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapWrapper_addMultilayerLink__SWIG_1 ( SEXP self, SEXP layer1, SEXP n1, SEXP layer2, SEXP n2)
{
  infomap::InfomapWrapper *arg1 = (infomap::InfomapWrapper *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  unsigned int arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapWrapper_addMultilayerLink" "', argument " "1"" of type '" "infomap::InfomapWrapper *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapWrapper * >(argp1);
  ecode2 = SWIG_AsVal_int(layer1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapWrapper_addMultilayerLink" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_int(n1, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "InfomapWrapper_addMultilayerLink" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_int(layer2, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "InfomapWrapper_addMultilayerLink" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  ecode5 = SWIG_AsVal_int(n2, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "InfomapWrapper_addMultilayerLink" "', argument " "5"" of type '" "unsigned int""'");
  } 
  arg5 = static_cast< unsigned int >(val5);
  {
    try {
      (arg1)->addMultilayerLink(arg2,arg3,arg4,arg5);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapWrapper_setBipartiteStartId ( SEXP self, SEXP startId)
{
  infomap::InfomapWrapper *arg1 = (infomap::InfomapWrapper *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapWrapper_setBipartiteStartId" "', argument " "1"" of type '" "infomap::InfomapWrapper *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapWrapper * >(argp1);
  ecode2 = SWIG_AsVal_int(startId, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "InfomapWrapper_setBipartiteStartId" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      (arg1)->setBipartiteStartId(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapWrapper_getModules__SWIG_0 ( SEXP self, SEXP level, SEXP states, SEXP s_swig_copy)
{
  SwigValueWrapper< std::map< unsigned int,unsigned int,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,unsigned int > > > > result;
  infomap::InfomapWrapper *arg1 = (infomap::InfomapWrapper *) 0 ;
  int arg2 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapWrapper_getModules" "', argument " "1"" of type '" "infomap::InfomapWrapper *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapWrapper * >(argp1);
  arg2 = static_cast< int >(INTEGER(level)[0]);
  arg3 = LOGICAL(states)[0] ? true : false;
  {
    try {
      result = (arg1)->getModules(arg2,arg3);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = swig::from(static_cast< std::map< unsigned int,unsigned int,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,unsigned int > > > >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapWrapper_getModules__SWIG_1 ( SEXP self, SEXP level, SEXP s_swig_copy)
{
  SwigValueWrapper< std::map< unsigned int,unsigned int,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,unsigned int > > > > result;
  infomap::InfomapWrapper *arg1 = (infomap::InfomapWrapper *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapWrapper_getModules" "', argument " "1"" of type '" "infomap::InfomapWrapper *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapWrapper * >(argp1);
  arg2 = static_cast< int >(INTEGER(level)[0]);
  {
    try {
      result = (arg1)->getModules(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = swig::from(static_cast< std::map< unsigned int,unsigned int,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,unsigned int > > > >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapWrapper_getModules__SWIG_2 ( SEXP self, SEXP s_swig_copy)
{
  SwigValueWrapper< std::map< unsigned int,unsigned int,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,unsigned int > > > > result;
  infomap::InfomapWrapper *arg1 = (infomap::InfomapWrapper *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapWrapper_getModules" "', argument " "1"" of type '" "infomap::InfomapWrapper *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapWrapper * >(argp1);
  {
    try {
      result = (arg1)->getModules();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = swig::from(static_cast< std::map< unsigned int,unsigned int,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,unsigned int > > > >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapWrapper_getMultilevelModules__SWIG_0 ( SEXP self, SEXP states, SEXP s_swig_copy)
{
  std::map< unsigned int,std::vector< unsigned int,std::allocator< unsigned int > >,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,std::vector< unsigned int,std::allocator< unsigned int > > > > > result;
  infomap::InfomapWrapper *arg1 = (infomap::InfomapWrapper *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapWrapper_getMultilevelModules" "', argument " "1"" of type '" "infomap::InfomapWrapper *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapWrapper * >(argp1);
  arg2 = LOGICAL(states)[0] ? true : false;
  {
    try {
      result = (arg1)->getMultilevelModules(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = swig::from(static_cast< std::map< unsigned int,std::vector< unsigned int,std::allocator< unsigned int > >,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,std::vector< unsigned int,std::allocator< unsigned int > > > > > >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapWrapper_getMultilevelModules__SWIG_1 ( SEXP self, SEXP s_swig_copy)
{
  std::map< unsigned int,std::vector< unsigned int,std::allocator< unsigned int > >,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,std::vector< unsigned int,std::allocator< unsigned int > > > > > result;
  infomap::InfomapWrapper *arg1 = (infomap::InfomapWrapper *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapWrapper_getMultilevelModules" "', argument " "1"" of type '" "infomap::InfomapWrapper *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapWrapper * >(argp1);
  {
    try {
      result = (arg1)->getMultilevelModules();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = swig::from(static_cast< std::map< unsigned int,std::vector< unsigned int,std::allocator< unsigned int > >,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,std::vector< unsigned int,std::allocator< unsigned int > > > > > >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapWrapper_run_SWIG_0_0 ( SEXP self, SEXP parameters)
{
  infomap::InfomapWrapper *arg1 = (infomap::InfomapWrapper *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapWrapper_run" "', argument " "1"" of type '" "infomap::InfomapWrapper *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapWrapper * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(parameters, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "InfomapWrapper_run" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try {
      (arg1)->run(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapWrapper_run_SWIG_0_1 ( SEXP self)
{
  infomap::InfomapWrapper *arg1 = (infomap::InfomapWrapper *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapWrapper_run" "', argument " "1"" of type '" "infomap::InfomapWrapper *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapWrapper * >(argp1);
  {
    try {
      (arg1)->run();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapWrapper_run_SWIG_0_2 ( SEXP self, SEXP network)
{
  infomap::InfomapWrapper *arg1 = (infomap::InfomapWrapper *) 0 ;
  infomap::Network *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapWrapper_run" "', argument " "1"" of type '" "infomap::InfomapWrapper *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapWrapper * >(argp1);
  res2 = SWIG_R_ConvertPtr(network, &argp2, SWIGTYPE_p_infomap__Network,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InfomapWrapper_run" "', argument " "2"" of type '" "infomap::Network &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InfomapWrapper_run" "', argument " "2"" of type '" "infomap::Network &""'"); 
  }
  arg2 = reinterpret_cast< infomap::Network * >(argp2);
  {
    try {
      (arg1)->run(*arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = R_NilValue;
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapWrapper_codelength ( SEXP self, SEXP s_swig_copy)
{
  double result;
  infomap::InfomapWrapper *arg1 = (infomap::InfomapWrapper *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapWrapper_codelength" "', argument " "1"" of type '" "infomap::InfomapWrapper const *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapWrapper * >(argp1);
  {
    try {
      result = (double)((infomap::InfomapWrapper const *)arg1)->codelength();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_From_double(static_cast< double >(result));
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapWrapper_iterTree_SWIG_0_0 ( SEXP self, SEXP maxClusterLevel, SEXP s_swig_copy)
{
  infomap::InfomapIterator result;
  infomap::InfomapWrapper *arg1 = (infomap::InfomapWrapper *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapWrapper_iterTree" "', argument " "1"" of type '" "infomap::InfomapWrapper *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapWrapper * >(argp1);
  arg2 = static_cast< int >(INTEGER(maxClusterLevel)[0]);
  {
    try {
      result = (arg1)->iterTree(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfomapIterator(static_cast< const infomap::InfomapIterator& >(result))), SWIGTYPE_p_infomap__InfomapIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapWrapper_iterTree_SWIG_0_1 ( SEXP self, SEXP s_swig_copy)
{
  infomap::InfomapIterator result;
  infomap::InfomapWrapper *arg1 = (infomap::InfomapWrapper *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapWrapper_iterTree" "', argument " "1"" of type '" "infomap::InfomapWrapper *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapWrapper * >(argp1);
  {
    try {
      result = (arg1)->iterTree();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfomapIterator(static_cast< const infomap::InfomapIterator& >(result))), SWIGTYPE_p_infomap__InfomapIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapWrapper_iterLeafNodes_SWIG_0_0 ( SEXP self, SEXP maxClusterLevel, SEXP s_swig_copy)
{
  infomap::InfomapLeafIterator result;
  infomap::InfomapWrapper *arg1 = (infomap::InfomapWrapper *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapWrapper_iterLeafNodes" "', argument " "1"" of type '" "infomap::InfomapWrapper *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapWrapper * >(argp1);
  arg2 = static_cast< int >(INTEGER(maxClusterLevel)[0]);
  {
    try {
      result = (arg1)->iterLeafNodes(arg2);
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfomapLeafIterator(static_cast< const infomap::InfomapLeafIterator& >(result))), SWIGTYPE_p_infomap__InfomapLeafIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


SWIGEXPORT SEXP
R_swig_InfomapWrapper_iterLeafNodes_SWIG_0_1 ( SEXP self, SEXP s_swig_copy)
{
  infomap::InfomapLeafIterator result;
  infomap::InfomapWrapper *arg1 = (infomap::InfomapWrapper *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int r_nprotect = 0;
  SEXP r_ans = R_NilValue ;
  VMAXTYPE r_vmax = vmaxget() ;
  
  res1 = SWIG_R_ConvertPtr(self, &argp1, SWIGTYPE_p_infomap__InfomapWrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InfomapWrapper_iterLeafNodes" "', argument " "1"" of type '" "infomap::InfomapWrapper *""'"); 
  }
  arg1 = reinterpret_cast< infomap::InfomapWrapper * >(argp1);
  {
    try {
      result = (arg1)->iterLeafNodes();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  r_ans = SWIG_R_NewPointerObj((new infomap::InfomapLeafIterator(static_cast< const infomap::InfomapLeafIterator& >(result))), SWIGTYPE_p_infomap__InfomapLeafIterator, SWIG_POINTER_OWN |  0 );
  vmaxset(r_vmax);
  if(r_nprotect)  Rf_unprotect(r_nprotect);
  
  return r_ans;
  fail: SWIGUNUSED;
  Rf_error("%s %s", SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
  return R_NilValue;
}


#ifdef __cplusplus
}
#endif

/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static void *_p_infomap__NetworkTo_p_infomap__StateNetwork(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((infomap::StateNetwork *)  ((infomap::Network *) x));
}
static void *_p_infomap__InfomapLeafIteratorPhysicalTo_p_infomap__InfomapIteratorPhysical(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((infomap::InfomapIteratorPhysical *)  ((infomap::InfomapLeafIteratorPhysical *) x));
}
static void *_p_infomap__InfomapIteratorPhysicalTo_p_infomap__InfomapIterator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((infomap::InfomapIterator *)  ((infomap::InfomapIteratorPhysical *) x));
}
static void *_p_infomap__InfomapLeafIteratorPhysicalTo_p_infomap__InfomapIterator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((infomap::InfomapIterator *) (infomap::InfomapIteratorPhysical *) ((infomap::InfomapLeafIteratorPhysical *) x));
}
static void *_p_infomap__InfomapModuleIteratorTo_p_infomap__InfomapIterator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((infomap::InfomapIterator *)  ((infomap::InfomapModuleIterator *) x));
}
static void *_p_infomap__InfomapLeafModuleIteratorTo_p_infomap__InfomapIterator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((infomap::InfomapIterator *)  ((infomap::InfomapLeafModuleIterator *) x));
}
static void *_p_infomap__InfomapLeafIteratorTo_p_infomap__InfomapIterator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((infomap::InfomapIterator *)  ((infomap::InfomapLeafIterator *) x));
}
static void *_p_infomap__InfomapCoreTo_p_infomap__InfomapConfigT_infomap__InfomapBase_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((infomap::InfomapConfig< infomap::InfomapBase > *) (infomap::InfomapBase *) ((infomap::InfomapCore *) x));
}
static void *_p_infomap__InfomapBaseTo_p_infomap__InfomapConfigT_infomap__InfomapBase_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((infomap::InfomapConfig< infomap::InfomapBase > *)  ((infomap::InfomapBase *) x));
}
static void *_p_infomap__InfomapWrapperTo_p_infomap__InfomapConfigT_infomap__InfomapBase_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((infomap::InfomapConfig< infomap::InfomapBase > *) (infomap::InfomapBase *)(infomap::InfomapCore *) ((infomap::InfomapWrapper *) x));
}
static void *_p_infomap__MemMapEquationTo_p_infomap__MapEquation(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((infomap::MapEquation *)  ((infomap::MemMapEquation *) x));
}
static void *_p_infomap__MetaMapEquationTo_p_infomap__MapEquation(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((infomap::MapEquation *)  ((infomap::MetaMapEquation *) x));
}
static void *_p_infomap__InfomapCoreTo_p_infomap__Config(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((infomap::Config *) (infomap::InfomapConfig< infomap::InfomapBase > *)(infomap::InfomapBase *) ((infomap::InfomapCore *) x));
}
static void *_p_infomap__InfomapConfigT_infomap__InfomapBase_tTo_p_infomap__Config(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((infomap::Config *)  ((infomap::InfomapConfig< infomap::InfomapBase > *) x));
}
static void *_p_infomap__InfomapBaseTo_p_infomap__Config(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((infomap::Config *) (infomap::InfomapConfig< infomap::InfomapBase > *) ((infomap::InfomapBase *) x));
}
static void *_p_infomap__InfomapWrapperTo_p_infomap__Config(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((infomap::Config *) (infomap::InfomapConfig< infomap::InfomapBase > *)(infomap::InfomapBase *)(infomap::InfomapCore *) ((infomap::InfomapWrapper *) x));
}
static void *_p_infomap__InfomapWrapperTo_p_infomap__InfomapCore(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((infomap::InfomapCore *)  ((infomap::InfomapWrapper *) x));
}
static void *_p_infomap__MemDeltaFlowTo_p_infomap__DeltaFlow(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((infomap::DeltaFlow *)  ((infomap::MemDeltaFlow *) x));
}
static void *_p_infomap__InfomapCoreTo_p_infomap__InfomapBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((infomap::InfomapBase *)  ((infomap::InfomapCore *) x));
}
static void *_p_infomap__InfomapWrapperTo_p_infomap__InfomapBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((infomap::InfomapBase *) (infomap::InfomapCore *) ((infomap::InfomapWrapper *) x));
}
static swig_type_info _swigt__p_ChildIteratorT_infomap__InfoNode_const_p_t = {"_p_ChildIteratorT_infomap__InfoNode_const_p_t", "infomap::InfoNode::const_child_iterator *|ChildIterator< infomap::InfoNode const * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ChildIteratorT_infomap__InfoNode_p_t = {"_p_ChildIteratorT_infomap__InfoNode_p_t", "infomap::InfoNode::child_iterator *|ChildIterator< infomap::InfoNode * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Date = {"_p_Date", "Date *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_DeltaFlowDataType = {"_p_DeltaFlowDataType", "DeltaFlowDataType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_DepthFirstIteratorT_infomap__InfoNode_p_false_t = {"_p_DepthFirstIteratorT_infomap__InfoNode_p_false_t", "infomap::InfoNode::post_depth_first_iterator *|DepthFirstIterator< infomap::InfoNode *,false > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_EdgeT_infomap__InfoNode_t = {"_p_EdgeT_infomap__InfoNode_t", "infomap::InfoNode::EdgeType *|Edge< infomap::InfoNode > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_EdgeType = {"_p_EdgeType", "EdgeType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FlowDataType = {"_p_FlowDataType", "FlowDataType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IterWrapperT_ChildIteratorT_infomap__InfoNode_const_p_t_t = {"_p_IterWrapperT_ChildIteratorT_infomap__InfoNode_const_p_t_t", "IterWrapper< ChildIterator< infomap::InfoNode const * > > *|infomap::InfoNode::const_child_iterator_wrapper *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IterWrapperT_ChildIteratorT_infomap__InfoNode_p_t_t = {"_p_IterWrapperT_ChildIteratorT_infomap__InfoNode_p_t_t", "IterWrapper< ChildIterator< infomap::InfoNode * > > *|infomap::InfoNode::child_iterator_wrapper *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IterWrapperT_InfomapChildIteratorT_infomap__InfoNode_const_p_t_t = {"_p_IterWrapperT_InfomapChildIteratorT_infomap__InfoNode_const_p_t_t", "IterWrapper< InfomapChildIterator< infomap::InfoNode const * > > *|infomap::InfoNode::const_infomap_child_iterator_wrapper *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IterWrapperT_InfomapChildIteratorT_infomap__InfoNode_p_t_t = {"_p_IterWrapperT_InfomapChildIteratorT_infomap__InfoNode_p_t_t", "infomap::InfoNode::infomap_child_iterator_wrapper *|IterWrapper< InfomapChildIterator< infomap::InfoNode * > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IterWrapperT_TreeIteratorT_infomap__InfoNode_const_p_t_t = {"_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_const_p_t_t", "infomap::InfoNode::const_infomap_iterator_wrapper *|IterWrapper< TreeIterator< infomap::InfoNode const * > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IterWrapperT_TreeIteratorT_infomap__InfoNode_p_t_t = {"_p_IterWrapperT_TreeIteratorT_infomap__InfoNode_p_t_t", "IterWrapper< TreeIterator< infomap::InfoNode * > > *|infomap::InfoNode::infomap_iterator_wrapper *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IterWrapperT_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator_t = {"_p_IterWrapperT_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator_t", "IterWrapper< std::vector< Edge< infomap::InfoNode > *,std::allocator< Edge< infomap::InfoNode > * > >::iterator > *|infomap::InfoNode::edge_iterator_wrapper *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_LeafModuleIteratorT_infomap__InfoNode_p_t = {"_p_LeafModuleIteratorT_infomap__InfoNode_p_t", "infomap::InfoNode::leaf_module_iterator *|LeafModuleIterator< infomap::InfoNode * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_LeafNodeIteratorT_infomap__InfoNode_p_t = {"_p_LeafNodeIteratorT_infomap__InfoNode_p_t", "infomap::InfoNode::leaf_node_iterator *|LeafNodeIterator< infomap::InfoNode * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MetaCollection = {"_p_MetaCollection", "MetaCollection *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_NodeLinkMap = {"_p_NodeLinkMap", "NodeLinkMap *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_NodeMap = {"_p_NodeMap", "NodeMap *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_NodePaths = {"_p_NodePaths", "NodePaths *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OutLinkMap = {"_p_OutLinkMap", "OutLinkMap *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_PartitionQueue = {"_p_PartitionQueue", "PartitionQueue *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_TreeIteratorT_infomap__InfoNode_const_p_t = {"_p_TreeIteratorT_infomap__InfoNode_const_p_t", "infomap::InfoNode::const_tree_iterator *|TreeIterator< infomap::InfoNode const * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_TreeIteratorT_infomap__InfoNode_p_t = {"_p_TreeIteratorT_infomap__InfoNode_p_t", "infomap::InfoNode::tree_iterator *|TreeIterator< infomap::InfoNode * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_VectorMapT_infomap__DeltaFlow_t = {"_p_VectorMapT_infomap__DeltaFlow_t", "VectorMap< infomap::DeltaFlow > *|VectorMap< infomap::MetaMapEquation::DeltaFlowDataType > *|VectorMap< infomap::MapEquation::DeltaFlowDataType > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_VectorMapT_infomap__MemDeltaFlow_t = {"_p_VectorMapT_infomap__MemDeltaFlow_t", "VectorMap< infomap::MemDeltaFlow > *|VectorMap< infomap::MemMapEquation::DeltaFlowDataType > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_allocator_type = {"_p_allocator_type", "allocator_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_child_iterator = {"_p_child_iterator", "child_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_child_iterator_wrapper = {"_p_child_iterator_wrapper", "child_iterator_wrapper *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_const_child_iterator = {"_p_const_child_iterator", "const_child_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_const_child_iterator_wrapper = {"_p_const_child_iterator_wrapper", "const_child_iterator_wrapper *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_const_edge_iterator = {"_p_const_edge_iterator", "const_edge_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_const_edge_iterator_wrapper = {"_p_const_edge_iterator_wrapper", "const_edge_iterator_wrapper *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_const_infomap_child_iterator = {"_p_const_infomap_child_iterator", "const_infomap_child_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_const_infomap_child_iterator_wrapper = {"_p_const_infomap_child_iterator_wrapper", "const_infomap_child_iterator_wrapper *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_const_infomap_iterator_wrapper = {"_p_const_infomap_iterator_wrapper", "const_infomap_iterator_wrapper *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_const_leaf_module_iterator = {"_p_const_leaf_module_iterator", "const_leaf_module_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_const_leaf_node_iterator = {"_p_const_leaf_node_iterator", "const_leaf_node_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_const_post_depth_first_iterator = {"_p_const_post_depth_first_iterator", "const_post_depth_first_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_const_tree_iterator = {"_p_const_tree_iterator", "const_tree_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_difference_type = {"_p_difference_type", "difference_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_edge_iterator = {"_p_edge_iterator", "edge_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_edge_iterator_wrapper = {"_p_edge_iterator_wrapper", "edge_iterator_wrapper *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap__Bigram = {"_p_infomap__Bigram", "infomap::Bigram *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap__BipartiteLink = {"_p_infomap__BipartiteLink", "infomap::BipartiteLink *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap__Config = {"_p_infomap__Config", "infomap::Config *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap__DeltaFlow = {"_p_infomap__DeltaFlow", "infomap::MapEquation::DeltaFlowDataType *|infomap::MetaMapEquation::DeltaFlowDataType *|infomap::DeltaFlow *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap__FlowData = {"_p_infomap__FlowData", "infomap::FlowData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap__FlowModel = {"_p_infomap__FlowModel", "infomap::FlowModel *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap__InfoNode = {"_p_infomap__InfoNode", "infomap::InfoNode *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap__InfomapBase = {"_p_infomap__InfomapBase", "infomap::InfomapBase *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap__InfomapConfigT_infomap__InfomapBase_t = {"_p_infomap__InfomapConfigT_infomap__InfomapBase_t", "infomap::InfomapConfig< infomap::InfomapBase > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap__InfomapCore = {"_p_infomap__InfomapCore", "infomap::InfomapCore *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap__InfomapIterator = {"_p_infomap__InfomapIterator", "infomap::InfomapIterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap__InfomapIteratorPhysical = {"_p_infomap__InfomapIteratorPhysical", "infomap::InfomapIteratorPhysical *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap__InfomapLeafIterator = {"_p_infomap__InfomapLeafIterator", "infomap::InfomapLeafIterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap__InfomapLeafIteratorPhysical = {"_p_infomap__InfomapLeafIteratorPhysical", "infomap::InfomapLeafIteratorPhysical *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap__InfomapLeafModuleIterator = {"_p_infomap__InfomapLeafModuleIterator", "infomap::InfomapLeafModuleIterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap__InfomapModuleIterator = {"_p_infomap__InfomapModuleIterator", "infomap::InfomapModuleIterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap__InfomapParentIterator = {"_p_infomap__InfomapParentIterator", "infomap::InfomapParentIterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap__InfomapWrapper = {"_p_infomap__InfomapWrapper", "infomap::InfomapWrapper *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap__LayerNode = {"_p_infomap__LayerNode", "infomap::LayerNode *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap__MapEquation = {"_p_infomap__MapEquation", "infomap::MapEquation *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap__MapMapT_unsigned_int_unsigned_int_double_t = {"_p_infomap__MapMapT_unsigned_int_unsigned_int_double_t", "infomap::MapMap< unsigned int,unsigned int,double > *|infomap::LinkMapMap *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap__MemDeltaFlow = {"_p_infomap__MemDeltaFlow", "infomap::MemMapEquation::DeltaFlowDataType *|infomap::MemDeltaFlow *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap__MemMapEquation = {"_p_infomap__MemMapEquation", "infomap::MemMapEquation *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap__MemNodeSet = {"_p_infomap__MemNodeSet", "infomap::MemNodeSet *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap__MetaMapEquation = {"_p_infomap__MetaMapEquation", "infomap::MetaMapEquation *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap__Network = {"_p_infomap__Network", "infomap::Network *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap__OptimizationLevel = {"_p_infomap__OptimizationLevel", "infomap::OptimizationLevel *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap__PerLevelStat = {"_p_infomap__PerLevelStat", "infomap::PerLevelStat *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap__PhysData = {"_p_infomap__PhysData", "infomap::PhysData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap__StateNetwork = {"_p_infomap__StateNetwork", "infomap::StateNetwork *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap__StateNetwork__PhysNode = {"_p_infomap__StateNetwork__PhysNode", "infomap::StateNetwork::PhysNode *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap__StateNetwork__StateNode = {"_p_infomap__StateNetwork__StateNode", "infomap::StateNetwork::StateNode *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap__Triple = {"_p_infomap__Triple", "infomap::Triple *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap__Weight = {"_p_infomap__Weight", "infomap::Weight *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap__detail__PartitionQueue = {"_p_infomap__detail__PartitionQueue", "infomap::detail::PartitionQueue *|infomap::InfomapBase::PartitionQueue *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap_child_iterator = {"_p_infomap_child_iterator", "infomap_child_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap_child_iterator_wrapper = {"_p_infomap_child_iterator_wrapper", "infomap_child_iterator_wrapper *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_infomap_iterator_wrapper = {"_p_infomap_iterator_wrapper", "infomap_iterator_wrapper *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_key_type = {"_p_key_type", "key_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_leaf_module_iterator = {"_p_leaf_module_iterator", "leaf_module_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_leaf_node_iterator = {"_p_leaf_node_iterator", "leaf_node_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_mapped_type = {"_p_mapped_type", "mapped_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_post_depth_first_iterator = {"_p_post_depth_first_iterator", "post_depth_first_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_size_t = {"_p_size_t", "size_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_size_type = {"_p_size_type", "size_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__allocatorT_double_t = {"_p_std__allocatorT_double_t", "std::vector< double >::allocator_type *|std::allocator< double > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t = {"_p_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t", "std::map< unsigned int,std::string >::allocator_type *|std::allocator< std::pair< unsigned int const,std::string > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t = {"_p_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t", "std::map< unsigned int,std::vector< unsigned int > >::allocator_type *|std::allocator< std::pair< unsigned int const,std::vector< unsigned int,std::allocator< unsigned int > > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t = {"_p_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t", "std::allocator< std::pair< unsigned int const,unsigned int > > *|std::map< unsigned int,unsigned int >::allocator_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__allocatorT_unsigned_int_t = {"_p_std__allocatorT_unsigned_int_t", "std::vector< unsigned int >::allocator_type *|std::deque< unsigned int >::allocator_type *|std::allocator< unsigned int > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__dequeT_infomap__InfoNode_p_std__allocatorT_infomap__InfoNode_p_t_t__size_type = {"_p_std__dequeT_infomap__InfoNode_p_std__allocatorT_infomap__InfoNode_p_t_t__size_type", "std::deque< infomap::InfoNode *,std::allocator< infomap::InfoNode * > >::size_type *|infomap::detail::PartitionQueue::size_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t = {"_p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t", "std::deque< unsigned int,std::allocator< unsigned int > > *|std::deque< unsigned int > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__lessT_unsigned_int_t = {"_p_std__lessT_unsigned_int_t", "std::less< unsigned int > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_infomap__StateNetwork__StateNode_std__mapT_infomap__StateNetwork__StateNode_infomap__StateNetwork__LinkData_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_infomap__StateNetwork__LinkData_t_t_t_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_std__mapT_infomap__StateNetwork__StateNode_infomap__StateNetwork__LinkData_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_infomap__StateNetwork__LinkData_t_t_t_t_t_t = {"_p_std__mapT_infomap__StateNetwork__StateNode_std__mapT_infomap__StateNetwork__StateNode_infomap__StateNetwork__LinkData_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_infomap__StateNetwork__LinkData_t_t_t_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_std__mapT_infomap__StateNetwork__StateNode_infomap__StateNetwork__LinkData_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_infomap__StateNetwork__LinkData_t_t_t_t_t_t", "infomap::StateNetwork::NodeLinkMap *|std::map< infomap::StateNetwork::StateNode,std::map< infomap::StateNetwork::StateNode,infomap::StateNetwork::LinkData,std::less< infomap::StateNetwork::StateNode >,std::allocator< std::pair< infomap::StateNetwork::StateNode const,infomap::StateNetwork::LinkData > > >,std::less< infomap::StateNetwork::StateNode >,std::allocator< std::pair< infomap::StateNetwork::StateNode const,std::map< infomap::StateNetwork::StateNode,infomap::StateNetwork::LinkData,std::less< infomap::StateNetwork::StateNode >,std::allocator< std::pair< infomap::StateNetwork::StateNode const,infomap::StateNetwork::LinkData > > > > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_unsigned_int_double_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_double_t_t_t = {"_p_std__mapT_unsigned_int_double_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_double_t_t_t", "std::map< unsigned int,double,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,double > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_unsigned_int_infomap__StateNetwork__StateNode_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_infomap__StateNetwork__StateNode_t_t_t = {"_p_std__mapT_unsigned_int_infomap__StateNetwork__StateNode_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_infomap__StateNetwork__StateNode_t_t_t", "std::map< unsigned int,infomap::StateNetwork::StateNode,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,infomap::StateNetwork::StateNode > > > *|infomap::StateNetwork::NodeMap *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t = {"_p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t", "std::map< unsigned int,std::string,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,std::string > > > *|std::map< unsigned int,std::string > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_unsigned_int_std__vectorT_int_std__allocatorT_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_int_std__allocatorT_int_t_t_t_t_t = {"_p_std__mapT_unsigned_int_std__vectorT_int_std__allocatorT_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_int_std__allocatorT_int_t_t_t_t_t", "std::map< unsigned int,std::vector< int,std::allocator< int > >,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,std::vector< int,std::allocator< int > > > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t = {"_p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t", "std::map< unsigned int,std::vector< unsigned int > > *|std::map< unsigned int,std::vector< unsigned int,std::allocator< unsigned int > >,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,std::vector< unsigned int,std::allocator< unsigned int > > > > > *|std::map< unsigned int,std::vector< unsigned int,std::allocator< unsigned int > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t = {"_p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t", "std::map< unsigned int,unsigned int,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,unsigned int > > > *|std::map< unsigned int,unsigned int > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__ostream = {"_p_std__ostream", "std::ostream *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__pairT_std__mapT_unsigned_int_infomap__StateNetwork__StateNode_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_infomap__StateNetwork__StateNode_t_t_t__iterator_bool_t = {"_p_std__pairT_std__mapT_unsigned_int_infomap__StateNetwork__StateNode_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_infomap__StateNetwork__StateNode_t_t_t__iterator_bool_t", "std::pair< std::map< unsigned int,infomap::StateNetwork::StateNode,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,infomap::StateNetwork::StateNode > > >::iterator,bool > *|std::pair< infomap::StateNetwork::NodeMap::iterator,bool > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__pairT_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t__iterator_bool_t = {"_p_std__pairT_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t__iterator_bool_t", "std::pair< std::map< unsigned int,std::string,std::less< unsigned int >,std::allocator< std::pair< unsigned int const,std::string > > >::iterator,bool > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator = {"_p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator", "std::vector< Edge< infomap::InfoNode > *,std::allocator< Edge< infomap::InfoNode > * > >::iterator *|infomap::InfoNode::edge_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_ParsedOption_std__allocatorT_ParsedOption_t_t = {"_p_std__vectorT_ParsedOption_std__allocatorT_ParsedOption_t_t", "std::vector< ParsedOption,std::allocator< ParsedOption > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_double_std__allocatorT_double_t_t = {"_p_std__vectorT_double_std__allocatorT_double_t_t", "std::vector< double,std::allocator< double > > *|std::vector< double > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_infomap__FlowData_std__allocatorT_infomap__FlowData_t_t = {"_p_std__vectorT_infomap__FlowData_std__allocatorT_infomap__FlowData_t_t", "std::vector< infomap::MemMapEquation::FlowDataType,std::allocator< infomap::MemMapEquation::FlowDataType > > *|std::vector< infomap::FlowData,std::allocator< infomap::FlowData > > *|std::vector< infomap::MapEquation::FlowDataType,std::allocator< infomap::MapEquation::FlowDataType > > *|std::vector< infomap::MetaMapEquation::FlowDataType,std::allocator< infomap::MetaMapEquation::FlowDataType > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_infomap__InfoNode_p_std__allocatorT_infomap__InfoNode_p_t_t = {"_p_std__vectorT_infomap__InfoNode_p_std__allocatorT_infomap__InfoNode_p_t_t", "std::vector< infomap::InfoNode *,std::allocator< infomap::InfoNode * > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_infomap__PerLevelStat_std__allocatorT_infomap__PerLevelStat_t_t = {"_p_std__vectorT_infomap__PerLevelStat_std__allocatorT_infomap__PerLevelStat_t_t", "std::vector< infomap::PerLevelStat,std::allocator< infomap::PerLevelStat > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_infomap__PhysData_std__allocatorT_infomap__PhysData_t_t = {"_p_std__vectorT_infomap__PhysData_std__allocatorT_infomap__PhysData_t_t", "std::vector< infomap::PhysData,std::allocator< infomap::PhysData > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_int_std__allocatorT_int_t_t = {"_p_std__vectorT_int_std__allocatorT_int_t_t", "std::vector< int,std::allocator< int > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_std__string_std__allocatorT_std__string_t_t = {"_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", "std::vector< std::string,std::allocator< std::string > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__allocatorT_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t = {"_p_std__vectorT_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__allocatorT_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t", "std::vector< std::vector< unsigned int,std::allocator< unsigned int > >,std::allocator< std::vector< unsigned int,std::allocator< unsigned int > > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t = {"_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t", "std::vector< unsigned int,std::allocator< unsigned int > > *|std::vector< unsigned int > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_tree_iterator = {"_p_tree_iterator", "tree_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_value_type = {"_p_value_type", "value_type *", 0, 0, (void*)0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_ChildIteratorT_infomap__InfoNode_const_p_t,
  &_swigt__p_ChildIteratorT_infomap__InfoNode_p_t,
  &_swigt__p_Date,
  &_swigt__p_DeltaFlowDataType,
  &_swigt__p_DepthFirstIteratorT_infomap__InfoNode_p_false_t,
  &_swigt__p_EdgeT_infomap__InfoNode_t,
  &_swigt__p_EdgeType,
  &_swigt__p_FlowDataType,
  &_swigt__p_IterWrapperT_ChildIteratorT_infomap__InfoNode_const_p_t_t,
  &_swigt__p_IterWrapperT_ChildIteratorT_infomap__InfoNode_p_t_t,
  &_swigt__p_IterWrapperT_InfomapChildIteratorT_infomap__InfoNode_const_p_t_t,
  &_swigt__p_IterWrapperT_InfomapChildIteratorT_infomap__InfoNode_p_t_t,
  &_swigt__p_IterWrapperT_TreeIteratorT_infomap__InfoNode_const_p_t_t,
  &_swigt__p_IterWrapperT_TreeIteratorT_infomap__InfoNode_p_t_t,
  &_swigt__p_IterWrapperT_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator_t,
  &_swigt__p_LeafModuleIteratorT_infomap__InfoNode_p_t,
  &_swigt__p_LeafNodeIteratorT_infomap__InfoNode_p_t,
  &_swigt__p_MetaCollection,
  &_swigt__p_NodeLinkMap,
  &_swigt__p_NodeMap,
  &_swigt__p_NodePaths,
  &_swigt__p_OutLinkMap,
  &_swigt__p_PartitionQueue,
  &_swigt__p_TreeIteratorT_infomap__InfoNode_const_p_t,
  &_swigt__p_TreeIteratorT_infomap__InfoNode_p_t,
  &_swigt__p_VectorMapT_infomap__DeltaFlow_t,
  &_swigt__p_VectorMapT_infomap__MemDeltaFlow_t,
  &_swigt__p_allocator_type,
  &_swigt__p_char,
  &_swigt__p_child_iterator,
  &_swigt__p_child_iterator_wrapper,
  &_swigt__p_const_child_iterator,
  &_swigt__p_const_child_iterator_wrapper,
  &_swigt__p_const_edge_iterator,
  &_swigt__p_const_edge_iterator_wrapper,
  &_swigt__p_const_infomap_child_iterator,
  &_swigt__p_const_infomap_child_iterator_wrapper,
  &_swigt__p_const_infomap_iterator_wrapper,
  &_swigt__p_const_leaf_module_iterator,
  &_swigt__p_const_leaf_node_iterator,
  &_swigt__p_const_post_depth_first_iterator,
  &_swigt__p_const_tree_iterator,
  &_swigt__p_difference_type,
  &_swigt__p_edge_iterator,
  &_swigt__p_edge_iterator_wrapper,
  &_swigt__p_infomap__Bigram,
  &_swigt__p_infomap__BipartiteLink,
  &_swigt__p_infomap__Config,
  &_swigt__p_infomap__DeltaFlow,
  &_swigt__p_infomap__FlowData,
  &_swigt__p_infomap__FlowModel,
  &_swigt__p_infomap__InfoNode,
  &_swigt__p_infomap__InfomapBase,
  &_swigt__p_infomap__InfomapConfigT_infomap__InfomapBase_t,
  &_swigt__p_infomap__InfomapCore,
  &_swigt__p_infomap__InfomapIterator,
  &_swigt__p_infomap__InfomapIteratorPhysical,
  &_swigt__p_infomap__InfomapLeafIterator,
  &_swigt__p_infomap__InfomapLeafIteratorPhysical,
  &_swigt__p_infomap__InfomapLeafModuleIterator,
  &_swigt__p_infomap__InfomapModuleIterator,
  &_swigt__p_infomap__InfomapParentIterator,
  &_swigt__p_infomap__InfomapWrapper,
  &_swigt__p_infomap__LayerNode,
  &_swigt__p_infomap__MapEquation,
  &_swigt__p_infomap__MapMapT_unsigned_int_unsigned_int_double_t,
  &_swigt__p_infomap__MemDeltaFlow,
  &_swigt__p_infomap__MemMapEquation,
  &_swigt__p_infomap__MemNodeSet,
  &_swigt__p_infomap__MetaMapEquation,
  &_swigt__p_infomap__Network,
  &_swigt__p_infomap__OptimizationLevel,
  &_swigt__p_infomap__PerLevelStat,
  &_swigt__p_infomap__PhysData,
  &_swigt__p_infomap__StateNetwork,
  &_swigt__p_infomap__StateNetwork__PhysNode,
  &_swigt__p_infomap__StateNetwork__StateNode,
  &_swigt__p_infomap__Triple,
  &_swigt__p_infomap__Weight,
  &_swigt__p_infomap__detail__PartitionQueue,
  &_swigt__p_infomap_child_iterator,
  &_swigt__p_infomap_child_iterator_wrapper,
  &_swigt__p_infomap_iterator_wrapper,
  &_swigt__p_key_type,
  &_swigt__p_leaf_module_iterator,
  &_swigt__p_leaf_node_iterator,
  &_swigt__p_mapped_type,
  &_swigt__p_post_depth_first_iterator,
  &_swigt__p_size_t,
  &_swigt__p_size_type,
  &_swigt__p_std__allocatorT_double_t,
  &_swigt__p_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t,
  &_swigt__p_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t,
  &_swigt__p_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t,
  &_swigt__p_std__allocatorT_unsigned_int_t,
  &_swigt__p_std__dequeT_infomap__InfoNode_p_std__allocatorT_infomap__InfoNode_p_t_t__size_type,
  &_swigt__p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t,
  &_swigt__p_std__lessT_unsigned_int_t,
  &_swigt__p_std__mapT_infomap__StateNetwork__StateNode_std__mapT_infomap__StateNetwork__StateNode_infomap__StateNetwork__LinkData_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_infomap__StateNetwork__LinkData_t_t_t_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_std__mapT_infomap__StateNetwork__StateNode_infomap__StateNetwork__LinkData_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_infomap__StateNetwork__LinkData_t_t_t_t_t_t,
  &_swigt__p_std__mapT_unsigned_int_double_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_double_t_t_t,
  &_swigt__p_std__mapT_unsigned_int_infomap__StateNetwork__StateNode_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_infomap__StateNetwork__StateNode_t_t_t,
  &_swigt__p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t,
  &_swigt__p_std__mapT_unsigned_int_std__vectorT_int_std__allocatorT_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_int_std__allocatorT_int_t_t_t_t_t,
  &_swigt__p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t,
  &_swigt__p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t,
  &_swigt__p_std__ostream,
  &_swigt__p_std__pairT_std__mapT_unsigned_int_infomap__StateNetwork__StateNode_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_infomap__StateNetwork__StateNode_t_t_t__iterator_bool_t,
  &_swigt__p_std__pairT_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t__iterator_bool_t,
  &_swigt__p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator,
  &_swigt__p_std__vectorT_ParsedOption_std__allocatorT_ParsedOption_t_t,
  &_swigt__p_std__vectorT_double_std__allocatorT_double_t_t,
  &_swigt__p_std__vectorT_infomap__FlowData_std__allocatorT_infomap__FlowData_t_t,
  &_swigt__p_std__vectorT_infomap__InfoNode_p_std__allocatorT_infomap__InfoNode_p_t_t,
  &_swigt__p_std__vectorT_infomap__PerLevelStat_std__allocatorT_infomap__PerLevelStat_t_t,
  &_swigt__p_std__vectorT_infomap__PhysData_std__allocatorT_infomap__PhysData_t_t,
  &_swigt__p_std__vectorT_int_std__allocatorT_int_t_t,
  &_swigt__p_std__vectorT_std__string_std__allocatorT_std__string_t_t,
  &_swigt__p_std__vectorT_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__allocatorT_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t,
  &_swigt__p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t,
  &_swigt__p_tree_iterator,
  &_swigt__p_value_type,
};

static swig_cast_info _swigc__p_ChildIteratorT_infomap__InfoNode_const_p_t[] = {  {&_swigt__p_ChildIteratorT_infomap__InfoNode_const_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ChildIteratorT_infomap__InfoNode_p_t[] = {  {&_swigt__p_ChildIteratorT_infomap__InfoNode_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Date[] = {  {&_swigt__p_Date, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_DeltaFlowDataType[] = {  {&_swigt__p_DeltaFlowDataType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_DepthFirstIteratorT_infomap__InfoNode_p_false_t[] = {  {&_swigt__p_DepthFirstIteratorT_infomap__InfoNode_p_false_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_EdgeT_infomap__InfoNode_t[] = {  {&_swigt__p_EdgeT_infomap__InfoNode_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_EdgeType[] = {  {&_swigt__p_EdgeType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FlowDataType[] = {  {&_swigt__p_FlowDataType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IterWrapperT_ChildIteratorT_infomap__InfoNode_const_p_t_t[] = {  {&_swigt__p_IterWrapperT_ChildIteratorT_infomap__InfoNode_const_p_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IterWrapperT_ChildIteratorT_infomap__InfoNode_p_t_t[] = {  {&_swigt__p_IterWrapperT_ChildIteratorT_infomap__InfoNode_p_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IterWrapperT_InfomapChildIteratorT_infomap__InfoNode_const_p_t_t[] = {  {&_swigt__p_IterWrapperT_InfomapChildIteratorT_infomap__InfoNode_const_p_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IterWrapperT_InfomapChildIteratorT_infomap__InfoNode_p_t_t[] = {  {&_swigt__p_IterWrapperT_InfomapChildIteratorT_infomap__InfoNode_p_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IterWrapperT_TreeIteratorT_infomap__InfoNode_const_p_t_t[] = {  {&_swigt__p_IterWrapperT_TreeIteratorT_infomap__InfoNode_const_p_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IterWrapperT_TreeIteratorT_infomap__InfoNode_p_t_t[] = {  {&_swigt__p_IterWrapperT_TreeIteratorT_infomap__InfoNode_p_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IterWrapperT_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator_t[] = {  {&_swigt__p_IterWrapperT_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_LeafModuleIteratorT_infomap__InfoNode_p_t[] = {  {&_swigt__p_LeafModuleIteratorT_infomap__InfoNode_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_LeafNodeIteratorT_infomap__InfoNode_p_t[] = {  {&_swigt__p_LeafNodeIteratorT_infomap__InfoNode_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MetaCollection[] = {  {&_swigt__p_MetaCollection, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_NodeLinkMap[] = {  {&_swigt__p_NodeLinkMap, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_NodeMap[] = {  {&_swigt__p_NodeMap, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_NodePaths[] = {  {&_swigt__p_NodePaths, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OutLinkMap[] = {  {&_swigt__p_OutLinkMap, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PartitionQueue[] = {  {&_swigt__p_PartitionQueue, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_TreeIteratorT_infomap__InfoNode_const_p_t[] = {  {&_swigt__p_TreeIteratorT_infomap__InfoNode_const_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_TreeIteratorT_infomap__InfoNode_p_t[] = {  {&_swigt__p_TreeIteratorT_infomap__InfoNode_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VectorMapT_infomap__DeltaFlow_t[] = {  {&_swigt__p_VectorMapT_infomap__DeltaFlow_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VectorMapT_infomap__MemDeltaFlow_t[] = {  {&_swigt__p_VectorMapT_infomap__MemDeltaFlow_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_allocator_type[] = {  {&_swigt__p_allocator_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_child_iterator[] = {  {&_swigt__p_child_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_child_iterator_wrapper[] = {  {&_swigt__p_child_iterator_wrapper, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_const_child_iterator[] = {  {&_swigt__p_const_child_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_const_child_iterator_wrapper[] = {  {&_swigt__p_const_child_iterator_wrapper, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_const_edge_iterator[] = {  {&_swigt__p_const_edge_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_const_edge_iterator_wrapper[] = {  {&_swigt__p_const_edge_iterator_wrapper, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_const_infomap_child_iterator[] = {  {&_swigt__p_const_infomap_child_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_const_infomap_child_iterator_wrapper[] = {  {&_swigt__p_const_infomap_child_iterator_wrapper, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_const_infomap_iterator_wrapper[] = {  {&_swigt__p_const_infomap_iterator_wrapper, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_const_leaf_module_iterator[] = {  {&_swigt__p_const_leaf_module_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_const_leaf_node_iterator[] = {  {&_swigt__p_const_leaf_node_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_const_post_depth_first_iterator[] = {  {&_swigt__p_const_post_depth_first_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_const_tree_iterator[] = {  {&_swigt__p_const_tree_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_difference_type[] = {  {&_swigt__p_difference_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_edge_iterator[] = {  {&_swigt__p_edge_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_edge_iterator_wrapper[] = {  {&_swigt__p_edge_iterator_wrapper, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap__Bigram[] = {  {&_swigt__p_infomap__Bigram, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap__BipartiteLink[] = {  {&_swigt__p_infomap__BipartiteLink, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap__Config[] = {  {&_swigt__p_infomap__Config, 0, 0, 0},  {&_swigt__p_infomap__InfomapCore, _p_infomap__InfomapCoreTo_p_infomap__Config, 0, 0},  {&_swigt__p_infomap__InfomapConfigT_infomap__InfomapBase_t, _p_infomap__InfomapConfigT_infomap__InfomapBase_tTo_p_infomap__Config, 0, 0},  {&_swigt__p_infomap__InfomapWrapper, _p_infomap__InfomapWrapperTo_p_infomap__Config, 0, 0},  {&_swigt__p_infomap__InfomapBase, _p_infomap__InfomapBaseTo_p_infomap__Config, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap__DeltaFlow[] = {  {&_swigt__p_infomap__DeltaFlow, 0, 0, 0},  {&_swigt__p_infomap__MemDeltaFlow, _p_infomap__MemDeltaFlowTo_p_infomap__DeltaFlow, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap__FlowData[] = {  {&_swigt__p_infomap__FlowData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap__FlowModel[] = {  {&_swigt__p_infomap__FlowModel, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap__InfoNode[] = {  {&_swigt__p_infomap__InfoNode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap__InfomapBase[] = {  {&_swigt__p_infomap__InfomapCore, _p_infomap__InfomapCoreTo_p_infomap__InfomapBase, 0, 0},  {&_swigt__p_infomap__InfomapBase, 0, 0, 0},  {&_swigt__p_infomap__InfomapWrapper, _p_infomap__InfomapWrapperTo_p_infomap__InfomapBase, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap__InfomapConfigT_infomap__InfomapBase_t[] = {  {&_swigt__p_infomap__InfomapConfigT_infomap__InfomapBase_t, 0, 0, 0},  {&_swigt__p_infomap__InfomapCore, _p_infomap__InfomapCoreTo_p_infomap__InfomapConfigT_infomap__InfomapBase_t, 0, 0},  {&_swigt__p_infomap__InfomapWrapper, _p_infomap__InfomapWrapperTo_p_infomap__InfomapConfigT_infomap__InfomapBase_t, 0, 0},  {&_swigt__p_infomap__InfomapBase, _p_infomap__InfomapBaseTo_p_infomap__InfomapConfigT_infomap__InfomapBase_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap__InfomapCore[] = {  {&_swigt__p_infomap__InfomapCore, 0, 0, 0},  {&_swigt__p_infomap__InfomapWrapper, _p_infomap__InfomapWrapperTo_p_infomap__InfomapCore, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap__InfomapIterator[] = {  {&_swigt__p_infomap__InfomapIteratorPhysical, _p_infomap__InfomapIteratorPhysicalTo_p_infomap__InfomapIterator, 0, 0},  {&_swigt__p_infomap__InfomapLeafIteratorPhysical, _p_infomap__InfomapLeafIteratorPhysicalTo_p_infomap__InfomapIterator, 0, 0},  {&_swigt__p_infomap__InfomapIterator, 0, 0, 0},  {&_swigt__p_infomap__InfomapModuleIterator, _p_infomap__InfomapModuleIteratorTo_p_infomap__InfomapIterator, 0, 0},  {&_swigt__p_infomap__InfomapLeafModuleIterator, _p_infomap__InfomapLeafModuleIteratorTo_p_infomap__InfomapIterator, 0, 0},  {&_swigt__p_infomap__InfomapLeafIterator, _p_infomap__InfomapLeafIteratorTo_p_infomap__InfomapIterator, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap__InfomapIteratorPhysical[] = {  {&_swigt__p_infomap__InfomapIteratorPhysical, 0, 0, 0},  {&_swigt__p_infomap__InfomapLeafIteratorPhysical, _p_infomap__InfomapLeafIteratorPhysicalTo_p_infomap__InfomapIteratorPhysical, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap__InfomapLeafIterator[] = {  {&_swigt__p_infomap__InfomapLeafIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap__InfomapLeafIteratorPhysical[] = {  {&_swigt__p_infomap__InfomapLeafIteratorPhysical, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap__InfomapLeafModuleIterator[] = {  {&_swigt__p_infomap__InfomapLeafModuleIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap__InfomapModuleIterator[] = {  {&_swigt__p_infomap__InfomapModuleIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap__InfomapParentIterator[] = {  {&_swigt__p_infomap__InfomapParentIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap__InfomapWrapper[] = {  {&_swigt__p_infomap__InfomapWrapper, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap__LayerNode[] = {  {&_swigt__p_infomap__LayerNode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap__MapEquation[] = {  {&_swigt__p_infomap__MapEquation, 0, 0, 0},  {&_swigt__p_infomap__MemMapEquation, _p_infomap__MemMapEquationTo_p_infomap__MapEquation, 0, 0},  {&_swigt__p_infomap__MetaMapEquation, _p_infomap__MetaMapEquationTo_p_infomap__MapEquation, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap__MapMapT_unsigned_int_unsigned_int_double_t[] = {  {&_swigt__p_infomap__MapMapT_unsigned_int_unsigned_int_double_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap__MemDeltaFlow[] = {  {&_swigt__p_infomap__MemDeltaFlow, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap__MemMapEquation[] = {  {&_swigt__p_infomap__MemMapEquation, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap__MemNodeSet[] = {  {&_swigt__p_infomap__MemNodeSet, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap__MetaMapEquation[] = {  {&_swigt__p_infomap__MetaMapEquation, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap__Network[] = {  {&_swigt__p_infomap__Network, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap__OptimizationLevel[] = {  {&_swigt__p_infomap__OptimizationLevel, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap__PerLevelStat[] = {  {&_swigt__p_infomap__PerLevelStat, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap__PhysData[] = {  {&_swigt__p_infomap__PhysData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap__StateNetwork[] = {  {&_swigt__p_infomap__StateNetwork, 0, 0, 0},  {&_swigt__p_infomap__Network, _p_infomap__NetworkTo_p_infomap__StateNetwork, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap__StateNetwork__PhysNode[] = {  {&_swigt__p_infomap__StateNetwork__PhysNode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap__StateNetwork__StateNode[] = {  {&_swigt__p_infomap__StateNetwork__StateNode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap__Triple[] = {  {&_swigt__p_infomap__Triple, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap__Weight[] = {  {&_swigt__p_infomap__Weight, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap__detail__PartitionQueue[] = {  {&_swigt__p_infomap__detail__PartitionQueue, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap_child_iterator[] = {  {&_swigt__p_infomap_child_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap_child_iterator_wrapper[] = {  {&_swigt__p_infomap_child_iterator_wrapper, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_infomap_iterator_wrapper[] = {  {&_swigt__p_infomap_iterator_wrapper, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_key_type[] = {  {&_swigt__p_key_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_leaf_module_iterator[] = {  {&_swigt__p_leaf_module_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_leaf_node_iterator[] = {  {&_swigt__p_leaf_node_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_mapped_type[] = {  {&_swigt__p_mapped_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_post_depth_first_iterator[] = {  {&_swigt__p_post_depth_first_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_size_t[] = {  {&_swigt__p_size_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_size_type[] = {  {&_swigt__p_size_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__allocatorT_double_t[] = {  {&_swigt__p_std__allocatorT_double_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t[] = {  {&_swigt__p_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t[] = {  {&_swigt__p_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t[] = {  {&_swigt__p_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__allocatorT_unsigned_int_t[] = {  {&_swigt__p_std__allocatorT_unsigned_int_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__dequeT_infomap__InfoNode_p_std__allocatorT_infomap__InfoNode_p_t_t__size_type[] = {  {&_swigt__p_std__dequeT_infomap__InfoNode_p_std__allocatorT_infomap__InfoNode_p_t_t__size_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t[] = {  {&_swigt__p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__lessT_unsigned_int_t[] = {  {&_swigt__p_std__lessT_unsigned_int_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_infomap__StateNetwork__StateNode_std__mapT_infomap__StateNetwork__StateNode_infomap__StateNetwork__LinkData_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_infomap__StateNetwork__LinkData_t_t_t_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_std__mapT_infomap__StateNetwork__StateNode_infomap__StateNetwork__LinkData_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_infomap__StateNetwork__LinkData_t_t_t_t_t_t[] = {  {&_swigt__p_std__mapT_infomap__StateNetwork__StateNode_std__mapT_infomap__StateNetwork__StateNode_infomap__StateNetwork__LinkData_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_infomap__StateNetwork__LinkData_t_t_t_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_std__mapT_infomap__StateNetwork__StateNode_infomap__StateNetwork__LinkData_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_infomap__StateNetwork__LinkData_t_t_t_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_unsigned_int_double_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_double_t_t_t[] = {  {&_swigt__p_std__mapT_unsigned_int_double_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_double_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_unsigned_int_infomap__StateNetwork__StateNode_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_infomap__StateNetwork__StateNode_t_t_t[] = {  {&_swigt__p_std__mapT_unsigned_int_infomap__StateNetwork__StateNode_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_infomap__StateNetwork__StateNode_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t[] = {  {&_swigt__p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_unsigned_int_std__vectorT_int_std__allocatorT_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_int_std__allocatorT_int_t_t_t_t_t[] = {  {&_swigt__p_std__mapT_unsigned_int_std__vectorT_int_std__allocatorT_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_int_std__allocatorT_int_t_t_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t[] = {  {&_swigt__p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t[] = {  {&_swigt__p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__ostream[] = {  {&_swigt__p_std__ostream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__pairT_std__mapT_unsigned_int_infomap__StateNetwork__StateNode_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_infomap__StateNetwork__StateNode_t_t_t__iterator_bool_t[] = {  {&_swigt__p_std__pairT_std__mapT_unsigned_int_infomap__StateNetwork__StateNode_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_infomap__StateNetwork__StateNode_t_t_t__iterator_bool_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__pairT_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t__iterator_bool_t[] = {  {&_swigt__p_std__pairT_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t__iterator_bool_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator[] = {  {&_swigt__p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_ParsedOption_std__allocatorT_ParsedOption_t_t[] = {  {&_swigt__p_std__vectorT_ParsedOption_std__allocatorT_ParsedOption_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_double_std__allocatorT_double_t_t[] = {  {&_swigt__p_std__vectorT_double_std__allocatorT_double_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_infomap__FlowData_std__allocatorT_infomap__FlowData_t_t[] = {  {&_swigt__p_std__vectorT_infomap__FlowData_std__allocatorT_infomap__FlowData_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_infomap__InfoNode_p_std__allocatorT_infomap__InfoNode_p_t_t[] = {  {&_swigt__p_std__vectorT_infomap__InfoNode_p_std__allocatorT_infomap__InfoNode_p_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_infomap__PerLevelStat_std__allocatorT_infomap__PerLevelStat_t_t[] = {  {&_swigt__p_std__vectorT_infomap__PerLevelStat_std__allocatorT_infomap__PerLevelStat_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_infomap__PhysData_std__allocatorT_infomap__PhysData_t_t[] = {  {&_swigt__p_std__vectorT_infomap__PhysData_std__allocatorT_infomap__PhysData_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_int_std__allocatorT_int_t_t[] = {  {&_swigt__p_std__vectorT_int_std__allocatorT_int_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_std__string_std__allocatorT_std__string_t_t[] = {  {&_swigt__p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__allocatorT_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t[] = {  {&_swigt__p_std__vectorT_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__allocatorT_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t[] = {  {&_swigt__p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_tree_iterator[] = {  {&_swigt__p_tree_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_value_type[] = {  {&_swigt__p_value_type, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_ChildIteratorT_infomap__InfoNode_const_p_t,
  _swigc__p_ChildIteratorT_infomap__InfoNode_p_t,
  _swigc__p_Date,
  _swigc__p_DeltaFlowDataType,
  _swigc__p_DepthFirstIteratorT_infomap__InfoNode_p_false_t,
  _swigc__p_EdgeT_infomap__InfoNode_t,
  _swigc__p_EdgeType,
  _swigc__p_FlowDataType,
  _swigc__p_IterWrapperT_ChildIteratorT_infomap__InfoNode_const_p_t_t,
  _swigc__p_IterWrapperT_ChildIteratorT_infomap__InfoNode_p_t_t,
  _swigc__p_IterWrapperT_InfomapChildIteratorT_infomap__InfoNode_const_p_t_t,
  _swigc__p_IterWrapperT_InfomapChildIteratorT_infomap__InfoNode_p_t_t,
  _swigc__p_IterWrapperT_TreeIteratorT_infomap__InfoNode_const_p_t_t,
  _swigc__p_IterWrapperT_TreeIteratorT_infomap__InfoNode_p_t_t,
  _swigc__p_IterWrapperT_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator_t,
  _swigc__p_LeafModuleIteratorT_infomap__InfoNode_p_t,
  _swigc__p_LeafNodeIteratorT_infomap__InfoNode_p_t,
  _swigc__p_MetaCollection,
  _swigc__p_NodeLinkMap,
  _swigc__p_NodeMap,
  _swigc__p_NodePaths,
  _swigc__p_OutLinkMap,
  _swigc__p_PartitionQueue,
  _swigc__p_TreeIteratorT_infomap__InfoNode_const_p_t,
  _swigc__p_TreeIteratorT_infomap__InfoNode_p_t,
  _swigc__p_VectorMapT_infomap__DeltaFlow_t,
  _swigc__p_VectorMapT_infomap__MemDeltaFlow_t,
  _swigc__p_allocator_type,
  _swigc__p_char,
  _swigc__p_child_iterator,
  _swigc__p_child_iterator_wrapper,
  _swigc__p_const_child_iterator,
  _swigc__p_const_child_iterator_wrapper,
  _swigc__p_const_edge_iterator,
  _swigc__p_const_edge_iterator_wrapper,
  _swigc__p_const_infomap_child_iterator,
  _swigc__p_const_infomap_child_iterator_wrapper,
  _swigc__p_const_infomap_iterator_wrapper,
  _swigc__p_const_leaf_module_iterator,
  _swigc__p_const_leaf_node_iterator,
  _swigc__p_const_post_depth_first_iterator,
  _swigc__p_const_tree_iterator,
  _swigc__p_difference_type,
  _swigc__p_edge_iterator,
  _swigc__p_edge_iterator_wrapper,
  _swigc__p_infomap__Bigram,
  _swigc__p_infomap__BipartiteLink,
  _swigc__p_infomap__Config,
  _swigc__p_infomap__DeltaFlow,
  _swigc__p_infomap__FlowData,
  _swigc__p_infomap__FlowModel,
  _swigc__p_infomap__InfoNode,
  _swigc__p_infomap__InfomapBase,
  _swigc__p_infomap__InfomapConfigT_infomap__InfomapBase_t,
  _swigc__p_infomap__InfomapCore,
  _swigc__p_infomap__InfomapIterator,
  _swigc__p_infomap__InfomapIteratorPhysical,
  _swigc__p_infomap__InfomapLeafIterator,
  _swigc__p_infomap__InfomapLeafIteratorPhysical,
  _swigc__p_infomap__InfomapLeafModuleIterator,
  _swigc__p_infomap__InfomapModuleIterator,
  _swigc__p_infomap__InfomapParentIterator,
  _swigc__p_infomap__InfomapWrapper,
  _swigc__p_infomap__LayerNode,
  _swigc__p_infomap__MapEquation,
  _swigc__p_infomap__MapMapT_unsigned_int_unsigned_int_double_t,
  _swigc__p_infomap__MemDeltaFlow,
  _swigc__p_infomap__MemMapEquation,
  _swigc__p_infomap__MemNodeSet,
  _swigc__p_infomap__MetaMapEquation,
  _swigc__p_infomap__Network,
  _swigc__p_infomap__OptimizationLevel,
  _swigc__p_infomap__PerLevelStat,
  _swigc__p_infomap__PhysData,
  _swigc__p_infomap__StateNetwork,
  _swigc__p_infomap__StateNetwork__PhysNode,
  _swigc__p_infomap__StateNetwork__StateNode,
  _swigc__p_infomap__Triple,
  _swigc__p_infomap__Weight,
  _swigc__p_infomap__detail__PartitionQueue,
  _swigc__p_infomap_child_iterator,
  _swigc__p_infomap_child_iterator_wrapper,
  _swigc__p_infomap_iterator_wrapper,
  _swigc__p_key_type,
  _swigc__p_leaf_module_iterator,
  _swigc__p_leaf_node_iterator,
  _swigc__p_mapped_type,
  _swigc__p_post_depth_first_iterator,
  _swigc__p_size_t,
  _swigc__p_size_type,
  _swigc__p_std__allocatorT_double_t,
  _swigc__p_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t,
  _swigc__p_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t,
  _swigc__p_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t,
  _swigc__p_std__allocatorT_unsigned_int_t,
  _swigc__p_std__dequeT_infomap__InfoNode_p_std__allocatorT_infomap__InfoNode_p_t_t__size_type,
  _swigc__p_std__dequeT_unsigned_int_std__allocatorT_unsigned_int_t_t,
  _swigc__p_std__lessT_unsigned_int_t,
  _swigc__p_std__mapT_infomap__StateNetwork__StateNode_std__mapT_infomap__StateNetwork__StateNode_infomap__StateNetwork__LinkData_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_infomap__StateNetwork__LinkData_t_t_t_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_std__mapT_infomap__StateNetwork__StateNode_infomap__StateNetwork__LinkData_std__lessT_infomap__StateNetwork__StateNode_t_std__allocatorT_std__pairT_infomap__StateNetwork__StateNode_const_infomap__StateNetwork__LinkData_t_t_t_t_t_t,
  _swigc__p_std__mapT_unsigned_int_double_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_double_t_t_t,
  _swigc__p_std__mapT_unsigned_int_infomap__StateNetwork__StateNode_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_infomap__StateNetwork__StateNode_t_t_t,
  _swigc__p_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t,
  _swigc__p_std__mapT_unsigned_int_std__vectorT_int_std__allocatorT_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_int_std__allocatorT_int_t_t_t_t_t,
  _swigc__p_std__mapT_unsigned_int_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t_t,
  _swigc__p_std__mapT_unsigned_int_unsigned_int_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_unsigned_int_t_t_t,
  _swigc__p_std__ostream,
  _swigc__p_std__pairT_std__mapT_unsigned_int_infomap__StateNetwork__StateNode_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_infomap__StateNetwork__StateNode_t_t_t__iterator_bool_t,
  _swigc__p_std__pairT_std__mapT_unsigned_int_std__string_std__lessT_unsigned_int_t_std__allocatorT_std__pairT_unsigned_int_const_std__string_t_t_t__iterator_bool_t,
  _swigc__p_std__vectorT_EdgeT_infomap__InfoNode_t_p_std__allocatorT_EdgeT_infomap__InfoNode_t_p_t_t__iterator,
  _swigc__p_std__vectorT_ParsedOption_std__allocatorT_ParsedOption_t_t,
  _swigc__p_std__vectorT_double_std__allocatorT_double_t_t,
  _swigc__p_std__vectorT_infomap__FlowData_std__allocatorT_infomap__FlowData_t_t,
  _swigc__p_std__vectorT_infomap__InfoNode_p_std__allocatorT_infomap__InfoNode_p_t_t,
  _swigc__p_std__vectorT_infomap__PerLevelStat_std__allocatorT_infomap__PerLevelStat_t_t,
  _swigc__p_std__vectorT_infomap__PhysData_std__allocatorT_infomap__PhysData_t_t,
  _swigc__p_std__vectorT_int_std__allocatorT_int_t_t,
  _swigc__p_std__vectorT_std__string_std__allocatorT_std__string_t_t,
  _swigc__p_std__vectorT_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__allocatorT_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t,
  _swigc__p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t,
  _swigc__p_tree_iterator,
  _swigc__p_value_type,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */


/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic
 * memory is used. Also, since swig_type_info structures store pointers to
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization.
 * The idea is that swig generates all the structures that are needed.
 * The runtime then collects these partially filled structures.
 * The SWIG_InitializeModule function takes these initial arrays out of
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned statically to an initial
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded.
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif


SWIGRUNTIME void
SWIG_InitializeModule(void *clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int init;

  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
    init = 1;
  } else {
    init = 0;
  }

  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    iter=module_head;
    do {
      if (iter==&swig_module) {
        /* Our module is already in the list, so there's nothing more to do. */
        return;
      }
      iter=iter->next;
    } while (iter!= module_head);

    /* otherwise we must add our module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }

  /* When multiple interpreters are used, a module could have already been initialized in
     a different interpreter, but not yet have a pointer in this interpreter.
     In this case, we do not want to continue adding types... everything should be
     set up already */
  if (init == 0) return;

  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %lu\n", (unsigned long)swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;

#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %lu %s\n", (unsigned long)i, swig_module.type_initial[i]->name);
#endif

    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
	type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }

    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {

      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
	if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
	if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
	  printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
	  cast->type = ret;
	  ret = 0;
	} else {
	  /* Check for casting already in the list */
	  swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
	  if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
	  if (!ocast) ret = 0;
	}
      }

      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
	printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;

#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %lu %s\n", (unsigned long)i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
  printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;

  if (init_run) return;
  init_run = 1;

  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
            SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{ /* c-mode */
#endif
}
#endif


SWIGEXPORT void SWIG_init(void) {

}
#ifdef __cplusplus
extern "C" {
#endif

#include <R_ext/Rdynload.h>

#ifdef __cplusplus
}
#endif

SWIGINTERN R_CallMethodDef CallEntries[] = {
   {"R_swig_deque_uint_clear", (DL_FUNC) &R_swig_deque_uint_clear, 1},
   {"R_swig_vector_uint_clear", (DL_FUNC) &R_swig_vector_uint_clear, 1},
   {"R_swig_map_uint_uint_clear", (DL_FUNC) &R_swig_map_uint_uint_clear, 1},
   {"R_swig_map_uint_vector_uint_clear", (DL_FUNC) &R_swig_map_uint_vector_uint_clear, 1},
   {"R_swig_delete_Config", (DL_FUNC) &R_swig_delete_Config, 1},
   {"R_swig_InfoNode_Equal", (DL_FUNC) &R_swig_InfoNode_Equal, 3},
   {"R_swig_FlowData_Equal", (DL_FUNC) &R_swig_FlowData_Equal, 3},
   {"R_swig_InfomapIterator_metaCollection_get", (DL_FUNC) &R_swig_InfomapIterator_metaCollection_get, 2},
   {"R_swig_InfoNode_metaCollection_get", (DL_FUNC) &R_swig_InfoNode_metaCollection_get, 2},
   {"R_swig_Config_innerParallelization_get", (DL_FUNC) &R_swig_Config_innerParallelization_get, 2},
   {"R_swig_Config_preferModularSolution_get", (DL_FUNC) &R_swig_Config_preferModularSolution_get, 2},
   {"R_swig_Config_fastFirstIteration_get", (DL_FUNC) &R_swig_Config_fastFirstIteration_get, 2},
   {"R_swig_Config_fastHierarchicalSolution_get", (DL_FUNC) &R_swig_Config_fastHierarchicalSolution_get, 2},
   {"R_swig_Config_fastCoarseTunePartition_get", (DL_FUNC) &R_swig_Config_fastCoarseTunePartition_get, 2},
   {"R_swig_Config_recordedTeleportation_get", (DL_FUNC) &R_swig_Config_recordedTeleportation_get, 2},
   {"R_swig_Config_bipartiteTeleportation_get", (DL_FUNC) &R_swig_Config_bipartiteTeleportation_get, 2},
   {"R_swig_Config_printJson_get", (DL_FUNC) &R_swig_Config_printJson_get, 2},
   {"R_swig_Config_verboseNumberPrecision_get", (DL_FUNC) &R_swig_Config_verboseNumberPrecision_get, 2},
   {"R_swig_Config_version_get", (DL_FUNC) &R_swig_Config_version_get, 2},
   {"R_swig_InfomapParentIterator_metaCollection_get", (DL_FUNC) &R_swig_InfomapParentIterator_metaCollection_get, 2},
   {"R_swig_InfomapConfigInfomapBase_setNoInfomap__SWIG_0", (DL_FUNC) &R_swig_InfomapConfigInfomapBase_setNoInfomap__SWIG_0, 3},
   {"R_swig_InfomapConfigInfomapBase_setNoInfomap__SWIG_1", (DL_FUNC) &R_swig_InfomapConfigInfomapBase_setNoInfomap__SWIG_1, 2},
   {"R_swig_map_uint_uint_erase", (DL_FUNC) &R_swig_map_uint_uint_erase, 3},
   {"R_swig_map_uint_vector_uint_erase", (DL_FUNC) &R_swig_map_uint_vector_uint_erase, 3},
   {"R_swig_InfomapIterator_isRoot", (DL_FUNC) &R_swig_InfomapIterator_isRoot, 2},
   {"R_swig_InfoNode_isRoot", (DL_FUNC) &R_swig_InfoNode_isRoot, 2},
   {"R_swig_InfomapParentIterator_isRoot", (DL_FUNC) &R_swig_InfomapParentIterator_isRoot, 2},
   {"R_swig_InfomapParentIterator_sortChildrenOnFlow__SWIG_0", (DL_FUNC) &R_swig_InfomapParentIterator_sortChildrenOnFlow__SWIG_0, 2},
   {"R_swig_InfomapParentIterator_sortChildrenOnFlow__SWIG_1", (DL_FUNC) &R_swig_InfomapParentIterator_sortChildrenOnFlow__SWIG_1, 1},
   {"R_swig_InfomapIterator_initClean", (DL_FUNC) &R_swig_InfomapIterator_initClean, 1},
   {"R_swig_InfoNode_initClean", (DL_FUNC) &R_swig_InfoNode_initClean, 1},
   {"R_swig_InfomapParentIterator_initClean", (DL_FUNC) &R_swig_InfomapParentIterator_initClean, 1},
   {"R_swig_map_uint_uint_count", (DL_FUNC) &R_swig_map_uint_uint_count, 3},
   {"R_swig_InfomapBase_moveActiveNodesToPredefinedModules", (DL_FUNC) &R_swig_InfomapBase_moveActiveNodesToPredefinedModules, 2},
   {"R_swig_map_uint_vector_uint_count", (DL_FUNC) &R_swig_map_uint_vector_uint_count, 3},
   {"R_swig_PartitionQueue_swap", (DL_FUNC) &R_swig_PartitionQueue_swap, 2},
   {"R_swig_InfomapIterator_moduleId", (DL_FUNC) &R_swig_InfomapIterator_moduleId, 2},
   {"R_swig_InfomapBase_transformNodeFlowToEnterFlow", (DL_FUNC) &R_swig_InfomapBase_transformNodeFlowToEnterFlow, 2},
   {"R_swig_LayerNode_LessThan", (DL_FUNC) &R_swig_LayerNode_LessThan, 3},
   {"R_swig_Bigram_LessThan", (DL_FUNC) &R_swig_Bigram_LessThan, 3},
   {"R_swig_BipartiteLink_LessThan", (DL_FUNC) &R_swig_BipartiteLink_LessThan, 3},
   {"R_swig_Triple_LessThan", (DL_FUNC) &R_swig_Triple_LessThan, 3},
   {"R_swig_delete_Triple", (DL_FUNC) &R_swig_delete_Triple, 1},
   {"R_swig_InfomapIterator_remove", (DL_FUNC) &R_swig_InfomapIterator_remove, 2},
   {"R_swig_InfoNode_remove", (DL_FUNC) &R_swig_InfoNode_remove, 2},
   {"R_swig_InfomapParentIterator_remove", (DL_FUNC) &R_swig_InfomapParentIterator_remove, 2},
   {"R_swig_InfomapBase_processPartitionQueue", (DL_FUNC) &R_swig_InfomapBase_processPartitionQueue, 4},
   {"R_swig_new_PartitionQueue", (DL_FUNC) &R_swig_new_PartitionQueue, 0},
   {"R_swig_delete_PartitionQueue", (DL_FUNC) &R_swig_delete_PartitionQueue, 1},
   {"R_swig_Config_printFlowNetwork_set", (DL_FUNC) &R_swig_Config_printFlowNetwork_set, 2},
   {"R_swig_Config_printPajekNetwork_set", (DL_FUNC) &R_swig_Config_printPajekNetwork_set, 2},
   {"R_swig_Config_printStateNetwork_set", (DL_FUNC) &R_swig_Config_printStateNetwork_set, 2},
   {"R_swig_Config_benchmark_set", (DL_FUNC) &R_swig_Config_benchmark_set, 2},
   {"R_swig_Config_coarseTuneLevel_set", (DL_FUNC) &R_swig_Config_coarseTuneLevel_set, 2},
   {"R_swig_Config_alternateCoarseTuneLevel_set", (DL_FUNC) &R_swig_Config_alternateCoarseTuneLevel_set, 2},
   {"R_swig_Config_twoLevel_set", (DL_FUNC) &R_swig_Config_twoLevel_set, 2},
   {"R_swig_Config_flowModel_set", (DL_FUNC) &R_swig_Config_flowModel_set, 2},
   {"R_swig_Config_cluLevel_set", (DL_FUNC) &R_swig_Config_cluLevel_set, 2},
   {"R_swig_PartitionQueue_level_set", (DL_FUNC) &R_swig_PartitionQueue_level_set, 2},
   {"R_swig_MetaMapEquation_getDeltaCodelengthOnMovingNode", (DL_FUNC) &R_swig_MetaMapEquation_getDeltaCodelengthOnMovingNode, 7},
   {"R_swig_StateNetwork_clear", (DL_FUNC) &R_swig_StateNetwork_clear, 1},
   {"R_swig_Network_clear", (DL_FUNC) &R_swig_Network_clear, 1},
   {"R_swig_vector_double_clear", (DL_FUNC) &R_swig_vector_double_clear, 1},
   {"R_swig_map_uint_string_clear", (DL_FUNC) &R_swig_map_uint_string_clear, 1},
   {"R_swig_StateNetwork_setConfig", (DL_FUNC) &R_swig_StateNetwork_setConfig, 2},
   {"R_swig_StateNetwork_getConfig", (DL_FUNC) &R_swig_StateNetwork_getConfig, 2},
   {"R_swig_InfomapConfigInfomapBase_setConfig", (DL_FUNC) &R_swig_InfomapConfigInfomapBase_setConfig, 3},
   {"R_swig_InfomapConfigInfomapBase_setNonMainConfig", (DL_FUNC) &R_swig_InfomapConfigInfomapBase_setNonMainConfig, 3},
   {"R_swig_Config_minimumRelativeTuneIterationImprovement_get", (DL_FUNC) &R_swig_Config_minimumRelativeTuneIterationImprovement_get, 2},
   {"R_swig_Config_minimumRelativeTuneIterationImprovement_set", (DL_FUNC) &R_swig_Config_minimumRelativeTuneIterationImprovement_set, 2},
   {"R_swig_vector_uint___getslice__", (DL_FUNC) &R_swig_vector_uint___getslice__, 3},
   {"R_swig_vector_uint___setslice__", (DL_FUNC) &R_swig_vector_uint___setslice__, 4},
   {"R_swig_vector_uint___delslice__", (DL_FUNC) &R_swig_vector_uint___delslice__, 3},
   {"R_swig_vector_double___getslice__", (DL_FUNC) &R_swig_vector_double___getslice__, 3},
   {"R_swig_vector_double___setslice__", (DL_FUNC) &R_swig_vector_double___setslice__, 4},
   {"R_swig_vector_double___delslice__", (DL_FUNC) &R_swig_vector_double___delslice__, 3},
   {"R_swig_map_uint_string_erase", (DL_FUNC) &R_swig_map_uint_string_erase, 3},
   {"R_swig_InfomapIterator_isEnd", (DL_FUNC) &R_swig_InfomapIterator_isEnd, 2},
   {"R_swig_InfomapParentIterator_isEnd", (DL_FUNC) &R_swig_InfomapParentIterator_isEnd, 2},
   {"R_swig_Config_printNewick_set", (DL_FUNC) &R_swig_Config_printNewick_set, 2},
   {"R_swig_Config_multilayerRelaxLimitUp_get", (DL_FUNC) &R_swig_Config_multilayerRelaxLimitUp_get, 2},
   {"R_swig_Config_haveMetaData", (DL_FUNC) &R_swig_Config_haveMetaData, 2},
   {"R_swig_Network_readMetaData", (DL_FUNC) &R_swig_Network_readMetaData, 2},
   {"R_swig_Network_metaData", (DL_FUNC) &R_swig_Network_metaData, 2},
   {"R_swig_InfomapBase_initMetaData", (DL_FUNC) &R_swig_InfomapBase_initMetaData, 3},
   {"R_swig_map_uint_string_count", (DL_FUNC) &R_swig_map_uint_string_count, 3},
   {"R_swig_new_PerLevelStat", (DL_FUNC) &R_swig_new_PerLevelStat, 0},
   {"R_swig_delete_PerLevelStat", (DL_FUNC) &R_swig_delete_PerLevelStat, 1},
   {"R_swig_delete_PhysData", (DL_FUNC) &R_swig_delete_PhysData, 1},
   {"R_swig_InfomapIterator_isLeafModule", (DL_FUNC) &R_swig_InfomapIterator_isLeafModule, 2},
   {"R_swig_InfoNode_isLeafModule", (DL_FUNC) &R_swig_InfoNode_isLeafModule, 2},
   {"R_swig_InfomapParentIterator_isLeafModule", (DL_FUNC) &R_swig_InfomapParentIterator_isLeafModule, 2},
   {"R_swig_InfomapConfigInfomapBase_setOnlySuperModules", (DL_FUNC) &R_swig_InfomapConfigInfomapBase_setOnlySuperModules, 3},
   {"R_swig_InfomapBase_calculateNumNonTrivialTopModules", (DL_FUNC) &R_swig_InfomapBase_calculateNumNonTrivialTopModules, 1},
   {"R_swig_Config_minimumSingleNodeCodelengthImprovement_get", (DL_FUNC) &R_swig_Config_minimumSingleNodeCodelengthImprovement_get, 2},
   {"R_swig_Config_minimumSingleNodeCodelengthImprovement_set", (DL_FUNC) &R_swig_Config_minimumSingleNodeCodelengthImprovement_set, 2},
   {"R_swig_Config_multilayerRelaxByJensenShannonDivergence_get", (DL_FUNC) &R_swig_Config_multilayerRelaxByJensenShannonDivergence_get, 2},
   {"R_swig_Config_multilayerRelaxByJensenShannonDivergence_set", (DL_FUNC) &R_swig_Config_multilayerRelaxByJensenShannonDivergence_set, 2},
   {"R_swig_InfomapIterator_id", (DL_FUNC) &R_swig_InfomapIterator_id, 2},
   {"R_swig_InfomapParentIterator_id", (DL_FUNC) &R_swig_InfomapParentIterator_id, 2},
   {"R_swig_PartitionQueue_skip_get", (DL_FUNC) &R_swig_PartitionQueue_skip_get, 2},
   {"R_swig_InfomapBase_restoreConsolidatedOptimizationPointIfNoImprovement__SWIG_0", (DL_FUNC) &R_swig_InfomapBase_restoreConsolidatedOptimizationPointIfNoImprovement__SWIG_0, 3},
   {"R_swig_InfomapBase_restoreConsolidatedOptimizationPointIfNoImprovement__SWIG_1", (DL_FUNC) &R_swig_InfomapBase_restoreConsolidatedOptimizationPointIfNoImprovement__SWIG_1, 2},
   {"R_swig_InfomapParentIterator_collapsedLastChild_get", (DL_FUNC) &R_swig_InfomapParentIterator_collapsedLastChild_get, 1},
   {"R_swig_InfomapBase_initEnterExitFlow", (DL_FUNC) &R_swig_InfomapBase_initEnterExitFlow, 1},
   {"R_swig_InfomapIterator_begin_leaf_modules", (DL_FUNC) &R_swig_InfomapIterator_begin_leaf_modules, 2},
   {"R_swig_InfoNode_begin_leaf_modules", (DL_FUNC) &R_swig_InfoNode_begin_leaf_modules, 2},
   {"R_swig_InfomapParentIterator_begin_leaf_modules", (DL_FUNC) &R_swig_InfomapParentIterator_begin_leaf_modules, 2},
   {"R_swig_InfomapConfigInfomapBase_setTuneIterationLimit", (DL_FUNC) &R_swig_InfomapConfigInfomapBase_setTuneIterationLimit, 3},
   {"R_swig_InfomapBase_numTopModules", (DL_FUNC) &R_swig_InfomapBase_numTopModules, 2},
   {"R_swig_InfomapBase_numActiveModules", (DL_FUNC) &R_swig_InfomapBase_numActiveModules, 2},
   {"R_swig_InfomapBase_numNonTrivialTopModules", (DL_FUNC) &R_swig_InfomapBase_numNonTrivialTopModules, 2},
   {"R_swig_InfomapBase_haveModules", (DL_FUNC) &R_swig_InfomapBase_haveModules, 2},
   {"R_swig_InfomapBase_haveNonTrivialModules", (DL_FUNC) &R_swig_InfomapBase_haveNonTrivialModules, 2},
   {"R_swig_InfomapBase_resetFlowOnModules", (DL_FUNC) &R_swig_InfomapBase_resetFlowOnModules, 1},
   {"R_swig_InfomapBase_removeModules", (DL_FUNC) &R_swig_InfomapBase_removeModules, 2},
   {"R_swig_InfomapBase_removeSubModules", (DL_FUNC) &R_swig_InfomapBase_removeSubModules, 3},
   {"R_swig_InfomapBase_queueTopModules", (DL_FUNC) &R_swig_InfomapBase_queueTopModules, 2},
   {"R_swig_InfomapBase_queueLeafModules", (DL_FUNC) &R_swig_InfomapBase_queueLeafModules, 2},
   {"R_swig_MapEquation_consolidateModules", (DL_FUNC) &R_swig_MapEquation_consolidateModules, 2},
   {"R_swig_MemMapEquation_consolidateModules", (DL_FUNC) &R_swig_MemMapEquation_consolidateModules, 2},
   {"R_swig_MetaMapEquation_consolidateModules", (DL_FUNC) &R_swig_MetaMapEquation_consolidateModules, 2},
   {"R_swig_InfomapConfigInfomapBase_reseed", (DL_FUNC) &R_swig_InfomapConfigInfomapBase_reseed, 3},
   {"R_swig_deque_uint_push_front", (DL_FUNC) &R_swig_deque_uint_push_front, 2},
   {"R_swig_deque_uint_pop_front", (DL_FUNC) &R_swig_deque_uint_pop_front, 1},
   {"R_swig_deque_uint_front", (DL_FUNC) &R_swig_deque_uint_front, 2},
   {"R_swig_vector_uint_front", (DL_FUNC) &R_swig_vector_uint_front, 2},
   {"R_swig_Config_seedToRandomNumberGenerator_get", (DL_FUNC) &R_swig_Config_seedToRandomNumberGenerator_get, 2},
   {"R_swig_Config_error_get", (DL_FUNC) &R_swig_Config_error_get, 2},
   {"R_swig_InfomapBase_setActiveNetworkFromChildrenOfRoot", (DL_FUNC) &R_swig_InfomapBase_setActiveNetworkFromChildrenOfRoot, 1},
   {"R_swig_delete_MapEquation", (DL_FUNC) &R_swig_delete_MapEquation, 1},
   {"R_swig_delete_MemMapEquation", (DL_FUNC) &R_swig_delete_MemMapEquation, 1},
   {"R_swig_delete_MetaMapEquation", (DL_FUNC) &R_swig_delete_MetaMapEquation, 1},
   {"R_swig_Config_isUndirectedFlow", (DL_FUNC) &R_swig_Config_isUndirectedFlow, 2},
   {"R_swig_InfomapParentIterator_stepForward", (DL_FUNC) &R_swig_InfomapParentIterator_stepForward, 2},
   {"R_swig_InfomapIterator_stepForward", (DL_FUNC) &R_swig_InfomapIterator_stepForward, 2},
   {"R_swig_Config_noInfomap_get", (DL_FUNC) &R_swig_Config_noInfomap_get, 2},
   {"R_swig_Config_printMap_get", (DL_FUNC) &R_swig_Config_printMap_get, 2},
   {"R_swig_Config_undirdir_get", (DL_FUNC) &R_swig_Config_undirdir_get, 2},
   {"R_swig_Config_outdirdir_get", (DL_FUNC) &R_swig_Config_outdirdir_get, 2},
   {"R_swig_Config_rawdir_get", (DL_FUNC) &R_swig_Config_rawdir_get, 2},
   {"R_swig_InfomapIterator_metaData_get", (DL_FUNC) &R_swig_InfomapIterator_metaData_get, 1},
   {"R_swig_InfomapIterator_data_get", (DL_FUNC) &R_swig_InfomapIterator_data_get, 1},
   {"R_swig_Config_unweightedMetaData_get", (DL_FUNC) &R_swig_Config_unweightedMetaData_get, 2},
   {"R_swig_InfoNode_data_get", (DL_FUNC) &R_swig_InfoNode_data_get, 1},
   {"R_swig_InfoNode_metaData_get", (DL_FUNC) &R_swig_InfoNode_metaData_get, 1},
   {"R_swig_InfomapParentIterator_data_get", (DL_FUNC) &R_swig_InfomapParentIterator_data_get, 1},
   {"R_swig_InfomapParentIterator_metaData_get", (DL_FUNC) &R_swig_InfomapParentIterator_metaData_get, 1},
   {"R_swig_InfomapBase_getOutputFileHeader", (DL_FUNC) &R_swig_InfomapBase_getOutputFileHeader, 2},
   {"R_swig_InfomapBase_getRelativeCodelengthSavings", (DL_FUNC) &R_swig_InfomapBase_getRelativeCodelengthSavings, 2},
   {"R_swig_InfomapBase_getNewInfomapInstance", (DL_FUNC) &R_swig_InfomapBase_getNewInfomapInstance, 1},
   {"R_swig_InfomapIterator_owner_get", (DL_FUNC) &R_swig_InfomapIterator_owner_get, 1},
   {"R_swig_Config_pathMarkovOrder_get", (DL_FUNC) &R_swig_Config_pathMarkovOrder_get, 2},
   {"R_swig_DeltaFlow_deltaEnter_get", (DL_FUNC) &R_swig_DeltaFlow_deltaEnter_get, 2},
   {"R_swig_InfoNode_owner_get", (DL_FUNC) &R_swig_InfoNode_owner_get, 1},
   {"R_swig_InfomapParentIterator_owner_get", (DL_FUNC) &R_swig_InfomapParentIterator_owner_get, 1},
   {"R_swig_BipartiteLink_swapOrder_get", (DL_FUNC) &R_swig_BipartiteLink_swapOrder_get, 2},
   {"R_swig_Triple_n1_get", (DL_FUNC) &R_swig_Triple_n1_get, 2},
   {"R_swig_Config_ignoreEdgeWeights_get", (DL_FUNC) &R_swig_Config_ignoreEdgeWeights_get, 2},
   {"R_swig_InfomapParentIterator___deref____SWIG_0", (DL_FUNC) &R_swig_InfomapParentIterator___deref____SWIG_0, 1},
   {"R_swig_InfomapParentIterator___ref____SWIG_0", (DL_FUNC) &R_swig_InfomapParentIterator___ref____SWIG_0, 2},
   {"R_swig_InfomapParentIterator_current__SWIG_0", (DL_FUNC) &R_swig_InfomapParentIterator_current__SWIG_0, 1},
   {"R_swig_new_InfomapParentIterator__SWIG_0", (DL_FUNC) &R_swig_new_InfomapParentIterator__SWIG_0, 0},
   {"R_swig_new_InfomapLeafIteratorPhysical__SWIG_0", (DL_FUNC) &R_swig_new_InfomapLeafIteratorPhysical__SWIG_0, 0},
   {"R_swig_InfomapIteratorPhysical_Equal__SWIG_0", (DL_FUNC) &R_swig_InfomapIteratorPhysical_Equal__SWIG_0, 3},
   {"R_swig_new_InfomapIteratorPhysical__SWIG_0", (DL_FUNC) &R_swig_new_InfomapIteratorPhysical__SWIG_0, 0},
   {"R_swig_new_InfomapLeafIterator__SWIG_0", (DL_FUNC) &R_swig_new_InfomapLeafIterator__SWIG_0, 0},
   {"R_swig_new_InfomapLeafModuleIterator__SWIG_0", (DL_FUNC) &R_swig_new_InfomapLeafModuleIterator__SWIG_0, 0},
   {"R_swig_new_InfomapModuleIterator__SWIG_0", (DL_FUNC) &R_swig_new_InfomapModuleIterator__SWIG_0, 0},
   {"R_swig_InfomapIterator_addOutEdge__SWIG_0", (DL_FUNC) &R_swig_InfomapIterator_addOutEdge__SWIG_0, 4},
   {"R_swig_InfomapIterator_sortChildrenOnFlow__SWIG_0", (DL_FUNC) &R_swig_InfomapIterator_sortChildrenOnFlow__SWIG_0, 2},
   {"R_swig_InfomapIterator_infomapTree__SWIG_0", (DL_FUNC) &R_swig_InfomapIterator_infomapTree__SWIG_0, 3},
   {"R_swig_InfomapIterator_end_tree__SWIG_0", (DL_FUNC) &R_swig_InfomapIterator_end_tree__SWIG_0, 2},
   {"R_swig_InfomapIterator_begin_tree__SWIG_0", (DL_FUNC) &R_swig_InfomapIterator_begin_tree__SWIG_0, 3},
   {"R_swig_InfomapIterator_infomap_children__SWIG_0", (DL_FUNC) &R_swig_InfomapIterator_infomap_children__SWIG_0, 2},
   {"R_swig_InfomapIterator_children__SWIG_0", (DL_FUNC) &R_swig_InfomapIterator_children__SWIG_0, 2},
   {"R_swig_InfomapIterator_end_child__SWIG_0", (DL_FUNC) &R_swig_InfomapIterator_end_child__SWIG_0, 2},
   {"R_swig_InfomapIterator_begin_child__SWIG_0", (DL_FUNC) &R_swig_InfomapIterator_begin_child__SWIG_0, 2},
   {"R_swig_InfomapIterator_end__SWIG_0", (DL_FUNC) &R_swig_InfomapIterator_end__SWIG_0, 2},
   {"R_swig_InfomapIterator_begin__SWIG_0", (DL_FUNC) &R_swig_InfomapIterator_begin__SWIG_0, 2},
   {"R_swig_InfomapIterator_getInfomapRoot__SWIG_0", (DL_FUNC) &R_swig_InfomapIterator_getInfomapRoot__SWIG_0, 1},
   {"R_swig_InfomapIterator_getMetaData__SWIG_0", (DL_FUNC) &R_swig_InfomapIterator_getMetaData__SWIG_0, 3},
   {"R_swig_InfomapIterator___deref____SWIG_0", (DL_FUNC) &R_swig_InfomapIterator___deref____SWIG_0, 1},
   {"R_swig_InfomapIterator___ref____SWIG_0", (DL_FUNC) &R_swig_InfomapIterator___ref____SWIG_0, 2},
   {"R_swig_InfomapIterator_current__SWIG_0", (DL_FUNC) &R_swig_InfomapIterator_current__SWIG_0, 1},
   {"R_swig_new_InfomapIterator__SWIG_0", (DL_FUNC) &R_swig_new_InfomapIterator__SWIG_0, 0},
   {"R_swig_deque_uint_resize__SWIG_0", (DL_FUNC) &R_swig_deque_uint_resize__SWIG_0, 2},
   {"R_swig_new_deque_uint__SWIG_0", (DL_FUNC) &R_swig_new_deque_uint__SWIG_0, 0},
   {"R_swig_InfoNode_addOutEdge__SWIG_0", (DL_FUNC) &R_swig_InfoNode_addOutEdge__SWIG_0, 4},
   {"R_swig_InfoNode_sortChildrenOnFlow__SWIG_0", (DL_FUNC) &R_swig_InfoNode_sortChildrenOnFlow__SWIG_0, 2},
   {"R_swig_InfoNode_infomapTree__SWIG_0", (DL_FUNC) &R_swig_InfoNode_infomapTree__SWIG_0, 3},
   {"R_swig_InfoNode_end_tree__SWIG_0", (DL_FUNC) &R_swig_InfoNode_end_tree__SWIG_0, 2},
   {"R_swig_InfoNode_begin_tree__SWIG_0", (DL_FUNC) &R_swig_InfoNode_begin_tree__SWIG_0, 3},
   {"R_swig_InfoNode_infomap_children__SWIG_0", (DL_FUNC) &R_swig_InfoNode_infomap_children__SWIG_0, 2},
   {"R_swig_InfoNode_children__SWIG_0", (DL_FUNC) &R_swig_InfoNode_children__SWIG_0, 2},
   {"R_swig_InfoNode_end_child__SWIG_0", (DL_FUNC) &R_swig_InfoNode_end_child__SWIG_0, 2},
   {"R_swig_InfoNode_begin_child__SWIG_0", (DL_FUNC) &R_swig_InfoNode_begin_child__SWIG_0, 2},
   {"R_swig_InfoNode_end__SWIG_0", (DL_FUNC) &R_swig_InfoNode_end__SWIG_0, 2},
   {"R_swig_InfoNode_begin__SWIG_0", (DL_FUNC) &R_swig_InfoNode_begin__SWIG_0, 2},
   {"R_swig_InfoNode_getInfomapRoot__SWIG_0", (DL_FUNC) &R_swig_InfoNode_getInfomapRoot__SWIG_0, 1},
   {"R_swig_InfoNode_getMetaData__SWIG_0", (DL_FUNC) &R_swig_InfoNode_getMetaData__SWIG_0, 3},
   {"R_swig_new_InfoNode__SWIG_0", (DL_FUNC) &R_swig_new_InfoNode__SWIG_0, 1},
   {"R_swig_new_Config__SWIG_0", (DL_FUNC) &R_swig_new_Config__SWIG_0, 0},
   {"R_swig_new_FlowData__SWIG_0", (DL_FUNC) &R_swig_new_FlowData__SWIG_0, 1},
   {"R_swig_new_DeltaFlow__SWIG_0", (DL_FUNC) &R_swig_new_DeltaFlow__SWIG_0, 0},
   {"R_swig_DeltaFlow_Equal__SWIG_0", (DL_FUNC) &R_swig_DeltaFlow_Equal__SWIG_0, 3},
   {"R_swig_new_MemDeltaFlow__SWIG_0", (DL_FUNC) &R_swig_new_MemDeltaFlow__SWIG_0, 0},
   {"R_swig_new_PhysData__SWIG_0", (DL_FUNC) &R_swig_new_PhysData__SWIG_0, 2},
   {"R_swig_new_vector_uint__SWIG_0", (DL_FUNC) &R_swig_new_vector_uint__SWIG_0, 0},
   {"R_swig_vector_uint_resize__SWIG_0", (DL_FUNC) &R_swig_vector_uint_resize__SWIG_0, 2},
   {"R_swig_InfomapParentIterator_getMetaData__SWIG_0", (DL_FUNC) &R_swig_InfomapParentIterator_getMetaData__SWIG_0, 3},
   {"R_swig_InfomapParentIterator_begin__SWIG_0", (DL_FUNC) &R_swig_InfomapParentIterator_begin__SWIG_0, 2},
   {"R_swig_InfomapParentIterator_end__SWIG_0", (DL_FUNC) &R_swig_InfomapParentIterator_end__SWIG_0, 2},
   {"R_swig_InfomapParentIterator_begin_child__SWIG_0", (DL_FUNC) &R_swig_InfomapParentIterator_begin_child__SWIG_0, 2},
   {"R_swig_InfomapParentIterator_end_child__SWIG_0", (DL_FUNC) &R_swig_InfomapParentIterator_end_child__SWIG_0, 2},
   {"R_swig_InfomapParentIterator_children__SWIG_0", (DL_FUNC) &R_swig_InfomapParentIterator_children__SWIG_0, 2},
   {"R_swig_InfomapParentIterator_begin_tree__SWIG_0", (DL_FUNC) &R_swig_InfomapParentIterator_begin_tree__SWIG_0, 3},
   {"R_swig_InfomapParentIterator_end_tree__SWIG_0", (DL_FUNC) &R_swig_InfomapParentIterator_end_tree__SWIG_0, 2},
   {"R_swig_InfomapParentIterator_infomapTree__SWIG_0", (DL_FUNC) &R_swig_InfomapParentIterator_infomapTree__SWIG_0, 3},
   {"R_swig_InfomapParentIterator_addOutEdge__SWIG_0", (DL_FUNC) &R_swig_InfomapParentIterator_addOutEdge__SWIG_0, 4},
   {"R_swig_new_StateNetwork__SWIG_0", (DL_FUNC) &R_swig_new_StateNetwork__SWIG_0, 0},
   {"R_swig_StateNetwork_addStateNode__SWIG_0", (DL_FUNC) &R_swig_StateNetwork_addStateNode__SWIG_0, 3},
   {"R_swig_StateNetwork_addNode__SWIG_0", (DL_FUNC) &R_swig_StateNetwork_addNode__SWIG_0, 3},
   {"R_swig_StateNetwork_addPhysicalNode__SWIG_0", (DL_FUNC) &R_swig_StateNetwork_addPhysicalNode__SWIG_0, 3},
   {"R_swig_StateNetwork_addLink__SWIG_0", (DL_FUNC) &R_swig_StateNetwork_addLink__SWIG_0, 5},
   {"R_swig_StateNetwork_nodeLinkMap__SWIG_0", (DL_FUNC) &R_swig_StateNetwork_nodeLinkMap__SWIG_0, 2},
   {"R_swig_StateNetwork_names__SWIG_0", (DL_FUNC) &R_swig_StateNetwork_names__SWIG_0, 2},
   {"R_swig_StateNetwork_writePajekNetwork__SWIG_0", (DL_FUNC) &R_swig_StateNetwork_writePajekNetwork__SWIG_0, 3},
   {"R_swig_new_Network__SWIG_0", (DL_FUNC) &R_swig_new_Network__SWIG_0, 0},
   {"R_swig_Network_readInputData__SWIG_0", (DL_FUNC) &R_swig_Network_readInputData__SWIG_0, 3},
   {"R_swig_Network_addMetaData__SWIG_0", (DL_FUNC) &R_swig_Network_addMetaData__SWIG_0, 3},
   {"R_swig_new_LayerNode__SWIG_0", (DL_FUNC) &R_swig_new_LayerNode__SWIG_0, 2},
   {"R_swig_new_Bigram__SWIG_0", (DL_FUNC) &R_swig_new_Bigram__SWIG_0, 2},
   {"R_swig_new_BipartiteLink__SWIG_0", (DL_FUNC) &R_swig_new_BipartiteLink__SWIG_0, 3},
   {"R_swig_new_Weight__SWIG_0", (DL_FUNC) &R_swig_new_Weight__SWIG_0, 1},
   {"R_swig_new_Triple__SWIG_0", (DL_FUNC) &R_swig_new_Triple__SWIG_0, 0},
   {"R_swig_new_map_uint_uint__SWIG_0", (DL_FUNC) &R_swig_new_map_uint_uint__SWIG_0, 1},
   {"R_swig_new_vector_double__SWIG_0", (DL_FUNC) &R_swig_new_vector_double__SWIG_0, 0},
   {"R_swig_vector_double_resize__SWIG_0", (DL_FUNC) &R_swig_vector_double_resize__SWIG_0, 2},
   {"R_swig_new_InfomapConfigInfomapBase__SWIG_0", (DL_FUNC) &R_swig_new_InfomapConfigInfomapBase__SWIG_0, 0},
   {"R_swig_InfomapConfigInfomapBase_getConfig__SWIG_0", (DL_FUNC) &R_swig_InfomapConfigInfomapBase_getConfig__SWIG_0, 2},
   {"R_swig_InfomapBase_network__SWIG_0", (DL_FUNC) &R_swig_InfomapBase_network__SWIG_0, 2},
   {"R_swig_InfomapBase_root__SWIG_0", (DL_FUNC) &R_swig_InfomapBase_root__SWIG_0, 2},
   {"R_swig_InfomapBase_iterTree__SWIG_0", (DL_FUNC) &R_swig_InfomapBase_iterTree__SWIG_0, 3},
   {"R_swig_InfomapBase_iterTreePhysical__SWIG_0", (DL_FUNC) &R_swig_InfomapBase_iterTreePhysical__SWIG_0, 3},
   {"R_swig_InfomapBase_iterModules__SWIG_0", (DL_FUNC) &R_swig_InfomapBase_iterModules__SWIG_0, 3},
   {"R_swig_InfomapBase_iterLeafModules__SWIG_0", (DL_FUNC) &R_swig_InfomapBase_iterLeafModules__SWIG_0, 3},
   {"R_swig_InfomapBase_iterLeafNodes__SWIG_0", (DL_FUNC) &R_swig_InfomapBase_iterLeafNodes__SWIG_0, 3},
   {"R_swig_InfomapBase_iterLeafNodesPhysical__SWIG_0", (DL_FUNC) &R_swig_InfomapBase_iterLeafNodesPhysical__SWIG_0, 3},
   {"R_swig_InfomapBase_begin__SWIG_0", (DL_FUNC) &R_swig_InfomapBase_begin__SWIG_0, 3},
   {"R_swig_InfomapBase_getMetaCodelength__SWIG_0", (DL_FUNC) &R_swig_InfomapBase_getMetaCodelength__SWIG_0, 3},
   {"R_swig_InfomapBase_run__SWIG_0", (DL_FUNC) &R_swig_InfomapBase_run__SWIG_0, 2},
   {"R_swig_InfomapBase_initNetwork__SWIG_0", (DL_FUNC) &R_swig_InfomapBase_initNetwork__SWIG_0, 3},
   {"R_swig_InfomapBase_generateSubNetwork__SWIG_0", (DL_FUNC) &R_swig_InfomapBase_generateSubNetwork__SWIG_0, 2},
   {"R_swig_InfomapBase_initPartition__SWIG_0", (DL_FUNC) &R_swig_InfomapBase_initPartition__SWIG_0, 4},
   {"R_swig_InfomapBase_calcCodelengthOnTree__SWIG_0", (DL_FUNC) &R_swig_InfomapBase_calcCodelengthOnTree__SWIG_0, 3},
   {"R_swig_InfomapBase_consolidateModules__SWIG_0", (DL_FUNC) &R_swig_InfomapBase_consolidateModules__SWIG_0, 2},
   {"R_swig_InfomapBase_writeTree__SWIG_0", (DL_FUNC) &R_swig_InfomapBase_writeTree__SWIG_0, 4},
   {"R_swig_InfomapBase_writeFlowTree__SWIG_0", (DL_FUNC) &R_swig_InfomapBase_writeFlowTree__SWIG_0, 4},
   {"R_swig_InfomapBase_writeNewickTree__SWIG_0", (DL_FUNC) &R_swig_InfomapBase_writeNewickTree__SWIG_0, 4},
   {"R_swig_InfomapBase_writeJsonTree__SWIG_0", (DL_FUNC) &R_swig_InfomapBase_writeJsonTree__SWIG_0, 4},
   {"R_swig_InfomapBase_writeClu__SWIG_0", (DL_FUNC) &R_swig_InfomapBase_writeClu__SWIG_0, 5},
   {"R_swig_new_MapEquation__SWIG_0", (DL_FUNC) &R_swig_new_MapEquation__SWIG_0, 0},
   {"R_swig_MapEquation_addMemoryContributions__SWIG_0", (DL_FUNC) &R_swig_MapEquation_addMemoryContributions__SWIG_0, 4},
   {"R_swig_new_MemMapEquation__SWIG_0", (DL_FUNC) &R_swig_new_MemMapEquation__SWIG_0, 0},
   {"R_swig_new_MemNodeSet__SWIG_0", (DL_FUNC) &R_swig_new_MemNodeSet__SWIG_0, 2},
   {"R_swig_new_MetaMapEquation__SWIG_0", (DL_FUNC) &R_swig_new_MetaMapEquation__SWIG_0, 0},
   {"R_swig_MetaMapEquation_getMetaCodelength__SWIG_0", (DL_FUNC) &R_swig_MetaMapEquation_getMetaCodelength__SWIG_0, 3},
   {"R_swig_new_InfomapCore__SWIG_0", (DL_FUNC) &R_swig_new_InfomapCore__SWIG_0, 0},
   {"R_swig_InfomapCore_getMetaCodelength__SWIG_0", (DL_FUNC) &R_swig_InfomapCore_getMetaCodelength__SWIG_0, 3},
   {"R_swig_new_map_uint_vector_uint__SWIG_0", (DL_FUNC) &R_swig_new_map_uint_vector_uint__SWIG_0, 1},
   {"R_swig_new_map_uint_string__SWIG_0", (DL_FUNC) &R_swig_new_map_uint_string__SWIG_0, 1},
   {"R_swig_new_InfomapWrapper__SWIG_0", (DL_FUNC) &R_swig_new_InfomapWrapper__SWIG_0, 0},
   {"R_swig_InfomapWrapper_readInputData__SWIG_0", (DL_FUNC) &R_swig_InfomapWrapper_readInputData__SWIG_0, 3},
   {"R_swig_InfomapWrapper_addNode__SWIG_0", (DL_FUNC) &R_swig_InfomapWrapper_addNode__SWIG_0, 2},
   {"R_swig_InfomapWrapper_addPhysicalNode__SWIG_0", (DL_FUNC) &R_swig_InfomapWrapper_addPhysicalNode__SWIG_0, 3},
   {"R_swig_InfomapWrapper_addLink__SWIG_0", (DL_FUNC) &R_swig_InfomapWrapper_addLink__SWIG_0, 4},
   {"R_swig_InfomapWrapper_addMultilayerLink__SWIG_0", (DL_FUNC) &R_swig_InfomapWrapper_addMultilayerLink__SWIG_0, 6},
   {"R_swig_InfomapWrapper_getModules__SWIG_0", (DL_FUNC) &R_swig_InfomapWrapper_getModules__SWIG_0, 4},
   {"R_swig_InfomapWrapper_getMultilevelModules__SWIG_0", (DL_FUNC) &R_swig_InfomapWrapper_getMultilevelModules__SWIG_0, 3},
   {"R_swig_InfomapParentIterator___deref____SWIG_1", (DL_FUNC) &R_swig_InfomapParentIterator___deref____SWIG_1, 1},
   {"R_swig_InfomapParentIterator___ref____SWIG_1", (DL_FUNC) &R_swig_InfomapParentIterator___ref____SWIG_1, 2},
   {"R_swig_InfomapParentIterator_current__SWIG_1", (DL_FUNC) &R_swig_InfomapParentIterator_current__SWIG_1, 1},
   {"R_swig_new_InfomapParentIterator__SWIG_1", (DL_FUNC) &R_swig_new_InfomapParentIterator__SWIG_1, 1},
   {"R_swig_new_InfomapLeafIteratorPhysical__SWIG_1", (DL_FUNC) &R_swig_new_InfomapLeafIteratorPhysical__SWIG_1, 2},
   {"R_swig_InfomapIteratorPhysical_Equal__SWIG_1", (DL_FUNC) &R_swig_InfomapIteratorPhysical_Equal__SWIG_1, 3},
   {"R_swig_new_InfomapIteratorPhysical__SWIG_1", (DL_FUNC) &R_swig_new_InfomapIteratorPhysical__SWIG_1, 2},
   {"R_swig_new_InfomapLeafIterator__SWIG_1", (DL_FUNC) &R_swig_new_InfomapLeafIterator__SWIG_1, 2},
   {"R_swig_new_InfomapLeafModuleIterator__SWIG_1", (DL_FUNC) &R_swig_new_InfomapLeafModuleIterator__SWIG_1, 2},
   {"R_swig_new_InfomapModuleIterator__SWIG_1", (DL_FUNC) &R_swig_new_InfomapModuleIterator__SWIG_1, 2},
   {"R_swig_InfomapIterator_addOutEdge__SWIG_1", (DL_FUNC) &R_swig_InfomapIterator_addOutEdge__SWIG_1, 3},
   {"R_swig_InfomapIterator_sortChildrenOnFlow__SWIG_1", (DL_FUNC) &R_swig_InfomapIterator_sortChildrenOnFlow__SWIG_1, 1},
   {"R_swig_InfomapIterator_infomapTree__SWIG_1", (DL_FUNC) &R_swig_InfomapIterator_infomapTree__SWIG_1, 2},
   {"R_swig_InfomapIterator_end_tree__SWIG_1", (DL_FUNC) &R_swig_InfomapIterator_end_tree__SWIG_1, 2},
   {"R_swig_InfomapIterator_begin_tree__SWIG_1", (DL_FUNC) &R_swig_InfomapIterator_begin_tree__SWIG_1, 2},
   {"R_swig_InfomapIterator_infomap_children__SWIG_1", (DL_FUNC) &R_swig_InfomapIterator_infomap_children__SWIG_1, 2},
   {"R_swig_InfomapIterator_children__SWIG_1", (DL_FUNC) &R_swig_InfomapIterator_children__SWIG_1, 2},
   {"R_swig_InfomapIterator_end_child__SWIG_1", (DL_FUNC) &R_swig_InfomapIterator_end_child__SWIG_1, 2},
   {"R_swig_InfomapIterator_begin_child__SWIG_1", (DL_FUNC) &R_swig_InfomapIterator_begin_child__SWIG_1, 2},
   {"R_swig_InfomapIterator_end__SWIG_1", (DL_FUNC) &R_swig_InfomapIterator_end__SWIG_1, 2},
   {"R_swig_InfomapIterator_begin__SWIG_1", (DL_FUNC) &R_swig_InfomapIterator_begin__SWIG_1, 2},
   {"R_swig_InfomapIterator_getInfomapRoot__SWIG_1", (DL_FUNC) &R_swig_InfomapIterator_getInfomapRoot__SWIG_1, 1},
   {"R_swig_InfomapIterator_getMetaData__SWIG_1", (DL_FUNC) &R_swig_InfomapIterator_getMetaData__SWIG_1, 2},
   {"R_swig_InfomapIterator___deref____SWIG_1", (DL_FUNC) &R_swig_InfomapIterator___deref____SWIG_1, 1},
   {"R_swig_InfomapIterator___ref____SWIG_1", (DL_FUNC) &R_swig_InfomapIterator___ref____SWIG_1, 2},
   {"R_swig_InfomapIterator_current__SWIG_1", (DL_FUNC) &R_swig_InfomapIterator_current__SWIG_1, 1},
   {"R_swig_new_InfomapIterator__SWIG_1", (DL_FUNC) &R_swig_new_InfomapIterator__SWIG_1, 2},
   {"R_swig_deque_uint_resize__SWIG_1", (DL_FUNC) &R_swig_deque_uint_resize__SWIG_1, 3},
   {"R_swig_new_deque_uint__SWIG_1", (DL_FUNC) &R_swig_new_deque_uint__SWIG_1, 1},
   {"R_swig_InfoNode_addOutEdge__SWIG_1", (DL_FUNC) &R_swig_InfoNode_addOutEdge__SWIG_1, 3},
   {"R_swig_InfoNode_sortChildrenOnFlow__SWIG_1", (DL_FUNC) &R_swig_InfoNode_sortChildrenOnFlow__SWIG_1, 1},
   {"R_swig_InfoNode_infomapTree__SWIG_1", (DL_FUNC) &R_swig_InfoNode_infomapTree__SWIG_1, 2},
   {"R_swig_InfoNode_end_tree__SWIG_1", (DL_FUNC) &R_swig_InfoNode_end_tree__SWIG_1, 2},
   {"R_swig_InfoNode_begin_tree__SWIG_1", (DL_FUNC) &R_swig_InfoNode_begin_tree__SWIG_1, 2},
   {"R_swig_InfoNode_infomap_children__SWIG_1", (DL_FUNC) &R_swig_InfoNode_infomap_children__SWIG_1, 2},
   {"R_swig_InfoNode_children__SWIG_1", (DL_FUNC) &R_swig_InfoNode_children__SWIG_1, 2},
   {"R_swig_InfoNode_end_child__SWIG_1", (DL_FUNC) &R_swig_InfoNode_end_child__SWIG_1, 2},
   {"R_swig_InfoNode_begin_child__SWIG_1", (DL_FUNC) &R_swig_InfoNode_begin_child__SWIG_1, 2},
   {"R_swig_InfoNode_end__SWIG_1", (DL_FUNC) &R_swig_InfoNode_end__SWIG_1, 2},
   {"R_swig_InfoNode_begin__SWIG_1", (DL_FUNC) &R_swig_InfoNode_begin__SWIG_1, 2},
   {"R_swig_InfoNode_getInfomapRoot__SWIG_1", (DL_FUNC) &R_swig_InfoNode_getInfomapRoot__SWIG_1, 1},
   {"R_swig_InfoNode_getMetaData__SWIG_1", (DL_FUNC) &R_swig_InfoNode_getMetaData__SWIG_1, 2},
   {"R_swig_new_InfoNode__SWIG_1", (DL_FUNC) &R_swig_new_InfoNode__SWIG_1, 2},
   {"R_swig_new_Config__SWIG_1", (DL_FUNC) &R_swig_new_Config__SWIG_1, 2},
   {"R_swig_new_FlowData__SWIG_1", (DL_FUNC) &R_swig_new_FlowData__SWIG_1, 0},
   {"R_swig_new_DeltaFlow__SWIG_1", (DL_FUNC) &R_swig_new_DeltaFlow__SWIG_1, 3},
   {"R_swig_DeltaFlow_Equal__SWIG_1", (DL_FUNC) &R_swig_DeltaFlow_Equal__SWIG_1, 3},
   {"R_swig_new_MemDeltaFlow__SWIG_1", (DL_FUNC) &R_swig_new_MemDeltaFlow__SWIG_1, 5},
   {"R_swig_new_PhysData__SWIG_1", (DL_FUNC) &R_swig_new_PhysData__SWIG_1, 1},
   {"R_swig_new_vector_uint__SWIG_1", (DL_FUNC) &R_swig_new_vector_uint__SWIG_1, 1},
   {"R_swig_vector_uint_resize__SWIG_1", (DL_FUNC) &R_swig_vector_uint_resize__SWIG_1, 3},
   {"R_swig_InfomapParentIterator_getMetaData__SWIG_1", (DL_FUNC) &R_swig_InfomapParentIterator_getMetaData__SWIG_1, 2},
   {"R_swig_InfomapParentIterator_begin__SWIG_1", (DL_FUNC) &R_swig_InfomapParentIterator_begin__SWIG_1, 2},
   {"R_swig_InfomapParentIterator_end__SWIG_1", (DL_FUNC) &R_swig_InfomapParentIterator_end__SWIG_1, 2},
   {"R_swig_InfomapParentIterator_begin_child__SWIG_1", (DL_FUNC) &R_swig_InfomapParentIterator_begin_child__SWIG_1, 2},
   {"R_swig_InfomapParentIterator_end_child__SWIG_1", (DL_FUNC) &R_swig_InfomapParentIterator_end_child__SWIG_1, 2},
   {"R_swig_InfomapParentIterator_children__SWIG_1", (DL_FUNC) &R_swig_InfomapParentIterator_children__SWIG_1, 2},
   {"R_swig_InfomapParentIterator_begin_tree__SWIG_1", (DL_FUNC) &R_swig_InfomapParentIterator_begin_tree__SWIG_1, 2},
   {"R_swig_InfomapParentIterator_end_tree__SWIG_1", (DL_FUNC) &R_swig_InfomapParentIterator_end_tree__SWIG_1, 2},
   {"R_swig_InfomapParentIterator_infomapTree__SWIG_1", (DL_FUNC) &R_swig_InfomapParentIterator_infomapTree__SWIG_1, 2},
   {"R_swig_InfomapParentIterator_addOutEdge__SWIG_1", (DL_FUNC) &R_swig_InfomapParentIterator_addOutEdge__SWIG_1, 3},
   {"R_swig_new_StateNetwork__SWIG_1", (DL_FUNC) &R_swig_new_StateNetwork__SWIG_1, 1},
   {"R_swig_StateNetwork_addStateNode__SWIG_1", (DL_FUNC) &R_swig_StateNetwork_addStateNode__SWIG_1, 4},
   {"R_swig_StateNetwork_addNode__SWIG_1", (DL_FUNC) &R_swig_StateNetwork_addNode__SWIG_1, 4},
   {"R_swig_StateNetwork_addPhysicalNode__SWIG_1", (DL_FUNC) &R_swig_StateNetwork_addPhysicalNode__SWIG_1, 4},
   {"R_swig_StateNetwork_addLink__SWIG_1", (DL_FUNC) &R_swig_StateNetwork_addLink__SWIG_1, 4},
   {"R_swig_StateNetwork_nodeLinkMap__SWIG_1", (DL_FUNC) &R_swig_StateNetwork_nodeLinkMap__SWIG_1, 2},
   {"R_swig_StateNetwork_names__SWIG_1", (DL_FUNC) &R_swig_StateNetwork_names__SWIG_1, 2},
   {"R_swig_StateNetwork_writePajekNetwork__SWIG_1", (DL_FUNC) &R_swig_StateNetwork_writePajekNetwork__SWIG_1, 2},
   {"R_swig_new_Network__SWIG_1", (DL_FUNC) &R_swig_new_Network__SWIG_1, 1},
   {"R_swig_Network_readInputData__SWIG_1", (DL_FUNC) &R_swig_Network_readInputData__SWIG_1, 2},
   {"R_swig_Network_addMetaData__SWIG_1", (DL_FUNC) &R_swig_Network_addMetaData__SWIG_1, 3},
   {"R_swig_new_LayerNode__SWIG_1", (DL_FUNC) &R_swig_new_LayerNode__SWIG_1, 1},
   {"R_swig_new_Bigram__SWIG_1", (DL_FUNC) &R_swig_new_Bigram__SWIG_1, 1},
   {"R_swig_new_BipartiteLink__SWIG_1", (DL_FUNC) &R_swig_new_BipartiteLink__SWIG_1, 2},
   {"R_swig_new_Weight__SWIG_1", (DL_FUNC) &R_swig_new_Weight__SWIG_1, 0},
   {"R_swig_new_Triple__SWIG_1", (DL_FUNC) &R_swig_new_Triple__SWIG_1, 3},
   {"R_swig_new_map_uint_uint__SWIG_1", (DL_FUNC) &R_swig_new_map_uint_uint__SWIG_1, 0},
   {"R_swig_new_vector_double__SWIG_1", (DL_FUNC) &R_swig_new_vector_double__SWIG_1, 1},
   {"R_swig_vector_double_resize__SWIG_1", (DL_FUNC) &R_swig_vector_double_resize__SWIG_1, 3},
   {"R_swig_new_InfomapConfigInfomapBase__SWIG_1", (DL_FUNC) &R_swig_new_InfomapConfigInfomapBase__SWIG_1, 1},
   {"R_swig_InfomapConfigInfomapBase_getConfig__SWIG_1", (DL_FUNC) &R_swig_InfomapConfigInfomapBase_getConfig__SWIG_1, 2},
   {"R_swig_InfomapBase_network__SWIG_1", (DL_FUNC) &R_swig_InfomapBase_network__SWIG_1, 2},
   {"R_swig_InfomapBase_root__SWIG_1", (DL_FUNC) &R_swig_InfomapBase_root__SWIG_1, 2},
   {"R_swig_InfomapBase_iterTree__SWIG_1", (DL_FUNC) &R_swig_InfomapBase_iterTree__SWIG_1, 2},
   {"R_swig_InfomapBase_iterTreePhysical__SWIG_1", (DL_FUNC) &R_swig_InfomapBase_iterTreePhysical__SWIG_1, 2},
   {"R_swig_InfomapBase_iterModules__SWIG_1", (DL_FUNC) &R_swig_InfomapBase_iterModules__SWIG_1, 2},
   {"R_swig_InfomapBase_iterLeafModules__SWIG_1", (DL_FUNC) &R_swig_InfomapBase_iterLeafModules__SWIG_1, 2},
   {"R_swig_InfomapBase_iterLeafNodes__SWIG_1", (DL_FUNC) &R_swig_InfomapBase_iterLeafNodes__SWIG_1, 2},
   {"R_swig_InfomapBase_iterLeafNodesPhysical__SWIG_1", (DL_FUNC) &R_swig_InfomapBase_iterLeafNodesPhysical__SWIG_1, 2},
   {"R_swig_InfomapBase_begin__SWIG_1", (DL_FUNC) &R_swig_InfomapBase_begin__SWIG_1, 2},
   {"R_swig_InfomapBase_getMetaCodelength__SWIG_1", (DL_FUNC) &R_swig_InfomapBase_getMetaCodelength__SWIG_1, 2},
   {"R_swig_InfomapBase_run__SWIG_1", (DL_FUNC) &R_swig_InfomapBase_run__SWIG_1, 1},
   {"R_swig_InfomapBase_initNetwork__SWIG_1", (DL_FUNC) &R_swig_InfomapBase_initNetwork__SWIG_1, 4},
   {"R_swig_InfomapBase_generateSubNetwork__SWIG_1", (DL_FUNC) &R_swig_InfomapBase_generateSubNetwork__SWIG_1, 2},
   {"R_swig_InfomapBase_initPartition__SWIG_1", (DL_FUNC) &R_swig_InfomapBase_initPartition__SWIG_1, 3},
   {"R_swig_InfomapBase_calcCodelengthOnTree__SWIG_1", (DL_FUNC) &R_swig_InfomapBase_calcCodelengthOnTree__SWIG_1, 2},
   {"R_swig_InfomapBase_consolidateModules__SWIG_1", (DL_FUNC) &R_swig_InfomapBase_consolidateModules__SWIG_1, 1},
   {"R_swig_InfomapBase_writeTree__SWIG_1", (DL_FUNC) &R_swig_InfomapBase_writeTree__SWIG_1, 3},
   {"R_swig_InfomapBase_writeFlowTree__SWIG_1", (DL_FUNC) &R_swig_InfomapBase_writeFlowTree__SWIG_1, 3},
   {"R_swig_InfomapBase_writeNewickTree__SWIG_1", (DL_FUNC) &R_swig_InfomapBase_writeNewickTree__SWIG_1, 3},
   {"R_swig_InfomapBase_writeJsonTree__SWIG_1", (DL_FUNC) &R_swig_InfomapBase_writeJsonTree__SWIG_1, 3},
   {"R_swig_InfomapBase_writeClu__SWIG_1", (DL_FUNC) &R_swig_InfomapBase_writeClu__SWIG_1, 4},
   {"R_swig_new_MapEquation__SWIG_1", (DL_FUNC) &R_swig_new_MapEquation__SWIG_1, 1},
   {"R_swig_MapEquation_addMemoryContributions__SWIG_1", (DL_FUNC) &R_swig_MapEquation_addMemoryContributions__SWIG_1, 4},
   {"R_swig_new_MemMapEquation__SWIG_1", (DL_FUNC) &R_swig_new_MemMapEquation__SWIG_1, 1},
   {"R_swig_new_MemNodeSet__SWIG_1", (DL_FUNC) &R_swig_new_MemNodeSet__SWIG_1, 1},
   {"R_swig_new_MetaMapEquation__SWIG_1", (DL_FUNC) &R_swig_new_MetaMapEquation__SWIG_1, 1},
   {"R_swig_MetaMapEquation_getMetaCodelength__SWIG_1", (DL_FUNC) &R_swig_MetaMapEquation_getMetaCodelength__SWIG_1, 2},
   {"R_swig_new_InfomapCore__SWIG_1", (DL_FUNC) &R_swig_new_InfomapCore__SWIG_1, 1},
   {"R_swig_InfomapCore_getMetaCodelength__SWIG_1", (DL_FUNC) &R_swig_InfomapCore_getMetaCodelength__SWIG_1, 2},
   {"R_swig_new_map_uint_vector_uint__SWIG_1", (DL_FUNC) &R_swig_new_map_uint_vector_uint__SWIG_1, 0},
   {"R_swig_new_map_uint_string__SWIG_1", (DL_FUNC) &R_swig_new_map_uint_string__SWIG_1, 0},
   {"R_swig_new_InfomapWrapper__SWIG_1", (DL_FUNC) &R_swig_new_InfomapWrapper__SWIG_1, 1},
   {"R_swig_InfomapWrapper_readInputData__SWIG_1", (DL_FUNC) &R_swig_InfomapWrapper_readInputData__SWIG_1, 2},
   {"R_swig_InfomapWrapper_addNode__SWIG_1", (DL_FUNC) &R_swig_InfomapWrapper_addNode__SWIG_1, 3},
   {"R_swig_InfomapWrapper_addPhysicalNode__SWIG_1", (DL_FUNC) &R_swig_InfomapWrapper_addPhysicalNode__SWIG_1, 2},
   {"R_swig_InfomapWrapper_addLink__SWIG_1", (DL_FUNC) &R_swig_InfomapWrapper_addLink__SWIG_1, 3},
   {"R_swig_InfomapWrapper_addMultilayerLink__SWIG_1", (DL_FUNC) &R_swig_InfomapWrapper_addMultilayerLink__SWIG_1, 5},
   {"R_swig_InfomapWrapper_getModules__SWIG_1", (DL_FUNC) &R_swig_InfomapWrapper_getModules__SWIG_1, 3},
   {"R_swig_InfomapWrapper_getMultilevelModules__SWIG_1", (DL_FUNC) &R_swig_InfomapWrapper_getMultilevelModules__SWIG_1, 2},
   {"R_swig_new_InfomapParentIterator__SWIG_2", (DL_FUNC) &R_swig_new_InfomapParentIterator__SWIG_2, 1},
   {"R_swig_new_InfomapLeafIteratorPhysical__SWIG_2", (DL_FUNC) &R_swig_new_InfomapLeafIteratorPhysical__SWIG_2, 1},
   {"R_swig_new_InfomapIteratorPhysical__SWIG_2", (DL_FUNC) &R_swig_new_InfomapIteratorPhysical__SWIG_2, 1},
   {"R_swig_new_InfomapLeafIterator__SWIG_2", (DL_FUNC) &R_swig_new_InfomapLeafIterator__SWIG_2, 1},
   {"R_swig_new_InfomapLeafModuleIterator__SWIG_2", (DL_FUNC) &R_swig_new_InfomapLeafModuleIterator__SWIG_2, 1},
   {"R_swig_new_InfomapModuleIterator__SWIG_2", (DL_FUNC) &R_swig_new_InfomapModuleIterator__SWIG_2, 1},
   {"R_swig_InfomapIterator_infomapTree__SWIG_2", (DL_FUNC) &R_swig_InfomapIterator_infomapTree__SWIG_2, 3},
   {"R_swig_InfomapIterator_begin_tree__SWIG_2", (DL_FUNC) &R_swig_InfomapIterator_begin_tree__SWIG_2, 3},
   {"R_swig_new_InfomapIterator__SWIG_2", (DL_FUNC) &R_swig_new_InfomapIterator__SWIG_2, 1},
   {"R_swig_new_deque_uint__SWIG_2", (DL_FUNC) &R_swig_new_deque_uint__SWIG_2, 1},
   {"R_swig_InfoNode_infomapTree__SWIG_2", (DL_FUNC) &R_swig_InfoNode_infomapTree__SWIG_2, 3},
   {"R_swig_InfoNode_begin_tree__SWIG_2", (DL_FUNC) &R_swig_InfoNode_begin_tree__SWIG_2, 3},
   {"R_swig_new_InfoNode__SWIG_2", (DL_FUNC) &R_swig_new_InfoNode__SWIG_2, 3},
   {"R_swig_new_Config__SWIG_2", (DL_FUNC) &R_swig_new_Config__SWIG_2, 1},
   {"R_swig_new_FlowData__SWIG_2", (DL_FUNC) &R_swig_new_FlowData__SWIG_2, 1},
   {"R_swig_new_DeltaFlow__SWIG_2", (DL_FUNC) &R_swig_new_DeltaFlow__SWIG_2, 1},
   {"R_swig_new_MemDeltaFlow__SWIG_2", (DL_FUNC) &R_swig_new_MemDeltaFlow__SWIG_2, 4},
   {"R_swig_new_PhysData__SWIG_2", (DL_FUNC) &R_swig_new_PhysData__SWIG_2, 1},
   {"R_swig_new_vector_uint__SWIG_2", (DL_FUNC) &R_swig_new_vector_uint__SWIG_2, 1},
   {"R_swig_InfomapParentIterator_begin_tree__SWIG_2", (DL_FUNC) &R_swig_InfomapParentIterator_begin_tree__SWIG_2, 3},
   {"R_swig_InfomapParentIterator_infomapTree__SWIG_2", (DL_FUNC) &R_swig_InfomapParentIterator_infomapTree__SWIG_2, 3},
   {"R_swig_StateNetwork_addNode__SWIG_2", (DL_FUNC) &R_swig_StateNetwork_addNode__SWIG_2, 4},
   {"R_swig_StateNetwork_addPhysicalNode__SWIG_2", (DL_FUNC) &R_swig_StateNetwork_addPhysicalNode__SWIG_2, 4},
   {"R_swig_StateNetwork_addLink__SWIG_2", (DL_FUNC) &R_swig_StateNetwork_addLink__SWIG_2, 5},
   {"R_swig_new_Network__SWIG_2", (DL_FUNC) &R_swig_new_Network__SWIG_2, 1},
   {"R_swig_Network_readInputData__SWIG_2", (DL_FUNC) &R_swig_Network_readInputData__SWIG_2, 1},
   {"R_swig_new_LayerNode__SWIG_2", (DL_FUNC) &R_swig_new_LayerNode__SWIG_2, 0},
   {"R_swig_new_Bigram__SWIG_2", (DL_FUNC) &R_swig_new_Bigram__SWIG_2, 0},
   {"R_swig_new_BipartiteLink__SWIG_2", (DL_FUNC) &R_swig_new_BipartiteLink__SWIG_2, 1},
   {"R_swig_new_Triple__SWIG_2", (DL_FUNC) &R_swig_new_Triple__SWIG_2, 1},
   {"R_swig_new_map_uint_uint__SWIG_2", (DL_FUNC) &R_swig_new_map_uint_uint__SWIG_2, 1},
   {"R_swig_new_vector_double__SWIG_2", (DL_FUNC) &R_swig_new_vector_double__SWIG_2, 1},
   {"R_swig_new_InfomapConfigInfomapBase__SWIG_2", (DL_FUNC) &R_swig_new_InfomapConfigInfomapBase__SWIG_2, 1},
   {"R_swig_InfomapBase_run__SWIG_2", (DL_FUNC) &R_swig_InfomapBase_run__SWIG_2, 2},
   {"R_swig_InfomapBase_initNetwork__SWIG_2", (DL_FUNC) &R_swig_InfomapBase_initNetwork__SWIG_2, 3},
   {"R_swig_InfomapBase_initPartition__SWIG_2", (DL_FUNC) &R_swig_InfomapBase_initPartition__SWIG_2, 4},
   {"R_swig_InfomapBase_writeTree__SWIG_2", (DL_FUNC) &R_swig_InfomapBase_writeTree__SWIG_2, 2},
   {"R_swig_InfomapBase_writeFlowTree__SWIG_2", (DL_FUNC) &R_swig_InfomapBase_writeFlowTree__SWIG_2, 2},
   {"R_swig_InfomapBase_writeNewickTree__SWIG_2", (DL_FUNC) &R_swig_InfomapBase_writeNewickTree__SWIG_2, 2},
   {"R_swig_InfomapBase_writeJsonTree__SWIG_2", (DL_FUNC) &R_swig_InfomapBase_writeJsonTree__SWIG_2, 2},
   {"R_swig_InfomapBase_writeClu__SWIG_2", (DL_FUNC) &R_swig_InfomapBase_writeClu__SWIG_2, 3},
   {"R_swig_new_InfomapCore__SWIG_2", (DL_FUNC) &R_swig_new_InfomapCore__SWIG_2, 1},
   {"R_swig_new_map_uint_vector_uint__SWIG_2", (DL_FUNC) &R_swig_new_map_uint_vector_uint__SWIG_2, 1},
   {"R_swig_new_map_uint_string__SWIG_2", (DL_FUNC) &R_swig_new_map_uint_string__SWIG_2, 1},
   {"R_swig_new_InfomapWrapper__SWIG_2", (DL_FUNC) &R_swig_new_InfomapWrapper__SWIG_2, 1},
   {"R_swig_InfomapWrapper_readInputData__SWIG_2", (DL_FUNC) &R_swig_InfomapWrapper_readInputData__SWIG_2, 1},
   {"R_swig_InfomapWrapper_addNode__SWIG_2", (DL_FUNC) &R_swig_InfomapWrapper_addNode__SWIG_2, 3},
   {"R_swig_InfomapWrapper_addLink__SWIG_2", (DL_FUNC) &R_swig_InfomapWrapper_addLink__SWIG_2, 4},
   {"R_swig_InfomapWrapper_getModules__SWIG_2", (DL_FUNC) &R_swig_InfomapWrapper_getModules__SWIG_2, 2},
   {"R_swig_new_InfomapLeafIteratorPhysical__SWIG_3", (DL_FUNC) &R_swig_new_InfomapLeafIteratorPhysical__SWIG_3, 1},
   {"R_swig_new_InfomapIteratorPhysical__SWIG_3", (DL_FUNC) &R_swig_new_InfomapIteratorPhysical__SWIG_3, 1},
   {"R_swig_new_InfomapLeafIterator__SWIG_3", (DL_FUNC) &R_swig_new_InfomapLeafIterator__SWIG_3, 1},
   {"R_swig_new_InfomapLeafModuleIterator__SWIG_3", (DL_FUNC) &R_swig_new_InfomapLeafModuleIterator__SWIG_3, 1},
   {"R_swig_new_InfomapModuleIterator__SWIG_3", (DL_FUNC) &R_swig_new_InfomapModuleIterator__SWIG_3, 1},
   {"R_swig_InfomapIterator_infomapTree__SWIG_3", (DL_FUNC) &R_swig_InfomapIterator_infomapTree__SWIG_3, 2},
   {"R_swig_InfomapIterator_begin_tree__SWIG_3", (DL_FUNC) &R_swig_InfomapIterator_begin_tree__SWIG_3, 2},
   {"R_swig_new_InfomapIterator__SWIG_3", (DL_FUNC) &R_swig_new_InfomapIterator__SWIG_3, 1},
   {"R_swig_new_deque_uint__SWIG_3", (DL_FUNC) &R_swig_new_deque_uint__SWIG_3, 2},
   {"R_swig_InfoNode_infomapTree__SWIG_3", (DL_FUNC) &R_swig_InfoNode_infomapTree__SWIG_3, 2},
   {"R_swig_InfoNode_begin_tree__SWIG_3", (DL_FUNC) &R_swig_InfoNode_begin_tree__SWIG_3, 2},
   {"R_swig_new_InfoNode__SWIG_3", (DL_FUNC) &R_swig_new_InfoNode__SWIG_3, 4},
   {"R_swig_new_DeltaFlow__SWIG_3", (DL_FUNC) &R_swig_new_DeltaFlow__SWIG_3, 1},
   {"R_swig_new_MemDeltaFlow__SWIG_3", (DL_FUNC) &R_swig_new_MemDeltaFlow__SWIG_3, 3},
   {"R_swig_new_vector_uint__SWIG_3", (DL_FUNC) &R_swig_new_vector_uint__SWIG_3, 2},
   {"R_swig_InfomapParentIterator_begin_tree__SWIG_3", (DL_FUNC) &R_swig_InfomapParentIterator_begin_tree__SWIG_3, 2},
   {"R_swig_InfomapParentIterator_infomapTree__SWIG_3", (DL_FUNC) &R_swig_InfomapParentIterator_infomapTree__SWIG_3, 2},
   {"R_swig_StateNetwork_addNode__SWIG_3", (DL_FUNC) &R_swig_StateNetwork_addNode__SWIG_3, 5},
   {"R_swig_StateNetwork_addPhysicalNode__SWIG_3", (DL_FUNC) &R_swig_StateNetwork_addPhysicalNode__SWIG_3, 5},
   {"R_swig_new_BipartiteLink__SWIG_3", (DL_FUNC) &R_swig_new_BipartiteLink__SWIG_3, 0},
   {"R_swig_new_vector_double__SWIG_3", (DL_FUNC) &R_swig_new_vector_double__SWIG_3, 2},
   {"R_swig_InfomapBase_initPartition__SWIG_3", (DL_FUNC) &R_swig_InfomapBase_initPartition__SWIG_3, 3},
   {"R_swig_InfomapBase_initNetwork__SWIG_3", (DL_FUNC) &R_swig_InfomapBase_initNetwork__SWIG_3, 1},
   {"R_swig_InfomapBase_writeClu__SWIG_3", (DL_FUNC) &R_swig_InfomapBase_writeClu__SWIG_3, 2},
   {"R_swig_InfomapWrapper_addNode__SWIG_3", (DL_FUNC) &R_swig_InfomapWrapper_addNode__SWIG_3, 4},
   {"R_swig_new_InfomapIteratorPhysical__SWIG_4", (DL_FUNC) &R_swig_new_InfomapIteratorPhysical__SWIG_4, 1},
   {"R_swig_new_InfoNode__SWIG_4", (DL_FUNC) &R_swig_new_InfoNode__SWIG_4, 0},
   {"R_swig_InfomapBase_initPartition__SWIG_4", (DL_FUNC) &R_swig_InfomapBase_initPartition__SWIG_4, 4},
   {"R_swig_InfomapBase_aggregateFlowValuesFromLeafToRoot", (DL_FUNC) &R_swig_InfomapBase_aggregateFlowValuesFromLeafToRoot, 1},
   {"R_swig_new_InfoNode__SWIG_5", (DL_FUNC) &R_swig_new_InfoNode__SWIG_5, 1},
   {"R_swig_InfomapBase_initPartition__SWIG_5", (DL_FUNC) &R_swig_InfomapBase_initPartition__SWIG_5, 3},
   {"R_swig_InfomapBase_initPartition__SWIG_6", (DL_FUNC) &R_swig_InfomapBase_initPartition__SWIG_6, 4},
   {"R_swig_InfomapBase_initPartition__SWIG_7", (DL_FUNC) &R_swig_InfomapBase_initPartition__SWIG_7, 3},
   {"R_swig_InfomapBase_initPartition__SWIG_8", (DL_FUNC) &R_swig_InfomapBase_initPartition__SWIG_8, 1},
   {"R_swig_Config_includeSelfLinks_get", (DL_FUNC) &R_swig_Config_includeSelfLinks_get, 2},
   {"R_swig_Config_printNodeRanks_get", (DL_FUNC) &R_swig_Config_printNodeRanks_get, 2},
   {"R_swig_Config_multilayerRelaxLimitDown_set", (DL_FUNC) &R_swig_Config_multilayerRelaxLimitDown_set, 2},
   {"R_swig_InfomapParentIterator_replaceChildrenWithGrandChildren", (DL_FUNC) &R_swig_InfomapParentIterator_replaceChildrenWithGrandChildren, 2},
   {"R_swig_InfomapParentIterator_replaceChildrenWithGrandChildrenDebug", (DL_FUNC) &R_swig_InfomapParentIterator_replaceChildrenWithGrandChildrenDebug, 1},
   {"R_swig_InfomapConfigInfomapBase_setNumTrials", (DL_FUNC) &R_swig_InfomapConfigInfomapBase_setNumTrials, 3},
   {"R_swig_Config_unweightedPaths_get", (DL_FUNC) &R_swig_Config_unweightedPaths_get, 2},
   {"R_swig_PartitionQueue_resize", (DL_FUNC) &R_swig_PartitionQueue_resize, 2},
   {"R_swig_InfomapIterator_stateNodes_get", (DL_FUNC) &R_swig_InfomapIterator_stateNodes_get, 1},
   {"R_swig_InfomapIterator_physicalNodes_get", (DL_FUNC) &R_swig_InfomapIterator_physicalNodes_get, 1},
   {"R_swig_InfoNode_stateNodes_get", (DL_FUNC) &R_swig_InfoNode_stateNodes_get, 1},
   {"R_swig_InfoNode_physicalNodes_get", (DL_FUNC) &R_swig_InfoNode_physicalNodes_get, 1},
   {"R_swig_Config_onlySuperModules_get", (DL_FUNC) &R_swig_Config_onlySuperModules_get, 2},
   {"R_swig_Config_preferredNumberOfModules_get", (DL_FUNC) &R_swig_Config_preferredNumberOfModules_get, 2},
   {"R_swig_Config_teleportToNodes_get", (DL_FUNC) &R_swig_Config_teleportToNodes_get, 2},
   {"R_swig_Config_hideBipartiteNodes_get", (DL_FUNC) &R_swig_Config_hideBipartiteNodes_get, 2},
   {"R_swig_vector_uint___delitem__", (DL_FUNC) &R_swig_vector_uint___delitem__, 2},
   {"R_swig_vector_uint___getitem__", (DL_FUNC) &R_swig_vector_uint___getitem__, 3},
   {"R_swig_vector_uint___setitem__", (DL_FUNC) &R_swig_vector_uint___setitem__, 3},
   {"R_swig_InfomapParentIterator_physicalNodes_get", (DL_FUNC) &R_swig_InfomapParentIterator_physicalNodes_get, 1},
   {"R_swig_InfomapParentIterator_stateNodes_get", (DL_FUNC) &R_swig_InfomapParentIterator_stateNodes_get, 1},
   {"R_swig_vector_double___delitem__", (DL_FUNC) &R_swig_vector_double___delitem__, 2},
   {"R_swig_vector_double___getitem__", (DL_FUNC) &R_swig_vector_double___getitem__, 3},
   {"R_swig_vector_double___setitem__", (DL_FUNC) &R_swig_vector_double___setitem__, 3},
   {"R_swig_PerLevelStat_numModules_get", (DL_FUNC) &R_swig_PerLevelStat_numModules_get, 2},
   {"R_swig_PerLevelStat_numLeafNodes_get", (DL_FUNC) &R_swig_PerLevelStat_numLeafNodes_get, 2},
   {"R_swig_PartitionQueue_numNonTrivialModules_get", (DL_FUNC) &R_swig_PartitionQueue_numNonTrivialModules_get, 2},
   {"R_swig_MemNodeSet_numMemNodes_get", (DL_FUNC) &R_swig_MemNodeSet_numMemNodes_get, 2},
   {"R_swig_vector_uint_append", (DL_FUNC) &R_swig_vector_uint_append, 2},
   {"R_swig_vector_double_append", (DL_FUNC) &R_swig_vector_double_append, 2},
   {"R_swig_vector_double_front", (DL_FUNC) &R_swig_vector_double_front, 2},
   {"R_swig_InfomapBase_getNewInfomapInstanceWithoutMemory", (DL_FUNC) &R_swig_InfomapBase_getNewInfomapInstanceWithoutMemory, 1},
   {"R_swig_InfomapIterator_metaCollection_set", (DL_FUNC) &R_swig_InfomapIterator_metaCollection_set, 2},
   {"R_swig_InfoNode_metaCollection_set", (DL_FUNC) &R_swig_InfoNode_metaCollection_set, 2},
   {"R_swig_Config_printJson_set", (DL_FUNC) &R_swig_Config_printJson_set, 2},
   {"R_swig_Config_innerParallelization_set", (DL_FUNC) &R_swig_Config_innerParallelization_set, 2},
   {"R_swig_Config_preferModularSolution_set", (DL_FUNC) &R_swig_Config_preferModularSolution_set, 2},
   {"R_swig_Config_fastFirstIteration_set", (DL_FUNC) &R_swig_Config_fastFirstIteration_set, 2},
   {"R_swig_Config_fastHierarchicalSolution_set", (DL_FUNC) &R_swig_Config_fastHierarchicalSolution_set, 2},
   {"R_swig_Config_fastCoarseTunePartition_set", (DL_FUNC) &R_swig_Config_fastCoarseTunePartition_set, 2},
   {"R_swig_Config_recordedTeleportation_set", (DL_FUNC) &R_swig_Config_recordedTeleportation_set, 2},
   {"R_swig_Config_bipartiteTeleportation_set", (DL_FUNC) &R_swig_Config_bipartiteTeleportation_set, 2},
   {"R_swig_Config_verboseNumberPrecision_set", (DL_FUNC) &R_swig_Config_verboseNumberPrecision_set, 2},
   {"R_swig_Config_version_set", (DL_FUNC) &R_swig_Config_version_set, 2},
   {"R_swig_InfomapParentIterator_metaCollection_set", (DL_FUNC) &R_swig_InfomapParentIterator_metaCollection_set, 2},
   {"R_swig_Triple_n2_get", (DL_FUNC) &R_swig_Triple_n2_get, 2},
   {"R_swig_Config_multilayerInput_get", (DL_FUNC) &R_swig_Config_multilayerInput_get, 2},
   {"R_swig_Config_memoryInput_get", (DL_FUNC) &R_swig_Config_memoryInput_get, 2},
   {"R_swig_Config_additionalInput_get", (DL_FUNC) &R_swig_Config_additionalInput_get, 1},
   {"R_swig_Config_noFileOutput_get", (DL_FUNC) &R_swig_Config_noFileOutput_get, 2},
   {"R_swig_vector_uint___nonzero__", (DL_FUNC) &R_swig_vector_uint___nonzero__, 2},
   {"R_swig_vector_double___nonzero__", (DL_FUNC) &R_swig_vector_double___nonzero__, 2},
   {"R_swig_Bigram_first_get", (DL_FUNC) &R_swig_Bigram_first_get, 2},
   {"R_swig_deque_uint_assign", (DL_FUNC) &R_swig_deque_uint_assign, 3},
   {"R_swig_vector_uint_assign", (DL_FUNC) &R_swig_vector_uint_assign, 3},
   {"R_swig_vector_double_assign", (DL_FUNC) &R_swig_vector_double_assign, 3},
   {"R_swig_Config_haveOutput", (DL_FUNC) &R_swig_Config_haveOutput, 2},
   {"R_swig_StateNetwork_calculateFlow", (DL_FUNC) &R_swig_StateNetwork_calculateFlow, 1},
   {"R_swig_Config_preClusterMultilayer_get", (DL_FUNC) &R_swig_Config_preClusterMultilayer_get, 2},
   {"R_swig_LayerNode_layer_get", (DL_FUNC) &R_swig_LayerNode_layer_get, 2},
   {"R_swig_InfomapBase_calcEntropyRate", (DL_FUNC) &R_swig_InfomapBase_calcEntropyRate, 2},
   {"R_swig_InfomapIterator_previous_get", (DL_FUNC) &R_swig_InfomapIterator_previous_get, 1},
   {"R_swig_InfoNode_previous_get", (DL_FUNC) &R_swig_InfoNode_previous_get, 1},
   {"R_swig_InfomapParentIterator_previous_get", (DL_FUNC) &R_swig_InfomapParentIterator_previous_get, 1},
   {"R_swig_Config_outputFormats_get", (DL_FUNC) &R_swig_Config_outputFormats_get, 2},
   {"R_swig_DeltaFlow_deltaExit_get", (DL_FUNC) &R_swig_DeltaFlow_deltaExit_get, 2},
   {"R_swig_InfomapIterator_stateId_get", (DL_FUNC) &R_swig_InfomapIterator_stateId_get, 2},
   {"R_swig_InfoNode_stateId_get", (DL_FUNC) &R_swig_InfoNode_stateId_get, 2},
   {"R_swig_InfomapParentIterator_stateId_get", (DL_FUNC) &R_swig_InfomapParentIterator_stateId_get, 2},
   {"R_swig_InfomapLeafIteratorPhysical_current_SWIG_0_1", (DL_FUNC) &R_swig_InfomapLeafIteratorPhysical_current_SWIG_0_1, 1},
   {"R_swig_InfomapLeafIteratorPhysical_current_SWIG_0_0", (DL_FUNC) &R_swig_InfomapLeafIteratorPhysical_current_SWIG_0_0, 1},
   {"R_swig_Config_zeroBasedNodeNumbers_get", (DL_FUNC) &R_swig_Config_zeroBasedNodeNumbers_get, 2},
   {"R_swig_Config_originallyUndirected_get", (DL_FUNC) &R_swig_Config_originallyUndirected_get, 2},
   {"R_swig_Config_directed_get", (DL_FUNC) &R_swig_Config_directed_get, 2},
   {"R_swig_Config_hardPartitions_get", (DL_FUNC) &R_swig_Config_hardPartitions_get, 2},
   {"R_swig_Config_numMetaDataDimensions_get", (DL_FUNC) &R_swig_Config_numMetaDataDimensions_get, 2},
   {"R_swig_Config_parsedOptions_get", (DL_FUNC) &R_swig_Config_parsedOptions_get, 1},
   {"R_swig_InfomapConfigInfomapBase_setMarkovTime", (DL_FUNC) &R_swig_InfomapConfigInfomapBase_setMarkovTime, 3},
   {"R_swig_Config_parseWithoutIOStreams_get", (DL_FUNC) &R_swig_Config_parseWithoutIOStreams_get, 2},
   {"R_swig_Config_numTrials_get", (DL_FUNC) &R_swig_Config_numTrials_get, 2},
   {"R_swig_Triple_n3_get", (DL_FUNC) &R_swig_Triple_n3_get, 2},
   {"R_swig_FlowModel_value_get", (DL_FUNC) &R_swig_FlowModel_value_get, 2},
   {"R_swig_OptimizationLevel_value_get", (DL_FUNC) &R_swig_OptimizationLevel_value_get, 2},
   {"R_swig_InfomapBase_findTopModulesRepeatedly", (DL_FUNC) &R_swig_InfomapBase_findTopModulesRepeatedly, 2},
   {"R_swig_Config_directedEdges_get", (DL_FUNC) &R_swig_Config_directedEdges_get, 2},
   {"R_swig_InfomapLeafIterator_path", (DL_FUNC) &R_swig_InfomapLeafIterator_path, 2},
   {"R_swig_InfomapLeafModuleIterator_path", (DL_FUNC) &R_swig_InfomapLeafModuleIterator_path, 2},
   {"R_swig_InfomapModuleIterator_path", (DL_FUNC) &R_swig_InfomapModuleIterator_path, 2},
   {"R_swig_InfomapIterator_path", (DL_FUNC) &R_swig_InfomapIterator_path, 2},
   {"R_swig_InfomapIterator__next_get", (DL_FUNC) &R_swig_InfomapIterator__next_get, 1},
   {"R_swig_InfoNode__next_get", (DL_FUNC) &R_swig_InfoNode__next_get, 1},
   {"R_swig_InfomapParentIterator__next_get", (DL_FUNC) &R_swig_InfomapParentIterator__next_get, 1},
   {"R_swig_Config_maxNodeIndexVisible_get", (DL_FUNC) &R_swig_Config_maxNodeIndexVisible_get, 2},
   {"R_swig_StateNetwork_sumLinkWeight", (DL_FUNC) &R_swig_StateNetwork_sumLinkWeight, 2},
   {"R_swig_StateNetwork_sumSelfLinkWeight", (DL_FUNC) &R_swig_StateNetwork_sumSelfLinkWeight, 2},
   {"R_swig_delete_Weight", (DL_FUNC) &R_swig_delete_Weight, 1},
   {"R_swig_Config_is3gram", (DL_FUNC) &R_swig_Config_is3gram, 2},
   {"R_swig_InfomapLeafIteratorPhysical_path", (DL_FUNC) &R_swig_InfomapLeafIteratorPhysical_path, 2},
   {"R_swig_InfomapIteratorPhysical_path", (DL_FUNC) &R_swig_InfomapIteratorPhysical_path, 2},
   {"R_swig_Config_setMemoryInput", (DL_FUNC) &R_swig_Config_setMemoryInput, 1},
   {"R_swig_StateNetwork_haveMemoryInput", (DL_FUNC) &R_swig_StateNetwork_haveMemoryInput, 2},
   {"R_swig_Config_multilayerRelaxLimitUp_set", (DL_FUNC) &R_swig_Config_multilayerRelaxLimitUp_set, 2},
   {"R_swig_Config_clusterDataIsHard_get", (DL_FUNC) &R_swig_Config_clusterDataIsHard_get, 2},
   {"R_swig_InfomapParentIterator_PlusPlusPostfix", (DL_FUNC) &R_swig_InfomapParentIterator_PlusPlusPostfix, 3},
   {"R_swig_InfomapLeafIteratorPhysical_PlusPlusPostfix", (DL_FUNC) &R_swig_InfomapLeafIteratorPhysical_PlusPlusPostfix, 3},
   {"R_swig_InfomapIteratorPhysical_PlusPlusPostfix", (DL_FUNC) &R_swig_InfomapIteratorPhysical_PlusPlusPostfix, 3},
   {"R_swig_InfomapLeafIterator_PlusPlusPostfix", (DL_FUNC) &R_swig_InfomapLeafIterator_PlusPlusPostfix, 3},
   {"R_swig_InfomapLeafModuleIterator_PlusPlusPostfix", (DL_FUNC) &R_swig_InfomapLeafModuleIterator_PlusPlusPostfix, 3},
   {"R_swig_InfomapModuleIterator_PlusPlusPostfix", (DL_FUNC) &R_swig_InfomapModuleIterator_PlusPlusPostfix, 3},
   {"R_swig_InfomapIterator_PlusPlusPostfix", (DL_FUNC) &R_swig_InfomapIterator_PlusPlusPostfix, 3},
   {"R_swig_Config_haveModularResultOutput", (DL_FUNC) &R_swig_Config_haveModularResultOutput, 2},
   {"R_swig_new_FlowModel", (DL_FUNC) &R_swig_new_FlowModel, 1},
   {"R_swig_delete_FlowModel", (DL_FUNC) &R_swig_delete_FlowModel, 1},
   {"R_swig_InfomapBase_codelengths", (DL_FUNC) &R_swig_InfomapBase_codelengths, 2},
   {"R_swig_Config_printFlowTree_get", (DL_FUNC) &R_swig_Config_printFlowTree_get, 2},
   {"R_swig_Config_printTree_get", (DL_FUNC) &R_swig_Config_printTree_get, 2},
   {"R_swig_Config_printBinaryTree_get", (DL_FUNC) &R_swig_Config_printBinaryTree_get, 2},
   {"R_swig_Config_printBinaryFlowTree_get", (DL_FUNC) &R_swig_Config_printBinaryFlowTree_get, 2},
   {"R_swig_delete_InfoNode", (DL_FUNC) &R_swig_delete_InfoNode, 1},
   {"R_swig_InfomapIterator_parent_get", (DL_FUNC) &R_swig_InfomapIterator_parent_get, 1},
   {"R_swig_Config_minimumCodelengthImprovement_get", (DL_FUNC) &R_swig_Config_minimumCodelengthImprovement_get, 2},
   {"R_swig_Config_silent_get", (DL_FUNC) &R_swig_Config_silent_get, 2},
   {"R_swig_DeltaFlow_count_get", (DL_FUNC) &R_swig_DeltaFlow_count_get, 2},
   {"R_swig_InfoNode_parent_get", (DL_FUNC) &R_swig_InfoNode_parent_get, 1},
   {"R_swig_InfomapParentIterator_parent_get", (DL_FUNC) &R_swig_InfomapParentIterator_parent_get, 1},
   {"R_swig_Bigram_second_get", (DL_FUNC) &R_swig_Bigram_second_get, 2},
   {"R_swig_InfoNode_replaceChildrenWithGrandChildrenDebug", (DL_FUNC) &R_swig_InfoNode_replaceChildrenWithGrandChildrenDebug, 1},
   {"R_swig_InfomapParentIterator_replaceWithChildrenDebug", (DL_FUNC) &R_swig_InfomapParentIterator_replaceWithChildrenDebug, 1},
   {"R_swig_InfomapIterator_collapsedLastChild_get", (DL_FUNC) &R_swig_InfomapIterator_collapsedLastChild_get, 1},
   {"R_swig_InfomapIterator_collapsedFirstChild_get", (DL_FUNC) &R_swig_InfomapIterator_collapsedFirstChild_get, 1},
   {"R_swig_InfomapIterator_lastChild_get", (DL_FUNC) &R_swig_InfomapIterator_lastChild_get, 1},
   {"R_swig_InfomapIterator_firstChild_get", (DL_FUNC) &R_swig_InfomapIterator_firstChild_get, 1},
   {"R_swig_InfoNode_collapsedLastChild_get", (DL_FUNC) &R_swig_InfoNode_collapsedLastChild_get, 1},
   {"R_swig_InfoNode_collapsedFirstChild_get", (DL_FUNC) &R_swig_InfoNode_collapsedFirstChild_get, 1},
   {"R_swig_Config_weightThreshold_get", (DL_FUNC) &R_swig_Config_weightThreshold_get, 2},
   {"R_swig_InfoNode_firstChild_get", (DL_FUNC) &R_swig_InfoNode_firstChild_get, 1},
   {"R_swig_InfoNode_lastChild_get", (DL_FUNC) &R_swig_InfoNode_lastChild_get, 1},
   {"R_swig_InfomapParentIterator_firstChild_get", (DL_FUNC) &R_swig_InfomapParentIterator_firstChild_get, 1},
   {"R_swig_InfomapParentIterator_lastChild_get", (DL_FUNC) &R_swig_InfomapParentIterator_lastChild_get, 1},
   {"R_swig_Config_superLevelLimit_get", (DL_FUNC) &R_swig_Config_superLevelLimit_get, 2},
   {"R_swig_Config_tuneIterationLimit_get", (DL_FUNC) &R_swig_Config_tuneIterationLimit_get, 2},
   {"R_swig_Config_levelAggregationLimit_get", (DL_FUNC) &R_swig_Config_levelAggregationLimit_get, 2},
   {"R_swig_Config_coreLoopLimit_get", (DL_FUNC) &R_swig_Config_coreLoopLimit_get, 2},
   {"R_swig_Config_randomizeCoreLoopLimit_get", (DL_FUNC) &R_swig_Config_randomizeCoreLoopLimit_get, 2},
   {"R_swig_Config_multilayerJSRelaxLimit_get", (DL_FUNC) &R_swig_Config_multilayerJSRelaxLimit_get, 2},
   {"R_swig_Config_multilayerRelaxLimit_get", (DL_FUNC) &R_swig_Config_multilayerRelaxLimit_get, 2},
   {"R_swig_Config_nodeLimit_get", (DL_FUNC) &R_swig_Config_nodeLimit_get, 2},
   {"R_swig_InfomapIterator_layerId_get", (DL_FUNC) &R_swig_InfomapIterator_layerId_get, 2},
   {"R_swig_InfomapIterator_physicalId_get", (DL_FUNC) &R_swig_InfomapIterator_physicalId_get, 2},
   {"R_swig_InfoNode_physicalId_get", (DL_FUNC) &R_swig_InfoNode_physicalId_get, 2},
   {"R_swig_InfoNode_layerId_get", (DL_FUNC) &R_swig_InfoNode_layerId_get, 2},
   {"R_swig_vector_uint___len__", (DL_FUNC) &R_swig_vector_uint___len__, 2},
   {"R_swig_InfomapParentIterator_physicalId_get", (DL_FUNC) &R_swig_InfomapParentIterator_physicalId_get, 2},
   {"R_swig_InfomapParentIterator_layerId_get", (DL_FUNC) &R_swig_InfomapParentIterator_layerId_get, 2},
   {"R_swig_vector_double___len__", (DL_FUNC) &R_swig_vector_double___len__, 2},
   {"R_swig_Weight_weight_get", (DL_FUNC) &R_swig_Weight_weight_get, 2},
   {"R_swig_PartitionQueue_skip_set", (DL_FUNC) &R_swig_PartitionQueue_skip_set, 2},
   {"R_swig_InfomapIterator_firstDepthBelow", (DL_FUNC) &R_swig_InfomapIterator_firstDepthBelow, 2},
   {"R_swig_InfoNode_firstDepthBelow", (DL_FUNC) &R_swig_InfoNode_firstDepthBelow, 2},
   {"R_swig_InfomapParentIterator_firstDepthBelow", (DL_FUNC) &R_swig_InfomapParentIterator_firstDepthBelow, 2},
   {"R_swig_delete_FlowData", (DL_FUNC) &R_swig_delete_FlowData, 1},
   {"R_swig_Config_isBipartite", (DL_FUNC) &R_swig_Config_isBipartite, 2},
   {"R_swig_InfomapIterator_moduleIndex", (DL_FUNC) &R_swig_InfomapIterator_moduleIndex, 2},
   {"R_swig_StateNetwork_isBipartite", (DL_FUNC) &R_swig_StateNetwork_isBipartite, 2},
   {"R_swig_InfoNode_id", (DL_FUNC) &R_swig_InfoNode_id, 2},
   {"R_swig_InfomapLeafIteratorPhysical_childIndex", (DL_FUNC) &R_swig_InfomapLeafIteratorPhysical_childIndex, 2},
   {"R_swig_InfomapIteratorPhysical_childIndex", (DL_FUNC) &R_swig_InfomapIteratorPhysical_childIndex, 2},
   {"R_swig_InfomapLeafIterator_childIndex", (DL_FUNC) &R_swig_InfomapLeafIterator_childIndex, 2},
   {"R_swig_InfomapLeafModuleIterator_childIndex", (DL_FUNC) &R_swig_InfomapLeafModuleIterator_childIndex, 2},
   {"R_swig_InfomapModuleIterator_childIndex", (DL_FUNC) &R_swig_InfomapModuleIterator_childIndex, 2},
   {"R_swig_InfomapIterator_childIndex", (DL_FUNC) &R_swig_InfomapIterator_childIndex, 2},
   {"R_swig_InfoNode_childIndex", (DL_FUNC) &R_swig_InfoNode_childIndex, 2},
   {"R_swig_InfomapParentIterator_childIndex", (DL_FUNC) &R_swig_InfomapParentIterator_childIndex, 2},
   {"R_swig_Config_seedToRandomNumberGenerator_set", (DL_FUNC) &R_swig_Config_seedToRandomNumberGenerator_set, 2},
   {"R_swig_Config_error_set", (DL_FUNC) &R_swig_Config_error_set, 2},
   {"R_swig_Config_inputFormat_get", (DL_FUNC) &R_swig_Config_inputFormat_get, 2},
   {"R_swig_InfomapIteratorPhysical_current_SWIG_0_0", (DL_FUNC) &R_swig_InfomapIteratorPhysical_current_SWIG_0_0, 1},
   {"R_swig_InfomapLeafIterator_current_SWIG_0_0", (DL_FUNC) &R_swig_InfomapLeafIterator_current_SWIG_0_0, 1},
   {"R_swig_InfomapLeafModuleIterator_current_SWIG_0_0", (DL_FUNC) &R_swig_InfomapLeafModuleIterator_current_SWIG_0_0, 1},
   {"R_swig_InfomapModuleIterator_current_SWIG_0_0", (DL_FUNC) &R_swig_InfomapModuleIterator_current_SWIG_0_0, 1},
   {"R_swig_InfomapIterator_begin_leaf_nodes", (DL_FUNC) &R_swig_InfomapIterator_begin_leaf_nodes, 2},
   {"R_swig_InfoNode_begin_leaf_nodes", (DL_FUNC) &R_swig_InfoNode_begin_leaf_nodes, 2},
   {"R_swig_InfomapParentIterator_begin_leaf_nodes", (DL_FUNC) &R_swig_InfomapParentIterator_begin_leaf_nodes, 2},
   {"R_swig_InfomapWrapper_run_SWIG_0_0", (DL_FUNC) &R_swig_InfomapWrapper_run_SWIG_0_0, 2},
   {"R_swig_InfomapWrapper_iterTree_SWIG_0_0", (DL_FUNC) &R_swig_InfomapWrapper_iterTree_SWIG_0_0, 3},
   {"R_swig_InfomapWrapper_iterLeafNodes_SWIG_0_0", (DL_FUNC) &R_swig_InfomapWrapper_iterLeafNodes_SWIG_0_0, 3},
   {"R_swig_InfomapIteratorPhysical_current_SWIG_0_1", (DL_FUNC) &R_swig_InfomapIteratorPhysical_current_SWIG_0_1, 1},
   {"R_swig_InfomapLeafIterator_current_SWIG_0_1", (DL_FUNC) &R_swig_InfomapLeafIterator_current_SWIG_0_1, 1},
   {"R_swig_InfomapLeafModuleIterator_current_SWIG_0_1", (DL_FUNC) &R_swig_InfomapLeafModuleIterator_current_SWIG_0_1, 1},
   {"R_swig_InfomapModuleIterator_current_SWIG_0_1", (DL_FUNC) &R_swig_InfomapModuleIterator_current_SWIG_0_1, 1},
   {"R_swig_InfomapWrapper_run_SWIG_0_1", (DL_FUNC) &R_swig_InfomapWrapper_run_SWIG_0_1, 1},
   {"R_swig_InfomapWrapper_iterTree_SWIG_0_1", (DL_FUNC) &R_swig_InfomapWrapper_iterTree_SWIG_0_1, 2},
   {"R_swig_InfomapWrapper_iterLeafNodes_SWIG_0_1", (DL_FUNC) &R_swig_InfomapWrapper_iterLeafNodes_SWIG_0_1, 2},
   {"R_swig_InfomapWrapper_run_SWIG_0_2", (DL_FUNC) &R_swig_InfomapWrapper_run_SWIG_0_2, 2},
   {"R_swig_Config_multilayerJSRelaxRate_get", (DL_FUNC) &R_swig_Config_multilayerJSRelaxRate_get, 2},
   {"R_swig_Config_multilayerRelaxRate_get", (DL_FUNC) &R_swig_Config_multilayerRelaxRate_get, 2},
   {"R_swig_Config_bipartite_get", (DL_FUNC) &R_swig_Config_bipartite_get, 2},
   {"R_swig_Config_metaDataRate_get", (DL_FUNC) &R_swig_Config_metaDataRate_get, 2},
   {"R_swig_Config_startDate_get", (DL_FUNC) &R_swig_Config_startDate_get, 2},
   {"R_swig_Config_noInfomap_set", (DL_FUNC) &R_swig_Config_noInfomap_set, 2},
   {"R_swig_Config_printMap_set", (DL_FUNC) &R_swig_Config_printMap_set, 2},
   {"R_swig_InfomapBase_initTree", (DL_FUNC) &R_swig_InfomapBase_initTree, 3},
   {"R_swig_InfomapConfigInfomapBase_setFastHierarchicalSolution", (DL_FUNC) &R_swig_InfomapConfigInfomapBase_setFastHierarchicalSolution, 3},
   {"R_swig_Config_undirdir_set", (DL_FUNC) &R_swig_Config_undirdir_set, 2},
   {"R_swig_Config_outdirdir_set", (DL_FUNC) &R_swig_Config_outdirdir_set, 2},
   {"R_swig_Config_rawdir_set", (DL_FUNC) &R_swig_Config_rawdir_set, 2},
   {"R_swig_InfomapIterator_metaData_set", (DL_FUNC) &R_swig_InfomapIterator_metaData_set, 2},
   {"R_swig_InfomapIterator_data_set", (DL_FUNC) &R_swig_InfomapIterator_data_set, 2},
   {"R_swig_Config_unweightedMetaData_set", (DL_FUNC) &R_swig_Config_unweightedMetaData_set, 2},
   {"R_swig_InfoNode_data_set", (DL_FUNC) &R_swig_InfoNode_data_set, 2},
   {"R_swig_InfoNode_metaData_set", (DL_FUNC) &R_swig_InfoNode_metaData_set, 2},
   {"R_swig_InfomapParentIterator_data_set", (DL_FUNC) &R_swig_InfomapParentIterator_data_set, 2},
   {"R_swig_InfomapParentIterator_metaData_set", (DL_FUNC) &R_swig_InfomapParentIterator_metaData_set, 2},
   {"R_swig_Config_noCoarseTune_get", (DL_FUNC) &R_swig_Config_noCoarseTune_get, 2},
   {"R_swig_InfomapIterator_owner_set", (DL_FUNC) &R_swig_InfomapIterator_owner_set, 2},
   {"R_swig_Config_pathMarkovOrder_set", (DL_FUNC) &R_swig_Config_pathMarkovOrder_set, 2},
   {"R_swig_DeltaFlow_deltaEnter_set", (DL_FUNC) &R_swig_DeltaFlow_deltaEnter_set, 2},
   {"R_swig_InfoNode_owner_set", (DL_FUNC) &R_swig_InfoNode_owner_set, 2},
   {"R_swig_InfomapParentIterator_owner_set", (DL_FUNC) &R_swig_InfomapParentIterator_owner_set, 2},
   {"R_swig_Network_addMultilayerIntraLink", (DL_FUNC) &R_swig_Network_addMultilayerIntraLink, 5},
   {"R_swig_BipartiteLink_swapOrder_set", (DL_FUNC) &R_swig_BipartiteLink_swapOrder_set, 2},
   {"R_swig_Config_outName_get", (DL_FUNC) &R_swig_Config_outName_get, 2},
   {"R_swig_Config_markovTime_get", (DL_FUNC) &R_swig_Config_markovTime_get, 2},
   {"R_swig_Config_printClu_get", (DL_FUNC) &R_swig_Config_printClu_get, 2},
   {"R_swig_Config_networkFile_get", (DL_FUNC) &R_swig_Config_networkFile_get, 2},
   {"R_swig_Config_clusterDataFile_get", (DL_FUNC) &R_swig_Config_clusterDataFile_get, 2},
   {"R_swig_Config_metaDataFile_get", (DL_FUNC) &R_swig_Config_metaDataFile_get, 2},
   {"R_swig_Config_assignToNeighbouringModule_get", (DL_FUNC) &R_swig_Config_assignToNeighbouringModule_get, 2},
   {"R_swig_DeltaFlow_module_get", (DL_FUNC) &R_swig_DeltaFlow_module_get, 2},
   {"R_swig_Triple_n1_set", (DL_FUNC) &R_swig_Triple_n1_set, 2},
   {"R_swig_InfomapConfigInfomapBase_setNoCoarseTune", (DL_FUNC) &R_swig_InfomapConfigInfomapBase_setNoCoarseTune, 3},
   {"R_swig_InfomapBase_coarseTune", (DL_FUNC) &R_swig_InfomapBase_coarseTune, 2},
   {"R_swig_deque_uint_empty", (DL_FUNC) &R_swig_deque_uint_empty, 2},
   {"R_swig_vector_uint_empty", (DL_FUNC) &R_swig_vector_uint_empty, 2},
   {"R_swig_map_uint_uint_empty", (DL_FUNC) &R_swig_map_uint_uint_empty, 2},
   {"R_swig_map_uint_vector_uint_empty", (DL_FUNC) &R_swig_map_uint_vector_uint_empty, 2},
   {"R_swig_Config_ignoreEdgeWeights_set", (DL_FUNC) &R_swig_Config_ignoreEdgeWeights_set, 2},
   {"R_swig_Config_useNodeWeightsAsFlow_get", (DL_FUNC) &R_swig_Config_useNodeWeightsAsFlow_get, 2},
   {"R_swig_Config_skipAdjustBipartiteFlow_get", (DL_FUNC) &R_swig_Config_skipAdjustBipartiteFlow_get, 2},
   {"R_swig_FlowData_flow_get", (DL_FUNC) &R_swig_FlowData_flow_get, 2},
   {"R_swig_FlowData_enterFlow_get", (DL_FUNC) &R_swig_FlowData_enterFlow_get, 2},
   {"R_swig_FlowData_exitFlow_get", (DL_FUNC) &R_swig_FlowData_exitFlow_get, 2},
   {"R_swig_MemDeltaFlow_sumDeltaPlogpPhysFlow_get", (DL_FUNC) &R_swig_MemDeltaFlow_sumDeltaPlogpPhysFlow_get, 2},
   {"R_swig_MemDeltaFlow_sumPlogpPhysFlow_get", (DL_FUNC) &R_swig_MemDeltaFlow_sumPlogpPhysFlow_get, 2},
   {"R_swig_StateNetwork_outWeights", (DL_FUNC) &R_swig_StateNetwork_outWeights, 2},
   {"R_swig_PartitionQueue_flow_get", (DL_FUNC) &R_swig_PartitionQueue_flow_get, 2},
   {"R_swig_PartitionQueue_nonTrivialFlow_get", (DL_FUNC) &R_swig_PartitionQueue_nonTrivialFlow_get, 2},
   {"R_swig_MemNodeSet_sumFlow_get", (DL_FUNC) &R_swig_MemNodeSet_sumFlow_get, 2},
   {"R_swig_InfomapIterator_disposeInfomap", (DL_FUNC) &R_swig_InfomapIterator_disposeInfomap, 2},
   {"R_swig_InfomapIterator_setInfomap", (DL_FUNC) &R_swig_InfomapIterator_setInfomap, 3},
   {"R_swig_InfomapIterator_getInfomap", (DL_FUNC) &R_swig_InfomapIterator_getInfomap, 2},
   {"R_swig_InfoNode_disposeInfomap", (DL_FUNC) &R_swig_InfoNode_disposeInfomap, 2},
   {"R_swig_InfoNode_setInfomap", (DL_FUNC) &R_swig_InfoNode_setInfomap, 3},
   {"R_swig_InfoNode_getInfomap", (DL_FUNC) &R_swig_InfoNode_getInfomap, 2},
   {"R_swig_InfomapParentIterator_getInfomap", (DL_FUNC) &R_swig_InfomapParentIterator_getInfomap, 2},
   {"R_swig_InfomapParentIterator_setInfomap", (DL_FUNC) &R_swig_InfomapParentIterator_setInfomap, 3},
   {"R_swig_InfomapParentIterator_disposeInfomap", (DL_FUNC) &R_swig_InfomapParentIterator_disposeInfomap, 2},
   {"R_swig_InfomapBase_getSubInfomap", (DL_FUNC) &R_swig_InfomapBase_getSubInfomap, 3},
   {"R_swig_InfomapBase_getSuperInfomap", (DL_FUNC) &R_swig_InfomapBase_getSuperInfomap, 3},
   {"R_swig_InfomapBase_isMainInfomap", (DL_FUNC) &R_swig_InfomapBase_isMainInfomap, 2},
   {"R_swig_PhysData_sumFlowFromM2Node_get", (DL_FUNC) &R_swig_PhysData_sumFlowFromM2Node_get, 2},
   {"R_swig_LayerNode_node_get", (DL_FUNC) &R_swig_LayerNode_node_get, 2},
   {"R_swig_BipartiteLink_featureNode_get", (DL_FUNC) &R_swig_BipartiteLink_featureNode_get, 2},
   {"R_swig_BipartiteLink_node_get", (DL_FUNC) &R_swig_BipartiteLink_node_get, 2},
   {"R_swig_StateNetwork_numNodes", (DL_FUNC) &R_swig_StateNetwork_numNodes, 2},
   {"R_swig_PerLevelStat_numNodes", (DL_FUNC) &R_swig_PerLevelStat_numNodes, 2},
   {"R_swig_InfomapParentIterator_begin_post_depth_first", (DL_FUNC) &R_swig_InfomapParentIterator_begin_post_depth_first, 2},
   {"R_swig_InfomapIterator_numPhysicalNodes", (DL_FUNC) &R_swig_InfomapIterator_numPhysicalNodes, 2},
   {"R_swig_InfoNode_numPhysicalNodes", (DL_FUNC) &R_swig_InfoNode_numPhysicalNodes, 2},
   {"R_swig_InfomapParentIterator_numPhysicalNodes", (DL_FUNC) &R_swig_InfomapParentIterator_numPhysicalNodes, 2},
   {"R_swig_StateNetwork_numPhysicalNodes", (DL_FUNC) &R_swig_StateNetwork_numPhysicalNodes, 2},
   {"R_swig_Config_setMultilayerInput", (DL_FUNC) &R_swig_Config_setMultilayerInput, 1},
   {"R_swig_InfomapBase_getCodelength", (DL_FUNC) &R_swig_InfomapBase_getCodelength, 2},
   {"R_swig_InfomapBase_codelength", (DL_FUNC) &R_swig_InfomapBase_codelength, 2},
   {"R_swig_InfomapBase_getIndexCodelength", (DL_FUNC) &R_swig_InfomapBase_getIndexCodelength, 2},
   {"R_swig_InfomapBase_getModuleCodelength", (DL_FUNC) &R_swig_InfomapBase_getModuleCodelength, 2},
   {"R_swig_InfomapBase_getHierarchicalCodelength", (DL_FUNC) &R_swig_InfomapBase_getHierarchicalCodelength, 2},
   {"R_swig_InfomapBase_getOneLevelCodelength", (DL_FUNC) &R_swig_InfomapBase_getOneLevelCodelength, 2},
   {"R_swig_InfomapBase_calcCodelength", (DL_FUNC) &R_swig_InfomapBase_calcCodelength, 3},
   {"R_swig_InfomapBase_printPerLevelCodelength", (DL_FUNC) &R_swig_InfomapBase_printPerLevelCodelength, 3},
   {"R_swig_PerLevelStat_codelength", (DL_FUNC) &R_swig_PerLevelStat_codelength, 2},
   {"R_swig_MapEquation_getIndexCodelength", (DL_FUNC) &R_swig_MapEquation_getIndexCodelength, 2},
   {"R_swig_MapEquation_getModuleCodelength", (DL_FUNC) &R_swig_MapEquation_getModuleCodelength, 2},
   {"R_swig_MapEquation_getCodelength", (DL_FUNC) &R_swig_MapEquation_getCodelength, 2},
   {"R_swig_MapEquation_calcCodelength", (DL_FUNC) &R_swig_MapEquation_calcCodelength, 3},
   {"R_swig_MemMapEquation_getIndexCodelength", (DL_FUNC) &R_swig_MemMapEquation_getIndexCodelength, 2},
   {"R_swig_MemMapEquation_getModuleCodelength", (DL_FUNC) &R_swig_MemMapEquation_getModuleCodelength, 2},
   {"R_swig_MemMapEquation_getCodelength", (DL_FUNC) &R_swig_MemMapEquation_getCodelength, 2},
   {"R_swig_MemMapEquation_calcCodelength", (DL_FUNC) &R_swig_MemMapEquation_calcCodelength, 3},
   {"R_swig_MetaMapEquation_getIndexCodelength", (DL_FUNC) &R_swig_MetaMapEquation_getIndexCodelength, 2},
   {"R_swig_MetaMapEquation_getModuleCodelength", (DL_FUNC) &R_swig_MetaMapEquation_getModuleCodelength, 2},
   {"R_swig_MetaMapEquation_getCodelength", (DL_FUNC) &R_swig_MetaMapEquation_getCodelength, 2},
   {"R_swig_MetaMapEquation_calcCodelength", (DL_FUNC) &R_swig_MetaMapEquation_calcCodelength, 3},
   {"R_swig_InfomapCore_getCodelength", (DL_FUNC) &R_swig_InfomapCore_getCodelength, 2},
   {"R_swig_InfomapCore_getIndexCodelength", (DL_FUNC) &R_swig_InfomapCore_getIndexCodelength, 2},
   {"R_swig_InfomapCore_getModuleCodelength", (DL_FUNC) &R_swig_InfomapCore_getModuleCodelength, 2},
   {"R_swig_InfomapWrapper_codelength", (DL_FUNC) &R_swig_InfomapWrapper_codelength, 2},
   {"R_swig_Config_includeSelfLinks_set", (DL_FUNC) &R_swig_Config_includeSelfLinks_set, 2},
   {"R_swig_Config_printNodeRanks_set", (DL_FUNC) &R_swig_Config_printNodeRanks_set, 2},
   {"R_swig_InfomapIterator_setNumLeafNodes", (DL_FUNC) &R_swig_InfomapIterator_setNumLeafNodes, 2},
   {"R_swig_InfoNode_setNumLeafNodes", (DL_FUNC) &R_swig_InfoNode_setNumLeafNodes, 2},
   {"R_swig_InfomapParentIterator_setNumLeafNodes", (DL_FUNC) &R_swig_InfomapParentIterator_setNumLeafNodes, 2},
   {"R_swig_InfomapBase_numLeafNodes", (DL_FUNC) &R_swig_InfomapBase_numLeafNodes, 2},
   {"R_swig_InfomapBase_leafNodes", (DL_FUNC) &R_swig_InfomapBase_leafNodes, 2},
   {"R_swig_InfomapWrapper_getNames", (DL_FUNC) &R_swig_InfomapWrapper_getNames, 2},
   {"R_swig_Config_unweightedPaths_set", (DL_FUNC) &R_swig_Config_unweightedPaths_set, 2},
   {"R_swig_InfomapBase_numLevels", (DL_FUNC) &R_swig_InfomapBase_numLevels, 2},
   {"R_swig_InfomapIterator_stateNodes_set", (DL_FUNC) &R_swig_InfomapIterator_stateNodes_set, 2},
   {"R_swig_InfomapIterator_physicalNodes_set", (DL_FUNC) &R_swig_InfomapIterator_physicalNodes_set, 2},
   {"R_swig_InfoNode_stateNodes_set", (DL_FUNC) &R_swig_InfoNode_stateNodes_set, 2},
   {"R_swig_InfoNode_physicalNodes_set", (DL_FUNC) &R_swig_InfoNode_physicalNodes_set, 2},
   {"R_swig_Config_onlySuperModules_set", (DL_FUNC) &R_swig_Config_onlySuperModules_set, 2},
   {"R_swig_Config_preferredNumberOfModules_set", (DL_FUNC) &R_swig_Config_preferredNumberOfModules_set, 2},
   {"R_swig_Config_teleportToNodes_set", (DL_FUNC) &R_swig_Config_teleportToNodes_set, 2},
   {"R_swig_Config_hideBipartiteNodes_set", (DL_FUNC) &R_swig_Config_hideBipartiteNodes_set, 2},
   {"R_swig_InfomapParentIterator_physicalNodes_set", (DL_FUNC) &R_swig_InfomapParentIterator_physicalNodes_set, 2},
   {"R_swig_InfomapParentIterator_stateNodes_set", (DL_FUNC) &R_swig_InfomapParentIterator_stateNodes_set, 2},
   {"R_swig_PerLevelStat_numModules_set", (DL_FUNC) &R_swig_PerLevelStat_numModules_set, 2},
   {"R_swig_PerLevelStat_numLeafNodes_set", (DL_FUNC) &R_swig_PerLevelStat_numLeafNodes_set, 2},
   {"R_swig_PartitionQueue_numNonTrivialModules_set", (DL_FUNC) &R_swig_PartitionQueue_numNonTrivialModules_set, 2},
   {"R_swig_MemNodeSet_numMemNodes_set", (DL_FUNC) &R_swig_MemNodeSet_numMemNodes_set, 2},
   {"R_swig_StateNetwork_nodes", (DL_FUNC) &R_swig_StateNetwork_nodes, 2},
   {"R_swig_vector_double_pop", (DL_FUNC) &R_swig_vector_double_pop, 2},
   {"R_swig_Triple_n2_set", (DL_FUNC) &R_swig_Triple_n2_set, 2},
   {"R_swig_Config_multilayerInput_set", (DL_FUNC) &R_swig_Config_multilayerInput_set, 2},
   {"R_swig_Config_memoryInput_set", (DL_FUNC) &R_swig_Config_memoryInput_set, 2},
   {"R_swig_Config_additionalInput_set", (DL_FUNC) &R_swig_Config_additionalInput_set, 2},
   {"R_swig_Config_noFileOutput_set", (DL_FUNC) &R_swig_Config_noFileOutput_set, 2},
   {"R_swig_StateNetwork_haveDirectedInput", (DL_FUNC) &R_swig_StateNetwork_haveDirectedInput, 2},
   {"R_swig_Bigram_first_set", (DL_FUNC) &R_swig_Bigram_first_set, 2},
   {"R_swig_Config_preClusterMultilayer_set", (DL_FUNC) &R_swig_Config_preClusterMultilayer_set, 2},
   {"R_swig_LayerNode_layer_set", (DL_FUNC) &R_swig_LayerNode_layer_set, 2},
   {"R_swig_InfomapBase_aggregatePerLevelCodelength__SWIG_0", (DL_FUNC) &R_swig_InfomapBase_aggregatePerLevelCodelength__SWIG_0, 3},
   {"R_swig_InfomapBase_aggregatePerLevelCodelength__SWIG_1", (DL_FUNC) &R_swig_InfomapBase_aggregatePerLevelCodelength__SWIG_1, 2},
   {"R_swig_InfomapBase_aggregatePerLevelCodelength__SWIG_2", (DL_FUNC) &R_swig_InfomapBase_aggregatePerLevelCodelength__SWIG_2, 4},
   {"R_swig_InfomapBase_printDebug", (DL_FUNC) &R_swig_InfomapBase_printDebug, 1},
   {"R_swig_MapEquation_printDebug", (DL_FUNC) &R_swig_MapEquation_printDebug, 1},
   {"R_swig_MemMapEquation_printDebug", (DL_FUNC) &R_swig_MemMapEquation_printDebug, 1},
   {"R_swig_MetaMapEquation_printDebug", (DL_FUNC) &R_swig_MetaMapEquation_printDebug, 1},
   {"R_swig_vector_uint_pop", (DL_FUNC) &R_swig_vector_uint_pop, 2},
   {"R_swig_Network_addMultilayerInterLink", (DL_FUNC) &R_swig_Network_addMultilayerInterLink, 5},
   {"R_swig_Config_cloneAsNonMain", (DL_FUNC) &R_swig_Config_cloneAsNonMain, 3},
   {"R_swig_InfomapIterator_previous_set", (DL_FUNC) &R_swig_InfomapIterator_previous_set, 2},
   {"R_swig_InfoNode_previous_set", (DL_FUNC) &R_swig_InfoNode_previous_set, 2},
   {"R_swig_InfomapParentIterator_previous_set", (DL_FUNC) &R_swig_InfomapParentIterator_previous_set, 2},
   {"R_swig_vector_double_empty", (DL_FUNC) &R_swig_vector_double_empty, 2},
   {"R_swig_map_uint_string_empty", (DL_FUNC) &R_swig_map_uint_string_empty, 2},
   {"R_swig_Config_isPath", (DL_FUNC) &R_swig_Config_isPath, 2},
   {"R_swig_Config_outputFormats_set", (DL_FUNC) &R_swig_Config_outputFormats_set, 2},
   {"R_swig_DeltaFlow_deltaExit_set", (DL_FUNC) &R_swig_DeltaFlow_deltaExit_set, 2},
   {"R_swig_InfomapIterator_stateId_set", (DL_FUNC) &R_swig_InfomapIterator_stateId_set, 2},
   {"R_swig_InfoNode_stateId_set", (DL_FUNC) &R_swig_InfoNode_stateId_set, 2},
   {"R_swig_InfomapParentIterator_stateId_set", (DL_FUNC) &R_swig_InfomapParentIterator_stateId_set, 2},
   {"R_swig_InfomapIterator_index_get", (DL_FUNC) &R_swig_InfomapIterator_index_get, 2},
   {"R_swig_Config_minBipartiteNodeIndex_get", (DL_FUNC) &R_swig_Config_minBipartiteNodeIndex_get, 2},
   {"R_swig_PhysData_physNodeIndex_get", (DL_FUNC) &R_swig_PhysData_physNodeIndex_get, 2},
   {"R_swig_InfoNode_index_get", (DL_FUNC) &R_swig_InfoNode_index_get, 2},
   {"R_swig_InfomapParentIterator_index_get", (DL_FUNC) &R_swig_InfomapParentIterator_index_get, 2},
   {"R_swig_InfomapConfigInfomapBase_setVerbosity", (DL_FUNC) &R_swig_InfomapConfigInfomapBase_setVerbosity, 3},
   {"R_swig_Config_zeroBasedNodeNumbers_set", (DL_FUNC) &R_swig_Config_zeroBasedNodeNumbers_set, 2},
   {"R_swig_Network_generateStateNetworkFromMultilayer", (DL_FUNC) &R_swig_Network_generateStateNetworkFromMultilayer, 1},
   {"R_swig_InfomapBase_fineTune", (DL_FUNC) &R_swig_InfomapBase_fineTune, 2},
   {"R_swig_Config_parsedString_get", (DL_FUNC) &R_swig_Config_parsedString_get, 2},
   {"R_swig_InfomapBase_haveHardPartition", (DL_FUNC) &R_swig_InfomapBase_haveHardPartition, 2},
   {"R_swig_InfomapBase_getInitialPartition", (DL_FUNC) &R_swig_InfomapBase_getInitialPartition, 2},
   {"R_swig_InfomapBase_setInitialPartition", (DL_FUNC) &R_swig_InfomapBase_setInitialPartition, 3},
   {"R_swig_InfomapBase_runPartition", (DL_FUNC) &R_swig_InfomapBase_runPartition, 1},
   {"R_swig_InfomapBase_restoreHardPartition", (DL_FUNC) &R_swig_InfomapBase_restoreHardPartition, 1},
   {"R_swig_InfomapBase_hierarchicalPartition", (DL_FUNC) &R_swig_InfomapBase_hierarchicalPartition, 1},
   {"R_swig_InfomapBase_partition", (DL_FUNC) &R_swig_InfomapBase_partition, 1},
   {"R_swig_InfomapBase_recursivePartition", (DL_FUNC) &R_swig_InfomapBase_recursivePartition, 2},
   {"R_swig_MapEquation_initPartition", (DL_FUNC) &R_swig_MapEquation_initPartition, 2},
   {"R_swig_MemMapEquation_initPartition", (DL_FUNC) &R_swig_MemMapEquation_initPartition, 2},
   {"R_swig_MetaMapEquation_initPartition", (DL_FUNC) &R_swig_MetaMapEquation_initPartition, 2},
   {"R_swig_Config_originallyUndirected_set", (DL_FUNC) &R_swig_Config_originallyUndirected_set, 2},
   {"R_swig_Config_directed_set", (DL_FUNC) &R_swig_Config_directed_set, 2},
   {"R_swig_Config_hardPartitions_set", (DL_FUNC) &R_swig_Config_hardPartitions_set, 2},
   {"R_swig_Config_numMetaDataDimensions_set", (DL_FUNC) &R_swig_Config_numMetaDataDimensions_set, 2},
   {"R_swig_Config_parsedOptions_set", (DL_FUNC) &R_swig_Config_parsedOptions_set, 2},
   {"R_swig_InfomapIterator_dirty_get", (DL_FUNC) &R_swig_InfomapIterator_dirty_get, 2},
   {"R_swig_InfoNode_dirty_get", (DL_FUNC) &R_swig_InfoNode_dirty_get, 2},
   {"R_swig_Config_parseWithoutIOStreams_set", (DL_FUNC) &R_swig_Config_parseWithoutIOStreams_set, 2},
   {"R_swig_InfomapParentIterator_dirty_get", (DL_FUNC) &R_swig_InfomapParentIterator_dirty_get, 2},
   {"R_swig_Config_numTrials_set", (DL_FUNC) &R_swig_Config_numTrials_set, 2},
   {"R_swig_Triple_n3_set", (DL_FUNC) &R_swig_Triple_n3_set, 2},
   {"R_swig_FlowModel_value_set", (DL_FUNC) &R_swig_FlowModel_value_set, 2},
   {"R_swig_OptimizationLevel_value_set", (DL_FUNC) &R_swig_OptimizationLevel_value_set, 2},
   {"R_swig_delete_InfomapWrapper", (DL_FUNC) &R_swig_delete_InfomapWrapper, 1},
   {"R_swig_delete_map_uint_uint", (DL_FUNC) &R_swig_delete_map_uint_uint, 1},
   {"R_swig_Network_numMetaDataColumns", (DL_FUNC) &R_swig_Network_numMetaDataColumns, 2},
   {"R_swig_InfomapIterator_end_inEdge", (DL_FUNC) &R_swig_InfomapIterator_end_inEdge, 2},
   {"R_swig_InfomapIterator_begin_inEdge", (DL_FUNC) &R_swig_InfomapIterator_begin_inEdge, 2},
   {"R_swig_InfoNode_end_inEdge", (DL_FUNC) &R_swig_InfoNode_end_inEdge, 2},
   {"R_swig_InfoNode_begin_inEdge", (DL_FUNC) &R_swig_InfoNode_begin_inEdge, 2},
   {"R_swig_Config_directedEdges_set", (DL_FUNC) &R_swig_Config_directedEdges_set, 2},
   {"R_swig_InfomapParentIterator_begin_inEdge", (DL_FUNC) &R_swig_InfomapParentIterator_begin_inEdge, 2},
   {"R_swig_InfomapParentIterator_end_inEdge", (DL_FUNC) &R_swig_InfomapParentIterator_end_inEdge, 2},
   {"R_swig_Config_isCLI_get", (DL_FUNC) &R_swig_Config_isCLI_get, 2},
   {"R_swig_InfomapIterator__next_set", (DL_FUNC) &R_swig_InfomapIterator__next_set, 2},
   {"R_swig_InfoNode__next_set", (DL_FUNC) &R_swig_InfoNode__next_set, 2},
   {"R_swig_InfomapParentIterator__next_set", (DL_FUNC) &R_swig_InfomapParentIterator__next_set, 2},
   {"R_swig_InfomapIterator_numLeafMembers", (DL_FUNC) &R_swig_InfomapIterator_numLeafMembers, 2},
   {"R_swig_InfoNode_numLeafMembers", (DL_FUNC) &R_swig_InfoNode_numLeafMembers, 2},
   {"R_swig_InfomapParentIterator_numLeafMembers", (DL_FUNC) &R_swig_InfomapParentIterator_numLeafMembers, 2},
   {"R_swig_InfomapParentIterator_replaceChildrenWithOneNode", (DL_FUNC) &R_swig_InfomapParentIterator_replaceChildrenWithOneNode, 2},
   {"R_swig_Config_maxNodeIndexVisible_set", (DL_FUNC) &R_swig_Config_maxNodeIndexVisible_set, 2},
   {"R_swig_InfomapIterator_codelength_get", (DL_FUNC) &R_swig_InfomapIterator_codelength_get, 2},
   {"R_swig_InfoNode_codelength_get", (DL_FUNC) &R_swig_InfoNode_codelength_get, 2},
   {"R_swig_InfomapParentIterator_codelength_get", (DL_FUNC) &R_swig_InfomapParentIterator_codelength_get, 2},
   {"R_swig_PerLevelStat_indexLength_get", (DL_FUNC) &R_swig_PerLevelStat_indexLength_get, 2},
   {"R_swig_PerLevelStat_leafLength_get", (DL_FUNC) &R_swig_PerLevelStat_leafLength_get, 2},
   {"R_swig_PartitionQueue_indexCodelength_get", (DL_FUNC) &R_swig_PartitionQueue_indexCodelength_get, 2},
   {"R_swig_PartitionQueue_leafCodelength_get", (DL_FUNC) &R_swig_PartitionQueue_leafCodelength_get, 2},
   {"R_swig_PartitionQueue_moduleCodelength_get", (DL_FUNC) &R_swig_PartitionQueue_moduleCodelength_get, 2},
   {"R_swig_MapEquation_codelength_get", (DL_FUNC) &R_swig_MapEquation_codelength_get, 2},
   {"R_swig_MapEquation_indexCodelength_get", (DL_FUNC) &R_swig_MapEquation_indexCodelength_get, 2},
   {"R_swig_MapEquation_moduleCodelength_get", (DL_FUNC) &R_swig_MapEquation_moduleCodelength_get, 2},
   {"R_swig_MemMapEquation_codelength_get", (DL_FUNC) &R_swig_MemMapEquation_codelength_get, 2},
   {"R_swig_MemMapEquation_indexCodelength_get", (DL_FUNC) &R_swig_MemMapEquation_indexCodelength_get, 2},
   {"R_swig_MemMapEquation_moduleCodelength_get", (DL_FUNC) &R_swig_MemMapEquation_moduleCodelength_get, 2},
   {"R_swig_MetaMapEquation_codelength_get", (DL_FUNC) &R_swig_MetaMapEquation_codelength_get, 2},
   {"R_swig_MetaMapEquation_indexCodelength_get", (DL_FUNC) &R_swig_MetaMapEquation_indexCodelength_get, 2},
   {"R_swig_MetaMapEquation_moduleCodelength_get", (DL_FUNC) &R_swig_MetaMapEquation_moduleCodelength_get, 2},
   {"R_swig_Config_clusterDataIsHard_set", (DL_FUNC) &R_swig_Config_clusterDataIsHard_set, 2},
   {"R_swig_delete_InfomapCore", (DL_FUNC) &R_swig_delete_InfomapCore, 1},
   {"R_swig_Config_printFlowTree_set", (DL_FUNC) &R_swig_Config_printFlowTree_set, 2},
   {"R_swig_Config_printTree_set", (DL_FUNC) &R_swig_Config_printTree_set, 2},
   {"R_swig_Config_printBinaryTree_set", (DL_FUNC) &R_swig_Config_printBinaryTree_set, 2},
   {"R_swig_Config_printBinaryFlowTree_set", (DL_FUNC) &R_swig_Config_printBinaryFlowTree_set, 2},
   {"R_swig_Config_isMultilayerNetwork", (DL_FUNC) &R_swig_Config_isMultilayerNetwork, 2},
   {"R_swig_Config_isStateNetwork", (DL_FUNC) &R_swig_Config_isStateNetwork, 2},
   {"R_swig_delete_StateNetwork", (DL_FUNC) &R_swig_delete_StateNetwork, 1},
   {"R_swig_StateNetwork_writeStateNetwork", (DL_FUNC) &R_swig_StateNetwork_writeStateNetwork, 2},
   {"R_swig_delete_Network", (DL_FUNC) &R_swig_delete_Network, 1},
   {"R_swig_Network_isMultilayerNetwork", (DL_FUNC) &R_swig_Network_isMultilayerNetwork, 2},
   {"R_swig_InfomapBase_isFullNetwork", (DL_FUNC) &R_swig_InfomapBase_isFullNetwork, 2},
   {"R_swig_InfomapBase_activeNetwork", (DL_FUNC) &R_swig_InfomapBase_activeNetwork, 2},
   {"R_swig_InfomapBase_initSuperNetwork", (DL_FUNC) &R_swig_InfomapBase_initSuperNetwork, 1},
   {"R_swig_InfomapBase_optimizeActiveNetwork", (DL_FUNC) &R_swig_InfomapBase_optimizeActiveNetwork, 2},
   {"R_swig_MapEquation_initNetwork", (DL_FUNC) &R_swig_MapEquation_initNetwork, 2},
   {"R_swig_MapEquation_initSuperNetwork", (DL_FUNC) &R_swig_MapEquation_initSuperNetwork, 2},
   {"R_swig_MapEquation_initSubNetwork", (DL_FUNC) &R_swig_MapEquation_initSubNetwork, 2},
   {"R_swig_MemMapEquation_initNetwork", (DL_FUNC) &R_swig_MemMapEquation_initNetwork, 2},
   {"R_swig_MemMapEquation_initSuperNetwork", (DL_FUNC) &R_swig_MemMapEquation_initSuperNetwork, 2},
   {"R_swig_MemMapEquation_initSubNetwork", (DL_FUNC) &R_swig_MemMapEquation_initSubNetwork, 2},
   {"R_swig_MetaMapEquation_initNetwork", (DL_FUNC) &R_swig_MetaMapEquation_initNetwork, 2},
   {"R_swig_MetaMapEquation_initSuperNetwork", (DL_FUNC) &R_swig_MetaMapEquation_initSuperNetwork, 2},
   {"R_swig_MetaMapEquation_initSubNetwork", (DL_FUNC) &R_swig_MetaMapEquation_initSubNetwork, 2},
   {"R_swig_InfomapIterator_parent_set", (DL_FUNC) &R_swig_InfomapIterator_parent_set, 2},
   {"R_swig_Config_minimumCodelengthImprovement_set", (DL_FUNC) &R_swig_Config_minimumCodelengthImprovement_set, 2},
   {"R_swig_Config_silent_set", (DL_FUNC) &R_swig_Config_silent_set, 2},
   {"R_swig_DeltaFlow_count_set", (DL_FUNC) &R_swig_DeltaFlow_count_set, 2},
   {"R_swig_InfoNode_parent_set", (DL_FUNC) &R_swig_InfoNode_parent_set, 2},
   {"R_swig_InfomapParentIterator_parent_set", (DL_FUNC) &R_swig_InfomapParentIterator_parent_set, 2},
   {"R_swig_Network_addMultilayerLink", (DL_FUNC) &R_swig_Network_addMultilayerLink, 6},
   {"R_swig_Bigram_second_set", (DL_FUNC) &R_swig_Bigram_second_set, 2},
   {"R_swig_InfomapIterator_collapsedLastChild_set", (DL_FUNC) &R_swig_InfomapIterator_collapsedLastChild_set, 2},
   {"R_swig_InfomapIterator_collapsedFirstChild_set", (DL_FUNC) &R_swig_InfomapIterator_collapsedFirstChild_set, 2},
   {"R_swig_InfomapIterator_lastChild_set", (DL_FUNC) &R_swig_InfomapIterator_lastChild_set, 2},
   {"R_swig_InfomapIterator_firstChild_set", (DL_FUNC) &R_swig_InfomapIterator_firstChild_set, 2},
   {"R_swig_InfoNode_collapsedLastChild_set", (DL_FUNC) &R_swig_InfoNode_collapsedLastChild_set, 2},
   {"R_swig_InfoNode_collapsedFirstChild_set", (DL_FUNC) &R_swig_InfoNode_collapsedFirstChild_set, 2},
   {"R_swig_Config_weightThreshold_set", (DL_FUNC) &R_swig_Config_weightThreshold_set, 2},
   {"R_swig_InfoNode_firstChild_set", (DL_FUNC) &R_swig_InfoNode_firstChild_set, 2},
   {"R_swig_InfoNode_lastChild_set", (DL_FUNC) &R_swig_InfoNode_lastChild_set, 2},
   {"R_swig_InfomapParentIterator_firstChild_set", (DL_FUNC) &R_swig_InfomapParentIterator_firstChild_set, 2},
   {"R_swig_InfomapParentIterator_lastChild_set", (DL_FUNC) &R_swig_InfomapParentIterator_lastChild_set, 2},
   {"R_swig_InfomapIterator_calculatePath", (DL_FUNC) &R_swig_InfomapIterator_calculatePath, 2},
   {"R_swig_InfoNode_calculatePath", (DL_FUNC) &R_swig_InfoNode_calculatePath, 2},
   {"R_swig_InfomapParentIterator_calculatePath", (DL_FUNC) &R_swig_InfomapParentIterator_calculatePath, 2},
   {"R_swig_MapEquation_print", (DL_FUNC) &R_swig_MapEquation_print, 3},
   {"R_swig_MemMapEquation_print", (DL_FUNC) &R_swig_MemMapEquation_print, 3},
   {"R_swig_MetaMapEquation_print", (DL_FUNC) &R_swig_MetaMapEquation_print, 3},
   {"R_swig_Config_superLevelLimit_set", (DL_FUNC) &R_swig_Config_superLevelLimit_set, 2},
   {"R_swig_Config_tuneIterationLimit_set", (DL_FUNC) &R_swig_Config_tuneIterationLimit_set, 2},
   {"R_swig_Config_levelAggregationLimit_set", (DL_FUNC) &R_swig_Config_levelAggregationLimit_set, 2},
   {"R_swig_Config_coreLoopLimit_set", (DL_FUNC) &R_swig_Config_coreLoopLimit_set, 2},
   {"R_swig_Config_randomizeCoreLoopLimit_set", (DL_FUNC) &R_swig_Config_randomizeCoreLoopLimit_set, 2},
   {"R_swig_Config_multilayerJSRelaxLimit_set", (DL_FUNC) &R_swig_Config_multilayerJSRelaxLimit_set, 2},
   {"R_swig_Config_multilayerRelaxLimit_set", (DL_FUNC) &R_swig_Config_multilayerRelaxLimit_set, 2},
   {"R_swig_Config_nodeLimit_set", (DL_FUNC) &R_swig_Config_nodeLimit_set, 2},
   {"R_swig_InfomapIterator_replaceWithChildrenDebug", (DL_FUNC) &R_swig_InfomapIterator_replaceWithChildrenDebug, 1},
   {"R_swig_InfoNode_replaceWithChildrenDebug", (DL_FUNC) &R_swig_InfoNode_replaceWithChildrenDebug, 1},
   {"R_swig_InfomapIterator_layerId_set", (DL_FUNC) &R_swig_InfomapIterator_layerId_set, 2},
   {"R_swig_InfomapIterator_physicalId_set", (DL_FUNC) &R_swig_InfomapIterator_physicalId_set, 2},
   {"R_swig_InfoNode_physicalId_set", (DL_FUNC) &R_swig_InfoNode_physicalId_set, 2},
   {"R_swig_InfoNode_layerId_set", (DL_FUNC) &R_swig_InfoNode_layerId_set, 2},
   {"R_swig_InfomapParentIterator_physicalId_set", (DL_FUNC) &R_swig_InfomapParentIterator_physicalId_set, 2},
   {"R_swig_InfomapParentIterator_layerId_set", (DL_FUNC) &R_swig_InfomapParentIterator_layerId_set, 2},
   {"R_swig_Weight_weight_set", (DL_FUNC) &R_swig_Weight_weight_set, 2},
   {"R_swig_Network_generateStateNetworkFromMultilayerWithInterLinks", (DL_FUNC) &R_swig_Network_generateStateNetworkFromMultilayerWithInterLinks, 1},
   {"R_swig_Network_generateStateNetworkFromMultilayerWithSimulatedInterLinks", (DL_FUNC) &R_swig_Network_generateStateNetworkFromMultilayerWithSimulatedInterLinks, 1},
   {"R_swig_delete_LayerNode", (DL_FUNC) &R_swig_delete_LayerNode, 1},
   {"R_swig_Config_teleportationProbability_get", (DL_FUNC) &R_swig_Config_teleportationProbability_get, 2},
   {"R_swig_Config_selfTeleportationProbability_get", (DL_FUNC) &R_swig_Config_selfTeleportationProbability_get, 2},
   {"R_swig_Config_verbosity_get", (DL_FUNC) &R_swig_Config_verbosity_get, 2},
   {"R_swig_Config_inputFormat_set", (DL_FUNC) &R_swig_Config_inputFormat_set, 2},
   {"R_swig_Config_outDirectory_get", (DL_FUNC) &R_swig_Config_outDirectory_get, 2},
   {"R_swig_Config_multilayerJSRelaxRate_set", (DL_FUNC) &R_swig_Config_multilayerJSRelaxRate_set, 2},
   {"R_swig_Config_multilayerRelaxRate_set", (DL_FUNC) &R_swig_Config_multilayerRelaxRate_set, 2},
   {"R_swig_Config_bipartite_set", (DL_FUNC) &R_swig_Config_bipartite_set, 2},
   {"R_swig_Config_metaDataRate_set", (DL_FUNC) &R_swig_Config_metaDataRate_set, 2},
   {"R_swig_Config_startDate_set", (DL_FUNC) &R_swig_Config_startDate_set, 2},
   {"R_swig_delete_Bigram", (DL_FUNC) &R_swig_delete_Bigram, 1},
   {"R_swig_delete_InfomapConfigInfomapBase", (DL_FUNC) &R_swig_delete_InfomapConfigInfomapBase, 1},
   {"R_swig_delete_InfomapBase", (DL_FUNC) &R_swig_delete_InfomapBase, 1},
   {"R_swig_DeltaFlow_reset", (DL_FUNC) &R_swig_DeltaFlow_reset, 1},
   {"R_swig_MemDeltaFlow_reset", (DL_FUNC) &R_swig_MemDeltaFlow_reset, 1},
   {"R_swig_delete_vector_uint", (DL_FUNC) &R_swig_delete_vector_uint, 1},
   {"R_swig_delete_map_uint_vector_uint", (DL_FUNC) &R_swig_delete_map_uint_vector_uint, 1},
   {"R_swig_StateNetwork_clearLinks", (DL_FUNC) &R_swig_StateNetwork_clearLinks, 1},
   {"R_swig_StateNetwork_bipartiteStartId", (DL_FUNC) &R_swig_StateNetwork_bipartiteStartId, 2},
   {"R_swig_StateNetwork_setBipartiteStartId", (DL_FUNC) &R_swig_StateNetwork_setBipartiteStartId, 2},
   {"R_swig_Network_simulateInterLayerLinks", (DL_FUNC) &R_swig_Network_simulateInterLayerLinks, 1},
   {"R_swig_InfomapWrapper_setBipartiteStartId", (DL_FUNC) &R_swig_InfomapWrapper_setBipartiteStartId, 2},
   {"R_swig_Config_noCoarseTune_set", (DL_FUNC) &R_swig_Config_noCoarseTune_set, 2},
   {"R_swig_InfomapIterator_setChildDegree", (DL_FUNC) &R_swig_InfomapIterator_setChildDegree, 2},
   {"R_swig_InfomapIterator_infomapChildDegree", (DL_FUNC) &R_swig_InfomapIterator_infomapChildDegree, 2},
   {"R_swig_InfomapIterator_degree", (DL_FUNC) &R_swig_InfomapIterator_degree, 2},
   {"R_swig_InfomapIterator_inDegree", (DL_FUNC) &R_swig_InfomapIterator_inDegree, 2},
   {"R_swig_InfomapIterator_outDegree", (DL_FUNC) &R_swig_InfomapIterator_outDegree, 2},
   {"R_swig_InfomapIterator_childDegree", (DL_FUNC) &R_swig_InfomapIterator_childDegree, 2},
   {"R_swig_InfoNode_setChildDegree", (DL_FUNC) &R_swig_InfoNode_setChildDegree, 2},
   {"R_swig_InfoNode_infomapChildDegree", (DL_FUNC) &R_swig_InfoNode_infomapChildDegree, 2},
   {"R_swig_InfoNode_degree", (DL_FUNC) &R_swig_InfoNode_degree, 2},
   {"R_swig_InfoNode_inDegree", (DL_FUNC) &R_swig_InfoNode_inDegree, 2},
   {"R_swig_InfoNode_outDegree", (DL_FUNC) &R_swig_InfoNode_outDegree, 2},
   {"R_swig_InfoNode_childDegree", (DL_FUNC) &R_swig_InfoNode_childDegree, 2},
   {"R_swig_InfomapParentIterator_childDegree", (DL_FUNC) &R_swig_InfomapParentIterator_childDegree, 2},
   {"R_swig_InfomapParentIterator_outDegree", (DL_FUNC) &R_swig_InfomapParentIterator_outDegree, 2},
   {"R_swig_InfomapParentIterator_inDegree", (DL_FUNC) &R_swig_InfomapParentIterator_inDegree, 2},
   {"R_swig_InfomapParentIterator_degree", (DL_FUNC) &R_swig_InfomapParentIterator_degree, 2},
   {"R_swig_InfomapParentIterator_infomapChildDegree", (DL_FUNC) &R_swig_InfomapParentIterator_infomapChildDegree, 2},
   {"R_swig_InfomapParentIterator_setChildDegree", (DL_FUNC) &R_swig_InfomapParentIterator_setChildDegree, 2},
   {"R_swig_Config_outName_set", (DL_FUNC) &R_swig_Config_outName_set, 2},
   {"R_swig_Config_markovTime_set", (DL_FUNC) &R_swig_Config_markovTime_set, 2},
   {"R_swig_Config_adaptDefaults", (DL_FUNC) &R_swig_Config_adaptDefaults, 1},
   {"R_swig_Config_printClu_set", (DL_FUNC) &R_swig_Config_printClu_set, 2},
   {"R_swig_Config_networkFile_set", (DL_FUNC) &R_swig_Config_networkFile_set, 2},
   {"R_swig_Config_clusterDataFile_set", (DL_FUNC) &R_swig_Config_clusterDataFile_set, 2},
   {"R_swig_Config_metaDataFile_set", (DL_FUNC) &R_swig_Config_metaDataFile_set, 2},
   {"R_swig_Config_assignToNeighbouringModule_set", (DL_FUNC) &R_swig_Config_assignToNeighbouringModule_set, 2},
   {"R_swig_DeltaFlow_module_set", (DL_FUNC) &R_swig_DeltaFlow_module_set, 2},
   {"R_swig_vector_uint_capacity", (DL_FUNC) &R_swig_vector_uint_capacity, 2},
   {"R_swig_vector_double_capacity", (DL_FUNC) &R_swig_vector_double_capacity, 2},
   {"R_swig_StateNetwork_numLinks", (DL_FUNC) &R_swig_StateNetwork_numLinks, 2},
   {"R_swig_InfomapParentIterator_collapsedLastChild_set", (DL_FUNC) &R_swig_InfomapParentIterator_collapsedLastChild_set, 2},
   {"R_swig_Config_skipAdjustBipartiteFlow_set", (DL_FUNC) &R_swig_Config_skipAdjustBipartiteFlow_set, 2},
   {"R_swig_Config_useNodeWeightsAsFlow_set", (DL_FUNC) &R_swig_Config_useNodeWeightsAsFlow_set, 2},
   {"R_swig_FlowData_flow_set", (DL_FUNC) &R_swig_FlowData_flow_set, 2},
   {"R_swig_FlowData_enterFlow_set", (DL_FUNC) &R_swig_FlowData_enterFlow_set, 2},
   {"R_swig_FlowData_exitFlow_set", (DL_FUNC) &R_swig_FlowData_exitFlow_set, 2},
   {"R_swig_MemDeltaFlow_sumDeltaPlogpPhysFlow_set", (DL_FUNC) &R_swig_MemDeltaFlow_sumDeltaPlogpPhysFlow_set, 2},
   {"R_swig_MemDeltaFlow_sumPlogpPhysFlow_set", (DL_FUNC) &R_swig_MemDeltaFlow_sumPlogpPhysFlow_set, 2},
   {"R_swig_PartitionQueue_flow_set", (DL_FUNC) &R_swig_PartitionQueue_flow_set, 2},
   {"R_swig_PartitionQueue_nonTrivialFlow_set", (DL_FUNC) &R_swig_PartitionQueue_nonTrivialFlow_set, 2},
   {"R_swig_MemNodeSet_sumFlow_set", (DL_FUNC) &R_swig_MemNodeSet_sumFlow_set, 2},
   {"R_swig_PhysData_sumFlowFromM2Node_set", (DL_FUNC) &R_swig_PhysData_sumFlowFromM2Node_set, 2},
   {"R_swig_LayerNode_node_set", (DL_FUNC) &R_swig_LayerNode_node_set, 2},
   {"R_swig_BipartiteLink_featureNode_set", (DL_FUNC) &R_swig_BipartiteLink_featureNode_set, 2},
   {"R_swig_BipartiteLink_node_set", (DL_FUNC) &R_swig_BipartiteLink_node_set, 2},
   {"R_swig_InfomapBase_findHierarchicalSuperModules__SWIG_0", (DL_FUNC) &R_swig_InfomapBase_findHierarchicalSuperModules__SWIG_0, 3},
   {"R_swig_InfomapBase_findHierarchicalSuperModules__SWIG_1", (DL_FUNC) &R_swig_InfomapBase_findHierarchicalSuperModules__SWIG_1, 2},
   {"R_swig_delete_deque_uint", (DL_FUNC) &R_swig_delete_deque_uint, 1},
   {"R_swig_InfomapParentIterator_getInfomapRoot__SWIG_0", (DL_FUNC) &R_swig_InfomapParentIterator_getInfomapRoot__SWIG_0, 1},
   {"R_swig_InfomapParentIterator_getInfomapRoot__SWIG_1", (DL_FUNC) &R_swig_InfomapParentIterator_getInfomapRoot__SWIG_1, 1},
   {"R_swig_InfomapIterator_replaceChildrenWithGrandChildrenDebug", (DL_FUNC) &R_swig_InfomapIterator_replaceChildrenWithGrandChildrenDebug, 1},
   {"R_swig_InfomapIterator_replaceChildrenWithGrandChildren", (DL_FUNC) &R_swig_InfomapIterator_replaceChildrenWithGrandChildren, 2},
   {"R_swig_InfomapIterator_begin_post_depth_first", (DL_FUNC) &R_swig_InfomapIterator_begin_post_depth_first, 2},
   {"R_swig_InfoNode_begin_post_depth_first", (DL_FUNC) &R_swig_InfoNode_begin_post_depth_first, 2},
   {"R_swig_MemMapEquation_addMemoryContributions", (DL_FUNC) &R_swig_MemMapEquation_addMemoryContributions, 4},
   {"R_swig_MetaMapEquation_addMemoryContributions", (DL_FUNC) &R_swig_MetaMapEquation_addMemoryContributions, 4},
   {"R_swig_InfomapBase_sortTreeOnFlow", (DL_FUNC) &R_swig_InfomapBase_sortTreeOnFlow, 1},
   {"R_swig_InfomapBase_writeResult", (DL_FUNC) &R_swig_InfomapBase_writeResult, 1},
   {"R_swig_deque_uint_size", (DL_FUNC) &R_swig_deque_uint_size, 2},
   {"R_swig_vector_uint_size", (DL_FUNC) &R_swig_vector_uint_size, 2},
   {"R_swig_map_uint_uint_size", (DL_FUNC) &R_swig_map_uint_uint_size, 2},
   {"R_swig_map_uint_vector_uint_size", (DL_FUNC) &R_swig_map_uint_vector_uint_size, 2},
   {"R_swig_InfomapIterator_isLast", (DL_FUNC) &R_swig_InfomapIterator_isLast, 2},
   {"R_swig_InfoNode_isLast", (DL_FUNC) &R_swig_InfoNode_isLast, 2},
   {"R_swig_InfomapParentIterator_isLast", (DL_FUNC) &R_swig_InfomapParentIterator_isLast, 2},
   {"R_swig_StateNetwork_removeLink", (DL_FUNC) &R_swig_StateNetwork_removeLink, 4},
   {"R_swig_delete_BipartiteLink", (DL_FUNC) &R_swig_delete_BipartiteLink, 1},
   {"R_swig_deque_uint_back", (DL_FUNC) &R_swig_deque_uint_back, 2},
   {"R_swig_vector_uint_back", (DL_FUNC) &R_swig_vector_uint_back, 2},
   {"R_swig_InfomapBase_end", (DL_FUNC) &R_swig_InfomapBase_end, 2},
   {"R_swig_InfomapIterator_isFirst", (DL_FUNC) &R_swig_InfomapIterator_isFirst, 2},
   {"R_swig_InfoNode_isFirst", (DL_FUNC) &R_swig_InfoNode_isFirst, 2},
   {"R_swig_InfomapParentIterator_isFirst", (DL_FUNC) &R_swig_InfomapParentIterator_isFirst, 2},
   {"R_swig_InfomapLeafIterator_init", (DL_FUNC) &R_swig_InfomapLeafIterator_init, 1},
   {"R_swig_InfomapLeafModuleIterator_init", (DL_FUNC) &R_swig_InfomapLeafModuleIterator_init, 1},
   {"R_swig_delete_InfomapLeafIteratorPhysical", (DL_FUNC) &R_swig_delete_InfomapLeafIteratorPhysical, 1},
   {"R_swig_delete_InfomapIteratorPhysical", (DL_FUNC) &R_swig_delete_InfomapIteratorPhysical, 1},
   {"R_swig_Config_haveMemory", (DL_FUNC) &R_swig_Config_haveMemory, 2},
   {"R_swig_map_uint_string_size", (DL_FUNC) &R_swig_map_uint_string_size, 2},
   {"R_swig_InfomapParentIterator_collapsedFirstChild_get", (DL_FUNC) &R_swig_InfomapParentIterator_collapsedFirstChild_get, 1},
   {"R_swig_MapEquation_init", (DL_FUNC) &R_swig_MapEquation_init, 2},
   {"R_swig_MemMapEquation_init", (DL_FUNC) &R_swig_MemMapEquation_init, 2},
   {"R_swig_MetaMapEquation_init", (DL_FUNC) &R_swig_MetaMapEquation_init, 2},
   {"R_swig_Config_printFlowNetwork_get", (DL_FUNC) &R_swig_Config_printFlowNetwork_get, 2},
   {"R_swig_Config_printPajekNetwork_get", (DL_FUNC) &R_swig_Config_printPajekNetwork_get, 2},
   {"R_swig_Config_printStateNetwork_get", (DL_FUNC) &R_swig_Config_printStateNetwork_get, 2},
   {"R_swig_Config_benchmark_get", (DL_FUNC) &R_swig_Config_benchmark_get, 2},
   {"R_swig_InfomapWrapper_addStateNode", (DL_FUNC) &R_swig_InfomapWrapper_addStateNode, 3},
   {"R_swig_vector_double_size", (DL_FUNC) &R_swig_vector_double_size, 2},
   {"R_swig_InfomapLeafIteratorPhysical_init", (DL_FUNC) &R_swig_InfomapLeafIteratorPhysical_init, 1},
   {"R_swig_Config_coarseTuneLevel_get", (DL_FUNC) &R_swig_Config_coarseTuneLevel_get, 2},
   {"R_swig_Config_alternateCoarseTuneLevel_get", (DL_FUNC) &R_swig_Config_alternateCoarseTuneLevel_get, 2},
   {"R_swig_Config_twoLevel_get", (DL_FUNC) &R_swig_Config_twoLevel_get, 2},
   {"R_swig_Config_flowModel_get", (DL_FUNC) &R_swig_Config_flowModel_get, 1},
   {"R_swig_Config_cluLevel_get", (DL_FUNC) &R_swig_Config_cluLevel_get, 2},
   {"R_swig_InfomapBase_isFirstLoop", (DL_FUNC) &R_swig_InfomapBase_isFirstLoop, 2},
   {"R_swig_PartitionQueue_level_get", (DL_FUNC) &R_swig_PartitionQueue_level_get, 2},
   {"R_swig_InfomapIterator_addChild", (DL_FUNC) &R_swig_InfomapIterator_addChild, 2},
   {"R_swig_InfoNode_addChild", (DL_FUNC) &R_swig_InfoNode_addChild, 2},
   {"R_swig_InfomapParentIterator_addChild", (DL_FUNC) &R_swig_InfomapParentIterator_addChild, 2},
   {"R_swig_delete_InfomapParentIterator", (DL_FUNC) &R_swig_delete_InfomapParentIterator, 1},
   {"R_swig_delete_InfomapLeafIterator", (DL_FUNC) &R_swig_delete_InfomapLeafIterator, 1},
   {"R_swig_delete_InfomapLeafModuleIterator", (DL_FUNC) &R_swig_delete_InfomapLeafModuleIterator, 1},
   {"R_swig_delete_InfomapModuleIterator", (DL_FUNC) &R_swig_delete_InfomapModuleIterator, 1},
   {"R_swig_delete_InfomapIterator", (DL_FUNC) &R_swig_delete_InfomapIterator, 1},
   {"R_swig_InfomapIterator_index_set", (DL_FUNC) &R_swig_InfomapIterator_index_set, 2},
   {"R_swig_Config_minBipartiteNodeIndex_set", (DL_FUNC) &R_swig_Config_minBipartiteNodeIndex_set, 2},
   {"R_swig_PhysData_physNodeIndex_set", (DL_FUNC) &R_swig_PhysData_physNodeIndex_set, 2},
   {"R_swig_InfoNode_index_set", (DL_FUNC) &R_swig_InfoNode_index_set, 2},
   {"R_swig_InfomapParentIterator_index_set", (DL_FUNC) &R_swig_InfomapParentIterator_index_set, 2},
   {"R_swig_InfomapBase_toString", (DL_FUNC) &R_swig_InfomapBase_toString, 3},
   {"R_swig_InfomapCore_toString", (DL_FUNC) &R_swig_InfomapCore_toString, 3},
   {"R_swig_InfomapParentIterator_collapsedFirstChild_set", (DL_FUNC) &R_swig_InfomapParentIterator_collapsedFirstChild_set, 2},
   {"R_swig_InfomapIterator_replaceChildrenWithOneNode", (DL_FUNC) &R_swig_InfomapIterator_replaceChildrenWithOneNode, 2},
   {"R_swig_InfoNode_replaceChildrenWithOneNode", (DL_FUNC) &R_swig_InfoNode_replaceChildrenWithOneNode, 2},
   {"R_swig_InfomapBase_isTopLevel", (DL_FUNC) &R_swig_InfomapBase_isTopLevel, 2},
   {"R_swig_InfomapBase_isSuperLevelOnTopLevel", (DL_FUNC) &R_swig_InfomapBase_isSuperLevelOnTopLevel, 2},
   {"R_swig_Config_parsedString_set", (DL_FUNC) &R_swig_Config_parsedString_set, 2},
   {"R_swig_InfomapConfigInfomapBase_setTwoLevel", (DL_FUNC) &R_swig_InfomapConfigInfomapBase_setTwoLevel, 3},
   {"R_swig_new_OptimizationLevel", (DL_FUNC) &R_swig_new_OptimizationLevel, 0},
   {"R_swig_delete_OptimizationLevel", (DL_FUNC) &R_swig_delete_OptimizationLevel, 1},
   {"R_swig_Config_setOptimizationLevel", (DL_FUNC) &R_swig_Config_setOptimizationLevel, 2},
   {"R_swig_vector_double_back", (DL_FUNC) &R_swig_vector_double_back, 2},
   {"R_swig_InfomapBase_init", (DL_FUNC) &R_swig_InfomapBase_init, 1},
   {"R_swig_InfomapBase_findHierarchicalSuperModulesFast__SWIG_0", (DL_FUNC) &R_swig_InfomapBase_findHierarchicalSuperModulesFast__SWIG_0, 3},
   {"R_swig_InfomapBase_findHierarchicalSuperModulesFast__SWIG_1", (DL_FUNC) &R_swig_InfomapBase_findHierarchicalSuperModulesFast__SWIG_1, 2},
   {"R_swig_InfomapIterator_dirty_set", (DL_FUNC) &R_swig_InfomapIterator_dirty_set, 2},
   {"R_swig_InfoNode_dirty_set", (DL_FUNC) &R_swig_InfoNode_dirty_set, 2},
   {"R_swig_InfomapParentIterator_dirty_set", (DL_FUNC) &R_swig_InfomapParentIterator_dirty_set, 2},
   {"R_swig_Config_printNewick_get", (DL_FUNC) &R_swig_Config_printNewick_get, 2},
   {"R_swig_deque_uint_get_allocator", (DL_FUNC) &R_swig_deque_uint_get_allocator, 2},
   {"R_swig_vector_uint_get_allocator", (DL_FUNC) &R_swig_vector_uint_get_allocator, 2},
   {"R_swig_map_uint_uint_get_allocator", (DL_FUNC) &R_swig_map_uint_uint_get_allocator, 2},
   {"R_swig_vector_double_get_allocator", (DL_FUNC) &R_swig_vector_double_get_allocator, 2},
   {"R_swig_map_uint_vector_uint_get_allocator", (DL_FUNC) &R_swig_map_uint_vector_uint_get_allocator, 2},
   {"R_swig_map_uint_string_get_allocator", (DL_FUNC) &R_swig_map_uint_string_get_allocator, 2},
   {"R_swig_MetaMapEquation_updateCodelengthOnMovingNode", (DL_FUNC) &R_swig_MetaMapEquation_updateCodelengthOnMovingNode, 6},
   {"R_swig_InfomapLeafIteratorPhysical_depth", (DL_FUNC) &R_swig_InfomapLeafIteratorPhysical_depth, 2},
   {"R_swig_InfomapIteratorPhysical_depth", (DL_FUNC) &R_swig_InfomapIteratorPhysical_depth, 2},
   {"R_swig_InfomapLeafIterator_depth", (DL_FUNC) &R_swig_InfomapLeafIterator_depth, 2},
   {"R_swig_InfomapLeafModuleIterator_depth", (DL_FUNC) &R_swig_InfomapLeafModuleIterator_depth, 2},
   {"R_swig_InfomapModuleIterator_depth", (DL_FUNC) &R_swig_InfomapModuleIterator_depth, 2},
   {"R_swig_InfomapIterator_depth", (DL_FUNC) &R_swig_InfomapIterator_depth, 2},
   {"R_swig_InfomapParentIterator_depth", (DL_FUNC) &R_swig_InfomapParentIterator_depth, 2},
   {"R_swig_Config_isCLI_set", (DL_FUNC) &R_swig_Config_isCLI_set, 2},
   {"R_swig_InfomapBase_setSubLevel", (DL_FUNC) &R_swig_InfomapBase_setSubLevel, 3},
   {"R_swig_InfomapIterator_codelength_set", (DL_FUNC) &R_swig_InfomapIterator_codelength_set, 2},
   {"R_swig_InfoNode_codelength_set", (DL_FUNC) &R_swig_InfoNode_codelength_set, 2},
   {"R_swig_InfomapParentIterator_codelength_set", (DL_FUNC) &R_swig_InfomapParentIterator_codelength_set, 2},
   {"R_swig_PerLevelStat_indexLength_set", (DL_FUNC) &R_swig_PerLevelStat_indexLength_set, 2},
   {"R_swig_PerLevelStat_leafLength_set", (DL_FUNC) &R_swig_PerLevelStat_leafLength_set, 2},
   {"R_swig_PartitionQueue_indexCodelength_set", (DL_FUNC) &R_swig_PartitionQueue_indexCodelength_set, 2},
   {"R_swig_PartitionQueue_leafCodelength_set", (DL_FUNC) &R_swig_PartitionQueue_leafCodelength_set, 2},
   {"R_swig_PartitionQueue_moduleCodelength_set", (DL_FUNC) &R_swig_PartitionQueue_moduleCodelength_set, 2},
   {"R_swig_MapEquation_codelength_set", (DL_FUNC) &R_swig_MapEquation_codelength_set, 2},
   {"R_swig_MapEquation_indexCodelength_set", (DL_FUNC) &R_swig_MapEquation_indexCodelength_set, 2},
   {"R_swig_MapEquation_moduleCodelength_set", (DL_FUNC) &R_swig_MapEquation_moduleCodelength_set, 2},
   {"R_swig_MemMapEquation_codelength_set", (DL_FUNC) &R_swig_MemMapEquation_codelength_set, 2},
   {"R_swig_MemMapEquation_indexCodelength_set", (DL_FUNC) &R_swig_MemMapEquation_indexCodelength_set, 2},
   {"R_swig_MemMapEquation_moduleCodelength_set", (DL_FUNC) &R_swig_MemMapEquation_moduleCodelength_set, 2},
   {"R_swig_MetaMapEquation_codelength_set", (DL_FUNC) &R_swig_MetaMapEquation_codelength_set, 2},
   {"R_swig_MetaMapEquation_indexCodelength_set", (DL_FUNC) &R_swig_MetaMapEquation_indexCodelength_set, 2},
   {"R_swig_MetaMapEquation_moduleCodelength_set", (DL_FUNC) &R_swig_MetaMapEquation_moduleCodelength_set, 2},
   {"R_swig_InfomapIterator_outEdges", (DL_FUNC) &R_swig_InfomapIterator_outEdges, 2},
   {"R_swig_InfoNode_outEdges", (DL_FUNC) &R_swig_InfoNode_outEdges, 2},
   {"R_swig_InfomapParentIterator_outEdges", (DL_FUNC) &R_swig_InfomapParentIterator_outEdges, 2},
   {"R_swig_InfomapBase_calculateMaxDepth", (DL_FUNC) &R_swig_InfomapBase_calculateMaxDepth, 2},
   {"R_swig_InfomapIterator_inEdges", (DL_FUNC) &R_swig_InfomapIterator_inEdges, 2},
   {"R_swig_InfoNode_inEdges", (DL_FUNC) &R_swig_InfoNode_inEdges, 2},
   {"R_swig_InfomapParentIterator_inEdges", (DL_FUNC) &R_swig_InfomapParentIterator_inEdges, 2},
   {"R_swig_deque_uint_swap", (DL_FUNC) &R_swig_deque_uint_swap, 2},
   {"R_swig_vector_uint_swap", (DL_FUNC) &R_swig_vector_uint_swap, 2},
   {"R_swig_deque_uint_pop_back", (DL_FUNC) &R_swig_deque_uint_pop_back, 1},
   {"R_swig_vector_uint_pop_back", (DL_FUNC) &R_swig_vector_uint_pop_back, 1},
   {"R_swig_map_uint_uint_swap", (DL_FUNC) &R_swig_map_uint_uint_swap, 2},
   {"R_swig_vector_double_pop_back", (DL_FUNC) &R_swig_vector_double_pop_back, 1},
   {"R_swig_map_uint_vector_uint_swap", (DL_FUNC) &R_swig_map_uint_vector_uint_swap, 2},
   {"R_swig_PartitionQueue_size", (DL_FUNC) &R_swig_PartitionQueue_size, 2},
   {"R_swig_InfomapParentIterator_Equal", (DL_FUNC) &R_swig_InfomapParentIterator_Equal, 3},
   {"R_swig_InfomapLeafIteratorPhysical_Equal", (DL_FUNC) &R_swig_InfomapLeafIteratorPhysical_Equal, 3},
   {"R_swig_InfomapLeafIterator_Equal", (DL_FUNC) &R_swig_InfomapLeafIterator_Equal, 3},
   {"R_swig_InfomapLeafModuleIterator_Equal", (DL_FUNC) &R_swig_InfomapLeafModuleIterator_Equal, 3},
   {"R_swig_InfomapModuleIterator_Equal", (DL_FUNC) &R_swig_InfomapModuleIterator_Equal, 3},
   {"R_swig_InfomapIterator_Equal", (DL_FUNC) &R_swig_InfomapIterator_Equal, 3},
   {"R_swig_FlowModel_Equal", (DL_FUNC) &R_swig_FlowModel_Equal, 3},
   {"R_swig_MapEquation_Equal", (DL_FUNC) &R_swig_MapEquation_Equal, 3},
   {"R_swig_MemMapEquation_Equal", (DL_FUNC) &R_swig_MemMapEquation_Equal, 3},
   {"R_swig_MemNodeSet_Equal", (DL_FUNC) &R_swig_MemNodeSet_Equal, 3},
   {"R_swig_MetaMapEquation_Equal", (DL_FUNC) &R_swig_MetaMapEquation_Equal, 3},
   {"R_swig_vector_uint_reserve", (DL_FUNC) &R_swig_vector_uint_reserve, 2},
   {"R_swig_InfomapParentIterator_infomap_children__SWIG_0", (DL_FUNC) &R_swig_InfomapParentIterator_infomap_children__SWIG_0, 2},
   {"R_swig_InfomapParentIterator_infomap_children__SWIG_1", (DL_FUNC) &R_swig_InfomapParentIterator_infomap_children__SWIG_1, 2},
   {"R_swig_vector_double_reserve", (DL_FUNC) &R_swig_vector_double_reserve, 2},
   {"R_swig_MemMapEquation_getDeltaCodelengthOnMovingNode", (DL_FUNC) &R_swig_MemMapEquation_getDeltaCodelengthOnMovingNode, 7},
   {"R_swig_InfomapWrapper_getName", (DL_FUNC) &R_swig_InfomapWrapper_getName, 3},
   {"R_swig_delete_map_uint_string", (DL_FUNC) &R_swig_delete_map_uint_string, 1},
   {"R_swig_deque_uint_push_back", (DL_FUNC) &R_swig_deque_uint_push_back, 2},
   {"R_swig_vector_uint_push_back", (DL_FUNC) &R_swig_vector_uint_push_back, 2},
   {"R_swig_vector_double_push_back", (DL_FUNC) &R_swig_vector_double_push_back, 2},
   {"R_swig_StateNetwork_addName", (DL_FUNC) &R_swig_StateNetwork_addName, 4},
   {"R_swig_InfomapWrapper_addName", (DL_FUNC) &R_swig_InfomapWrapper_addName, 3},
   {"R_swig_delete_DeltaFlow", (DL_FUNC) &R_swig_delete_DeltaFlow, 1},
   {"R_swig_delete_MemDeltaFlow", (DL_FUNC) &R_swig_delete_MemDeltaFlow, 1},
   {"R_swig_Config_teleportationProbability_set", (DL_FUNC) &R_swig_Config_teleportationProbability_set, 2},
   {"R_swig_Config_selfTeleportationProbability_set", (DL_FUNC) &R_swig_Config_selfTeleportationProbability_set, 2},
   {"R_swig_Config_verbosity_set", (DL_FUNC) &R_swig_Config_verbosity_set, 2},
   {"R_swig_map_uint_string_swap", (DL_FUNC) &R_swig_map_uint_string_swap, 2},
   {"R_swig_InfomapBase_maxTreeDepth", (DL_FUNC) &R_swig_InfomapBase_maxTreeDepth, 2},
   {"R_swig_InfomapParentIterator_NotEqual", (DL_FUNC) &R_swig_InfomapParentIterator_NotEqual, 3},
   {"R_swig_InfomapIterator_NotEqual", (DL_FUNC) &R_swig_InfomapIterator_NotEqual, 3},
   {"R_swig_InfoNode_NotEqual", (DL_FUNC) &R_swig_InfoNode_NotEqual, 3},
   {"R_swig_Config_outDirectory_set", (DL_FUNC) &R_swig_Config_outDirectory_set, 2},
   {"R_swig_vector_double_swap", (DL_FUNC) &R_swig_vector_double_swap, 2},
   {"R_swig_InfomapBase_setActiveNetworkFromLeafs", (DL_FUNC) &R_swig_InfomapBase_setActiveNetworkFromLeafs, 1},
   {"R_swig_FlowData_PlusEqual", (DL_FUNC) &R_swig_FlowData_PlusEqual, 3},
   {"R_swig_FlowData_MinusEqual", (DL_FUNC) &R_swig_FlowData_MinusEqual, 3},
   {"R_swig_DeltaFlow_PlusEqual", (DL_FUNC) &R_swig_DeltaFlow_PlusEqual, 3},
   {"R_swig_MemDeltaFlow_PlusEqual", (DL_FUNC) &R_swig_MemDeltaFlow_PlusEqual, 3},
   {"R_swig_InfomapIterator_end_outEdge", (DL_FUNC) &R_swig_InfomapIterator_end_outEdge, 2},
   {"R_swig_InfomapIterator_begin_outEdge", (DL_FUNC) &R_swig_InfomapIterator_begin_outEdge, 2},
   {"R_swig_InfoNode_end_outEdge", (DL_FUNC) &R_swig_InfoNode_end_outEdge, 2},
   {"R_swig_InfoNode_begin_outEdge", (DL_FUNC) &R_swig_InfoNode_begin_outEdge, 2},
   {"R_swig_InfomapParentIterator_begin_outEdge", (DL_FUNC) &R_swig_InfomapParentIterator_begin_outEdge, 2},
   {"R_swig_InfomapParentIterator_end_outEdge", (DL_FUNC) &R_swig_InfomapParentIterator_end_outEdge, 2},
   {"R_swig_Weight_PlusEqual", (DL_FUNC) &R_swig_Weight_PlusEqual, 3},
   {"R_swig_Config_printAsUndirected", (DL_FUNC) &R_swig_Config_printAsUndirected, 2},
   {"R_swig_StateNetwork_undirectedToDirected", (DL_FUNC) &R_swig_StateNetwork_undirectedToDirected, 2},
   {"R_swig_MapEquation_getDeltaCodelengthOnMovingNode", (DL_FUNC) &R_swig_MapEquation_getDeltaCodelengthOnMovingNode, 7},
   {"R_swig_MapEquation_updateCodelengthOnMovingNode", (DL_FUNC) &R_swig_MapEquation_updateCodelengthOnMovingNode, 6},
   {"R_swig_MemMapEquation_updateCodelengthOnMovingNode", (DL_FUNC) &R_swig_MemMapEquation_updateCodelengthOnMovingNode, 6},
   {"R_swig_InfoNode_depth", (DL_FUNC) &R_swig_InfoNode_depth, 2},
   {"R_swig_InfomapParentIterator_EqualEqual", (DL_FUNC) &R_swig_InfomapParentIterator_EqualEqual, 3},
   {"R_swig_InfomapIterator_EqualEqual", (DL_FUNC) &R_swig_InfomapIterator_EqualEqual, 3},
   {"R_swig_InfoNode_EqualEqual", (DL_FUNC) &R_swig_InfoNode_EqualEqual, 3},
   {"R_swig_Triple_EqualEqual", (DL_FUNC) &R_swig_Triple_EqualEqual, 3},
   {"R_swig_InfomapParentIterator_PlusPlusPrefix", (DL_FUNC) &R_swig_InfomapParentIterator_PlusPlusPrefix, 2},
   {"R_swig_InfomapLeafIteratorPhysical_PlusPlusPrefix", (DL_FUNC) &R_swig_InfomapLeafIteratorPhysical_PlusPlusPrefix, 2},
   {"R_swig_InfomapIteratorPhysical_PlusPlusPrefix", (DL_FUNC) &R_swig_InfomapIteratorPhysical_PlusPlusPrefix, 2},
   {"R_swig_InfomapLeafIterator_PlusPlusPrefix", (DL_FUNC) &R_swig_InfomapLeafIterator_PlusPlusPrefix, 2},
   {"R_swig_InfomapLeafModuleIterator_PlusPlusPrefix", (DL_FUNC) &R_swig_InfomapLeafModuleIterator_PlusPlusPrefix, 2},
   {"R_swig_InfomapModuleIterator_PlusPlusPrefix", (DL_FUNC) &R_swig_InfomapModuleIterator_PlusPlusPrefix, 2},
   {"R_swig_InfomapIterator_PlusPlusPrefix", (DL_FUNC) &R_swig_InfomapIterator_PlusPlusPrefix, 2},
   {"R_swig_delete_vector_double", (DL_FUNC) &R_swig_delete_vector_double, 1},
   {"R_swig_InfomapBase_setIsMain", (DL_FUNC) &R_swig_InfomapBase_setIsMain, 3},
   {"R_swig_InfomapIterator_deleteChildren", (DL_FUNC) &R_swig_InfomapIterator_deleteChildren, 1},
   {"R_swig_InfomapIterator_replaceWithChildren", (DL_FUNC) &R_swig_InfomapIterator_replaceWithChildren, 2},
   {"R_swig_InfomapIterator_releaseChildren", (DL_FUNC) &R_swig_InfomapIterator_releaseChildren, 1},
   {"R_swig_InfomapIterator_expandChildren", (DL_FUNC) &R_swig_InfomapIterator_expandChildren, 2},
   {"R_swig_InfomapIterator_collapseChildren", (DL_FUNC) &R_swig_InfomapIterator_collapseChildren, 2},
   {"R_swig_InfoNode_deleteChildren", (DL_FUNC) &R_swig_InfoNode_deleteChildren, 1},
   {"R_swig_InfoNode_replaceChildrenWithGrandChildren", (DL_FUNC) &R_swig_InfoNode_replaceChildrenWithGrandChildren, 2},
   {"R_swig_InfoNode_replaceWithChildren", (DL_FUNC) &R_swig_InfoNode_replaceWithChildren, 2},
   {"R_swig_InfoNode_releaseChildren", (DL_FUNC) &R_swig_InfoNode_releaseChildren, 1},
   {"R_swig_InfoNode_expandChildren", (DL_FUNC) &R_swig_InfoNode_expandChildren, 2},
   {"R_swig_InfoNode_collapseChildren", (DL_FUNC) &R_swig_InfoNode_collapseChildren, 2},
   {"R_swig_InfomapParentIterator_collapseChildren", (DL_FUNC) &R_swig_InfomapParentIterator_collapseChildren, 2},
   {"R_swig_InfomapParentIterator_expandChildren", (DL_FUNC) &R_swig_InfomapParentIterator_expandChildren, 2},
   {"R_swig_InfomapParentIterator_releaseChildren", (DL_FUNC) &R_swig_InfomapParentIterator_releaseChildren, 1},
   {"R_swig_InfomapParentIterator_replaceWithChildren", (DL_FUNC) &R_swig_InfomapParentIterator_replaceWithChildren, 2},
   {"R_swig_InfomapParentIterator_deleteChildren", (DL_FUNC) &R_swig_InfomapParentIterator_deleteChildren, 1},
   {"R_swig_Config_isUndirectedClustering", (DL_FUNC) &R_swig_Config_isUndirectedClustering, 2},
   {"R_swig_InfomapIterator_isLeaf", (DL_FUNC) &R_swig_InfomapIterator_isLeaf, 2},
   {"R_swig_InfoNode_isLeaf", (DL_FUNC) &R_swig_InfoNode_isLeaf, 2},
   {"R_swig_Config_multilayerRelaxLimitDown_get", (DL_FUNC) &R_swig_Config_multilayerRelaxLimitDown_get, 2},
   {"R_swig_InfomapParentIterator_isLeaf", (DL_FUNC) &R_swig_InfomapParentIterator_isLeaf, 2},
   {"R_swig_InfomapIterator_isDangling", (DL_FUNC) &R_swig_InfomapIterator_isDangling, 2},
   {"R_swig_InfoNode_isDangling", (DL_FUNC) &R_swig_InfoNode_isDangling, 2},
   {"R_swig_InfomapParentIterator_isDangling", (DL_FUNC) &R_swig_InfomapParentIterator_isDangling, 2},
   {"R_swig_delete_MemNodeSet", (DL_FUNC) &R_swig_delete_MemNodeSet, 1},
   {NULL, NULL, 0}
};

extern "C" SWIGEXPORT void R_init_infomap(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);


SWIG_init();
SWIG_InitializeModule(0);


}

